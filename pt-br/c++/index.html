<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-WXC8R75DEN');
    </script>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="Content-Language" content="pt-BR">
    <title>Learn C++ in Y Minutes</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto+Slab:wght@100..900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/screen.css">
    <link rel="stylesheet" href="/css/light.css">
    <link rel="stylesheet" href="/css/dark.css">

    <link rel="canonical" href="https://learnxinyminutes.com/pt-br/c++/">
    <script>
      localStorage.removeItem("lxiym_theme");
    </script>
  </head>
  <body>
    <div class="container">
      <div class="share">
        <span class="sharemsg">
          <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fpt-br%2Fc%2B%2B%2F&amp;text=Aprenda+X+em+Y+Minutos%2C+onde+X%3DC%2B%2B">
            Compartilhe esta página
          </a>
        </span>
        <span class='st_facebook_large' displayText='Facebook'></span>
        <span class='st_twitter_large' displayText='Tweet'></span>
      </div>
      <h1><a href="/">Aprenda X em Y Minutos</a></h1>
      <h2>Onde X=C++</h2>
      <p class="filelink">
        Baixar o código:
        <a href="/pt-br/files/learncpp.cpp">learncpp.cpp</a>
      </p>
      <div id="doc">
<p>C++ é uma linguagem de programação de sistemas que,
<a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">de acordo com seu inventor Bjarne Stroustrup</a>,
foi concebida para</p>
<ul>
<li>ser um &quot;C melhor&quot;</li>
<li>suportar abstração de dados</li>
<li>suportar programação orientada a objetos</li>
<li>suportar programação genérica</li>
</ul>
<p>Embora sua sintaxe possa ser mais difícil ou complexa do que as linguagens mais
recentes, C++ é amplamente utilizada porque compila para instruções nativas que
podem ser executadas diretamente pelo processador e oferece um controle rígido sobre o hardware (como C), enquanto oferece recursos de alto nível, como os
genéricos, exceções e classes. Esta combinação de velocidade e funcionalidade
faz C++ uma das linguagens de programação mais utilizadas.</p>
<div class="highlight"><pre lang="c++"><span class="c1">//////////////////</span>
<span class="c1">// Comparação com C</span>
<span class="c1">//////////////////</span>

<span class="c1">// C ++ é quase um super conjunto de C e compartilha sua sintaxe básica para</span>
<span class="c1">// declarações de variáveis, tipos primitivos, e funções. No entanto, C++ varia</span>
<span class="c1">// em algumas das seguintes maneiras:</span>

<span class="c1">// A função main() em C++ deve retornar um int, embora void main() é aceita</span>
<span class="c1">// pela maioria dos compiladores (gcc, bumbum, etc.)</span>
<span class="c1">// Este valor serve como o status de saída do programa.</span>
<span class="c1">// Veja http://en.wikipedia.org/wiki/Exit_status para mais informações.</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Argumentos de linha de comando são passados para argc e argv da mesma</span>
<span class="w">    </span><span class="c1">// forma que eles estão em C.</span>
<span class="w">    </span><span class="c1">// argc indica o número de argumentos,</span>
<span class="w">    </span><span class="c1">// e argv é um array de strings, feito C (char*) representando os argumentos</span>
<span class="w">    </span><span class="c1">// O primeiro argumento é o nome pelo qual o programa foi chamado.</span>
<span class="w">    </span><span class="c1">// argc e argv pode ser omitido se você não se importa com argumentos,</span>
<span class="w">    </span><span class="c1">// dando a assinatura da função de int main()</span>

<span class="w">    </span><span class="c1">// Uma saída de status de 0 indica sucesso.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Em C++, caracteres literais são um byte.</span>
<span class="k">sizeof</span><span class="p">(</span><span class="sc">&#39;c&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span>

<span class="c1">// Em C, caracteres literais são do mesmo tamanho que ints.</span>
<span class="k">sizeof</span><span class="p">(</span><span class="sc">&#39;c&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="c1">// C++ tem prototipagem estrita</span>
<span class="kt">void</span><span class="w"> </span><span class="n">func</span><span class="p">();</span><span class="w"> </span><span class="c1">// função que não aceita argumentos</span>

<span class="c1">// Em C</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">();</span><span class="w"> </span><span class="c1">// função que pode aceitar qualquer número de argumentos</span>

<span class="c1">// Use nullptr em vez de NULL em C++</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="c1">// Cabeçalhos padrão C estão disponíveis em C++,</span>
<span class="c1">// mas são prefixados com &quot;c&quot; e não têm sufixo .h</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdio&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, world!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">///////////////////////</span>
<span class="c1">// Sobrecarga de função</span>
<span class="c1">///////////////////////</span>

<span class="c1">// C++ suporta sobrecarga de função</span>
<span class="c1">// desde que cada função tenha parâmetros diferentes.</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">myString</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;String %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">myString</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">myInt</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;My int is %d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">myInt</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Funciona para void print(const char*)</span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span><span class="w"> </span><span class="c1">// Funciona para void print(int)</span>
<span class="p">}</span>

<span class="c1">/////////////////////////////</span>
<span class="c1">// Parâmetros padrão de função</span>
<span class="c1">/////////////////////////////</span>

<span class="c1">// Você pode fornecer argumentos padrões para uma função se eles não são</span>
<span class="c1">// fornecidos pelo chamador.</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">doSomethingWithInts</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Faça alguma coisa com os ints aqui</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">doSomethingWithInts</span><span class="p">();</span><span class="w">      </span><span class="c1">// a = 1,  b = 4</span>
<span class="w">    </span><span class="n">doSomethingWithInts</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w">    </span><span class="c1">// a = 20, b = 4</span>
<span class="w">    </span><span class="n">doSomethingWithInts</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// a = 20, b = 5</span>
<span class="p">}</span>

<span class="c1">// Argumentos padrões devem estar no final da lista de argumentos.</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">invalidDeclaration</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="c1">// Erro!</span>
<span class="p">{</span>
<span class="p">}</span>


<span class="c1">/////////////</span>
<span class="c1">// Namespaces (nome de espaços)</span>
<span class="c1">/////////////</span>

<span class="c1">// Namespaces fornecem escopos distintos para variável, função e outras</span>
<span class="c1">// declarações. Namespaces podem estar aninhados.</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">First</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Nested</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;This is First::Nested::foo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// Fim do namespace aninhado</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// Fim do namespace First</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">Second</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;This is Second::foo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;This is global foo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Assuma que tudo é do namespace &quot;Second&quot; a menos que especificado de</span>
<span class="w">    </span><span class="c1">// outra forma.</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Second</span><span class="p">;</span>

<span class="w">    </span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// imprime &quot;This is Second::foo&quot;</span>
<span class="w">    </span><span class="n">First</span><span class="o">::</span><span class="n">Nested</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// imprime &quot;This is First::Nested::foo&quot;</span>
<span class="w">    </span><span class="o">::</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// imprime &quot;This is global foo&quot;</span>
<span class="p">}</span>

<span class="c1">///////////////</span>
<span class="c1">// Entrada/Saída</span>
<span class="c1">///////////////</span>

<span class="c1">// C ++ usa a entrada e saída de fluxos (streams)</span>
<span class="c1">// cin, cout, and cerr representa stdin, stdout, and stderr.</span>
<span class="c1">// &lt;&lt; É o operador de inserção e &gt;&gt; é o operador de extração.</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="c1"> // Inclusão para o I/O streams</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"> </span><span class="c1">// Streams estão no namespace std (biblioteca padrão)</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">myInt</span><span class="p">;</span>

<span class="w">   </span><span class="c1">// Imprime na saída padrão (ou terminal/tela)</span>
<span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Enter your favorite number:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">   </span><span class="c1">// Pega a entrada</span>
<span class="w">   </span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">myInt</span><span class="p">;</span>

<span class="w">   </span><span class="c1">// cout também pode ser formatado</span>
<span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Your favorite number is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myInt</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">   </span><span class="c1">// imprime &quot;Your favorite number is &lt;myInt&gt;&quot;</span>

<span class="w">    </span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Usado para mensagens de erro&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//////////</span>
<span class="c1">// Strings</span>
<span class="c1">//////////</span>

<span class="c1">// Strings em C++ são objetos e têm muitas funções de membro</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"> </span><span class="c1">// Strings também estão no namespace std (bib. padrão)</span>

<span class="n">string</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span><span class="p">;</span>
<span class="n">string</span><span class="w"> </span><span class="n">myOtherString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot; World&quot;</span><span class="p">;</span>

<span class="c1">// + é usado para concatenação.</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">myOtherString</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;Hello World&quot;</span>

<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; You&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;Hello You&quot;</span>

<span class="c1">// Em C++, strings são mutáveis e têm valores semânticos.</span>
<span class="n">myString</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot; Dog&quot;</span><span class="p">);</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myString</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;Hello Dog&quot;</span>


<span class="c1">/////////////</span>
<span class="c1">// Referência</span>
<span class="c1">/////////////</span>

<span class="c1">// Além de indicadores como os de C, C++ têm _referências_. Esses são tipos de</span>
<span class="c1">// ponteiro que não pode ser reatribuída uma vez definidos e não pode ser nulo.</span>
<span class="c1">// Eles também têm a mesma sintaxe que a própria variável: Não * é necessário</span>
<span class="c1">// para _dereferencing_ e &amp; (endereço de) não é usado para atribuição.</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="n">string</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;I am foo&quot;</span><span class="p">;</span>
<span class="n">string</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;I am bar&quot;</span><span class="p">;</span>


<span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">fooRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w"> </span><span class="c1">// Isso cria uma referência para foo.</span>
<span class="n">fooRef</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;. Hi!&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Modifica foo através da referência</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fooRef</span><span class="p">;</span><span class="w"> </span><span class="c1">// Imprime &quot;I am foo. Hi!&quot;</span>

<span class="c1">// Não realocar &quot;fooRef&quot;. Este é o mesmo que &quot;foo = bar&quot;, e foo == &quot;I am bar&quot;</span>
<span class="c1">// depois desta linha.</span>

<span class="n">fooRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span>

<span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">barRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span><span class="w"> </span><span class="c1">// Cria uma referência const para bar.</span>
<span class="c1">// Como C, valores const (e ponteiros e referências) não podem ser modificado.</span>
<span class="n">barRef</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;. Hi!&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Erro, referência const não pode ser modificada.</span>

<span class="c1">//////////////////////////////////////////</span>
<span class="c1">// Classes e programação orientada a objeto</span>
<span class="c1">//////////////////////////////////////////</span>

<span class="c1">// Primeiro exemplo de classes</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="c1">// Declara a classe.</span>
<span class="c1">// As classes são geralmente declarado no cabeçalho arquivos (.h ou .hpp).</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Dog</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Variáveis de membro e funções são privadas por padrão.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">weight</span><span class="p">;</span>

<span class="c1">// Todos os membros a seguir este são públicos até que &quot;private:&quot; ou</span>
<span class="c1">// &quot;protected:&quot; é encontrado.</span>
<span class="k">public</span><span class="o">:</span>

<span class="w">    </span><span class="c1">// Construtor padrão</span>
<span class="w">    </span><span class="n">Dog</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Declarações de função Membro (implementações a seguir)</span>
<span class="w">    </span><span class="c1">// Note que usamos std :: string aqui em vez de colocar</span>
<span class="w">    </span><span class="c1">// using namespace std;</span>
<span class="w">    </span><span class="c1">// acima.</span>
<span class="w">    </span><span class="c1">// Nunca coloque uma declaração &quot;using namespace&quot; em um cabeçalho.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">setName</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dogsName</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">setWeight</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">dogsWeight</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Funções que não modificam o estado do objeto devem ser marcadas como</span>
<span class="w">    </span><span class="c1">// const. Isso permite que você chamá-los se for dada uma referência const</span>
<span class="w">    </span><span class="c1">// para o objeto. Além disso, observe as funções devem ser explicitamente</span>
<span class="w">    </span><span class="c1">// declarados como _virtual_, a fim de ser substituídas em classes</span>
<span class="w">    </span><span class="c1">// derivadas. As funções não são virtuais por padrão por razões de</span>
<span class="w">    </span><span class="c1">// performance.</span>

<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// As funções também podem ser definidas no interior do corpo da classe.</span>
<span class="w">    </span><span class="c1">// Funções definidas como tal são automaticamente embutidas.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">bark</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; barks!</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Junto com os construtores, C++ fornece destruidores.</span>
<span class="w">    </span><span class="c1">// Estes são chamados quando um objeto é excluído ou fica fora do escopo.</span>
<span class="w">    </span><span class="c1">// Isto permite paradigmas poderosos, como RAII</span>
<span class="w">    </span><span class="c1">// (veja abaixo)</span>
<span class="w">    </span><span class="c1">// Destruidores devem ser virtual para permitir que as classes de ser</span>
<span class="w">    </span><span class="c1">// derivada desta.</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Dog</span><span class="p">();</span>

<span class="p">};</span><span class="w"> </span><span class="c1">// Um ponto e vírgula deve seguir a definição de classe.</span>

<span class="c1">// Funções membro da classe geralmente são implementados em arquivos .cpp.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Dog::Dog</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;A dog has been constructed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Objetos (como strings) devem ser passados por referência</span>
<span class="c1">// se você pretende modificá-los, ou com const caso contrário.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Dog::setName</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dogsName</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dogsName</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">Dog::setWeight</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">dogsWeight</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dogsWeight</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Observe que &quot;virtual&quot; só é necessária na declaração, não a definição.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Dog::print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Dog is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; and weighs &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;kg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">Dog</span><span class="o">::~</span><span class="n">Dog</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Goodbye &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Dog</span><span class="w"> </span><span class="n">myDog</span><span class="p">;</span><span class="w"> </span><span class="c1">// imprime &quot;A dog has been constructed&quot;</span>
<span class="w">    </span><span class="n">myDog</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">&quot;Barkley&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">myDog</span><span class="p">.</span><span class="n">setWeight</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="n">myDog</span><span class="p">.</span><span class="n">printDog</span><span class="p">();</span><span class="w"> </span><span class="c1">// imprime &quot;Dog is Barkley and weighs 10 kg&quot;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// imprime &quot;Goodbye Barkley&quot;</span>

<span class="c1">// herança:</span>

<span class="c1">// Essa classe herda tudo público e protegido da classe Dog</span>
<span class="k">class</span><span class="w"> </span><span class="nc">OwnedDog</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Dog</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">setOwner</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dogsOwner</span><span class="p">)</span>

<span class="w">    </span><span class="c1">// Substituir o comportamento da função de impressão de todas OwnedDogs.</span>
<span class="w">    </span><span class="c1">// Ver http://en.wikipedia.org/wiki/Polymorphism_(computer_science)#Subtyping</span>
<span class="w">    </span><span class="c1">// Para uma introdução mais geral, se você não estiver familiarizado com o</span>
<span class="w">    </span><span class="c1">// polimorfismo subtipo. A palavra-chave override é opcional, mas torna-se</span>
<span class="w">    </span><span class="c1">// na verdade você está substituindo o método em uma classe base.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">owner</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Enquanto isso, no arquivo .cpp correspondente:</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">OwnedDog::setOwner</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dogsOwner</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dogsOwner</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">OwnedDog::print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Dog</span><span class="o">::</span><span class="n">print</span><span class="p">();</span><span class="w"> </span><span class="c1">// Chame a função de impressão na classe Dog base de</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Dog is owned by &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">owner</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Imprime &quot;Dog is &lt;name&gt; and weights &lt;weight&gt;&quot;</span>
<span class="w">    </span><span class="c1">//        &quot;Dog is owned by &lt;owner&gt;&quot;</span>
<span class="p">}</span>

<span class="c1">//////////////////////////////////////////</span>
<span class="c1">// Inicialização e Sobrecarga de Operadores</span>
<span class="c1">//////////////////////////////////////////</span>

<span class="c1">// Em C ++, você pode sobrecarregar o comportamento dos operadores, tais como</span>
<span class="c1">// +, -, *, /, etc. Isto é feito através da definição de uma função que é</span>
<span class="c1">// chamado sempre que o operador é usado.</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Point</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// Variáveis membro pode ser dado valores padrão desta maneira.</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Define um construtor padrão que não faz nada</span>
<span class="w">    </span><span class="c1">// mas inicializar o Point para o valor padrão (0, 0)</span>
<span class="w">    </span><span class="n">Point</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// A sintaxe a seguir é conhecido como uma lista de inicialização</span>
<span class="w">    </span><span class="c1">// e é a maneira correta de inicializar os valores de membro de classe</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">        </span><span class="n">x</span><span class="p">(</span><span class="n">a</span><span class="p">),</span>
<span class="w">        </span><span class="n">y</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="cm">/* Não fazer nada, exceto inicializar os valores */</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Sobrecarrega o operador +.</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Sobrecarregar o operador +=.</span>
<span class="w">    </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Ele também faria sentido para adicionar os operadores - e -=,</span>
<span class="w">    </span><span class="c1">// mas vamos pular para sermos breves.</span>
<span class="p">};</span>

<span class="n">Point</span><span class="w"> </span><span class="n">Point</span><span class="o">::</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Criar um novo ponto que é a soma de um e rhs.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Point</span><span class="o">::</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="nf">up</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="nf">right</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Isto chama que o operador ponto +</span>
<span class="w">    </span><span class="c1">// Ressalte-se a chamadas (função)+ com direito como seu parâmetro...</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Imprime &quot;Result is upright (1,1)&quot;</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Result is upright (&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;,&#39;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/////////////////////////</span>
<span class="c1">// Tratamento de Exceções</span>
<span class="c1">/////////////////////////</span>

<span class="c1">// A biblioteca padrão fornece alguns tipos de exceção</span>
<span class="c1">// (see http://en.cppreference.com/w/cpp/error/exception)</span>
<span class="c1">// mas qualquer tipo pode ser jogado como uma exceção</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exception&gt;</span>

<span class="c1">// Todas as exceções lançadas dentro do bloco try pode ser capturado por</span>
<span class="c1">// manipuladores de captura subseqüentes</span>
<span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Não aloca exceções no heap usando _new_.</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="p">(</span><span class="s">&quot;A problem occurred&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// Capturar exceções por referência const se eles são objetos</span>
<span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
<span class="c1">// Captura qualquer exceção não capturada pelos blocos _catch_ anteriores</span>
<span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(...)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Exceção desconhecida encontrada&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">throw</span><span class="p">;</span><span class="w"> </span><span class="c1">// Re-lança a exceção</span>
<span class="p">}</span>

<span class="c1">///////</span>
<span class="c1">// RAII</span>
<span class="c1">///////</span>

<span class="c1">// RAII significa alocação de recursos é de inicialização.</span>
<span class="c1">// Muitas vezes, é considerado o paradigma mais poderoso em C++, e é o</span>
<span class="c1">// conceito simples que um construtor para um objeto adquire recursos daquele</span>
<span class="c1">// objeto e o destruidor liberá-los.</span>

<span class="c1">// Para entender como isso é útil,</span>
<span class="c1">// Considere uma função que usa um identificador de arquivo C:</span>
<span class="kt">void</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Para começar, assuma que nada pode falhar.</span>

<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Abra o arquivo em modo de leitura.</span>

<span class="w">    </span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Feche o arquivo.</span>
<span class="p">}</span>

<span class="c1">// Infelizmente, as coisas são levemente complicadas para tratamento de erros.</span>
<span class="c1">// Suponha que fopen pode falhar, e que doSomethingWithTheFile e</span>
<span class="c1">// doSomethingElseWithIt retornam códigos de erro se eles falharem. (As</span>
<span class="c1">// exceções são a forma preferida de lidar com o fracasso, mas alguns</span>
<span class="c1">// programadores, especialmente aqueles com um conhecimento em C, discordam</span>
<span class="c1">// sobre a utilidade de exceções). Agora temos que verificar cada chamada para</span>
<span class="c1">// o fracasso e fechar o identificador de arquivo se ocorreu um problema.</span>

<span class="kt">bool</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Abra o arquivo em modo de leitura</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fh</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="c1">// O ponteiro retornado é nulo em caso de falha.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Relate o fracasso para o chamador.</span>

<span class="w">    </span><span class="c1">// Suponha cada função retorne false, se falhar</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Feche o identificador de arquivo para que ele não vaze.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Propague o erro.</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Feche o identificador de arquivo para que ele não vaze.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Propague o erro.</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Feche o identificador de arquivo para que ele não vaze.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// Indica sucesso</span>
<span class="p">}</span>

<span class="c1">// Programadores C frequentemente limpam isso um pouco usando Goto:</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fh</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">failure</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">failure</span><span class="p">;</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Close the file</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// Indica sucesso</span>

<span class="nl">failure</span><span class="p">:</span>
<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Propague o erro.</span>
<span class="p">}</span>

<span class="c1">// Se as funções indicam erros usando exceções,</span>
<span class="c1">// as coisas são um pouco mais limpo, mas ainda abaixo do ideal.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Abra o arquivo em modo de leitura.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fh</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="p">(</span><span class="s">&quot;Não pode abrir o arquivo.&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">        </span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">catch</span><span class="w"> </span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Certifique-se de fechar o arquivo se ocorrer um erro.</span>
<span class="w">        </span><span class="k">throw</span><span class="p">;</span><span class="w"> </span><span class="c1">// Em seguida, re-lance a exceção.</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Feche o arquivo</span>
<span class="w">    </span><span class="c1">// Tudo ocorreu com sucesso!</span>
<span class="p">}</span>

<span class="c1">// Compare isso com o uso de C++ classe fluxo de arquivo (fstream) fstream usa</span>
<span class="c1">// seu destruidor para fechar o arquivo. Lembre-se de cima que destruidores são</span>
<span class="c1">// automaticamente chamado sempre que um objeto cai fora do âmbito.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// ifstream é curto para o fluxo de arquivo de entrada</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span><span class="w"> </span><span class="nf">fh</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span><span class="w"> </span><span class="c1">// Abra o arquivo</span>

<span class="w">    </span><span class="c1">// faça alguma coisa com o arquivo</span>
<span class="w">    </span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// O arquivo é automaticamente fechado aqui pelo destructor</span>

<span class="c1">// Isto tem _grandes_ vantagens:</span>
<span class="c1">// 1. Não importa o que aconteça,</span>
<span class="c1">//    o recurso (neste caso, o identificador de ficheiro) será limpo.</span>
<span class="c1">//    Depois de escrever o destruidor corretamente,</span>
<span class="c1">//    É _impossível_ esquecer de fechar e vazar o recurso</span>
<span class="c1">// 2. Nota-se que o código é muito mais limpo.</span>
<span class="c1">//    As alças destructor fecham o arquivo por trás das cenas</span>
<span class="c1">//    sem que você precise se preocupar com isso.</span>
<span class="c1">// 3. O código é seguro de exceção.</span>
<span class="c1">//    Uma exceção pode ser lançada em qualquer lugar na função e a limpeza</span>
<span class="c1">//    ainda irá ocorrer.</span>

<span class="c1">// Todos códigos C++ usam RAII extensivamente para todos os recursos.</span>
<span class="c1">// Outros exemplos incluem</span>
<span class="c1">// - Memória usa unique_ptr e shared_ptr</span>
<span class="c1">// - Contentores - a lista da biblioteca ligada padrão,</span>
<span class="c1">//   vetor (i.e. array de autodimensionamento), mapas hash, e assim por diante</span>
<span class="c1">//   tudo é automaticamente destruído quando eles saem de escopo</span>
<span class="c1">// - Mutex usa lock_guard e unique_lock</span>


<span class="c1">/////////////////////</span>
<span class="c1">// Templates</span>
<span class="c1">/////////////////////</span>

<span class="c1">// Templates em C++ são utilizados para programação genérica, ou seja,</span>
<span class="c1">// utilizar um tipo de dado genérico onde possa suportar qualquer entrada.</span>
<span class="c1">// Por exemplo, invés de criar uma função que apenas some inteiros, você</span>
<span class="c1">// poderá fazer uma função que soma double, float e inteiros em uma única</span>
<span class="c1">// definição para reutilizar código.</span>

<span class="c1">// Definimos um função que utiliza um &quot;typename&quot;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">soma</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// E agora para executá-la</span>
<span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">;</span>
<span class="kt">double</span><span class="w"> </span><span class="n">f</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="n">h</span><span class="p">;</span>
<span class="n">k</span><span class="o">=</span><span class="n">sum</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>
<span class="n">h</span><span class="o">=</span><span class="n">sum</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">g</span><span class="p">);</span>

<span class="c1">// Deste modo, não precisamos fazer overload nas funções! (:</span>
</pre></div>
<p>Leitura Adicional:</p>
<ul>
<li>Uma referência atualizada da linguagem pode ser encontrada em <a href="http://cppreference.com/w/cpp">CPP Reference</a>.</li>
<li>Uma fonte adicional pode ser encontrada em <a href="http://cplusplus.com">CPlusPlus</a>.</li>
<li>Um tutorial cobrindo o básico da linguagem e configurando o ambiente de codificação está disponível em <a href="https://www.youtube.com/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb">TheChernoProject - C ++</a>.</li>
</ul>

        <hr>
        <p>
          Sugestões ou correções? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Abra uma issue</a> no repositório do GitHub, ou faça um <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/pt-br/c++.md">pull request</a> você mesmo!
        </p>
        <p class="contributed">
          Originalmente contribuído por Steven Basart e atualizado por <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/pt-br/c++.md">12 colaboradores</a>.
        </p>

        <footer>
          <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width: 0; width: 80px; height: 28px; padding-bottom: 5px;" src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-sa.svg" /></a>
          <p>
            &copy; 2025
            <a href="http://github.com/xksteven">Steven Basart</a>,
            <a href="https://github.com/mrkline">Matt Kline</a>
          </p>
        </footer>
      </div>
    </div>
  </body>
</html>