<!DOCTYPE html>
<html lang="en">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-WXC8R75DEN');
    </script>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="Content-Language" content="en">
    <title>Learn Lisp Flavoured Erlang (LFE) in Y Minutes</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto+Slab:wght@100..900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/screen.css">
    <link rel="stylesheet" href="/css/light.css">
    <link rel="stylesheet" href="/css/dark.css">

    <link rel="canonical" href="https://learnxinyminutes.com/lfe/">
    <script>
      localStorage.removeItem("lxiym_theme");
    </script>
  </head>
  <body>
    <div class="container">
      <h1><a href="/">Learn X in Y minutes</a></h1>
      <h2>Where X=Lisp Flavoured Erlang (LFE)</h2>

      <p class="filelink">
        Get the code:
        <a href="/files/lispflavourederlang.lfe">lispflavourederlang.lfe</a>
      </p>
      <div id="doc">
<p>Lisp Flavoured Erlang (LFE) is a functional, concurrent, general-purpose programming
language and Lisp dialect (Lisp-2) built on top of Core Erlang and the Erlang Virtual Machine (BEAM).</p>
<p>LFE can be obtained from <a href="https://github.com/rvirding/lfe">LFE</a>.
The classic starting point is the <a href="http://docs.lfe.io">LFE docs</a>.</p>
<div class="highlight"><pre lang="lisp"><span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;;; 0. Syntax</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;;; General form.</span>

<span class="c1">;; Lisp is comprised of two syntaxes, the ATOM and the S-expression.</span>
<span class="c1">;; `forms` are known as grouped S-expressions.</span>

<span class="mi">8</span><span class="w">  </span><span class="c1">; an atom; it evaluates to itself</span>

<span class="ss">:ERLANG</span><span class="w"> </span><span class="c1">;Atom; evaluates to the symbol :ERLANG.</span>

<span class="no">t</span><span class="w">  </span><span class="c1">; another atom which denotes true.</span>

<span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">21</span><span class="p">)</span><span class="w"> </span><span class="c1">; an S- expression</span>

<span class="o">&#39;</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="ss">:foo</span><span class="w"> </span><span class="no">t</span><span class="p">)</span><span class="w">  </span><span class="c1">;another one</span>


<span class="c1">;;; Comments</span>

<span class="c1">;; Single line comments start with a semicolon; use two for normal</span>
<span class="c1">;; comments, three for section comments, and four fo file-level</span>
<span class="c1">;; comments.</span>

<span class="c1">;; Block Comment</span>

<span class="w">   </span><span class="cm">#| comment text |#</span>

<span class="c1">;;; Environment</span>

<span class="c1">;; LFE is the de-facto standard.</span>

<span class="c1">;; Libraries can be used directly from the Erlang ecosystem. Rebar3 is the build tool.</span>

<span class="c1">;; LFE is usually developed with a text editor(preferably Emacs) and a REPL</span>
<span class="c1">;; (Read Evaluate Print Loop) running at the same time. The REPL</span>
<span class="c1">;; allows for interactive exploration of the program as it is &quot;live&quot;</span>
<span class="c1">;; in the system.</span>

<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;;; 1. Literals and Special Syntactic Rules</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;;; Integers</span>

<span class="mi">1234</span><span class="w"> </span><span class="mi">-123</span><span class="w">           </span><span class="c1">; Regular decimal notation</span>
<span class="mb">#b0</span><span class="w"> </span><span class="mb">#b10101</span><span class="w">         </span><span class="c1">; Binary notation</span>
<span class="err">#</span><span class="mi">0</span><span class="w"> </span><span class="err">#</span><span class="mi">10101</span><span class="w">           </span><span class="c1">; Binary notation (alternative form)</span>
<span class="mo">#o377</span><span class="w"> </span><span class="mo">#o-111</span><span class="w">        </span><span class="c1">; Octal notation</span>
<span class="err">#</span><span class="nv">d123456789</span><span class="w"> </span><span class="err">#</span><span class="nv">d+123</span><span class="w">  </span><span class="c1">; Explicitly decimal notation</span>
<span class="mh">#xc0ffe</span><span class="w"> </span><span class="nv">0x-01</span><span class="w">       </span><span class="c1">; Hexadecimal notation</span>
<span class="m">#2r1010</span><span class="w"> </span><span class="m">#8r377</span><span class="w">      </span><span class="c1">;Notation with explicit base (up to 36)</span>
<span class="sc">#\a</span><span class="w"> </span><span class="err">#</span><span class="nv">$</span><span class="w"> </span><span class="sc">#\√§</span><span class="w"> </span><span class="sc">#\üê≠</span><span class="w">     </span><span class="c1">;Character notation (the value is the Unicode code point of the character)</span>
<span class="sc">#\x1f42d</span><span class="c1">;           ;Character notation with the value in hexadecimal</span>

<span class="c1">;;; Floating point numbers</span>
<span class="mf">1.0</span><span class="w"> </span><span class="mf">+2.0</span><span class="w"> </span><span class="mf">-1.5</span><span class="w"> </span><span class="mf">1.0e10</span><span class="w"> </span><span class="mf">1.111e-10</span>

<span class="c1">;;; Strings</span>

<span class="s">&quot;any text between double quotes where \&quot; and other special characters like \n can be escaped&quot;</span><span class="o">.</span>
<span class="c1">; List String</span>
<span class="s">&quot;Cat: \x1f639;&quot;</span><span class="w"> </span><span class="c1">; writing unicode in string for regular font ending with semicolon.</span>

<span class="l l-Other">#&quot;This is a binary string \n with some \&quot;escaped\&quot; and quoted (\x1f639;) characters&quot;</span>
<span class="c1">; Binary strings are just strings but function different in the VM.</span>
<span class="c1">; Other ways of writing it are:  #B(&quot;a&quot;), #&quot;a&quot;, and #B(97).</span>


<span class="c1">;;; Character escaping</span>

<span class="nv">\b</span><span class="w">  </span><span class="c1">; =&gt; Backspace</span>
<span class="nv">\t</span><span class="w">  </span><span class="c1">; =&gt; Tab</span>
<span class="nv">\n</span><span class="w">  </span><span class="c1">; =&gt; Newline</span>
<span class="nv">\v</span><span class="w">  </span><span class="c1">; =&gt; Vertical tab</span>
<span class="nv">\f</span><span class="w">  </span><span class="c1">; =&gt; Form Feed</span>
<span class="nv">\r</span><span class="w">  </span><span class="c1">; =&gt; Carriage Return</span>
<span class="nv">\e</span><span class="w">  </span><span class="c1">; =&gt; Escape</span>
<span class="nv">\s</span><span class="w">  </span><span class="c1">; =&gt; Space</span>
<span class="nv">\d</span><span class="w">  </span><span class="c1">; =&gt; Delete</span>

<span class="c1">;;; Binaries</span>
<span class="c1">;; It is used to create binaries with any contents.</span>
<span class="err">#</span><span class="nv">B</span><span class="p">((</span><span class="l l-Other">#&quot;a&quot;</span><span class="w"> </span><span class="nv">binary</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="l l-Other">#&quot;b&quot;</span><span class="w"> </span><span class="nv">binary</span><span class="p">))</span><span class="w">                 </span><span class="c1">; #&quot;ab&quot; (Evaluated form)</span>

<span class="c1">;;; Lists are: () or (foo bar baz)</span>

<span class="c1">;;; Tuples are written in: #(value1 value2 ...). Empty tuple #() is also valid.</span>

<span class="c1">;;; Maps are written as: #M(key1 value1 key2 value2 ...). Empty map #M() is also valid.</span>

<span class="c1">;;; Symbols: Things that cannot be parsed. Eg: foo, Foo, foo-bar, :foo</span>
<span class="nv">| foo |</span><span class="w"> </span><span class="c1">; explicit construction of symbol by wrapping vertical bars.</span>

<span class="c1">;;; Evaluation</span>

<span class="c1">;; #.(... some expression ...). E.g. &#39;#.(+ 1 1) will evaluate the (+ 1 1) while it            ;; reads the expression and then be effectively &#39;2.</span>

<span class="c1">;; List comprehension in LFE REPL</span>

<span class="nv">lfe&gt;</span><span class="w"> </span><span class="p">(</span><span class="nv">list-comp</span>
<span class="w">          </span><span class="p">((</span><span class="nv">&lt;-</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)))</span>
<span class="w">          </span><span class="p">(</span><span class="nv">trunc</span><span class="w"> </span><span class="p">(</span><span class="nv">math:pow</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="nv">x</span><span class="p">)))</span>
<span class="w">       </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">27</span><span class="p">)</span>


<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; 2. Core forms</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;; These forms are the same as those found in Common Lisp and Scheme.</span>

<span class="p">(</span><span class="k">quote</span><span class="w"> </span><span class="nv">e</span><span class="p">)</span>
<span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="nv">head</span><span class="w"> </span><span class="nv">tail</span><span class="p">)</span>
<span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="nv">e</span><span class="p">)</span>
<span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="nv">e</span><span class="p">)</span>
<span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">e</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="p">(</span><span class="nv">tuple</span><span class="w"> </span><span class="nv">e</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="p">(</span><span class="nv">binary</span><span class="w"> </span><span class="nv">seg</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nv">key</span><span class="w"> </span><span class="nv">val</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="o">,</span><span class="w"> </span><span class="p">(</span><span class="nv">map-get</span><span class="w"> </span><span class="nv">m</span><span class="w"> </span><span class="nv">k</span><span class="p">)</span><span class="o">,</span><span class="w"> </span><span class="p">(</span><span class="nv">map-set</span><span class="w"> </span><span class="nv">m</span><span class="w"> </span><span class="nv">k</span><span class="w"> </span><span class="nv">v</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="o">,</span><span class="w"> </span><span class="p">(</span><span class="nv">map-update</span><span class="w"> </span><span class="nv">m</span><span class="w"> </span><span class="nv">k</span><span class="w"> </span><span class="nv">v</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>

<span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nv">arg</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nv">match-lambda</span>
<span class="w">    </span><span class="p">((</span><span class="nv">arg</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="nv">{{</span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="nv">e</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="nv">}}</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="w"> </span><span class="c1">; Matches clauses</span>
<span class="w">    </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nv">pat</span><span class="w"> </span><span class="nv">{{</span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="nv">e</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="nv">}}</span><span class="w"> </span><span class="nv">e</span><span class="p">)</span>
<span class="w">      </span><span class="o">...</span><span class="p">)</span>
<span class="w">  </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="p">(</span><span class="nv">let-function</span><span class="w"> </span><span class="p">((</span><span class="nv">name</span><span class="w"> </span><span class="k">lambda</span><span class="nv">|match-lambda) ; Only define local</span>
<span class="nv">               ... )                      ; functions</span>
<span class="nv">  ... )</span>
<span class="nv">(letrec-function ((name lambda|match-lambda</span><span class="p">)</span><span class="w"> </span><span class="c1">; Only define local</span>
<span class="w">                  </span><span class="o">...</span><span class="w"> </span><span class="p">)</span><span class="w">                      </span><span class="c1">; functions</span>
<span class="w">  </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="p">(</span><span class="nv">let-macro</span><span class="w"> </span><span class="p">((</span><span class="nv">name</span><span class="w"> </span><span class="nv">lambda-match-lambda</span><span class="p">)</span><span class="w"> </span><span class="c1">; Only define local</span>
<span class="w">            </span><span class="o">...</span><span class="p">)</span><span class="w">                       </span><span class="c1">; macros</span>
<span class="w">  </span><span class="o">...</span><span class="p">)</span>
<span class="p">(</span><span class="k">progn</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">test</span><span class="w"> </span><span class="nv">true-expr</span><span class="w"> </span><span class="nv">{{false-expr}}</span><span class="p">)</span>
<span class="p">(</span><span class="nb">case</span><span class="w"> </span><span class="nv">e</span>
<span class="w">  </span><span class="p">(</span><span class="nv">pat</span><span class="w"> </span><span class="nv">{{</span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="nv">e</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="nv">}}</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>
<span class="w">   </span><span class="o">...</span><span class="w"> </span><span class="p">))</span>
<span class="p">(</span><span class="nv">receive</span>
<span class="w">  </span><span class="p">(</span><span class="nv">pat</span><span class="w"> </span><span class="nv">{{</span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="nv">e</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="nv">}}</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="w">  </span><span class="o">...</span>
<span class="w">  </span><span class="p">(</span><span class="nv">after</span><span class="w"> </span><span class="nv">timeout</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">))</span>
<span class="p">(</span><span class="k">catch</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="p">(</span><span class="nv">try</span>
<span class="w">  </span><span class="nv">e</span>
<span class="w">  </span><span class="nv">{{</span><span class="p">(</span><span class="nb">case</span><span class="w"> </span><span class="p">((</span><span class="nv">pat</span><span class="w"> </span><span class="nv">{{</span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="nv">e</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="nv">}}</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="w">          </span><span class="o">...</span><span class="w"> </span><span class="p">))</span><span class="nv">}}</span>
<span class="w">  </span><span class="nv">{{</span><span class="p">(</span><span class="k">catch</span>
<span class="w">     </span><span class="c1">; Next must be tuple of length 3!</span>
<span class="w">     </span><span class="p">(((</span><span class="nv">tuple</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="nv">value</span><span class="w"> </span><span class="k">ignore</span><span class="p">)</span><span class="w"> </span><span class="nv">{{</span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="nv">e</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="nv">}}</span>
<span class="w">      </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="w">     </span><span class="o">...</span><span class="w"> </span><span class="p">)</span><span class="nv">}}</span>
<span class="w">  </span><span class="nv">{{</span><span class="p">(</span><span class="nv">after</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span><span class="nv">}}</span><span class="p">)</span>

<span class="p">(</span><span class="nb">funcall</span><span class="w"> </span><span class="nv">func</span><span class="w"> </span><span class="nv">arg</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="p">(</span><span class="nv">call</span><span class="w"> </span><span class="nb">mod</span><span class="w"> </span><span class="nv">func</span><span class="w"> </span><span class="nv">arg</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="nb">-</span><span class="w"> </span><span class="nv">Call</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">Erlang</span><span class="w"> </span><span class="nv">Mod:Func</span><span class="p">(</span><span class="nv">Arg,</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="p">(</span><span class="nv">define-module</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="nv">declaration</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="p">(</span><span class="nv">extend-module</span><span class="w"> </span><span class="nv">declaration</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="nb">-</span><span class="w"> </span><span class="nv">Define/extend</span><span class="w"> </span><span class="nv">module</span><span class="w"> </span><span class="nb">and</span><span class="w"> </span><span class="nv">declarations.</span>
<span class="p">(</span><span class="nv">define-function</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="k">lambda</span><span class="nv">|match-lambda)</span>
<span class="nv">(define-macro name lambda|match-lambda</span><span class="p">)</span><span class="w"> </span><span class="nb">-</span><span class="w"> </span><span class="nv">Define</span><span class="w"> </span><span class="nv">functions/macros</span><span class="w"> </span><span class="nv">at</span><span class="w"> </span><span class="nv">top-level.</span>

<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; 3. Macros</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;; Macros are part of the language and allow you to create abstractions</span>
<span class="c1">;; on top of the core language and standard library that move you closer</span>
<span class="c1">;; toward being able to directly express the things you want to express.</span>

<span class="c1">;; Top-level function</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="p">(</span><span class="nv">arg</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>

<span class="c1">;; Adding comments in functions</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">name</span>
<span class="w">  </span><span class="s">&quot;Toplevel function with pattern-matching arguments&quot;</span>
<span class="w">  </span><span class="p">((</span><span class="nv">argpat</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>
<span class="w">  </span><span class="o">...</span><span class="p">)</span>

<span class="c1">;; Top-level macro</span>

<span class="p">(</span><span class="nb">defmacro</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="p">(</span><span class="nv">arg</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>
<span class="p">(</span><span class="nb">defmacro</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="nv">arg</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>

<span class="c1">;; Top-level macro with pattern matching arguments</span>

<span class="p">(</span><span class="nb">defmacro</span><span class="w"> </span><span class="nv">name</span>
<span class="w">  </span><span class="p">((</span><span class="nv">argpat</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>
<span class="w">  </span><span class="o">...</span><span class="p">)</span>

<span class="c1">;; Top-level macro using Scheme inspired syntax-rules format</span>

<span class="p">(</span><span class="nv">defsyntax</span><span class="w"> </span><span class="nv">name</span>
<span class="w">  </span><span class="p">(</span><span class="nv">pat</span><span class="w"> </span><span class="nb">exp</span><span class="p">)</span>
<span class="w">  </span><span class="o">...</span><span class="p">)</span>

<span class="c1">;;; Local macros in macro or syntax-rule format</span>

<span class="p">(</span><span class="k">macrolet</span><span class="w"> </span><span class="p">((</span><span class="nv">name</span><span class="w"> </span><span class="p">(</span><span class="nv">arg</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>

<span class="p">(</span><span class="nv">syntaxlet</span><span class="w"> </span><span class="p">((</span><span class="nv">name</span><span class="w"> </span><span class="p">(</span><span class="nv">pat</span><span class="w"> </span><span class="nb">exp</span><span class="p">)</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>
<span class="w">             </span><span class="o">...</span><span class="p">)</span>
<span class="w"> </span><span class="o">...</span><span class="p">)</span>

<span class="c1">;; Like CLISP</span>

<span class="p">(</span><span class="nb">prog1</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>
<span class="p">(</span><span class="nb">prog2</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>

<span class="c1">;; Erlang LFE module</span>

<span class="p">(</span><span class="nv">defmodule</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>

<span class="c1">;; Erlang LFE record</span>

<span class="p">(</span><span class="nv">defrecord</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>

<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; 4. Patterns and Guards</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;; Using patterns in LFE compared to that of Erlang</span>

<span class="c1">;; Erlang                     ;; LFE</span>
<span class="c1">;; {ok, X}                       (tuple &#39;ok x)</span>
<span class="c1">;; error                         &#39;error</span>
<span class="c1">;; {yes, [X|Xs]}                 (tuple &#39;yes (cons x xs))</span>
<span class="c1">;; &lt;&lt;34,F/float&gt;&gt;                (binary 34 (f float))</span>
<span class="c1">;; [P|Ps]=All                    (= (cons p ps) all)</span>

<span class="w">  </span><span class="nv">_</span><span class="w">    </span><span class="c1">; =&gt; is don&#39;t care while pattern matching</span>

<span class="w">  </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="nv">pattern1</span><span class="w"> </span><span class="nv">pattern2</span><span class="p">)</span><span class="w">     </span><span class="c1">; =&gt; easier, better version of pattern matching</span>

<span class="c1">;; Guards</span>

<span class="c1">;; Whenever pattern occurs (let, case, receive, lc, etc) it can be followed by an optional</span>
<span class="c1">;; guard which has the form (when test ...).</span>

<span class="p">(</span><span class="k">progn</span><span class="w"> </span><span class="nv">gtest</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="w">             </span><span class="c1">;; =&gt; Sequence of guard tests</span>
<span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">gexpr</span><span class="w"> </span><span class="nv">gexpr</span><span class="w"> </span><span class="nv">gexpr</span><span class="p">)</span>
<span class="p">(</span><span class="nv">type-test</span><span class="w"> </span><span class="nv">e</span><span class="p">)</span>
<span class="p">(</span><span class="nv">guard-bif</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="w">               </span><span class="c1">;; =&gt; Guard BIFs, arithmetic, boolean and comparison operators</span>

<span class="c1">;;; REPL</span>

<span class="nv">lfe&gt;</span><span class="p">(</span><span class="nb">set</span><span class="w"> </span><span class="p">(</span><span class="nv">tuple</span><span class="w"> </span><span class="nv">len</span><span class="w"> </span><span class="nv">status</span><span class="w"> </span><span class="nv">msg</span><span class="p">)</span><span class="w"> </span><span class="o">#(</span><span class="mi">8</span><span class="w"> </span><span class="nv">ok</span><span class="w"> </span><span class="s">&quot;Trillian&quot;</span><span class="p">))</span>
<span class="w">    </span><span class="o">#(</span><span class="mi">8</span><span class="w"> </span><span class="nv">ok</span><span class="w"> </span><span class="s">&quot;Trillian&quot;</span><span class="p">)</span>
<span class="nv">lfe&gt;msg</span>
<span class="w">    </span><span class="s">&quot;Trillian&quot;</span>

<span class="c1">;;; Program illustrating use of Guards</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">right-number?</span>
<span class="w">        </span><span class="p">((</span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nv">orelse</span><span class="w"> </span><span class="p">(</span><span class="nv">==</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="mi">42</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">==</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="mi">276709</span><span class="p">)))</span>
<span class="w">          </span><span class="ss">&#39;true</span><span class="p">)</span>
<span class="w">        </span><span class="p">((</span><span class="nv">_</span><span class="p">)</span><span class="w"> </span><span class="ss">&#39;false</span><span class="p">))</span>

<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; 5. Functions</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;; A simple function using if.</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nb">max</span><span class="w"> </span><span class="p">(</span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;The max function.&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;=</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">))</span>

<span class="c1">;; Same function using more clause</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nb">max</span>
<span class="w">  </span><span class="s">&quot;The max function.&quot;</span>
<span class="w">  </span><span class="p">((</span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;=</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">))</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span>
<span class="w">  </span><span class="p">((</span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span><span class="w"> </span><span class="nv">y</span><span class="p">))</span>

<span class="c1">;; Same function using similar style but using local functions defined by flet or fletrec</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">foo</span><span class="w"> </span><span class="p">(</span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;The max function.&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="k">flet</span><span class="w"> </span><span class="p">((</span><span class="nv">m</span><span class="w"> </span><span class="p">(</span><span class="nv">a</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span><span class="w"> </span><span class="s">&quot;Local comment.&quot;</span>
<span class="w">            </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;=</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">b</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">m</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">)))</span>

<span class="c1">;; LFE being Lisp-2 has separate namespaces for variables and functions</span>
<span class="c1">;; Both variables and function/macros are lexically scoped.</span>
<span class="c1">;; Variables are bound by lambda, match-lambda and let.</span>
<span class="c1">;; Functions are bound by top-level defun, flet and fletrec.</span>
<span class="c1">;; Macros are bound by top-level defmacro/defsyntax and by macrolet/syntaxlet.</span>

<span class="c1">;; (funcall func arg ...) like CL to call lambdas/match-lambdas</span>
<span class="c1">;; (funs) bound to variables are used.</span>

<span class="c1">;; separate bindings and special for apply.</span>
<span class="nb">apply</span><span class="w"> </span><span class="nv">_F</span><span class="w"> </span><span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="o">,</span>
<span class="nb">apply</span><span class="w"> </span><span class="nv">_F/3</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nv">a1,</span><span class="w"> </span><span class="nv">a2,</span><span class="w"> </span><span class="nv">a3</span><span class="w"> </span><span class="p">)</span>

<span class="c1">;; Cons&#39;ing in function heads</span>
<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">sum</span><span class="w"> </span><span class="p">(</span><span class="nv">l</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">sum</span><span class="w"> </span><span class="nv">l</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">sum</span>
<span class="w">    </span><span class="p">((</span><span class="o">&#39;</span><span class="p">()</span><span class="w"> </span><span class="nv">total</span><span class="p">)</span><span class="w"> </span><span class="nv">total</span><span class="p">)</span>
<span class="w">    </span><span class="p">(((</span><span class="nb">cons</span><span class="w"> </span><span class="nv">h</span><span class="w"> </span><span class="no">t</span><span class="p">)</span><span class="w"> </span><span class="nv">total</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">sum</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="nv">h</span><span class="w"> </span><span class="nv">total</span><span class="p">))))</span>

<span class="c1">;; ``cons`` literal instead of constructor form</span>
<span class="w">      </span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">sum</span><span class="w"> </span><span class="p">(</span><span class="nv">l</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">sum</span><span class="w"> </span><span class="nv">l</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">sum</span>
<span class="w">        </span><span class="p">((</span><span class="o">&#39;</span><span class="p">()</span><span class="w"> </span><span class="nv">total</span><span class="p">)</span><span class="w"> </span><span class="nv">total</span><span class="p">)</span>
<span class="w">        </span><span class="p">((</span><span class="o">`</span><span class="p">(</span><span class="o">,</span><span class="nv">h</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="o">,</span><span class="no">t</span><span class="p">)</span><span class="w"> </span><span class="nv">total</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">sum</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="nv">h</span><span class="w"> </span><span class="nv">total</span><span class="p">))))</span>

<span class="c1">;; Matching records in function heads</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">handle_info</span>
<span class="w">  </span><span class="p">((</span><span class="ss">&#39;ping</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nv">match-state</span><span class="w"> </span><span class="nv">remote-pid</span><span class="w"> </span><span class="ss">&#39;undefined</span><span class="p">)</span><span class="w"> </span><span class="nv">state</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">gen_server:cast</span><span class="w"> </span><span class="p">(</span><span class="nv">self</span><span class="p">)</span><span class="w"> </span><span class="ss">&#39;ping</span><span class="p">)</span>
<span class="w">    </span><span class="o">`#(</span><span class="nv">noreply</span><span class="w"> </span><span class="o">,</span><span class="nv">state</span><span class="p">))</span>
<span class="w">  </span><span class="p">((</span><span class="ss">&#39;ping</span><span class="w"> </span><span class="nv">state</span><span class="p">)</span>
<span class="w">   </span><span class="o">`#(</span><span class="nv">noreply</span><span class="w"> </span><span class="o">,</span><span class="nv">state</span><span class="p">)))</span>

<span class="c1">;; Receiving Messages</span>
<span class="w">      </span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">universal-server</span><span class="w"> </span><span class="p">()</span>
<span class="w">        </span><span class="p">(</span><span class="nv">receive</span>
<span class="w">          </span><span class="p">((</span><span class="nv">tuple</span><span class="w"> </span><span class="ss">&#39;become</span><span class="w"> </span><span class="nv">func</span><span class="p">)</span>
<span class="w">           </span><span class="p">(</span><span class="nb">funcall</span><span class="w"> </span><span class="nv">func</span><span class="p">))))</span>

<span class="c1">;; another way for receiving messages</span>

<span class="w"> </span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">universal-server</span><span class="w"> </span><span class="p">()</span>
<span class="w">        </span><span class="p">(</span><span class="nv">receive</span>
<span class="w">          </span><span class="p">(</span><span class="o">`#(</span><span class="nv">become</span><span class="w"> </span><span class="o">,</span><span class="nv">func</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nb">funcall</span><span class="w"> </span><span class="nv">func</span><span class="p">))))</span>

<span class="c1">;; Composing a complete function for specific tasks</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">compose</span><span class="w"> </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="nv">g</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nv">x</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">funcall</span><span class="w"> </span><span class="nv">f</span>
<span class="w">     </span><span class="p">(</span><span class="nb">funcall</span><span class="w"> </span><span class="nv">g</span><span class="w"> </span><span class="nv">x</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">check</span><span class="w"> </span><span class="p">()</span>
<span class="w">  </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="p">((</span><span class="nv">sin-asin</span><span class="w"> </span><span class="p">(</span><span class="nv">compose</span><span class="w"> </span><span class="nf">#&#39;</span><span class="nv">sin/1</span><span class="w"> </span><span class="nf">#&#39;</span><span class="nv">asin/1</span><span class="p">))</span>
<span class="w">         </span><span class="p">(</span><span class="nv">expected</span><span class="w"> </span><span class="p">(</span><span class="nb">sin</span><span class="w"> </span><span class="p">(</span><span class="nb">asin</span><span class="w"> </span><span class="mf">0.5</span><span class="p">)))</span>
<span class="w">         </span><span class="p">(</span><span class="nv">compose-result</span><span class="w"> </span><span class="p">(</span><span class="nb">funcall</span><span class="w"> </span><span class="nv">sin-asin</span><span class="w"> </span><span class="mf">0.5</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">io:format</span><span class="w"> </span><span class="s">&quot;Expected answer: ~p~n&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">expected</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">io:format</span><span class="w"> </span><span class="s">&quot;Answer with compose: ~p~n&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">compose-result</span><span class="p">))))</span>


<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; 6. Concurrency</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;; Message passing as done by Erlang&#39;s light-weight &quot;processes&quot;.</span>

<span class="p">(</span><span class="nv">defmodule</span><span class="w"> </span><span class="nv">messenger-back</span>
<span class="w"> </span><span class="p">(</span><span class="nb">export</span><span class="w"> </span><span class="p">(</span><span class="nv">print-result</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">send-message</span><span class="w"> </span><span class="mi">2</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">print-result</span><span class="w"> </span><span class="p">()</span>
<span class="w">  </span><span class="p">(</span><span class="nv">receive</span>
<span class="w">    </span><span class="p">((</span><span class="nv">tuple</span><span class="w"> </span><span class="nv">pid</span><span class="w"> </span><span class="nv">msg</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nv">io:format</span><span class="w"> </span><span class="s">&quot;Received message: &#39;~s&#39;~n&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">msg</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nv">io:format</span><span class="w"> </span><span class="s">&quot;Sending message to process ~p ...~n&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">pid</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nv">!</span><span class="w"> </span><span class="nv">pid</span><span class="w"> </span><span class="p">(</span><span class="nv">tuple</span><span class="w"> </span><span class="nv">msg</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nv">print-result</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">send-message</span><span class="w"> </span><span class="p">(</span><span class="nv">calling-pid</span><span class="w"> </span><span class="nv">msg</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nv">spawned-pid</span><span class="w"> </span><span class="p">(</span><span class="nv">spawn</span><span class="w"> </span><span class="ss">&#39;messenger-back</span><span class="w"> </span><span class="ss">&#39;print-result</span><span class="w"> </span><span class="p">())))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">!</span><span class="w"> </span><span class="nv">spawned-pid</span><span class="w"> </span><span class="p">(</span><span class="nv">tuple</span><span class="w"> </span><span class="nv">calling-pid</span><span class="w"> </span><span class="nv">msg</span><span class="p">))))</span>

<span class="c1">;; Multiple simultaneous HTTP Requests:</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">parse-args</span><span class="w"> </span><span class="p">(</span><span class="nv">flag</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Given one or more command-line arguments, extract the passed values.</span>

<span class="s">  For example, if the following was passed via the command line:</span>

<span class="s">    $ erl -my-flag my-value-1 -my-flag my-value-2</span>

<span class="s">  One could then extract it in an LFE program by calling this function:</span>

<span class="s">    (let ((args (parse-args &#39;my-flag)))</span>
<span class="s">      ...</span>
<span class="s">      )</span>
<span class="s">  In this example, the value assigned to the arg variable would be a list</span>
<span class="s">  containing the values my-value-1 and my-value-2.&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="o">`#(</span><span class="nv">ok</span><span class="w"> </span><span class="o">,</span><span class="nv">data</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">init:get_argument</span><span class="w"> </span><span class="nv">flag</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">lists:merge</span><span class="w"> </span><span class="nv">data</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">get-pages</span><span class="w"> </span><span class="p">()</span>
<span class="w">  </span><span class="s">&quot;With no argument, assume &#39;url parameter was passed via command line.&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nv">urls</span><span class="w"> </span><span class="p">(</span><span class="nv">parse-args</span><span class="w"> </span><span class="ss">&#39;url</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">get-pages</span><span class="w"> </span><span class="nv">urls</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">get-pages</span><span class="w"> </span><span class="p">(</span><span class="nv">urls</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Start inets and make (potentially many) HTTP requests.&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="nv">inets:start</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nv">plists:map</span>
<span class="w">    </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nv">x</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nv">get-page</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span><span class="w"> </span><span class="nv">urls</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">get-page</span><span class="w"> </span><span class="p">(</span><span class="nv">url</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Make a single HTTP request.&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="p">((</span><span class="nc">method</span><span class="w"> </span><span class="ss">&#39;get</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="nv">headers</span><span class="w"> </span><span class="o">&#39;</span><span class="p">())</span>
<span class="w">         </span><span class="p">(</span><span class="nv">request-data</span><span class="w"> </span><span class="o">`#(,</span><span class="nv">url</span><span class="w"> </span><span class="o">,</span><span class="nv">headers</span><span class="p">))</span>
<span class="w">         </span><span class="p">(</span><span class="nv">http-options</span><span class="w"> </span><span class="p">())</span>
<span class="w">         </span><span class="p">(</span><span class="nv">request-options</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="o">#(</span><span class="nv">sync</span><span class="w"> </span><span class="nv">false</span><span class="p">))))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">httpc:request</span><span class="w"> </span><span class="nc">method</span><span class="w"> </span><span class="nv">request-data</span><span class="w"> </span><span class="nv">http-options</span><span class="w"> </span><span class="nv">request-options</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nv">receive</span>
<span class="w">      </span><span class="p">(</span><span class="o">`#(</span><span class="nv">http</span><span class="w"> </span><span class="o">#(,</span><span class="nv">request-id</span><span class="w"> </span><span class="o">#(</span><span class="nb">error</span><span class="w"> </span><span class="o">,</span><span class="nv">reason</span><span class="p">)))</span>
<span class="w">       </span><span class="p">(</span><span class="nv">io:format</span><span class="w"> </span><span class="s">&quot;Error: ~p~n&quot;</span><span class="w"> </span><span class="o">`</span><span class="p">(</span><span class="o">,</span><span class="nv">reason</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="o">`#(</span><span class="nv">http</span><span class="w"> </span><span class="o">#(,</span><span class="nv">request-id</span><span class="w"> </span><span class="o">,</span><span class="nv">result</span><span class="p">))</span>
<span class="w">       </span><span class="p">(</span><span class="nv">io:format</span><span class="w"> </span><span class="s">&quot;Result: ~p~n&quot;</span><span class="w"> </span><span class="o">`</span><span class="p">(</span><span class="o">,</span><span class="nv">result</span><span class="p">))))))</span>
</pre></div>
<h2>Further Reading</h2>
<ul>
<li><a href="http://docs.lfe.io">LFE DOCS</a></li>
<li><a href="https://lfe.gitbooks.io/reference-guide/index.html">LFE GitBook</a></li>
<li><a href="https://en.wikipedia.org/wiki/LFE_(programming_language)">LFE Wiki</a></li>
</ul>
<h2>Extra Info</h2>
<ul>
<li><a href="http://www.erlang-factory.com/upload/presentations/61/Robertvirding-LispFlavouredErlang.pdf">LFE PDF</a></li>
<li><a href="https://groups.google.com/d/msg/lisp-flavoured-erlang/XA5HeLbQQDk/TUHabZCHXB0J">LFE mail</a></li>
</ul>

        <hr>
        <p>
          Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the GitHub Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/lfe.md">pull request</a> yourself!
        </p>
        <p class="contributed">
          Originally contributed by Pratik Karki, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/lfe.md">3 contributors</a>.
        </p>

        <footer>
          <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width: 0; width: 80px; height: 28px; padding-bottom: 5px;" src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-sa.svg" /></a>
          <p>
            &copy; 2025
            <a href="https://github.com/prertik">Pratik Karki</a>
          </p>
        </footer>
      </div>

      <script>
        document.addEventListener('DOMContentLoaded', () => {
          const langSelect = document.getElementById('lang-select');
          langSelect?.addEventListener('change', () => {
            const selectedOption = langSelect.options[langSelect.selectedIndex];
            const url = selectedOption?.getAttribute('data-url');
            if (url) {
              window.location.href = url;
            }
          });
        });
      </script>
    </div>
  </body>
</html>