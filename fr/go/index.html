<!DOCTYPE html>
<html lang="fr">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-WXC8R75DEN');
    </script>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="Content-Language" content="fr">
    <title>Learn Go in Y Minutes</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto+Slab:wght@100..900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/screen.css">
    <link rel="stylesheet" href="/css/light.css">
    <link rel="stylesheet" href="/css/dark.css">

    <link rel="canonical" href="https://learnxinyminutes.com/fr/go/">
    <script>
      localStorage.removeItem("lxiym_theme");
    </script>
  </head>
  <body>
    <div class="container">
      <div class="share">
        <span class="sharemsg">
          <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Ffr%2Fgo%2F&amp;text=Apprendre+X+en+Y+minutes%2C+o%C3%B9+X%3DGo">
            Partager cette page
          </a>
        </span>
        <span class='st_facebook_large' displayText='Facebook'></span>
        <span class='st_twitter_large' displayText='Tweet'></span>
      </div>
      <h1><a href="/">Apprendre X en Y minutes</a></h1>
      <h2>Où X=Go</h2>
      <p class="filelink">
        Récupérer le code:
        <a href="/fr/files/learngo.go">learngo.go</a>
      </p>
      <div id="doc">
<p>Go a été créé dans l'optique de développer de façon efficace. Ce n'est pas la
dernière tendance en ce qui est au développement, mais c'est la nouvelle façon
de régler des défis réels de façon rapide.</p>
<p>Le langage possède des concepts familiers à la programmation impérative avec
typage. Il est rapide à compiler et exécuter, ajoute une concurrence facile à
comprendre, pour les processeurs multi coeurs d'aujourd'hui et apporte des
fonctionnalités facilitant le développement à grande échelle.</p>
<p>Développer avec Go, c'est bénéficier d'une riche bibliothèque standard et d'une
communauté active.</p>
<div class="highlight"><pre lang="go"><span class="c1">// Commentaire ligne simple</span>
<span class="cm">/* Commentaire</span>
<span class="cm"> multiligne */</span>

<span class="c1">// Un paquet débute avec une clause &quot;package&quot;</span>
<span class="c1">// &quot;main&quot; est un nom spécial déclarant un paquet de type exécutable plutôt</span>
<span class="c1">// qu&#39;une bibliothèque</span>
<span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="c1">// &quot;Import&quot; déclare les paquets référencés dans ce fichier.</span>
<span class="kn">import</span><span class="w"> </span><span class="p">(</span>
<span class="w">  </span><span class="s">&quot;fmt&quot;</span><span class="w">       </span><span class="c1">// Un paquet dans la bibliothèque standard.</span>
<span class="w">  </span><span class="s">&quot;io/ioutil&quot;</span><span class="w"> </span><span class="c1">// Implémente des fonctions utilitaires I/O.</span>
<span class="w">  </span><span class="nx">m</span><span class="w"> </span><span class="s">&quot;math&quot;</span><span class="w">    </span><span class="c1">// Bibliothèque mathématique utilisant un alias local &quot;m&quot;.</span>
<span class="w">  </span><span class="s">&quot;net/http&quot;</span><span class="w">  </span><span class="c1">// Un serveur Web!</span>
<span class="w">  </span><span class="s">&quot;strconv&quot;</span><span class="w">   </span><span class="c1">// Bibliothèque pour convertir les chaînes de caractères.</span>
<span class="p">)</span>

<span class="c1">// Une définition de fonction. La fonction &quot;main&quot; est spéciale - c&#39;est le point</span>
<span class="c1">// d&#39;entrée du binaire.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Println retournera la valeur à la console.</span>
<span class="w">  </span><span class="c1">// Associez la fonction avec son paquet respectif, fmt.</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Hello world!&quot;</span><span class="p">)</span>

<span class="w">  </span><span class="c1">// Appelez une fonction différente à partir de ce paquet.</span>
<span class="w">  </span><span class="nx">beyondHello</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// Les fonctions ont des paramètres entre parenthèses.</span>
<span class="c1">// Les parenthèses sont nécessaires avec ou sans paramètre.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">beyondHello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="c1">// Déclaration de variable. Les variables doivent être déclarées</span>
<span class="w">            </span><span class="c1">// avant leur utilisation.</span>
<span class="w">  </span><span class="nx">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">3</span><span class="w">     </span><span class="c1">// Assignation de valeur.</span>
<span class="w">  </span><span class="c1">// Les déclarations courtes utilisent := pour inférer le type, déclarer et</span>
<span class="w">  </span><span class="c1">// assigner.</span>
<span class="w">  </span><span class="nx">y</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">4</span>
<span class="w">  </span><span class="nx">sum</span><span class="p">,</span><span class="w"> </span><span class="nx">prod</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">learnMultiple</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="p">)</span><span class="w">        </span><span class="c1">// La fonction retourne deux valeurs.</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;sum:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">sum</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;prod:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">prod</span><span class="p">)</span><span class="w"> </span><span class="c1">// Affichage simple.</span>
<span class="w">  </span><span class="nx">learnTypes</span><span class="p">()</span><span class="w">                            </span><span class="c1">// &lt; y minutes, en savoir plus!</span>
<span class="p">}</span>

<span class="c1">// Les fonctions peuvent avoir des paramètres et plusieurs valeurs retournées.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">learnMultiple</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">sum</span><span class="p">,</span><span class="w"> </span><span class="nx">prod</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">y</span><span class="p">,</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="c1">// Deux valeurs retournées.</span>
<span class="p">}</span>

<span class="c1">// Quelques types inclus et littéraux.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">learnTypes</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Une déclaration courte infère généralement le type désiré.</span>
<span class="w">  </span><span class="nx">str</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="s">&quot;Learn Go!&quot;</span><span class="w"> </span><span class="c1">// Type string.</span>

<span class="w">  </span><span class="nx">s2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="s">`Une chaîne de caractères peut contenir des</span>
<span class="s">sauts de ligne.`</span><span class="w"> </span><span class="c1">// Chaîne de caractère.</span>

<span class="w">  </span><span class="c1">// Littéral non-ASCII. Les sources Go utilisent le charset UTF-8.</span>
<span class="w">  </span><span class="nx">g</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="sc">&#39;Σ&#39;</span><span class="w"> </span><span class="c1">// type rune, un alias pour le type int32, contenant un caractère</span>
<span class="w">           </span><span class="c1">// unicode.</span>

<span class="w">  </span><span class="nx">f</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mf">3.14159</span><span class="w"> </span><span class="c1">// float64, un nombre flottant IEEE-754 de 64-bit.</span>
<span class="w">  </span><span class="nx">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">4i</span><span class="w">  </span><span class="c1">// complex128, considéré comme deux float64 par le compilateur.</span>

<span class="w">  </span><span class="c1">// Syntaxe &quot;var&quot; avec une valeur d&#39;initialisation.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">u</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="c1">// Non signé, mais la taille dépend selon l&#39;entier.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">pi</span><span class="w"> </span><span class="kt">float32</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">22.</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">7</span>

<span class="w">  </span><span class="c1">// Conversion avec syntaxe courte.</span>
<span class="w">  </span><span class="nx">n</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">byte</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">)</span><span class="w"> </span><span class="c1">// byte est un alias du type uint8.</span>

<span class="w">  </span><span class="c1">// Les tableaux ont une taille fixe déclarée à la compilation.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">a4</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">int</span><span class="w">           </span><span class="c1">// Un tableau de 4 ints, tous initialisés à 0.</span>
<span class="w">  </span><span class="nx">a3</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">}</span><span class="w"> </span><span class="c1">// Un tableau initialisé avec une taille fixe de 3</span>
<span class="w">  </span><span class="c1">// éléments, contenant les valeurs 3, 1 et 5.</span>

<span class="w">  </span><span class="c1">// Les slices ont des tailles dynamiques. Les tableaux et slices ont chacun</span>
<span class="w">  </span><span class="c1">// des avantages, mais les cas d&#39;utilisation des slices sont plus fréquents.</span>
<span class="w">  </span><span class="nx">s3</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">}</span><span class="w">    </span><span class="c1">// Comparable à a3.</span>
<span class="w">  </span><span class="nx">s4</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">    </span><span class="c1">// Alloue un slice de 4 ints, initialisés à 0.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">d2</span><span class="w"> </span><span class="p">[][]</span><span class="kt">float64</span><span class="w">      </span><span class="c1">// Déclaration seulement, sans allocation de mémoire.</span>
<span class="w">  </span><span class="nx">bs</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;a slice&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">// Conversion d&#39;une chaîne en slice de bytes.</span>

<span class="w">  </span><span class="c1">// Parce qu&#39;elles sont dynamiques, les slices peuvent être jointes sur</span>
<span class="w">  </span><span class="c1">// demande. Pour joindre un élément à une slice, la fonction standard append()</span>
<span class="w">  </span><span class="c1">// est utilisée. Le premier argument est la slice à utiliser. Habituellement,</span>
<span class="w">  </span><span class="c1">// la variable tableau est mise à jour sur place, voir ci-bas.</span>
<span class="w">  </span><span class="nx">s</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">     </span><span class="c1">// Le résultat est une slice de taille 3.</span>
<span class="w">  </span><span class="nx">s</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w">  </span><span class="c1">// Ajout de 3 valeurs. La taille est de 6.</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="w">          </span><span class="c1">// La valeur est de [1 2 3 4 5 6]</span>

<span class="w">  </span><span class="c1">// Pour ajouter une slice à une autre, au lieu d&#39;utiliser une liste de valeurs</span>
<span class="w">  </span><span class="c1">// atomiques, il est possible de mettre en argument une référence de</span>
<span class="w">  </span><span class="c1">// slice littérale grâce aux points de suspension.</span>
<span class="w">  </span><span class="nx">s</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">}</span><span class="o">...</span><span class="p">)</span><span class="w"> </span><span class="c1">// Le deuxième argument est une slice</span>
<span class="w">                                   </span><span class="c1">// littérale.</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="w">  </span><span class="c1">// La slice contient [1 2 3 4 5 6 7 8 9]</span>

<span class="w">  </span><span class="nx">p</span><span class="p">,</span><span class="w"> </span><span class="nx">q</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">learnMemory</span><span class="p">()</span><span class="w"> </span><span class="c1">// Déclare p, q comme étant des pointeurs de type int.</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="nx">q</span><span class="p">)</span><span class="w">   </span><span class="c1">// * suit un pointeur. Ceci retourne deux ints.</span>

<span class="w">  </span><span class="c1">// Les maps sont des tableaux associatifs de taille dynamique, comme les</span>
<span class="w">  </span><span class="c1">// hash ou les types dictionnaires de certains langages.</span>
<span class="w">  </span><span class="nx">m</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">&quot;trois&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;quatre&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">4</span><span class="p">}</span>
<span class="w">  </span><span class="nx">m</span><span class="p">[</span><span class="s">&quot;un&quot;</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span>

<span class="w">  </span><span class="c1">// Les valeurs inutilisées sont considérées comme des erreurs en Go.</span>
<span class="w">  </span><span class="c1">// Un tiret bas permet d&#39;ignorer une valeur inutilisée, évitant une erreur.</span>
<span class="w">  </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">str</span><span class="p">,</span><span class="w"> </span><span class="nx">s2</span><span class="p">,</span><span class="w"> </span><span class="nx">g</span><span class="p">,</span><span class="w"> </span><span class="nx">f</span><span class="p">,</span><span class="w"> </span><span class="nx">u</span><span class="p">,</span><span class="w"> </span><span class="nx">pi</span><span class="p">,</span><span class="w"> </span><span class="nx">n</span><span class="p">,</span><span class="w"> </span><span class="nx">a3</span><span class="p">,</span><span class="w"> </span><span class="nx">s4</span><span class="p">,</span><span class="w"> </span><span class="nx">bs</span>

<span class="w">  </span><span class="c1">// Cependant, son affichage en console est considéré comme une utilisation,</span>
<span class="w">  </span><span class="c1">// ce qui ne sera pas considéré comme une erreur à la compilation.</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">,</span><span class="w"> </span><span class="nx">a4</span><span class="p">,</span><span class="w"> </span><span class="nx">s3</span><span class="p">,</span><span class="w"> </span><span class="nx">d2</span><span class="p">,</span><span class="w"> </span><span class="nx">m</span><span class="p">)</span>

<span class="w">  </span><span class="nx">learnFlowControl</span><span class="p">()</span><span class="w"> </span><span class="c1">// De retour dans le flux.</span>
<span class="p">}</span>

<span class="c1">// Il est possible, à l&#39;opposé de plusieurs autres langages, de retourner des</span>
<span class="c1">// variables par leur nom à partir de fonctions.</span>
<span class="c1">// Assigner un nom à un type retourné par une fonction permet de retrouver sa</span>
<span class="c1">// valeur ainsi que d&#39;utiliser le mot-clé &quot;return&quot; uniquement, sans plus.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">learnNamedReturns</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">z</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">z</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">y</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="c1">// z est implicite, car la variable a été définie précédemment.</span>
<span class="p">}</span>

<span class="c1">// La récupération de la mémoire est automatique en Go. Le langage possède des</span>
<span class="c1">// pointeurs, mais aucune arithmétique des pointeurs (*(a + b) en C). Vous</span>
<span class="c1">// pouvez produire une erreur avec un pointeur nil, mais pas en incrémentant un</span>
<span class="c1">// pointeur.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">learnMemory</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="nx">p</span><span class="p">,</span><span class="w"> </span><span class="nx">q</span><span class="w"> </span><span class="o">*</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Les valeurs retournées p et q auront le type pointeur int.</span>
<span class="w">  </span><span class="nx">p</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="c1">// Fonction standard &quot;new&quot; alloue la mémoire.</span>
<span class="w">  </span><span class="c1">// Le int alloué est initialisé à 0, p n&#39;est plus nil.</span>
<span class="w">  </span><span class="nx">s</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="c1">// Alloue 20 ints en un seul bloc de mémoire.</span>
<span class="w">  </span><span class="nx">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">7</span><span class="w">             </span><span class="c1">// Assigne l&#39;un des entiers.</span>
<span class="w">  </span><span class="nx">r</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="w">              </span><span class="c1">// Déclare une autre variable locale.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">s</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">r</span><span class="w">     </span><span class="c1">// &amp; retourne l&#39;adresse d&#39;un objet.</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">expensiveComputation</span><span class="p">()</span><span class="w"> </span><span class="kt">float64</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">m</span><span class="p">.</span><span class="nx">Exp</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">learnFlowControl</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Bien que les &quot;if&quot; requièrent des accolades, les parenthèses ne sont pas</span>
<span class="w">  </span><span class="c1">// nécessaires pour contenir le test booléen.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;voilà!&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Le formatage du code est standardisé par la commande shell &quot;go fmt.&quot;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// bing.</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// bang.</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Utilisez &quot;switch&quot; au lieu des &quot;if&quot; en chaîne</span>
<span class="w">  </span><span class="nx">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mf">42.0</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">42</span><span class="p">:</span>
<span class="w">    </span><span class="c1">// Les &quot;case&quot; n&#39;ont pas besoin de &quot;break;&quot;.</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">43</span><span class="p">:</span>
<span class="w">    </span><span class="c1">// Non-exécuté.</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Comme les &quot;if&quot;, les &quot;for&quot; n&#39;utilisent pas de parenthèses.</span>
<span class="w">  </span><span class="c1">// Les variables déclarées dans les &quot;for&quot; et les &quot;if&quot; sont locales à leur</span>
<span class="w">  </span><span class="c1">// portée.</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="nx">x</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ++ est une incrémentation.</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;itération &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">x</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// x == 42 ici.</span>

<span class="w">  </span><span class="c1">// &quot;For&quot; est le seul type de boucle en Go, mais possède différentes formes.</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Boucle infinie</span>
<span class="w">    </span><span class="k">break</span><span class="w">    </span><span class="c1">// C&#39;est une farce</span>
<span class="w">    </span><span class="k">continue</span><span class="w"> </span><span class="c1">// Non atteint.</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Vous pouvez utiliser une &quot;range&quot; pour itérer dans un tableau, une slice, une</span>
<span class="w">  </span><span class="c1">// chaîne, une map ou un canal. Les &quot;range&quot; retournent un canal ou deux</span>
<span class="w">  </span><span class="c1">// valeurs (tableau, slice, chaîne et map).</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">key</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">&quot;une&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;deux&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;trois&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// pour chaque pair dans une map, affichage de la valeur et clé</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;clé=%s, valeur=%d\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">key</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// À l&#39;opposé du &quot;for&quot;, := dans un &quot;if&quot; signifie la déclaration et</span>
<span class="w">  </span><span class="c1">// l&#39;assignation y en premier, et ensuite y &gt; x</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">expensiveComputation</span><span class="p">();</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">y</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Les fonctions littérales sont des fermetures.</span>
<span class="w">  </span><span class="nx">xBig</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mi">10000</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;xBig:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">xBig</span><span class="p">())</span><span class="w"> </span><span class="c1">// true (la valeur e^10 a été assignée à x).</span>
<span class="w">  </span><span class="nx">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">1.3e3</span><span class="w">                    </span><span class="c1">// Ceci fait x == 1300</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;xBig:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">xBig</span><span class="p">())</span><span class="w"> </span><span class="c1">// Maintenant false.</span>

<span class="w">  </span><span class="c1">// De plus, les fonctions littérales peuvent être définies et appelées</span>
<span class="w">  </span><span class="c1">// sur la même ligne, agissant comme argument à cette fonction, tant que:</span>
<span class="w">  </span><span class="c1">// a) la fonction littérale est appelée suite à (),</span>
<span class="w">  </span><span class="c1">// b) le résultat correspond au type de l&#39;argument.</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Ajoute + multiplie deux nombres : &quot;</span><span class="p">,</span>
<span class="w">    </span><span class="kd">func</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">b</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span>
<span class="w">    </span><span class="p">}(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="c1">// Appelle la fonction avec les arguments 10 et 2</span>
<span class="w">  </span><span class="c1">// =&gt; Ajoute + double deux nombres : 24</span>

<span class="w">  </span><span class="c1">// Quand vous en aurez besoin, vous allez l&#39;adorer.</span>
<span class="w">  </span><span class="k">goto</span><span class="w"> </span><span class="nx">love</span>
<span class="nx">love</span><span class="p">:</span>

<span class="w">  </span><span class="nx">learnFunctionFactory</span><span class="p">()</span><span class="w"> </span><span class="c1">// func retournant func correspondant à fun(3)(3).</span>
<span class="w">  </span><span class="nx">learnDefer</span><span class="p">()</span><span class="w">           </span><span class="c1">// Un survol de cette instruction importante.</span>
<span class="w">  </span><span class="nx">learnInterfaces</span><span class="p">()</span><span class="w">      </span><span class="c1">// Incontournable !</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">learnFunctionFactory</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Les deux syntaxes sont identiques, bien que la seconde soit plus pratique.</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">sentenceFactory</span><span class="p">(</span><span class="s">&quot;été&quot;</span><span class="p">)(</span><span class="s">&quot;Une matinée d&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;agréable!&quot;</span><span class="p">))</span>

<span class="w">  </span><span class="nx">d</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">sentenceFactory</span><span class="p">(</span><span class="s">&quot;été&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">d</span><span class="p">(</span><span class="s">&quot;Une matinée d&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;agréable!&quot;</span><span class="p">))</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">d</span><span class="p">(</span><span class="s">&quot;Une soirée d&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;relaxante!&quot;</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// Le décorateur est un patron de conception commun dans d&#39;autres langages.</span>
<span class="c1">// Il est possible de faire de même en Go avec des fonctions littérales</span>
<span class="c1">// acceptant des arguments.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">sentenceFactory</span><span class="p">(</span><span class="nx">mystring</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">before</span><span class="p">,</span><span class="w"> </span><span class="nx">after</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">before</span><span class="p">,</span><span class="w"> </span><span class="nx">after</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%s %s %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">before</span><span class="p">,</span><span class="w"> </span><span class="nx">mystring</span><span class="p">,</span><span class="w"> </span><span class="nx">after</span><span class="p">)</span><span class="w"> </span><span class="c1">// nouvelle chaîne</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">learnDefer</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="nx">ok</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Les déclarations différées sont exécutées avant la sortie d&#39;une fonction.</span>
<span class="w">  </span><span class="k">defer</span><span class="w"> </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;les déclarations différées s&#39;exécutent en ordre LIFO.&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="k">defer</span><span class="w"> </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;\nCette ligne est affichée en premier parce que&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="c1">// Les déclarations différées sont utilisées fréquemment pour fermer un</span>
<span class="w">  </span><span class="c1">// fichier, afin que la fonction ferme le fichier en fin d&#39;exécution.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span>
<span class="p">}</span>

<span class="c1">// Défini Stringer comme étant une interface avec une méthode, String.</span>
<span class="kd">type</span><span class="w"> </span><span class="nx">Stringer</span><span class="w"> </span><span class="kd">interface</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">String</span><span class="p">()</span><span class="w"> </span><span class="kt">string</span>
<span class="p">}</span>

<span class="c1">// Défini pair comme étant une structure contenant deux entiers, x et y.</span>
<span class="kd">type</span><span class="w"> </span><span class="nx">pair</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="kt">int</span>
<span class="p">}</span>

<span class="c1">// Défini une méthode associée au type pair. Pair implémente maintenant Stringer</span>
<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">p</span><span class="w"> </span><span class="nx">pair</span><span class="p">)</span><span class="w"> </span><span class="nx">String</span><span class="p">()</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// p s&#39;appelle le &quot;destinataire&quot;</span>
<span class="w">  </span><span class="c1">// Sprintf est une autre fonction publique dans le paquet fmt.</span>
<span class="w">  </span><span class="c1">// La syntaxe avec point permet de faire référence aux valeurs de p.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;(%d, %d)&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">p</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">p</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">learnInterfaces</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// La syntaxe avec accolade défini une &quot;structure littérale&quot;. Celle-ci</span>
<span class="w">  </span><span class="c1">// s&#39;évalue comme étant une structure. La syntaxe := déclare et initialise p</span>
<span class="w">  </span><span class="c1">// comme étant une instance.</span>
<span class="w">  </span><span class="nx">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">pair</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">}</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span><span class="w"> </span><span class="c1">// Appelle la méthode String de p, de type pair.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="nx">Stringer</span><span class="w">          </span><span class="c1">// Déclare i instance de l&#39;interface Stringer.</span>
<span class="w">  </span><span class="nx">i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">p</span><span class="w">                   </span><span class="c1">// Valide, car pair implémente Stringer.</span>
<span class="w">  </span><span class="c1">// Appelle la méthode String de i, de type Stringer. Retourne la même valeur</span>
<span class="w">  </span><span class="c1">// que ci-haut.</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span>

<span class="w">  </span><span class="c1">// Les fonctions dans le paquet fmt appellent la méthode String, demandant</span>
<span class="w">  </span><span class="c1">// aux objets d&#39;afficher une représentation de leur structure.</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span><span class="w"> </span><span class="c1">// Affiche la même chose que ci-haut. Println appelle la</span>
<span class="w">                 </span><span class="c1">// méthode String.</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="w"> </span><span class="c1">// Affiche la même chose que ci-haut.</span>

<span class="w">  </span><span class="nx">learnVariadicParams</span><span class="p">(</span><span class="s">&quot;apprentissage&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;génial&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ici!&quot;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Les fonctions peuvent être définie de façon à accepter un ou plusieurs</span>
<span class="c1">// paramètres grâce aux points de suspension, offrant une flexibilité lors de</span>
<span class="c1">// son appel.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">learnVariadicParams</span><span class="p">(</span><span class="nx">myStrings</span><span class="w"> </span><span class="o">...</span><span class="kd">interface</span><span class="p">{})</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Itère chaque paramètre dans la range.</span>
<span class="w">  </span><span class="c1">// Le tiret bas sert à ignorer l&#39;index retourné du tableau.</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">param</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">myStrings</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;paramètre:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">param</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Passe une valeur variadique comme paramètre variadique.</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;paramètres:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintln</span><span class="p">(</span><span class="nx">myStrings</span><span class="o">...</span><span class="p">))</span>

<span class="w">  </span><span class="nx">learnErrorHandling</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">learnErrorHandling</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// &quot;, ok&quot; idiome utilisée pour définir si l&#39;opération s&#39;est déroulée avec</span>
<span class="w">  </span><span class="c1">// succès ou non</span>
<span class="w">  </span><span class="nx">m</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="mi">3</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;trois&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;quatre&quot;</span><span class="p">}</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">m</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ok sera faux, car 1 n&#39;est pas dans la map.</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;inexistant&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span><span class="w"> </span><span class="c1">// x serait la valeur, si elle se trouvait dans la map.</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Une erreur ne retourne qu&#39;un &quot;ok&quot;, mais également plus d&#39;information</span>
<span class="w">  </span><span class="c1">// par rapport à un problème survenu.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">strconv</span><span class="p">.</span><span class="nx">Atoi</span><span class="p">(</span><span class="s">&quot;non-int&quot;</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// _ discarte la valeur</span>
<span class="w">    </span><span class="c1">// retourne: &#39;strconv.ParseInt: parsing &quot;non-int&quot;: invalid syntax&#39;</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Nous réviserons les interfaces un peu plus tard. Pour l&#39;instant,</span>
<span class="w">  </span><span class="nx">learnConcurrency</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// c est un canal, un objet permettant de communiquer en simultané de façon</span>
<span class="c1">// sécurisée.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">inc</span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="kd">chan</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">c</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// &lt;- est l&#39;opérateur &quot;envoi&quot; quand un canal apparaît à</span>
<span class="w">             </span><span class="c1">// gauche.</span>
<span class="p">}</span>

<span class="c1">// Nous utiliserons inc pour incrémenter des nombres en même temps.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">learnConcurrency</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// La fonction &quot;make&quot; utilisée précédemment pour générer un slice. Elle</span>
<span class="w">  </span><span class="c1">// alloue et initialise les slices, maps et les canaux.</span>
<span class="w">  </span><span class="nx">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span>
<span class="w">  </span><span class="c1">// Démarrage de trois goroutines simultanées. Les nombres seront incrémentés</span>
<span class="w">  </span><span class="c1">// simultanément, peut-être en paralèle si la machine le permet et configurée</span>
<span class="w">  </span><span class="c1">// correctement. Les trois utilisent le même canal.</span>
<span class="w">  </span><span class="k">go</span><span class="w"> </span><span class="nx">inc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">)</span><span class="w"> </span><span class="c1">// go est une instruction démarrant une nouvelle goroutine.</span>
<span class="w">  </span><span class="k">go</span><span class="w"> </span><span class="nx">inc</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">)</span>
<span class="w">  </span><span class="k">go</span><span class="w"> </span><span class="nx">inc</span><span class="p">(</span><span class="o">-</span><span class="mi">805</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">)</span>
<span class="w">  </span><span class="c1">// Lis et affiche trois résultats du canal - impossible de savoir dans quel</span>
<span class="w">  </span><span class="c1">// ordre !</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">c</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">c</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">c</span><span class="p">)</span><span class="w"> </span><span class="c1">// Canal à droite, &lt;- est l&#39;opérateur de</span>
<span class="w">                             </span><span class="c1">// &quot;réception&quot;.</span>

<span class="w">  </span><span class="nx">cs</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w">       </span><span class="c1">// Un autre canal, celui-ci gère des chaînes.</span>
<span class="w">  </span><span class="nx">ccs</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kd">chan</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="c1">// Un canal de canaux de chaînes.</span>
<span class="w">  </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">84</span><span class="w"> </span><span class="p">}()</span><span class="w">       </span><span class="c1">// Démarre une nouvelle goroutine, pour</span>
<span class="w">                                </span><span class="c1">// envoyer une valeur.</span>
<span class="w">  </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">cs</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s">&quot;wordy&quot;</span><span class="w"> </span><span class="p">}()</span><span class="w"> </span><span class="c1">// De nouveau, pour cs cette fois-ci.</span>
<span class="w">  </span><span class="c1">// Select possède une syntaxe similaire au switch, mais chaque cas requiert</span>
<span class="w">  </span><span class="c1">// une opération impliquant un canal. Il sélectionne un cas aléatoirement</span>
<span class="w">  </span><span class="c1">// prêt à communiquer.</span>
<span class="w">  </span><span class="k">select</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">c</span><span class="p">:</span><span class="w"> </span><span class="c1">// La valeur reçue peut être assignée à une variable,</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;c&#39;est un %T&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">cs</span><span class="p">:</span><span class="w"> </span><span class="c1">// ou la valeur reçue peut être ignorée.</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;c&#39;est une chaîne&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">ccs</span><span class="p">:</span><span class="w"> </span><span class="c1">// Un canal vide, indisponible à la communication.</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;ne surviendra pas.&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// À ce point, une valeur a été prise de c ou cs. L&#39;une des deux goroutines</span>
<span class="w">  </span><span class="c1">// démarrée plus haut a complétée, la seconde restera bloquée.</span>

<span class="w">  </span><span class="nx">learnWebProgramming</span><span class="p">()</span><span class="w"> </span><span class="c1">// Go permet la programmation Web.</span>
<span class="p">}</span>

<span class="c1">// Une seule fonction du paquet http démarre un serveur Web.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">learnWebProgramming</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="c1">// Le premier paramètre de ListenAndServe est une adresse TCP à écouter.</span>
<span class="w">  </span><span class="c1">// Le second est une interface, de type http.Handler.</span>
<span class="w">  </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">http</span><span class="p">.</span><span class="nx">ListenAndServe</span><span class="p">(</span><span class="s">&quot;:8080&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">pair</span><span class="p">{})</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"> </span><span class="c1">// n&#39;ignorez pas les erreurs !</span>
<span class="w">  </span><span class="p">}()</span>

<span class="w">  </span><span class="nx">requestServer</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// Implémente la méthode ServeHTTP de http.Handler à pair, la rendant compatible</span>
<span class="c1">// avec les opérations utilisant l&#39;interface http.Handler.</span>
<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">p</span><span class="w"> </span><span class="nx">pair</span><span class="p">)</span><span class="w"> </span><span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span><span class="w"> </span><span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Répondez à une requête à l&#39;aide de la méthode http.ResponseWriter.</span>
<span class="w">  </span><span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;Vous avez appris Go en Y minutes!&quot;</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">requestServer</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">resp</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;http://localhost:8080&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="w">  </span><span class="k">defer</span><span class="w"> </span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="w">  </span><span class="nx">body</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ioutil</span><span class="p">.</span><span class="nx">ReadAll</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;\nLe serveur Web a dit: `%s`&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">string</span><span class="p">(</span><span class="nx">body</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
<h2>En savoir plus</h2>
<p>La référence Go se trouve sur <a href="https://go.dev/">le site officiel de Go</a>.
Vous pourrez y suivre le tutoriel interactif et en apprendre beaucoup plus.</p>
<p>Une lecture de la documentation du langage est grandement conseillée. C'est
facile à lire et très court (comparé aux autres langages).</p>
<p>Vous pouvez exécuter et modifier le code sur <a href="https://go.dev/play/p/tnWMjr16Mm">Go playground</a>. Essayez de le modifier et de l'exécuter à partir de votre navigateur! Prennez en note que vous pouvez utiliser <a href="https://go.dev/play/">https://go.dev/play/</a> comme un <a href="https://en.wikipedia.org/wiki/Read-eval-print_loop">REPL</a> pour tester et coder dans votre navigateur, sans même avoir à installer Go.</p>
<p>Sur la liste de lecteur des étudiants de Go se trouve le <a href="https://go.dev/src/">code source de la
librairie standard</a>. Bien documentée, elle démontre
le meilleur de la clarté de Go, le style ainsi que ses expressions. Sinon, vous
pouvez cliquer sur le nom d'une fonction dans <a href="https://go.dev/pkg/">la
documentation</a> et le code source apparaît!</p>
<p>Une autre excellente ressource pour apprendre est <a href="https://gobyexample.com/">Go par l'exemple</a>.</p>

        <hr>
        <p>
          Vous avez une suggestion ? Peut-être une correction ? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Ouvrez un ticket</a> sur GitHub, ou faites vous-même une <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/fr/go.md">pull request</a> !
        </p>
        <p class="contributed">
          Version originale par Sonia Keys, mis à jour par <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/fr/go.md">4 contributeur(s)</a>.
        </p>

        <footer>
          <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width: 0; width: 88px; height: 31px;" src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-sa.svg" /></a>
          <p>
            &copy; 2025
            <a href="https://github.com/soniakeys">Sonia Keys</a>,
            <a href="https://github.com/cbess">Christopher Bess</a>,
            <a href="https://github.com/holocronweaver">Jesse Johnson</a>,
            <a href="https://github.com/qguv">Quint Guvernator</a>,
            <a href="https://github.com/josedonizetti">Jose Donizetti</a>,
            <a href="https://github.com/heyalexej">Alexej Friesen</a>,
            <a href="http://blogue.jpmonette.net/">Jean-Philippe Monette</a>
          </p>
        </footer>
      </div>
    </div>
  </body>
</html>