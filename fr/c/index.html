<!DOCTYPE html>
<html lang="fr">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-WXC8R75DEN');
    </script>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="Content-Language" content="fr">
    <title>Learn C in Y Minutes</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto+Slab:wght@100..900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/screen.css">
    <link rel="stylesheet" href="/css/light.css">
    <link rel="stylesheet" href="/css/dark.css">

    <link rel="canonical" href="https://learnxinyminutes.com/fr/c/">
    <script>
      localStorage.removeItem("lxiym_theme");
    </script>
  </head>
  <body>
    <div class="container">
      <div class="share">
        <span class="sharemsg">
          <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Ffr%2Fc%2F&amp;text=Apprendre+X+en+Y+minutes%2C+o%C3%B9+X%3DC">
            Partager cette page
          </a>
        </span>
        <span class='st_facebook_large' displayText='Facebook'></span>
        <span class='st_twitter_large' displayText='Tweet'></span>
      </div>
      <h1><a href="/">Apprendre X en Y minutes</a></h1>
      <h2>Où X=C</h2>
      <p class="filelink">
        Récupérer le code:
        <a href="/fr/files/learnc.c">learnc.c</a>
      </p>
      <div id="doc">
<p>Le C est le langage de plus bas niveau que la plupart des programmeurs seront
amenés à utiliser, mais ceci est largement conpensé par sa vitesse brute.</p>
<div class="highlight"><pre lang="c"><span class="c1">// Les commentaires sur une ligne commencent par // - valable seulement pour C99 et plus tard.</span>

<span class="cm">/*</span>
<span class="cm">Les commentaires multilignes resemblent à ceci. Ils restent valables en C89.</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">Les commentaires multilignes ne s&#39;emboîtent pas /* Attention */</span><span class="w">  </span><span class="c1">// Le commentaire se termine sur cette ligne...</span>
<span class="o">*/</span><span class="w"> </span><span class="c1">// ...pas ici !</span>

<span class="c1">// Constante : #define &lt;nom&gt;</span>
<span class="c1">// Les constantes sont écrites en majuscules par convention, pas d&#39;obligation</span>
<span class="cp">#define DAYS_IN_YEAR 365</span>

<span class="c1">// Les constantes d&#39;énumeration sont aussi une façon de déclarer des valeurs.</span>
<span class="c1">// Toutes les instructions doivent se terminer par un point-virgule.</span>
<span class="k">enum</span><span class="w"> </span><span class="n">days</span><span class="w"> </span><span class="p">{</span><span class="n">SUN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">MON</span><span class="p">,</span><span class="w"> </span><span class="n">TUE</span><span class="p">,</span><span class="w"> </span><span class="n">WED</span><span class="p">,</span><span class="w"> </span><span class="n">THU</span><span class="p">,</span><span class="w"> </span><span class="n">FRI</span><span class="p">,</span><span class="w"> </span><span class="n">SAT</span><span class="p">};</span>
<span class="c1">// MON vaut 2 automatiquement, TUE vaut 3, etc.</span>

<span class="c1">// Import de fichiers d&#39;en-tête avec #include</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>

<span class="c1">// Pour vos propres fichiers d&#39;en-tête, utilisez les doubles quotes au lieu des crochets sup. et inf.:</span>
<span class="c1">//#include &quot;my_header.h&quot;</span>

<span class="c1">// Declarez les signatures des fonctions auparavant dans un fichier .h, ou en haut de votre</span>
<span class="c1">// fichier .c.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">function_1</span><span class="p">();</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">function_2</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="c1">// Si vous voulez appeler une fonction avant de la définir,</span>
<span class="c1">// vous pouvez déclarer son prototype</span>
<span class="c1">// (types des arguments et de la valeur renvoyée)</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">add_two_ints</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x2</span><span class="p">);</span><span class="w"> </span><span class="c1">// prototype de la fonction</span>
<span class="c1">// bien que `int add_two_ints (int, int);` soit également valide (pas besoin de nommer les arguments),</span>
<span class="c1">// il est recommandé de nommer les arguments dans le prototype pour faciliter l&#39;inspection.</span>

<span class="c1">// Le point d&#39;entrée de votre programme est une fonction appélée</span>
<span class="c1">// main avec une sortie de type entier.</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// votre programme</span>
<span class="p">}</span>

<span class="c1">// Les arguments de la ligne de commande utilisés pour exécuter votre programme sont également passés à la fonction main</span>
<span class="c1">// argc étant le nombre d&#39;arguments - le nom de votre programme compte pour 1</span>
<span class="c1">// argv est un tableau de tableaux de caractères - contenant les arguments eux-mêmes</span>
<span class="c1">// argv[0] = nom de votre programme, argv[1] = premier argument, etc.</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// écriture en sortie à l&#39;aide de printf, pour &quot;print formatted&quot;</span>
<span class="w">  </span><span class="c1">// %d est un entier, \n est une nouvelle ligne</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Prints 0</span>

<span class="w">  </span><span class="c1">///////////////////////////////////////</span>
<span class="w">  </span><span class="c1">// Types</span>
<span class="w">  </span><span class="c1">///////////////////////////////////////</span>

<span class="w">  </span><span class="c1">// Les compilateurs qui ne sont pas conformes C99 nécessitent de déclarer</span>
<span class="w">  </span><span class="c1">// les variables en début de portée du bloc de code courant.</span>
<span class="w">  </span><span class="c1">// Les compilateurs qui SONT conformes C99 acceptent les déclarations</span>
<span class="w">  </span><span class="c1">// plus tard dans les fonctions.</span>

<span class="w">  </span><span class="c1">// Les entiers font généralement de 4 octets</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x_int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Les entiers courts font généralement 2 octets</span>
<span class="w">  </span><span class="kt">short</span><span class="w"> </span><span class="n">x_short</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Les caractères ont une taille fixée à 1 octet</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">x_char</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">y_char</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;y&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// les caractères littéraux sont entre apostrophes &#39;&#39;</span>

<span class="w">  </span><span class="c1">// Les entiers longs font généralement 4 à 8 octets; les entiers longs de type long font</span>
<span class="w">  </span><span class="c1">// 8 octets</span>
<span class="w">  </span><span class="kt">long</span><span class="w"> </span><span class="n">x_long</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x_long_long</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// les nombres à virgule sont généralement des nombres à virgule flottantes de 32 bits</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">x_float</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span><span class="w"> </span><span class="c1">// &#39;f&#39; est le suffixe qui indique ici le littéral à virgule flottante</span>

<span class="w">  </span><span class="c1">// les nombres de type double sont généralement des nombres à virgule flottante de 64 bits</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">x_double</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"> </span><span class="c1">// les nombres réels sans suffixe sont de type double</span>

<span class="w">  </span><span class="c1">// Les types entier peuvent être non signés (plus grand ou égal à zero)</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">ux_short</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ux_int</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">ux_long_long</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Les caractères entre guillemets simples sont des entiers d&#39;un jeu de caractères machine.</span>
<span class="w">  </span><span class="sc">&#39;0&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 48 dans le jeu de caractères ASCII.</span>
<span class="w">  </span><span class="sc">&#39;A&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 65 dans le jeu de caractères ASCII.</span>

<span class="w">  </span><span class="c1">// sizeof(T) vous rend la taille d&#39;une variable de type T en octets.</span>
<span class="w">  </span><span class="c1">// sizeof obj revoie la taille en sortie de l&#39;expression (variable, littéral, etc.).</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"> </span><span class="c1">// =&gt; 4 (sur la plupart des machines les mots font 4 octets)</span>

<span class="w">  </span><span class="c1">// Si l&#39;argument de l&#39;opérateur `sizeof` est une expression, alors son argument</span>
<span class="w">  </span><span class="c1">// n&#39;est pas évalué (sauf les VLA - voir ci-dessous).</span>
<span class="w">  </span><span class="c1">// La valeur qu&#39;elle donne dans ce cas est une constante évaluée à la compilation.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// size_t est un type entier non signé d&#39;au moins 2 octets utilisé pour représenter</span>
<span class="w">  </span><span class="c1">// la taille d&#39;un objet.</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="o">++</span><span class="p">);</span><span class="w"> </span><span class="c1">// a++ n&#39;est pas évalué</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(a++) = %zu où a = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// affiche &quot;sizeof(a++) = 4 où a = 1&quot; (sur une architecture 32 bits)</span>

<span class="w">  </span><span class="c1">// Si l&#39;argument de l&#39;opérateur `sizeof` est une expression, alors son argument</span>
<span class="w">  </span><span class="c1">// n&#39;est pas évalué (sauf les VLAs (voir ci-dessous)).</span>
<span class="w">  </span><span class="c1">// La valeur qu&#39;elle donne dans ce cas est une constante évaluée au moment de la compilation.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// size_t est un nombre de type entier non signé dont au moins 2 octets sont utilisés pour représenter</span>
<span class="w">  </span><span class="c1">// la taille d&#39;un objet.</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="o">++</span><span class="p">);</span><span class="w"> </span><span class="c1">// a++ n&#39;est pas évalué</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(a++) = %zu where a = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// affiche &quot;sizeof(a++) = 4 where a = 1&quot; (sur une architecture 32-bit)</span>

<span class="w">  </span><span class="c1">// Les tableaux doivent être initialisés avec une taille concrète.</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">my_char_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span><span class="w"> </span><span class="c1">// Ce tableau occupe 1 * 20 = 20 octets</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">my_int_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span><span class="w"> </span><span class="c1">// Ce tableau occupe 4 * 20 = 80 octets</span>
<span class="w">  </span><span class="c1">// (en considérant des mots de 4 octets)</span>

<span class="w">  </span><span class="c1">// Vous pouvez ainsi initialiser un tableau à 0:</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">my_array</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="w">  </span><span class="c1">// où la partie &quot;{0}&quot; est appelée &quot;initialiseur de tableau&quot;.</span>
<span class="w">  </span><span class="c1">// NOTEZ que vous vous en sortez sans déclarer explicitement la taille du tableau,</span>
<span class="w">  </span><span class="c1">// SI vous initialisez le tableau sur la même ligne. Ainsi, la déclaration suivante</span>
<span class="w">  </span><span class="c1">// est équivalent:</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">my_array</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="w">  </span><span class="c1">// MAIS, alors vous devez évaluer la taille du tableau au moment de l&#39;exécution, comme ceci:</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">my_array_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">my_array</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">my_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">  </span><span class="c1">// ATTENTION Si vous adoptez cette approche, vous devez évaluer la taille *avant*</span>
<span class="w">  </span><span class="c1">// qui vous commenciez à transmettre le tableau à la fonction (voir la discussion ultérieure), car</span>
<span class="w">  </span><span class="c1">// les tableaux sont &quot;rétrogradés&quot; en pointeurs bruts lorsqu&#39;ils sont passés à des fonctions</span>
<span class="w">  </span><span class="c1">// (donc l&#39;instruction ci-dessus produira le mauvais résultat à l&#39;intérieur de la fonction).</span>

<span class="w">  </span><span class="c1">// L&#39;indexation commence à zero et utilise []</span>
<span class="w">  </span><span class="n">my_array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="c1">// =&gt; 0</span>

<span class="w">  </span><span class="c1">// Les tableaux sont modifiables ; c&#39;est juste de la mémoire!</span>
<span class="w">  </span><span class="n">my_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">my_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"> </span><span class="c1">// =&gt; 2</span>

<span class="w">  </span><span class="c1">// En C99 (et optionnellement en C11), des tableaux à taille variable (VLAs)</span>
<span class="w">  </span><span class="c1">// peuvent également être déclarés. La taille d&#39;un tel tableau n&#39;a pas besoin d&#39;être</span>
<span class="w">  </span><span class="c1">// une constante définie lors de la compilation:</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Enter the array size: &quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// demande à l&#39;utilisateur la taille du tableau</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">array_size</span><span class="p">;</span>
<span class="w">  </span><span class="n">fscanf</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">array_size</span><span class="p">);</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">var_length_array</span><span class="p">[</span><span class="n">array_size</span><span class="p">];</span><span class="w"> </span><span class="c1">// déclare le VLA</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof array = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="n">var_length_array</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Exemple:</span>
<span class="w">  </span><span class="c1">// &gt; Enter the array size: 10</span>
<span class="w">  </span><span class="c1">// &gt; sizeof array = 40</span>

<span class="w">  </span><span class="c1">// Les chaînes de caractères sont juste des tableaux de caractères de terminant par octet NULL (0x00),</span>
<span class="w">  </span><span class="c1">// représenté dans les chaînes de caractères par le caractère spécial &#39;\0&#39;.</span>
<span class="w">  </span><span class="c1">// (Nous n&#39;avons pas besoin d&#39;ajouter l&#39;octet NULL dans les chaînes de caractères littérales; le compilateur</span>
<span class="w">  </span><span class="c1">// l&#39;ajoute à la fin du tableau pour nous.)</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">a_string</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;This is a string&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a_string</span><span class="p">);</span><span class="w"> </span><span class="c1">// %s insère une chaîne de caractères</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a_string</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span><span class="w"> </span><span class="c1">// =&gt; 0</span>
<span class="w">  </span><span class="c1">// i.e., l&#39;octet #17 est 0 (comme le sont 18, 19, et 20)</span>

<span class="w">  </span><span class="c1">// Si nous avons un caractère entre apostrophes, c&#39;est un caractère littéral.</span>
<span class="w">  </span><span class="c1">// Ils sont de types `int`, et *non* `char` (pour des raisons historiques).</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">cha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// bon</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">chb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// bon aussi (conversion implicite de int vers char)</span>

<span class="w">  </span><span class="c1">// Tableaux dimension multiple:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">multi_array</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>
<span class="w">  </span><span class="c1">// Accés au éléments:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">array_int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">multi_array</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="c1">// =&gt; 3</span>

<span class="w">  </span><span class="c1">///////////////////////////////////////</span>
<span class="w">  </span><span class="c1">// Operateurs</span>
<span class="w">  </span><span class="c1">///////////////////////////////////////</span>

<span class="w">  </span><span class="c1">// Raccourcis pour plusieurs déclarations:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">i2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="n">f2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">  </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Arithmétique</span>
<span class="w">  </span><span class="n">i1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 3</span>
<span class="w">  </span><span class="n">i2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">i1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>
<span class="w">  </span><span class="n">i2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 2</span>
<span class="w">  </span><span class="n">i1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">i2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0 (0.5, mais tronqué après 0)</span>

<span class="w">  </span><span class="c1">// Vous devez convertir un entier en type &#39;float&#39; pour obtenir un résultat en virgule flottante</span>
<span class="w">  </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">i1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">i2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0.5f</span>
<span class="w">  </span><span class="n">i1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">i2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0.5 // Pareil avec double</span>
<span class="w">  </span><span class="n">f1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0.5, plus ou moins epsilon</span>
<span class="w">  </span><span class="c1">// Les nombres à virgule flottante et leurs calculs ne sont pas exacts</span>

<span class="w">  </span><span class="c1">// Modulo est aussi là</span>
<span class="w">  </span><span class="mi">11</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 2</span>

<span class="w">  </span><span class="c1">// Les opérateurs de comparaison sont probablement familiers, mais</span>
<span class="w">  </span><span class="c1">// il n&#39;y a pas de type booléen en C. On utilise plutôt des entiers</span>
<span class="w">  </span><span class="c1">// (C99 introduit _Bool ou bool).</span>
<span class="w">  </span><span class="c1">// 0 est faux, tout le reste est vrai.</span>
<span class="w">  </span><span class="c1">// (La comparaison les opérateurs donnent toujours 0 ou 1)</span>
<span class="w">  </span><span class="mi">3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0 (faux)</span>
<span class="w">  </span><span class="mi">3</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1 (vrai)</span>
<span class="w">  </span><span class="mi">3</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>
<span class="w">  </span><span class="mi">3</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0</span>
<span class="w">  </span><span class="mi">2</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>
<span class="w">  </span><span class="mi">2</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>

<span class="w">  </span><span class="c1">// C n&#39;est pas Python - les comparaisons ne s&#39;enchaînent pas.</span>
<span class="w">  </span><span class="c1">// Attention : la ligne ci-dessous se compilera, mais cela signifie `(0 &lt; a) &lt;2`.</span>
<span class="w">  </span><span class="c1">// Cette expression est toujours vraie, car (0 &lt; a) peut être 1 ou 0.</span>
<span class="w">  </span><span class="c1">// Dans ce cas, c&#39;est 1, car (0 &lt; 1).</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">between_0_and_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Utilisez plutôt:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">between_0_and_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// La logique fonctionne avec les entiers</span>
<span class="w">  </span><span class="o">!</span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0 (non logique)</span>
<span class="w">  </span><span class="o">!</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>
<span class="w">  </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1 (et logique)</span>
<span class="w">  </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0</span>
<span class="w">  </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1 (ou logique)</span>
<span class="w">  </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0</span>

<span class="w">  </span><span class="c1">// Expression conditionnelle ternaire ( ? : )</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="w">  </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 10 &quot;if e &gt; f return e, else return f.&quot;</span>

<span class="w">  </span><span class="c1">// Opérateurs d&#39;incrémentation et de décrémentation :</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">// Renvoi j PUIS augmente j. (s = 0, j = 1)</span>
<span class="w">  </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">;</span><span class="w"> </span><span class="c1">// Augmente j PUIS revoi j. (s = 2, j = 2)</span>
<span class="w">  </span><span class="c1">// pareil avec j-- et --j</span>

<span class="w">  </span><span class="c1">// Opérateurs de manipulation des bits !</span>
<span class="w">  </span><span class="o">~</span><span class="mh">0x0F</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0xFFFFFFF0 (opérateur de négation, &quot;complémentaire de 1&quot;, exemple d&#39;un résultat pour un entier 32-bit)</span>
<span class="w">  </span><span class="mh">0x0F</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xF0</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0x00 (opérateur AND)</span>
<span class="w">  </span><span class="mh">0x0F</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0xF0</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0xFF (opérateur OR)</span>
<span class="w">  </span><span class="mh">0x04</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="mh">0x0F</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0x0B (opérateur XOR)</span>
<span class="w">  </span><span class="mh">0x01</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0x02 (opérateur de décalage à gauche - de 1)</span>
<span class="w">  </span><span class="mh">0x02</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0x01 (opérateur de décalage à droite - de 1)</span>

<span class="w">  </span><span class="c1">// Soyez prudent lorsque vous effectuez un décalage sur des entiers signés - les éléments suivants ne sont pas définis:</span>
<span class="w">  </span><span class="c1">// - décalage du bit de signe d&#39;un entier signé (int a = 1 &lt;&lt; 31)</span>
<span class="w">  </span><span class="c1">// - décalage à gauche d&#39;un nombre négatif (int a = -1 &lt;&lt; 2)</span>
<span class="w">  </span><span class="c1">// - décalage par un offset qui est &gt;= à la largeur du type LHS (partie de gauche de l&#39;affectation):</span>
<span class="w">  </span><span class="c1">// int a = 1 &lt;&lt; 32; // UB (comportement indéfini) si int a une taille de 32 bits</span>

<span class="w">  </span><span class="c1">///////////////////////////////////////</span>
<span class="w">  </span><span class="c1">// Structures de contrôle</span>
<span class="w">  </span><span class="c1">///////////////////////////////////////</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Je ne serai jamais exécuté</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Moi aussi, je ne serai jamais exécuté</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Je suis affiché</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Les boucles while</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">ii</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// TOUTE valeur plus petite que dix est vraie.</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ii</span><span class="o">++</span><span class="p">);</span><span class="w"> </span><span class="c1">// ii++ augmente ii APRES avoir utilisé sa valeur actuelle.</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="c1">// =&gt; affiche &quot;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">kk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">kk</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">++</span><span class="n">kk</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="c1">// ++kk augmente kk AVANT d&#39;utiliser sa valeur actuelle.</span>
<span class="w">  </span><span class="c1">// =&gt; affiche &quot;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Les boucles for</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">jj</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">jj</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">jj</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">jj</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">jj</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="c1">// =&gt; affiche &quot;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// *NOTES* :</span>
<span class="w">  </span><span class="c1">// Les boucles et les fonctions DOIVENT posséder un corps.</span>
<span class="w">  </span><span class="c1">// Vous pouvez toutefois utiliser un bloc vide ({}) ou un point-virgule.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Ou</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">);</span><span class="w"> </span><span class="c1">// Déconseillé, car facilement confondable</span>

<span class="w">  </span><span class="c1">// condition à choix multiples : switch()</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span><span class="w"> </span><span class="c1">// les options doivent être des expressions intégrales *constantes* (telles que des énumérations)</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hey, &#39;a&#39; equals 0!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"> </span><span class="c1">// si vous ne mettez pas &#39;break&#39;, le cas d&#39;après est exécuté sans tester le `case`</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Huh, &#39;a&#39; equals 1!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Attention - sans le &quot;break&quot;, l&#39;execution se poursuit jusqu&#39;au</span>
<span class="w">    </span><span class="c1">// prochain &quot;break&quot; atteint.</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">3</span><span class="p">:</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">4</span><span class="p">:</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Look at that.. &#39;a&#39; is either 3, or 4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="k">default</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// si `a` ne correspond à aucune option</span>
<span class="w">    </span><span class="n">fputs</span><span class="p">(</span><span class="s">&quot;Erreur !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">stderr</span><span class="p">);</span>
<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="mi">-1</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">// Utilisation de &quot;goto&quot; en C</span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kt">bool</span><span class="p">;</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">disaster</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">150</span><span class="p">)</span>
<span class="w">        </span><span class="n">disaster</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">disaster</span><span class="p">)</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">error</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nl">error</span><span class="p">:</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Error occurred at i = %d &amp; j = %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// Ceci affichera &quot;Error occurred at i = 51 &amp; j = 99.&quot;</span>

<span class="w">  </span><span class="c1">///////////////////////////////////////</span>
<span class="w">  </span><span class="c1">// Transtypage</span>
<span class="w">  </span><span class="c1">///////////////////////////////////////</span>

<span class="w">  </span><span class="c1">// Chaque valeur de C a un type, mais vous pouvez convertir le type d&#39;une valeur en un autre type</span>
<span class="w">  </span><span class="c1">// si vous le souhaitez (avec quelques contraintes).</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x_hex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x01</span><span class="p">;</span><span class="w"> </span><span class="c1">// Vous pouvez définir des variables avec des littéraux hexadécimaux</span>

<span class="w">  </span><span class="c1">// La conversion entre les types tentera de conserver leurs valeurs numériques</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x_hex</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Affiche 1</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">short</span><span class="p">)</span><span class="w"> </span><span class="n">x_hex</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Affiche 1</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="n">x_hex</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Affiche 1</span>

<span class="w">  </span><span class="c1">// Les types déborderont sans avertissement</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="mi">257</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; 1 (max = 255 si le caractère mesure 8 bits)</span>

<span class="w">  </span><span class="c1">// Pour déterminer la valeur maximale d&#39;un `char`, d&#39;un `signed char` et d&#39;un `unsigned char`,</span>
<span class="w">  </span><span class="c1">// respectivement, utilisez les macros CHAR_MAX, SCHAR_MAX et UCHAR_MAX de &lt;limits.h&gt;</span>

<span class="w">  </span><span class="c1">// Les types entiers peuvent être convertis en types à virgule flottante et vice versa.</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span><span class="w"> </span><span class="c1">// %f toujours utilisé pour un type double...</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w">  </span><span class="mi">100</span><span class="p">);</span><span class="w"> </span><span class="c1">// ...même avec un float.</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mf">100.0</span><span class="p">);</span>

<span class="w">  </span><span class="c1">///////////////////////////////////////</span>
<span class="w">  </span><span class="c1">// Pointeurs</span>
<span class="w">  </span><span class="c1">///////////////////////////////////////</span>

<span class="w">  </span><span class="c1">// Un pointeur est une variable déclarée pour stocker une adresse mémoire. Sa déclaration</span>
<span class="w">  </span><span class="c1">// vous indique également le type de données vers lequel il pointe. Vous pouvez récupérer l&#39;adresse mémoire</span>
<span class="w">  </span><span class="c1">// de vos variables, puis jouer avec.</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// Utilisez le caractère &amp; pour récupérer l&#39;adresse d&#39;une variable</span>
<span class="w">  </span><span class="c1">// (%p met en forme un objet pointeur de type void *)</span>
<span class="w">  </span><span class="c1">// =&gt; Affiche une adresse en mémoire;</span>

<span class="w">  </span><span class="c1">// Les pointeurs sont préfixés du caractère * lors de la déclaration</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">px</span><span class="p">,</span><span class="w"> </span><span class="n">not_a_pointer</span><span class="p">;</span><span class="w"> </span><span class="c1">// px est un pointeur sur un entier</span>
<span class="w">  </span><span class="n">px</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// Sauvegarde de l&#39;adressse mémoire de x dans px</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">px</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Affiche une adresse mémoire</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%zu, %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">px</span><span class="p">),</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">not_a_pointer</span><span class="p">));</span>
<span class="w">  </span><span class="c1">// =&gt; Affiche &quot;8, 4&quot; sur un système classique 64-bit</span>

<span class="w">  </span><span class="c1">// Pour avoir la valeur située à l&#39;adresse du pointeur,</span>
<span class="w">  </span><span class="c1">// on met * devant pour le déréférencer.</span>
<span class="w">  </span><span class="c1">// Remarque: oui, il peut être déroutant que &#39;*&#39; soit utilisé pour _les deux_ déclarer un</span>
<span class="w">  </span><span class="c1">// pointeur et le déréférencement.</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">px</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Affiche 0, la valeur de x</span>

<span class="w">  </span><span class="c1">// Vous pouvez également modifier la valeur vers laquelle pointe le pointeur.</span>
<span class="w">  </span><span class="c1">// Nous devons mettre la déréférence entre parenthèses car</span>
<span class="w">  </span><span class="c1">// ++ a une priorité plus élevée que *.</span>
<span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">px</span><span class="p">)</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">// Augmente de 1 la valeur pointée par px</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">px</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Affiche 1</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Affiche 1</span>

<span class="w">  </span><span class="c1">// Les tableaux sont un bon moyen d&#39;allouer un bloc de mémoire contigu</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span><span class="w"> </span><span class="c1">//déclare un tableau de taille 20 (la taille ne pourra être changée)</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">xx</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">xx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">xx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"> </span><span class="n">xx</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x_array</span><span class="p">[</span><span class="n">xx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">xx</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="c1">// Initialise x_array à 20, 19, 18,... 2, 1</span>

<span class="w">  </span><span class="c1">// Declare un pointeur sur un type entier et l&#39;initialise pour pointer sur x_array</span>
<span class="w">  </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">x_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x_array</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// x_ptr pointe maintenant vers le premier élément du tableau (l&#39;entier 20).</span>
<span class="w">  </span><span class="c1">// Cela fonctionne car les tableaux s&#39;interprètent souvent comme pointeurs vers leur premier élément.</span>
<span class="w">  </span><span class="c1">// Par exemple, lorsqu&#39;un tableau est transmis à une fonction ou affecté à un pointeur,</span>
<span class="w">  </span><span class="c1">// il est converti implicitement en pointeur.</span>
<span class="w">  </span><span class="c1">// Exceptions : lorsque le tableau est l&#39;argument de l&#39;opérateur `&amp;` (adresse de):</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">ptr_to_arr</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arr</span><span class="p">;</span><span class="w"> </span><span class="c1">// &amp;arr n&#39;est PAS de type `int *`!</span>
<span class="w">  </span><span class="c1">// Il est de type &quot;pointeur sur tableau&quot; (de dix entiers).</span>
<span class="w">  </span><span class="c1">// ou losqu&#39;une chaine de caractères littérale est utilisée pour initialiser un tableau de caractères:</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">otherarr</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foobarbazquirk&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// ou lorsqu&#39;il est l&#39;argument de l&#39;opérateur `sizeof` ou `alignof`:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">arraythethird</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arraythethird</span><span class="p">;</span><span class="w"> </span><span class="c1">// équivalent à int *ptr = &amp;arr[0];</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%zu, %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">arraythethird</span><span class="p">),</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">ptr</span><span class="p">));</span>
<span class="w">  </span><span class="c1">// affiche probablement &quot;40, 4&quot; ou &quot;40, 8&quot;</span>

<span class="w">  </span><span class="c1">// L&#39;augmentation ou la diminution d&#39;un pointeur se fait suivant son type</span>
<span class="w">  </span><span class="c1">// (c&#39;est ce qu&#39;on appelle l&#39;arithmétique du pointeur)</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">x_ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w"> </span><span class="c1">// =&gt; Affiche 19</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"> </span><span class="c1">// =&gt; Affiche 19</span>

<span class="w">  </span><span class="c1">// You can also dynamically allocate contiguous blocks of memory with the</span>
<span class="w">  </span><span class="c1">// standard library function malloc, which takes one argument of type size_t</span>
<span class="w">  </span><span class="c1">// representing the number of bytes to allocate (usually from the heap, although this</span>
<span class="w">  </span><span class="c1">// may not be true on e.g. embedded systems - the C standard says nothing about it).</span>
<span class="w">  </span><span class="c1">// Vous pouvez également allouer dynamiquement des blocs de mémoire contigus avec la</span>
<span class="w">  </span><span class="c1">// fonction malloc de la bibliothèque standard, qui prend un argument de type size_t</span>
<span class="w">  </span><span class="c1">// représentant le nombre d&#39;octets à allouer (généralement à partir du tas, bien que cela</span>
<span class="w">  </span><span class="c1">// peut ne pas être vrai par exemple dans les systèmes embarqués - la norme C ne dit rien à ce sujet).</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">my_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">my_ptr</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">20</span><span class="p">);</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">xx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">xx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"> </span><span class="n">xx</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">*</span><span class="p">(</span><span class="n">my_ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">xx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">xx</span><span class="p">;</span><span class="w"> </span><span class="c1">// my_ptr[xx] = 20-xx</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="c1">// Initialise la mémoire à 20, 19, 18, 17... 2, 1 (comme entiers)</span>

<span class="w">  </span><span class="c1">// Soyez prudent en passant des valeurs fournies par l&#39;utilisateur à malloc! Si vous le souhaitez</span>
<span class="w">  </span><span class="c1">// pour plus de sécurité, vous pouvez utiliser calloc à la place (qui, contrairement à malloc, met également à zéro la mémoire)</span>
<span class="w">  </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">my_other_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calloc</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// Notez qu&#39;il n&#39;y a pas de méthode standard pour obtenir la longueur d&#39;un</span>
<span class="w">  </span><span class="c1">// tableau alloué dynamiquement en C. Pour cette raison, si vos tableaux sont</span>
<span class="w">  </span><span class="c1">// manipulés par votre programme, vous avez besoin d&#39;une autre variable</span>
<span class="w">  </span><span class="c1">// pour garder une trace du nombre d&#39;éléments (taille) d&#39;un tableau. Voir la</span>
<span class="w">  </span><span class="c1">// section fonctions pour plus d&#39;informations.</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">my_arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="w">  </span><span class="c1">// Add an element to the array</span>
<span class="w">  </span><span class="n">size</span><span class="o">++</span><span class="p">;</span>
<span class="w">  </span><span class="n">my_arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">realloc</span><span class="p">(</span><span class="n">my_arr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">my_arr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">//N&#39;oubliez pas de vérifier l&#39;échec de la fonction realloc!</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">my_arr</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Déréférencer de la mémoire que vous n&#39;avez pas allouée donne des</span>
<span class="w">  </span><span class="c1">// UBs &quot;undefined behaviors&quot; ou &quot;comportement imprévisibles&quot;,</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">my_ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">21</span><span class="p">));</span><span class="w"> </span><span class="c1">// =&gt; Peut crash, afficher n&#39;importe quoi, ou autre</span>

<span class="w">  </span><span class="c1">// Lorsque vous avez terminé avec un bloc de mémoire alloué via malloc, vous devez le libérer,</span>
<span class="w">  </span><span class="c1">// ou bien personne d&#39;autre ne pourra l&#39;utiliser jusqu&#39;à la fin de votre programme :</span>
<span class="w">  </span><span class="c1">// (cela s&#39;appelle une &quot;fuite de mémoire&quot;)</span>
<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">my_ptr</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Les chaînes de caractères sont des tableaux de caractères, mais ils sont généralement représentés comme</span>
<span class="w">  </span><span class="c1">// pointeur-vers-caractère (qui est un pointeur vers le premier élément du tableau).</span>
<span class="w">  </span><span class="c1">// Il est recommandé d&#39;utiliser un `const char *&#39; pour référencer une chaîne littérale de caractères,</span>
<span class="w">  </span><span class="c1">// car les chaînes de caractères littérales ne doivent pas être modifiées (i.e. &quot;foo&quot;[0] = &#39;a&#39; est INCORRECT.)</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">my_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;This is my very own string literal&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">my_str</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; &#39;T&#39;</span>

<span class="w">  </span><span class="c1">// Ce n&#39;est pas le cas si la chaîne de caractères est un tableau</span>
<span class="w">  </span><span class="c1">// (potentiellement initialisée avec une chaîne littérale)</span>
<span class="w">  </span><span class="c1">// qui réside dans la mémoire réinscriptible, comme dans:</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">foo</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foo&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">foo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// ceci est correct, foo contient maintenant &quot;aoo&quot;</span>

<span class="w">  </span><span class="n">function_1</span><span class="p">();</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// fin de la fonction main</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Fonctions</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// Sytaxe pour déclarer une fonction:</span>
<span class="c1">// &lt;type de sortie&gt; &lt;nom de la fonstion&gt;(&lt;arguments&gt;)</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">add_two_ints</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x2</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x2</span><span class="p">;</span><span class="w"> </span><span class="c1">// Utilisez return pour retourner une valeur de sortie</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">Les fonctions sont appelées par valeur. Lorsqu&#39;une fonction est appelée, les arguments passés à</span>
<span class="cm">à la fonction sont une copie des arguments originaux (sauf pour les tableaux). Tout ce que vous</span>
<span class="cm">allez faire aux arguments de la fonction ne changera pas la valeur des arguments</span>
<span class="cm">originaux avant appel de la fonction.</span>

<span class="cm">Utilisez les pointeurs si vous avez besoin de modifier la valeur d&#39;origine des arguments.</span>

<span class="cm">Exemple : inversion sur place d&#39;une chaîne de caractères</span>
<span class="cm">*/</span>

<span class="c1">// Une fonction void ne retourne aucune valeur</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">str_reverse</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str_in</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">str_in</span><span class="p">);</span><span class="w"> </span><span class="c1">// `strlen()` fait partie de la bibliothèque standard c</span>
<span class="w">                               </span><span class="c1">// REMARQUE : la longueur renvoyée par `strlen` N&#39;INCLUT PAS</span>
<span class="w">                               </span><span class="c1">//            l&#39;octet NULL de fin (&#39;\0&#39;).</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">ii</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// en C99 vous pouvez déclarer directement le type de `ii` ici</span>
<span class="w">    </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str_in</span><span class="p">[</span><span class="n">ii</span><span class="p">];</span>
<span class="w">    </span><span class="n">str_in</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str_in</span><span class="p">[</span><span class="n">len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="c1">// ii-ème caractère depuis la fin</span>
<span class="w">    </span><span class="n">str_in</span><span class="p">[</span><span class="n">len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">// REMARQUE : le fichier d&#39;entête string.h a besoin d&#39;être inclus pour utiliser strlen()</span>

<span class="cm">/*</span>
<span class="cm">char c[] = &quot;This is a test.&quot;;</span>
<span class="cm">str_reverse(c);</span>
<span class="cm">printf(&quot;%s\n&quot;, c); // =&gt; &quot;.tset a si sihT&quot;</span>
<span class="cm">*/</span>
<span class="cm">/*</span>
<span class="cm">car nous ne pouvons renvoyer qu&#39;une seule variable</span>
<span class="cm">pour changer les valeurs de plusieurs variables, nous passons des pointeurs</span>
<span class="cm">*/</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">swapTwoNumbers</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm">int first = 10;</span>
<span class="cm">int second = 20;</span>
<span class="cm">printf(&quot;first: %d\nsecond: %d\n&quot;, first, second);</span>
<span class="cm">swapTwoNumbers(&amp;first, &amp;second);</span>
<span class="cm">printf(&quot;first: %d\nsecond: %d\n&quot;, first, second);</span>
<span class="cm">// les valeurs seront échangées</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">En ce qui concerne les tableaux, ils seront toujours transmis aux fonctions</span>
<span class="cm">comme pointeurs. Même si vous allouez statiquement un tableau comme `arr[10]`,</span>
<span class="cm">il est toujours passé en tant que pointeur vers le premier élément de tout appel de fonction.</span>
<span class="cm">Encore une fois, il n&#39;y a pas de moyen standard pour connaître la taille d&#39;un tableau</span>
<span class="cm">alloué dynamiquement en C.</span>
<span class="cm">*/</span>
<span class="c1">// La taille doit être transmise!</span>
<span class="c1">// Sinon, cette fonction n&#39;a aucun moyen de connaître la taille du tableau.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">printIntArray</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;arr[%d] is: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm">int my_arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</span>
<span class="cm">int size = 10;</span>
<span class="cm">printIntArray(my_arr, size);</span>
<span class="cm">// affichera &quot;arr[0] is: 1&quot; etc</span>
<span class="cm">*/</span>

<span class="c1">// si vous faites référence à des variables externes en dehors de la fonction, vous devez utiliser le mot clé extern.</span>
<span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">testFunc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">extern</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="c1">//i ici utilise la variable externe i</span>
<span class="p">}</span>

<span class="c1">// rendre les variables external privées au fichier source avec static:</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">//les autres fichiers utilisant testFunc2() n&#39;auront pas accés à la variable j</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">testFunc2</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">extern</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Le mot clé static rend une variable inaccessible au code en dehors de</span>
<span class="c1">// l&#39;unité de compilation. (Sur presque tous les systèmes, une &quot;unité de compilation&quot; est un</span>
<span class="c1">// fichier .c.) static peut être appliqué aussi bien aux variables globales (à l&#39;unité de compilation),</span>
<span class="c1">// aux fonctions et aux variables locales aux fonctions. Lorsque vous utilisez static avec</span>
<span class="c1">// une variable locale à une fonction, la variable est effectivement globale et conserve sa</span>
<span class="c1">// valeur sur les appels de la fonction, mais n&#39;est accessible que dans la fonction où</span>
<span class="c1">// elle a été déclarée. De plus, les variables statiques sont initialisées à 0 si pas</span>
<span class="c1">// déjà déclaré avec une autre valeur de départ.</span>
<span class="c1">// ** Vous pouvez également déclarer des fonctions statiques pour les rendre privées **</span>

<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// Types et structures définis par l&#39;utilisateur</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Typedef peuvent être utilisé pour créer un alias de type</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">my_type</span><span class="p">;</span>
<span class="n">my_type</span><span class="w"> </span><span class="n">my_type_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// Struct est juste une collection de données, dont les membres sont positionnés séquentiellement,</span>
<span class="c1">// dans l&#39;ordre où ils sont écrits::</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">height</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Il n&#39;est généralement aps vrai que</span>
<span class="c1">// sizeof(struct rectangle) == sizeof(int) + sizeof(int)</span>
<span class="c1">// en raison du remplissage potentiel entre les membres de la structure (c&#39;est pour des raisons</span>
<span class="c1">// d&#39;alignement). [1]</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">function_1</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="n">my_rec</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// L&#39;accés aux membres de la structure se fait avec .</span>
<span class="w">  </span><span class="n">my_rec</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">  </span><span class="n">my_rec</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Vous pouvez déclarer un pointeur vers une structure</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="o">*</span><span class="n">my_rec_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">my_rec</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Utiliser le déréférencement pour définir les membres du pointeur de structure...</span>
<span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">my_rec_ptr</span><span class="p">).</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// préférez le raccourci -&gt; par souci de lisibilité</span>
<span class="w">  </span><span class="n">my_rec_ptr</span><span class="o">-&gt;</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="c1">// Identique à (*my_rec_ptr).height = 10;</span>
<span class="p">}</span>

<span class="c1">// Vous pouvez appliquer un typedef à une structure pour plus de commodité</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="n">rect</span><span class="p">;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">area</span><span class="p">(</span><span class="n">rect</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// si vous avez de grandes structures, vous pouvez les passer &quot;par pointeur&quot; afin d&#39;éviter la copie</span>
<span class="c1">// de toute la structure:</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">areaptr</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">rect</span><span class="w"> </span><span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Pointeurs sur fonction</span>
<span class="c1">///////////////////////////////////////</span>
<span class="cm">/*</span>
<span class="cm">Au moment de l&#39;exécution, les fonctions sont situées à des adresses de mémoire connues. Les pointeurs de fonction sont</span>
<span class="cm">un peu comme n&#39;importe quel autre pointeur (ils stockent juste une adresse mémoire), mais peuvent être utilisés</span>
<span class="cm">pour appeler directement des fonctions et pour transmettre des gestionnaires de fonctions (ou des fonctions de rappel).</span>
<span class="cm">Cependant, la syntaxe de définition peut être source de confusion au départ.</span>

<span class="cm">Exemple: Utilisation de str_reverse à partir d&#39;un pointeur</span>
<span class="cm">*/</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">str_reverse_through_pointer</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str_in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Définit une variable pointeur sur fonction, nommée f.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"> </span><span class="c1">// La signature doit être la même que la fonction cible.</span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">str_reverse</span><span class="p">;</span><span class="w"> </span><span class="c1">// Assigne l&#39;adresse de la fonction réelle (déterminé au runtime)</span>
<span class="w">  </span><span class="c1">// f = str_reverse; marcherait aussi - les fonctions s&#39;interprètent en pointeurs, comme les tableaux</span>
<span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="n">str_in</span><span class="p">);</span><span class="w"> </span><span class="c1">// Il suffit d&#39;appeler la fonction via le pointeur</span>
<span class="w">  </span><span class="c1">// f(str_in); // C&#39;est une syntaxe alternative mais tout aussi valide pour l&#39;appel.</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">Tant que les signatures de fonction correspondent, vous pouvez affecter n&#39;importe quelle fonction au même pointeur.</span>
<span class="cm">Les pointeurs de fonction sont généralement typés via typedef pour plus de simplicité et de lisibilité, comme suit:</span>
<span class="cm">*/</span>

<span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">my_fnp_type</span><span class="p">)(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>

<span class="c1">// Puis utilisé lors de la déclaration de la variable réelle de pointeur:</span>
<span class="c1">// ...</span>
<span class="c1">// my_fnp_type f;</span>


<span class="c1">//Caractères spéciaux:</span>
<span class="cm">/*</span>
<span class="cm">&#39;\a&#39;; // caractère d&#39;alerte (cloche)</span>
<span class="cm">&#39;\n&#39;; // caractère de nouvelle ligne</span>
<span class="cm">&#39;\t&#39;; // caractère de tabulation (texte justifié à gauche)</span>
<span class="cm">&#39;\v&#39;; // tabulation verticale</span>
<span class="cm">&#39;\f&#39;; // nouvelle page (flux de formulaire)</span>
<span class="cm">&#39;\r&#39;; // retour chariot</span>
<span class="cm">&#39;\b&#39;; // caractère de retour arrière</span>
<span class="cm">&#39;\0&#39;; // Caractère NULL. Habituellement mis à la fin des chaînes en C.</span>
<span class="cm">// bonjour\n\0. \0 utilisé par convention pour marquer la fin de la chaîne.</span>
<span class="cm">&#39;\\&#39;; // barre oblique inverse</span>
<span class="cm">&#39;\?&#39;; // point d&#39;interrogation</span>
<span class="cm">&#39;\&#39; &#39;; // simple guillemet</span>
<span class="cm">&#39;\&quot;&#39;; // double quillemets</span>
<span class="cm">&#39;\xhh&#39;; // nombre hexadécimal. Exemple: &#39;\xb&#39; = caractère de tabulation verticale</span>
<span class="cm">&#39;\0oo&#39;; // nombre octal. Exemple: &#39;\013&#39; = caractère de tabulation verticale</span>

<span class="cm">//Format d&#39;affichage:</span>
<span class="cm">&quot;%d&quot;;    // entier</span>
<span class="cm">&quot;%3d&quot;;   // entier avec une taille minimum de 3 digits (texte justifié à droite)</span>
<span class="cm">&quot;%s&quot;;    // chaîne de caractères</span>
<span class="cm">&quot;%f&quot;;    // nombre à virgule flottante</span>
<span class="cm">&quot;%ld&quot;;   // nombre long</span>
<span class="cm">&quot;%3.2f&quot;; // minimum de 3 digits à gauche et 2 digits à droite nombre décimal à virgule flottante</span>
<span class="cm">&quot;%7.4s&quot;; // (peut être fait aussi avec une chaîne de caractères)</span>
<span class="cm">&quot;%c&quot;;    // caratère</span>
<span class="cm">&quot;%p&quot;;    // pointeur. REMARQUE: il est nécessaire de caster en (void *) le pointeur, avant de la passer</span>
<span class="cm">         //                comme argument à `printf`.</span>
<span class="cm">&quot;%x&quot;;    // hexadecimal</span>
<span class="cm">&quot;%o&quot;;    // octal</span>
<span class="cm">&quot;%%&quot;;    // affiche %</span>
<span class="cm">*/</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Ordre des évaluations</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">//--------------------------------------------------------//</span>
<span class="c1">//        Operateurs                 | Associativité      //</span>
<span class="c1">//--------------------------------------------------------//</span>
<span class="c1">// () [] -&gt; .                        | de gauche à droite //</span>
<span class="c1">// ! ~ ++ -- + - *(type)sizeof       | de droite à gauche //</span>
<span class="c1">// * / %                             | de gauche à droite //</span>
<span class="c1">// + -                               | de gauche à droite //</span>
<span class="c1">// &lt;&lt; &gt;&gt;                             | de gauche à droite //</span>
<span class="c1">// &lt; &lt;= &gt; &gt;=                         | de gauche à droite //</span>
<span class="c1">// == !=                             | de gauche à droite //</span>
<span class="c1">// &amp;                                 | de gauche à droite //</span>
<span class="c1">// ^                                 | de gauche à droite //</span>
<span class="c1">// |                                 | de gauche à droite //</span>
<span class="c1">// &amp;&amp;                                | de gauche à droite //</span>
<span class="c1">// ||                                | de gauche à droite //</span>
<span class="c1">// ?:                                | de droite à gauche //</span>
<span class="c1">// = += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;= | de droite à gauche //</span>
<span class="c1">// ,                                 | de gauche à droite //</span>
<span class="c1">//--------------------------------------------------------//</span>

<span class="cm">/******************************* Fichiers en-têtes **********************************</span>

<span class="cm">Les fichiers d&#39;en-tête sont une partie importante de C car ils permettent l&#39;interconnexion</span>
<span class="cm">des fichiers source C ce qui permet de simplifier le code et les définitions en les séparant</span>
<span class="cm">dans des fichiers séparés.</span>

<span class="cm">Les fichiers d&#39;en-tête sont syntaxiquement similaires aux fichiers source C mais résident dans</span>
<span class="cm">des fichiers &quot;.h&quot;. Ils peuvent être inclus dans votre fichier source C en utilisant la commande</span>
<span class="cm">du précompilateur #include &quot;example.h&quot;, avec example.h existant dans le même répertoire</span>
<span class="cm">que le fichier C.</span>
<span class="cm">*/</span>

<span class="cm">/* Un garde-fou pour éviter que l&#39;en-tête ne soit défini trop de fois. Ce          */</span>
<span class="cm">/* qui se produit dans le cas de dépendance cyclique, et que le contenu du fichier */</span>
<span class="cm">/* d&#39;en-tête est déjà défini.                                                      */</span>
<span class="cp">#ifndef EXAMPLE_H </span><span class="cm">/* si EXAMPLE_H n&#39;est pas déjà défini. */</span>
<span class="cp">#define EXAMPLE_H </span><span class="cm">/* Definit la macro EXAMPLE_H. */</span>

<span class="cm">/* Des en-têtes peuvent être inclus dans d&#39;autres en-têtes et donc par transitivité */</span>
<span class="cm">/* être inclus dans des fichiers qui incluent un en-tête.                           */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>

<span class="cm">/* Les macros de fichiers source c peuvent être définies dans les en-têtes et utilisées dans les fichiers */</span>
<span class="cm">/* qui incluent ce fichier d&#39;en-tête.                                                                     */</span>
<span class="cp">#define EXAMPLE_NAME &quot;Dennis Ritchie&quot;</span>

<span class="cm">/* Les macros de fonction peuvent aussi être définies.  */</span>
<span class="cp">#define ADD(a, b) ((a) + (b))</span>

<span class="cm">/* Remarquez les parenthèses entourant les arguments - c&#39;est important pour                 */</span>
<span class="cm">/* assurer que a et b ne soient pas développés de manière inattendue (par exemple, pensez à */</span>
<span class="cm">/* MUL (x, y) (x * y); MUL (1 + 2, 3) s&#39;étendrait à (1 + 2 * 3), produisant un              */</span>
<span class="cm">/* résultat incorrect)                                                                      */</span>

<span class="cm">/* Les structures et les typedefs peuvent être utilisés pour la cohérence entre les fichiers. */</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Node</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Node</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">Node</span><span class="p">;</span>

<span class="cm">/* Il en va de même pour les énumérations. */</span>
<span class="k">enum</span><span class="w"> </span><span class="n">traffic_light_state</span><span class="w"> </span><span class="p">{</span><span class="n">GREEN</span><span class="p">,</span><span class="w"> </span><span class="n">YELLOW</span><span class="p">,</span><span class="w"> </span><span class="n">RED</span><span class="p">};</span>

<span class="cm">/* Les prototypes de fonctions peuvent également être définis ici pour une utilisation dans plusieurs fichiers, */</span>
<span class="cm">/* mais c&#39;est une mauvaise pratique de définir la fonction dans l&#39;en-tête. Les définitions                      */</span>
<span class="cm">/* devraient plutôt être placées dans un fichier C.                                                             */</span>
<span class="n">Node</span><span class="w"> </span><span class="nf">createLinkedList</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">vals</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>

<span class="cm">/* Au-delà des éléments ci-dessus, les autres définitions devraient être placées dans un fichier source C */</span>
<span class="cm">/* Les inclusions ou définitions excessives ne devraient pas non plus figurer dans                        */</span>
<span class="cm">/* un fichier d&#39;en-tête mais placées plutôt dans des en-têtes séparés ou un fichier C.                    */</span>

<span class="cp">#endif </span><span class="cm">/* Fin de la directive if du precompilateur. */</span>
</pre></div>
<h2>Lectures complémentaires</h2>
<ul>
<li><a href="http://learncodethehardway.org/c/">Learn C The Hard Way</a>.</li>
<li>Si vous avez une question, lisez le <a href="http://c-faq.com">compl.lang.c Frequently Asked Questions</a>.</li>
</ul>
<p>Il est très important d'utiliser un espacement et une indentation appropriés et d'être cohérent avec votre style de codage en général.
Un code lisible est meilleur qu'un code intelligent et un code rapide. Pour un bon style de codage sain à adopter, consultez le
<a href="https://www.kernel.org/doc/Documentation/process/coding-style.rst">Linux kernel coding style</a>.</p>
<p>[1] <a href="http://stackoverflow.com/questions/119123/why-isnt-sizeof-for-a-struct-equal-to-the-sum-of-sizeof-of-each-member">Why isn't sizeof for a struct equal to the sum of sizeof of each member?</a></p>

        <hr>
        <p>
          Vous avez une suggestion ? Peut-être une correction ? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Ouvrez un ticket</a> sur GitHub, ou faites vous-même une <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/fr/c.md">pull request</a> !
        </p>
        <p class="contributed">
          Version originale par Adam Bard, mis à jour par <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/fr/c.md">2 contributeur(s)</a>.
        </p>

        <footer>
          <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width: 0; width: 80px; height: 28px; padding-bottom: 5px;" src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-sa.svg" /></a>
          <p>
            &copy; 2025
            <a href="http://adambard.com/">Adam Bard</a>,
            <a href="http://twitter.com/H2CO3_iOS">Árpád Goretity</a>,
            <a href="http://cbs.stgn.pl">Jakub Trzebiatowski</a>,
            <a href="https://marcoms.github.io">Marco Scannadinari</a>,
            <a href="https://github.io/zfergus2">Zachary Ferguson</a>,
            <a href="https://github.com/himanshu81494">himanshu</a>,
            <a href="https://github.com/JoshuaRLi">Joshua Li</a>,
            <a href="https://github.com/dchirila">Dragos B. Chirila</a>,
            <a href="https://github.com/heitorPB/">Heitor P. de Bittencourt</a>
          </p>
        </footer>
      </div>
    </div>
  </body>
</html>