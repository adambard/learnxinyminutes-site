<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="en-us" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="en-us" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="en-us" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="en-us" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="en-us">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Standard ML in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/standard-ml/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fstandard-ml%2F&text=Learn+X+in+Y+minutes%2C+where+X%3DStandard+ML">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="/">Learn X in Y minutes</a></h1>
  <h2>Where X=Standard ML</h2>
    <p class="filelink">
    Get the code:
    <a href="/docs/files/standardml.sml">standardml.sml</a>
    </p>
  <div id="doc">
    <p>Standard ML is a functional programming language with type inference and some
side-effects.  Some of the hard parts of learning Standard ML are: Recursion,
pattern matching, type inference (guessing the right types but never allowing
implicit type conversion). Standard ML is distinguished from Haskell by including
references, allowing variables to be updated.</p>
<div class="highlight"><pre><span></span><span class="c">(* Comments in Standard ML begin with (* and end with *).  Comments can be</span>
<span class="c">   nested which means that all (* tags must end with a *) tag.  This comment,</span>
<span class="c">   for example, contains two nested comments. *)</span>

<span class="c">(* A Standard ML program consists of declarations, e.g. value declarations: *)</span>
<span class="k">val</span> <span class="n">rent</span> <span class="o">=</span> <span class="mi">1200</span>
<span class="k">val</span> <span class="n">phone_no</span> <span class="o">=</span> <span class="mi">5551337</span>
<span class="k">val</span> <span class="n">pi</span> <span class="o">=</span> <span class="mi">3</span><span class="o">.</span><span class="mi">14159</span>
<span class="k">val</span> <span class="n">negative_number</span> <span class="o">=</span> <span class="o">~</span><span class="mi">15</span>  <span class="c">(* Yeah, unary minus uses the &#39;tilde&#39; symbol *)</span>

<span class="c">(* Optionally, you can explicitly declare types. This is not necessary as</span>
<span class="c">   ML will automatically figure out the types of your values. *)</span>
<span class="k">val</span> <span class="n">diameter</span> <span class="o">=</span> <span class="mi">7926</span> <span class="o">:</span> <span class="kt">int</span>
<span class="k">val</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">2</span><span class="o">.</span><span class="mi">718</span> <span class="o">:</span> <span class="n">real</span>
<span class="k">val</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Bobby&quot;</span> <span class="o">:</span> <span class="kt">string</span>

<span class="c">(* And just as importantly, functions: *)</span>
<span class="k">fun</span> <span class="n">is_large</span><span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="kt">int</span><span class="o">)</span> <span class="o">=</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">37</span> <span class="k">then</span> <span class="bp">true</span> <span class="k">else</span> <span class="bp">false</span>

<span class="c">(* Floating-point numbers are called &quot;reals&quot;. *)</span>
<span class="k">val</span> <span class="n">tau</span> <span class="o">=</span> <span class="mi">2</span><span class="o">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">pi</span>         <span class="c">(* You can multiply two reals *)</span>
<span class="k">val</span> <span class="n">twice_rent</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">rent</span>  <span class="c">(* You can multiply two ints *)</span>
<span class="c">(* val meh = 1.25 * 10 *)</span>  <span class="c">(* But you can&#39;t multiply an int and a real *)</span>
<span class="k">val</span> <span class="n">yeh</span> <span class="o">=</span> <span class="mi">1</span><span class="o">.</span><span class="mi">25</span> <span class="o">*</span> <span class="o">(</span><span class="nn">Real</span><span class="p">.</span><span class="n">fromInt</span> <span class="mi">10</span><span class="o">)</span> <span class="c">(* ...unless you explicitly convert</span>
<span class="c">                                      one or the other *)</span>

<span class="c">(* +, - and * are overloaded so they work for both int and real. *)</span>
<span class="c">(* The same cannot be said for division which has separate operators: *)</span>
<span class="k">val</span> <span class="n">real_division</span> <span class="o">=</span> <span class="mi">14</span><span class="o">.</span><span class="mi">0</span> <span class="o">/</span> <span class="mi">4</span><span class="o">.</span><span class="mi">0</span>  <span class="c">(* gives 3.5 *)</span>
<span class="k">val</span> <span class="n">int_division</span>  <span class="o">=</span> <span class="mi">14</span> <span class="n">div</span> <span class="mi">4</span>    <span class="c">(* gives 3, rounding down *)</span>
<span class="k">val</span> <span class="n">int_remainder</span> <span class="o">=</span> <span class="mi">14</span> <span class="ow">mod</span> <span class="mi">4</span>    <span class="c">(* gives 2, since 3*4 = 12 *)</span>

<span class="c">(* ~ is actually sometimes a function (e.g. when put in front of variables) *)</span>
<span class="k">val</span> <span class="n">negative_rent</span> <span class="o">=</span> <span class="o">~(</span><span class="n">rent</span><span class="o">)</span>  <span class="c">(* Would also have worked if rent were a &quot;real&quot; *)</span>

<span class="c">(* There are also booleans and boolean operators *)</span>
<span class="k">val</span> <span class="n">got_milk</span> <span class="o">=</span> <span class="bp">true</span>
<span class="k">val</span> <span class="n">got_bread</span> <span class="o">=</span> <span class="bp">false</span>
<span class="k">val</span> <span class="n">has_breakfast</span> <span class="o">=</span> <span class="n">got_milk</span> <span class="n">andalso</span> <span class="n">got_bread</span>  <span class="c">(* &#39;andalso&#39; is the operator *)</span>
<span class="k">val</span> <span class="n">has_something</span> <span class="o">=</span> <span class="n">got_milk</span> <span class="n">orelse</span> <span class="n">got_bread</span>   <span class="c">(* &#39;orelse&#39; is the operator *)</span>
<span class="k">val</span> <span class="n">is_sad</span> <span class="o">=</span> <span class="n">not</span><span class="o">(</span><span class="n">has_something</span><span class="o">)</span>                 <span class="c">(* not is a function *)</span>

<span class="c">(* Many values can be compared using equality operators: = and &lt;&gt; *)</span>
<span class="k">val</span> <span class="n">pays_same_rent</span> <span class="o">=</span> <span class="o">(</span><span class="n">rent</span> <span class="o">=</span> <span class="mi">1300</span><span class="o">)</span>  <span class="c">(* false *)</span>
<span class="k">val</span> <span class="n">is_wrong_phone_no</span> <span class="o">=</span> <span class="o">(</span><span class="n">phone_no</span> <span class="o">&lt;&gt;</span> <span class="mi">5551337</span><span class="o">)</span>  <span class="c">(* false *)</span>

<span class="c">(* The operator &lt;&gt; is what most other languages call !=. *)</span>
<span class="c">(* &#39;andalso&#39; and &#39;orelse&#39; are called &amp;&amp; and || in many other languages. *)</span>

<span class="c">(* Actually, most of the parentheses above are unnecessary.  Here are some</span>
<span class="c">   different ways to say some of the things mentioned above: *)</span>
<span class="k">fun</span> <span class="n">is_large</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">37</span>  <span class="c">(* The parens above were necessary because of &#39;: int&#39; *)</span>
<span class="k">val</span> <span class="n">is_sad</span> <span class="o">=</span> <span class="n">not</span> <span class="n">has_something</span>
<span class="k">val</span> <span class="n">pays_same_rent</span> <span class="o">=</span> <span class="n">rent</span> <span class="o">=</span> <span class="mi">1300</span>  <span class="c">(* Looks confusing, but works *)</span>
<span class="k">val</span> <span class="n">is_wrong_phone_no</span> <span class="o">=</span> <span class="n">phone_no</span> <span class="o">&lt;&gt;</span> <span class="mi">5551337</span>
<span class="k">val</span> <span class="n">negative_rent</span> <span class="o">=</span> <span class="o">~</span><span class="n">rent</span>  <span class="c">(* ~ rent (notice the space) would also work *)</span>

<span class="c">(* Parentheses are mostly necessary when grouping things: *)</span>
<span class="k">val</span> <span class="n">some_answer</span> <span class="o">=</span> <span class="n">is_large</span> <span class="o">(</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">5</span><span class="o">)</span>      <span class="c">(* Without parens, this would break! *)</span>
<span class="c">(* val some_answer = is_large 5 + 5 *)</span>  <span class="c">(* Read as: (is_large 5) + 5. Bad! *)</span>


<span class="c">(* Besides booleans, ints and reals, Standard ML also has chars and strings: *)</span>
<span class="k">val</span> <span class="n">foo</span> <span class="o">=</span> <span class="s2">&quot;Hello, World!</span><span class="se">\n</span><span class="s2">&quot;</span>  <span class="c">(* The \n is the escape sequence for linebreaks *)</span>
<span class="k">val</span> <span class="n">one_letter</span> <span class="o">=</span> <span class="o">#</span><span class="s2">&quot;a&quot;</span>        <span class="c">(* That funky syntax is just one character, a *)</span>

<span class="k">val</span> <span class="n">combined</span> <span class="o">=</span> <span class="s2">&quot;Hello &quot;</span> <span class="o">^</span> <span class="s2">&quot;there, &quot;</span> <span class="o">^</span> <span class="s2">&quot;fellow!</span><span class="se">\n</span><span class="s2">&quot;</span>  <span class="c">(* Concatenate strings *)</span>

<span class="k">val</span> <span class="o">_</span> <span class="o">=</span> <span class="n">print</span> <span class="n">foo</span>       <span class="c">(* You can print things. We are not interested in the *)</span>
<span class="k">val</span> <span class="o">_</span> <span class="o">=</span> <span class="n">print</span> <span class="n">combined</span>  <span class="c">(* result of this computation, so we throw it away. *)</span>
<span class="c">(* val _ = print one_letter *)</span>  <span class="c">(* Only strings can be printed this way *)</span>


<span class="k">val</span> <span class="n">bar</span> <span class="o">=</span> <span class="o">[</span> <span class="o">#</span><span class="s2">&quot;H&quot;</span><span class="o">,</span> <span class="o">#</span><span class="s2">&quot;e&quot;</span><span class="o">,</span> <span class="o">#</span><span class="s2">&quot;l&quot;</span><span class="o">,</span> <span class="o">#</span><span class="s2">&quot;l&quot;</span><span class="o">,</span> <span class="o">#</span><span class="s2">&quot;o&quot;</span> <span class="o">]</span>  <span class="c">(* SML also has lists! *)</span>
<span class="c">(* val _ = print bar *)</span>  <span class="c">(* Lists are unfortunately not the same as strings *)</span>

<span class="c">(* Fortunately they can be converted.  String is a library and implode and size</span>
<span class="c">   are functions available in that library that take strings as argument. *)</span>
<span class="k">val</span> <span class="n">bob</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">implode</span> <span class="n">bar</span>          <span class="c">(* gives &quot;Hello&quot; *)</span>
<span class="k">val</span> <span class="n">bob_char_count</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">size</span> <span class="n">bob</span>  <span class="c">(* gives 5 *)</span>
<span class="k">val</span> <span class="o">_</span> <span class="o">=</span> <span class="n">print</span> <span class="o">(</span><span class="n">bob</span> <span class="o">^</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">)</span>            <span class="c">(* For good measure, add a linebreak *)</span>

<span class="c">(* You can have lists of any kind *)</span>
<span class="k">val</span> <span class="n">numbers</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">229</span><span class="o">,</span> <span class="mi">230</span><span class="o">,</span> <span class="mi">248</span><span class="o">]</span>  <span class="c">(* : int list *)</span>
<span class="k">val</span> <span class="n">names</span> <span class="o">=</span> <span class="o">[</span> <span class="s2">&quot;Fred&quot;</span><span class="o">,</span> <span class="s2">&quot;Jane&quot;</span><span class="o">,</span> <span class="s2">&quot;Alice&quot;</span> <span class="o">]</span>    <span class="c">(* : string list *)</span>

<span class="c">(* Even lists of lists of things *)</span>
<span class="k">val</span> <span class="n">groups</span> <span class="o">=</span> <span class="o">[</span> <span class="o">[</span> <span class="s2">&quot;Alice&quot;</span><span class="o">,</span> <span class="s2">&quot;Bob&quot;</span> <span class="o">],</span>
               <span class="o">[</span> <span class="s2">&quot;Huey&quot;</span><span class="o">,</span> <span class="s2">&quot;Dewey&quot;</span><span class="o">,</span> <span class="s2">&quot;Louie&quot;</span> <span class="o">],</span>
               <span class="o">[</span> <span class="s2">&quot;Bonnie&quot;</span><span class="o">,</span> <span class="s2">&quot;Clyde&quot;</span> <span class="o">]</span> <span class="o">]</span>     <span class="c">(* : string list list *)</span>

<span class="k">val</span> <span class="n">number_count</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">numbers</span>     <span class="c">(* gives 7 *)</span>

<span class="c">(* You can put single values in front of lists of the same kind using</span>
<span class="c">   the :: operator, called &quot;the cons operator&quot; (known from Lisp). *)</span>
<span class="k">val</span> <span class="n">more_numbers</span> <span class="o">=</span> <span class="mi">13</span> <span class="o">::</span> <span class="n">numbers</span>  <span class="c">(* gives [13, 1, 3, 3, 7, ...] *)</span>
<span class="k">val</span> <span class="n">more_groups</span>  <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;Batman&quot;</span><span class="o">,</span><span class="s2">&quot;Superman&quot;</span><span class="o">]</span> <span class="o">::</span> <span class="n">groups</span>

<span class="c">(* Lists of the same kind can be appended using the @ (&quot;append&quot;) operator *)</span>
<span class="k">val</span> <span class="n">guest_list</span> <span class="o">=</span> <span class="o">[</span> <span class="s2">&quot;Mom&quot;</span><span class="o">,</span> <span class="s2">&quot;Dad&quot;</span> <span class="o">]</span> <span class="o">@</span> <span class="o">[</span> <span class="s2">&quot;Aunt&quot;</span><span class="o">,</span> <span class="s2">&quot;Uncle&quot;</span> <span class="o">]</span>

<span class="c">(* This could have been done with the &quot;cons&quot; operator.  It is tricky because the</span>
<span class="c">   left-hand-side must be an element whereas the right-hand-side must be a list</span>
<span class="c">   of those elements. *)</span>
<span class="k">val</span> <span class="n">guest_list</span> <span class="o">=</span> <span class="s2">&quot;Mom&quot;</span> <span class="o">::</span> <span class="s2">&quot;Dad&quot;</span> <span class="o">::</span> <span class="o">[</span> <span class="s2">&quot;Aunt&quot;</span><span class="o">,</span> <span class="s2">&quot;Uncle&quot;</span> <span class="o">]</span>
<span class="k">val</span> <span class="n">guest_list</span> <span class="o">=</span> <span class="s2">&quot;Mom&quot;</span> <span class="o">::</span> <span class="o">(</span><span class="s2">&quot;Dad&quot;</span> <span class="o">::</span> <span class="o">(</span><span class="s2">&quot;Aunt&quot;</span> <span class="o">::</span> <span class="o">(</span><span class="s2">&quot;Uncle&quot;</span> <span class="o">::</span> <span class="bp">[]</span><span class="o">)))</span>

<span class="c">(* If you have many lists of the same kind, you can concatenate them all *)</span>
<span class="k">val</span> <span class="n">everyone</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">concat</span> <span class="n">groups</span>  <span class="c">(* [ &quot;Alice&quot;, &quot;Bob&quot;, &quot;Huey&quot;, ... ] *)</span>

<span class="c">(* A list can contain any (finite) number of values *)</span>
<span class="k">val</span> <span class="n">lots</span> <span class="o">=</span> <span class="o">[</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">3</span> <span class="o">]</span>  <span class="c">(* still just an int list *)</span>

<span class="c">(* Lists can only contain one kind of thing... *)</span>
<span class="c">(* val bad_list = [ 1, &quot;Hello&quot;, 3.14159 ] : ??? list *)</span>


<span class="c">(* Tuples, on the other hand, can contain a fixed number of different things *)</span>
<span class="k">val</span> <span class="n">person1</span> <span class="o">=</span> <span class="o">(</span><span class="s2">&quot;Simon&quot;</span><span class="o">,</span> <span class="mi">28</span><span class="o">,</span> <span class="mi">3</span><span class="o">.</span><span class="mi">14159</span><span class="o">)</span>  <span class="c">(* : string * int * real *)</span>

<span class="c">(* You can even have tuples inside lists and lists inside tuples *)</span>
<span class="k">val</span> <span class="n">likes</span> <span class="o">=</span> <span class="o">[</span> <span class="o">(</span><span class="s2">&quot;Alice&quot;</span><span class="o">,</span> <span class="s2">&quot;ice cream&quot;</span><span class="o">),</span>
              <span class="o">(</span><span class="s2">&quot;Bob&quot;</span><span class="o">,</span>   <span class="s2">&quot;hot dogs&quot;</span><span class="o">),</span>
              <span class="o">(</span><span class="s2">&quot;Bob&quot;</span><span class="o">,</span>   <span class="s2">&quot;Alice&quot;</span><span class="o">)</span> <span class="o">]</span>     <span class="c">(* : (string * string) list *)</span>

<span class="k">val</span> <span class="n">mixup</span> <span class="o">=</span> <span class="o">[</span> <span class="o">(</span><span class="s2">&quot;Alice&quot;</span><span class="o">,</span> <span class="mi">39</span><span class="o">),</span>
              <span class="o">(</span><span class="s2">&quot;Bob&quot;</span><span class="o">,</span>   <span class="mi">37</span><span class="o">),</span>
              <span class="o">(</span><span class="s2">&quot;Eve&quot;</span><span class="o">,</span>   <span class="mi">41</span><span class="o">)</span> <span class="o">]</span>  <span class="c">(* : (string * int) list *)</span>

<span class="k">val</span> <span class="n">good_bad_stuff</span> <span class="o">=</span>
  <span class="o">([</span><span class="s2">&quot;ice cream&quot;</span><span class="o">,</span> <span class="s2">&quot;hot dogs&quot;</span><span class="o">,</span> <span class="s2">&quot;chocolate&quot;</span><span class="o">],</span>
   <span class="o">[</span><span class="s2">&quot;liver&quot;</span><span class="o">,</span> <span class="s2">&quot;paying the rent&quot;</span> <span class="o">])</span>           <span class="c">(* : string list * string list *)</span>


<span class="c">(* Records are tuples with named slots *)</span>

<span class="k">val</span> <span class="n">rgb</span> <span class="o">=</span> <span class="o">{</span> <span class="n">r</span><span class="o">=</span><span class="mi">0</span><span class="o">.</span><span class="mi">23</span><span class="o">,</span> <span class="n">g</span><span class="o">=</span><span class="mi">0</span><span class="o">.</span><span class="mi">56</span><span class="o">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">0</span><span class="o">.</span><span class="mi">91</span> <span class="o">}</span> <span class="c">(* : {b:real, g:real, r:real} *)</span>

<span class="c">(* You don&#39;t need to declare their slots ahead of time. Records with</span>
<span class="c">   different slot names are considered different types, even if their</span>
<span class="c">   slot value types match up. For instance... *)</span>

<span class="k">val</span> <span class="nc">Hsl</span> <span class="o">=</span> <span class="o">{</span> <span class="nc">H</span><span class="o">=</span><span class="mi">310</span><span class="o">.</span><span class="mi">3</span><span class="o">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="o">.</span><span class="mi">51</span><span class="o">,</span> <span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="o">.</span><span class="mi">23</span> <span class="o">}</span> <span class="c">(* : {H:real, l:real, s:real} *)</span>
<span class="k">val</span> <span class="nc">Hsv</span> <span class="o">=</span> <span class="o">{</span> <span class="nc">H</span><span class="o">=</span><span class="mi">310</span><span class="o">.</span><span class="mi">3</span><span class="o">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="o">.</span><span class="mi">51</span><span class="o">,</span> <span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="o">.</span><span class="mi">23</span> <span class="o">}</span> <span class="c">(* : {H:real, s:real, v:real} *)</span>

<span class="c">(* ...trying to evaluate `Hsv = Hsl` or `rgb = Hsl` would give a type</span>
<span class="c">   error. While they&#39;re all three-slot records composed only of `real`s,</span>
<span class="c">   they each have different names for at least some slots. *)</span>

<span class="c">(* You can use hash notation to get values out of tuples. *)</span>

<span class="k">val</span> <span class="nc">H</span> <span class="o">=</span> <span class="o">#</span><span class="nc">H</span> <span class="nc">Hsv</span> <span class="c">(* : real *)</span>
<span class="k">val</span> <span class="n">s</span> <span class="o">=</span> <span class="o">#</span><span class="n">s</span> <span class="nc">Hsl</span> <span class="c">(* : real *)</span>

<span class="c">(* Functions! *)</span>
<span class="k">fun</span> <span class="n">add_them</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>    <span class="c">(* A simple function that adds two numbers *)</span>
<span class="k">val</span> <span class="n">test_it</span> <span class="o">=</span> <span class="n">add_them</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>  <span class="c">(* gives 7 *)</span>

<span class="c">(* Larger functions are usually broken into several lines for readability *)</span>
<span class="k">fun</span> <span class="n">thermometer</span> <span class="n">temp</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">temp</span> <span class="o">&lt;</span> <span class="mi">37</span>
    <span class="k">then</span> <span class="s2">&quot;Cold&quot;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">temp</span> <span class="o">&gt;</span> <span class="mi">37</span>
         <span class="k">then</span> <span class="s2">&quot;Warm&quot;</span>
         <span class="k">else</span> <span class="s2">&quot;Normal&quot;</span>

<span class="k">val</span> <span class="n">test_thermo</span> <span class="o">=</span> <span class="n">thermometer</span> <span class="mi">40</span>  <span class="c">(* gives &quot;Warm&quot; *)</span>

<span class="c">(* if-sentences are actually expressions and not statements/declarations.</span>
<span class="c">   A function body can only contain one expression.  There are some tricks</span>
<span class="c">   for making a function do more than just one thing, though. *)</span>

<span class="c">(* A function can call itself as part of its result (recursion!) *)</span>
<span class="k">fun</span> <span class="n">fibonacci</span> <span class="n">n</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span>                   <span class="c">(* Base case *)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span>                   <span class="c">(* Base case *)</span>
    <span class="n">fibonacci</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">fibonacci</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span>  <span class="c">(* Recursive case *)</span>

<span class="c">(* Sometimes recursion is best understood by evaluating a function by hand:</span>

<span class="c"> fibonacci 4</span>
<span class="c">   ~&gt; fibonacci (4 - 1) + fibonacci (4 - 2)</span>
<span class="c">   ~&gt; fibonacci 3 + fibonacci 2</span>
<span class="c">   ~&gt; (fibonacci (3 - 1) + fibonacci (3 - 2)) + fibonacci 2</span>
<span class="c">   ~&gt; (fibonacci 2 + fibonacci 1) + fibonacci 2</span>
<span class="c">   ~&gt; ((fibonacci (2 - 1) + fibonacci (2 - 2)) + fibonacci 1) + fibonacci 2</span>
<span class="c">   ~&gt; ((fibonacci 1 + fibonacci 0) + fibonacci 1) + fibonacci 2</span>
<span class="c">   ~&gt; ((1 + fibonacci 0) + fibonacci 1) + fibonacci 2</span>
<span class="c">   ~&gt; ((1 + 0) + fibonacci 1) + fibonacci 2</span>
<span class="c">   ~&gt; (1 + fibonacci 1) + fibonacci 2</span>
<span class="c">   ~&gt; (1 + 1) + fibonacci 2</span>
<span class="c">   ~&gt; 2 + fibonacci 2</span>
<span class="c">   ~&gt; 2 + (fibonacci (2 - 1) + fibonacci (2 - 2))</span>
<span class="c">   ~&gt; 2 + (fibonacci (2 - 1) + fibonacci (2 - 2))</span>
<span class="c">   ~&gt; 2 + (fibonacci 1 + fibonacci 0)</span>
<span class="c">   ~&gt; 2 + (1 + fibonacci 0)</span>
<span class="c">   ~&gt; 2 + (1 + 0)</span>
<span class="c">   ~&gt; 2 + 1</span>
<span class="c">   ~&gt; 3  which is the 4th Fibonacci number, according to this definition</span>

<span class="c"> *)</span>

<span class="c">(* A function cannot change the variables it can refer to.  It can only</span>
<span class="c">   temporarily shadow them with new variables that have the same names.  In this</span>
<span class="c">   sense, variables are really constants and only behave like variables when</span>
<span class="c">   dealing with recursion.  For this reason, variables are also called value</span>
<span class="c">   bindings. An example of this: *)</span>

<span class="k">val</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">42</span>
<span class="k">fun</span> <span class="n">answer</span><span class="o">(</span><span class="n">question</span><span class="o">)</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">question</span> <span class="o">=</span> <span class="s2">&quot;What is the meaning of life, the universe and everything?&quot;</span>
    <span class="k">then</span> <span class="n">x</span>
    <span class="k">else</span> <span class="k">raise</span> <span class="nc">Fail</span> <span class="s2">&quot;I&#39;m an exception. Also, I don&#39;t know what the answer is.&quot;</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">43</span>
<span class="k">val</span> <span class="n">hmm</span> <span class="o">=</span> <span class="n">answer</span> <span class="s2">&quot;What is the meaning of life, the universe and everything?&quot;</span>
<span class="c">(* Now, hmm has the value 42.  This is because the function answer refers to</span>
<span class="c">   the copy of x that was visible before its own function definition. *)</span>


<span class="c">(* Functions can take several arguments by taking one tuples as argument: *)</span>
<span class="k">fun</span> <span class="n">solve2</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">real</span><span class="o">,</span> <span class="n">b</span> <span class="o">:</span> <span class="n">real</span><span class="o">,</span> <span class="n">c</span> <span class="o">:</span> <span class="n">real</span><span class="o">)</span> <span class="o">=</span>
    <span class="o">((~</span><span class="n">b</span> <span class="o">+</span> <span class="nn">Math</span><span class="p">.</span><span class="n">sqrt</span><span class="o">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">4</span><span class="o">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span><span class="o">))</span> <span class="o">/</span> <span class="o">(</span><span class="mi">2</span><span class="o">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">a</span><span class="o">),</span>
     <span class="o">(~</span><span class="n">b</span> <span class="o">-</span> <span class="nn">Math</span><span class="p">.</span><span class="n">sqrt</span><span class="o">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">4</span><span class="o">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span><span class="o">))</span> <span class="o">/</span> <span class="o">(</span><span class="mi">2</span><span class="o">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">a</span><span class="o">))</span>

<span class="c">(* Sometimes, the same computation is carried out several times. It makes sense</span>
<span class="c">   to save and re-use the result the first time. We can use &quot;let-bindings&quot;: *)</span>
<span class="k">fun</span> <span class="n">solve2</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">real</span><span class="o">,</span> <span class="n">b</span> <span class="o">:</span> <span class="n">real</span><span class="o">,</span> <span class="n">c</span> <span class="o">:</span> <span class="n">real</span><span class="o">)</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">val</span> <span class="n">discr</span>  <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">4</span><span class="o">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span>
        <span class="k">val</span> <span class="n">sqr</span> <span class="o">=</span> <span class="nn">Math</span><span class="p">.</span><span class="n">sqrt</span> <span class="n">discr</span>
        <span class="k">val</span> <span class="n">denom</span> <span class="o">=</span> <span class="mi">2</span><span class="o">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">a</span>
    <span class="k">in</span> <span class="o">((~</span><span class="n">b</span> <span class="o">+</span> <span class="n">sqr</span><span class="o">)</span> <span class="o">/</span> <span class="n">denom</span><span class="o">,</span>
        <span class="o">(~</span><span class="n">b</span> <span class="o">-</span> <span class="n">sqr</span><span class="o">)</span> <span class="o">/</span> <span class="n">denom</span><span class="o">)</span>
    <span class="k">end</span>


<span class="c">(* Pattern matching is a funky part of functional programming.  It is an</span>
<span class="c">   alternative to if-sentences.  The fibonacci function can be rewritten: *)</span>
<span class="k">fun</span> <span class="n">fibonacci</span> <span class="mi">0</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c">(* Base case *)</span>
  <span class="o">|</span> <span class="n">fibonacci</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c">(* Base case *)</span>
  <span class="o">|</span> <span class="n">fibonacci</span> <span class="n">n</span> <span class="o">=</span> <span class="n">fibonacci</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">fibonacci</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span>  <span class="c">(* Recursive case *)</span>

<span class="c">(* Pattern matching is also possible on composite types like tuples, lists and</span>
<span class="c">   records. Writing &quot;fun solve2 (a, b, c) = ...&quot; is in fact a pattern match on</span>
<span class="c">   the one three-tuple solve2 takes as argument. Similarly, but less intuitively,</span>
<span class="c">   you can match on a list consisting of elements in it (from the beginning of</span>
<span class="c">   the list only). *)</span>
<span class="k">fun</span> <span class="n">first_elem</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">)</span> <span class="o">=</span> <span class="n">x</span>
<span class="k">fun</span> <span class="n">second_elem</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">y</span><span class="o">::</span><span class="n">xs</span><span class="o">)</span> <span class="o">=</span> <span class="n">y</span>
<span class="k">fun</span> <span class="n">evenly_positioned_elems</span> <span class="o">(</span><span class="n">odd</span><span class="o">::</span><span class="n">even</span><span class="o">::</span><span class="n">xs</span><span class="o">)</span> <span class="o">=</span> <span class="n">even</span><span class="o">::</span><span class="n">evenly_positioned_elems</span> <span class="n">xs</span>
  <span class="o">|</span> <span class="n">evenly_positioned_elems</span> <span class="o">[</span><span class="n">odd</span><span class="o">]</span> <span class="o">=</span> <span class="bp">[]</span>  <span class="c">(* Base case: throw away *)</span>
  <span class="o">|</span> <span class="n">evenly_positioned_elems</span> <span class="bp">[]</span>    <span class="o">=</span> <span class="bp">[]</span>  <span class="c">(* Base case *)</span>

<span class="c">(* The case expression can also be used to pattern match and return a value *)</span>
<span class="n">datatype</span> <span class="n">temp</span> <span class="o">=</span>
      <span class="nc">C</span> <span class="k">of</span> <span class="n">real</span>
    <span class="o">|</span> <span class="nc">F</span> <span class="k">of</span> <span class="n">real</span>

<span class="c">(*  Declaring a new C temp value...</span>
<span class="c">    val t: temp = C 45.0  *)</span>

<span class="k">fun</span> <span class="n">temp_to_f</span> <span class="n">t</span> <span class="o">=</span>
    <span class="n">case</span> <span class="n">t</span> <span class="k">of</span>
      <span class="nc">C</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="o">(</span><span class="mi">9</span><span class="o">.</span><span class="mi">0</span> <span class="o">/</span> <span class="mi">5</span><span class="o">.</span><span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">32</span><span class="o">.</span><span class="mi">0</span>
    <span class="o">|</span> <span class="nc">F</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">x</span>

<span class="c">(* When matching on records, you must use their slot names, and you must bind</span>
<span class="c">   every slot in a record. The order of the slots doesn&#39;t matter though. *)</span>

<span class="k">fun</span> <span class="n">rgbToTup</span> <span class="o">{</span><span class="n">r</span><span class="o">,</span> <span class="n">g</span><span class="o">,</span> <span class="n">b</span><span class="o">}</span> <span class="o">=</span> <span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="n">g</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>    <span class="c">(* fn : {b:&#39;a, g:&#39;b, r:&#39;c} -&gt; &#39;c * &#39;b * &#39;a *)</span>
<span class="k">fun</span> <span class="n">mixRgbToTup</span> <span class="o">{</span><span class="n">g</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">r</span><span class="o">}</span> <span class="o">=</span> <span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="n">g</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="c">(* fn : {b:&#39;a, g:&#39;b, r:&#39;c} -&gt; &#39;c * &#39;b * &#39;a *)</span>

<span class="c">(* If called with {r=0.1, g=0.2, b=0.3}, either of the above functions</span>
<span class="c">   would return (0.1, 0.2, 0.3). But it would be a type error to call them</span>
<span class="c">   with {r=0.1, g=0.2, b=0.3, a=0.4} *)</span>

<span class="c">(* Higher order functions: Functions can take other functions as arguments.</span>
<span class="c">   Functions are just other kinds of values, and functions don&#39;t need names</span>
<span class="c">   to exist.  Functions without names are called &quot;anonymous functions&quot; or</span>
<span class="c">   lambda expressions or closures (since they also have a lexical scope). *)</span>
<span class="k">val</span> <span class="n">is_large</span> <span class="o">=</span> <span class="o">(</span><span class="n">fn</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">37</span><span class="o">)</span>
<span class="k">val</span> <span class="n">add_them</span> <span class="o">=</span> <span class="n">fn</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="k">val</span> <span class="n">thermometer</span> <span class="o">=</span>
    <span class="n">fn</span> <span class="n">temp</span> <span class="o">=&gt;</span> <span class="k">if</span> <span class="n">temp</span> <span class="o">&lt;</span> <span class="mi">37</span>
               <span class="k">then</span> <span class="s2">&quot;Cold&quot;</span>
               <span class="k">else</span> <span class="k">if</span> <span class="n">temp</span> <span class="o">&gt;</span> <span class="mi">37</span>
                    <span class="k">then</span> <span class="s2">&quot;Warm&quot;</span>
                    <span class="k">else</span> <span class="s2">&quot;Normal&quot;</span>

<span class="c">(* The following uses an anonymous function directly and gives &quot;ColdWarm&quot; *)</span>
<span class="k">val</span> <span class="n">some_result</span> <span class="o">=</span> <span class="o">(</span><span class="n">fn</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">thermometer</span> <span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">5</span><span class="o">)</span> <span class="o">^</span> <span class="n">thermometer</span> <span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">5</span><span class="o">))</span> <span class="mi">37</span>

<span class="c">(* Here is a higher-order function that works on lists (a list combinator) *)</span>
<span class="c">(* map f l</span>
<span class="c">       applies f to each element of l from left to right, </span>
<span class="c">       returning the list of results. *)</span>
<span class="k">val</span> <span class="n">readings</span> <span class="o">=</span> <span class="o">[</span> <span class="mi">34</span><span class="o">,</span> <span class="mi">39</span><span class="o">,</span> <span class="mi">37</span><span class="o">,</span> <span class="mi">38</span><span class="o">,</span> <span class="mi">35</span><span class="o">,</span> <span class="mi">36</span><span class="o">,</span> <span class="mi">37</span><span class="o">,</span> <span class="mi">37</span><span class="o">,</span> <span class="mi">37</span> <span class="o">]</span>  <span class="c">(* first an int list *)</span>
<span class="k">val</span> <span class="n">opinions</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">thermometer</span> <span class="n">readings</span> <span class="c">(* gives [ &quot;Cold&quot;, &quot;Warm&quot;, ... ] *)</span>

<span class="c">(* And here is another one for filtering lists *)</span>
<span class="k">val</span> <span class="n">warm_readings</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="n">is_large</span> <span class="n">readings</span>  <span class="c">(* gives [39, 38] *)</span>

<span class="c">(* You can create your own higher-order functions, too.  Functions can also take</span>
<span class="c">   several arguments by &quot;currying&quot; them. Syntax-wise this means adding spaces</span>
<span class="c">   between function arguments instead of commas and surrounding parentheses. *)</span>
<span class="k">fun</span> <span class="n">map</span> <span class="n">f</span> <span class="bp">[]</span> <span class="o">=</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="n">map</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">)</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">::</span> <span class="n">map</span> <span class="n">f</span> <span class="n">xs</span>

<span class="c">(* map has type (&#39;a -&gt; &#39;b) -&gt; &#39;a list -&gt; &#39;b list and is called polymorphic. *)</span>
<span class="c">(* &#39;a is called a type variable. *)</span>


<span class="c">(* We can declare functions as infix *)</span>
<span class="k">val</span> <span class="n">plus</span> <span class="o">=</span> <span class="n">add_them</span>   <span class="c">(* plus is now equal to the same function as add_them *)</span>
<span class="n">infix</span> <span class="n">plus</span>            <span class="c">(* plus is now an infix operator *)</span>
<span class="k">val</span> <span class="n">seven</span> <span class="o">=</span> <span class="mi">2</span> <span class="n">plus</span> <span class="mi">5</span>  <span class="c">(* seven is now bound to 7 *)</span>

<span class="c">(* Functions can also be made infix before they are declared *)</span>
<span class="n">infix</span> <span class="n">minus</span>
<span class="k">fun</span> <span class="n">x</span> <span class="n">minus</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="c">(* It becomes a little hard to see what&#39;s the argument *)</span>
<span class="k">val</span> <span class="n">four</span> <span class="o">=</span> <span class="mi">8</span> <span class="n">minus</span> <span class="mi">4</span>  <span class="c">(* four is now bound to 4 *)</span>

<span class="c">(* An infix function/operator can be made prefix with &#39;op&#39; *)</span>
<span class="k">val</span> <span class="n">n</span> <span class="o">=</span> <span class="n">op</span> <span class="o">+</span> <span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>   <span class="c">(* n is now 10 *)</span>

<span class="c">(* &#39;op&#39; is useful when combined with high order functions because they expect</span>
<span class="c">   functions and not operators as arguments. Most operators are really just</span>
<span class="c">   infix functions. *)</span>
<span class="c">(* foldl f init [x1, x2, ..., xn]</span>
<span class="c">       returns</span>
<span class="c">       f(xn, ...f(x2, f(x1, init))...)</span>
<span class="c">       or init if the list is empty. *)</span>
<span class="k">val</span> <span class="n">sum_of_numbers</span> <span class="o">=</span> <span class="n">foldl</span> <span class="n">op</span><span class="o">+</span> <span class="mi">0</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">]</span>


<span class="c">(* Datatypes are useful for creating both simple and complex structures *)</span>
<span class="n">datatype</span> <span class="n">color</span> <span class="o">=</span> <span class="nc">Red</span> <span class="o">|</span> <span class="nc">Green</span> <span class="o">|</span> <span class="nc">Blue</span>

<span class="c">(* Here is a function that takes one of these as argument *)</span>
<span class="k">fun</span> <span class="n">say</span><span class="o">(</span><span class="n">col</span><span class="o">)</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">col</span> <span class="o">=</span> <span class="nc">Red</span> <span class="k">then</span> <span class="s2">&quot;You are red!&quot;</span> <span class="k">else</span>
    <span class="k">if</span> <span class="n">col</span> <span class="o">=</span> <span class="nc">Green</span> <span class="k">then</span> <span class="s2">&quot;You are green!&quot;</span> <span class="k">else</span>
    <span class="k">if</span> <span class="n">col</span> <span class="o">=</span> <span class="nc">Blue</span> <span class="k">then</span> <span class="s2">&quot;You are blue!&quot;</span> <span class="k">else</span>
    <span class="k">raise</span> <span class="nc">Fail</span> <span class="s2">&quot;Unknown color&quot;</span>

<span class="k">val</span> <span class="o">_</span> <span class="o">=</span> <span class="n">print</span> <span class="o">(</span><span class="n">say</span><span class="o">(</span><span class="nc">Red</span><span class="o">)</span> <span class="o">^</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">)</span>

<span class="c">(* Datatypes are very often used in combination with pattern matching *)</span>
<span class="k">fun</span> <span class="n">say</span> <span class="nc">Red</span>   <span class="o">=</span> <span class="s2">&quot;You are red!&quot;</span>
  <span class="o">|</span> <span class="n">say</span> <span class="nc">Green</span> <span class="o">=</span> <span class="s2">&quot;You are green!&quot;</span>
  <span class="o">|</span> <span class="n">say</span> <span class="nc">Blue</span>  <span class="o">=</span> <span class="s2">&quot;You are blue!&quot;</span>

<span class="c">(* We did not include the match arm `say _ = raise Fail &quot;Unknown color&quot;`</span>
<span class="c">because after specifying all three colors, the pattern is exhaustive</span>
<span class="c">and redundancy is not permitted in pattern matching *)</span>


<span class="c">(* Here is a binary tree datatype *)</span>
<span class="n">datatype</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">btree</span> <span class="o">=</span> <span class="nc">Leaf</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span>
                  <span class="o">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">btree</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">btree</span> <span class="c">(* three-arg constructor *)</span>

<span class="c">(* Here is a binary tree *)</span>
<span class="k">val</span> <span class="n">myTree</span> <span class="o">=</span> <span class="nc">Node</span> <span class="o">(</span><span class="nc">Leaf</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="nc">Node</span> <span class="o">(</span><span class="nc">Leaf</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="nc">Leaf</span> <span class="mi">7</span><span class="o">))</span>

<span class="c">(* Drawing it, it might look something like...</span>

<span class="c">           8</span>
<span class="c">          / \</span>
<span class="c"> leaf -&gt; 9   5</span>
<span class="c">            / \</span>
<span class="c">   leaf -&gt; 3   7 &lt;- leaf</span>
<span class="c"> *)</span>

<span class="c">(* This function counts the sum of all the elements in a tree *)</span>
<span class="k">fun</span> <span class="n">count</span> <span class="o">(</span><span class="nc">Leaf</span> <span class="n">n</span><span class="o">)</span> <span class="o">=</span> <span class="n">n</span>
  <span class="o">|</span> <span class="n">count</span> <span class="o">(</span><span class="nc">Node</span> <span class="o">(</span><span class="n">leftTree</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">rightTree</span><span class="o">))</span> <span class="o">=</span> <span class="n">count</span> <span class="n">leftTree</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="n">count</span> <span class="n">rightTree</span>

<span class="k">val</span> <span class="n">myTreeCount</span> <span class="o">=</span> <span class="n">count</span> <span class="n">myTree</span>  <span class="c">(* myTreeCount is now bound to 32 *)</span>


<span class="c">(* Exceptions! *)</span>
<span class="c">(* Exceptions can be raised/thrown using the reserved word &#39;raise&#39; *)</span>
<span class="k">fun</span> <span class="n">calculate_interest</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">=</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span>
                            <span class="k">then</span> <span class="k">raise</span> <span class="nc">Domain</span>
                            <span class="k">else</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">1</span><span class="o">.</span><span class="mi">04</span>

<span class="c">(* Exceptions can be caught using &quot;handle&quot; *)</span>
<span class="k">val</span> <span class="n">balance</span> <span class="o">=</span> <span class="n">calculate_interest</span> <span class="o">~</span><span class="mi">180</span><span class="o">.</span><span class="mi">0</span>
              <span class="n">handle</span> <span class="nc">Domain</span> <span class="o">=&gt;</span> <span class="o">~</span><span class="mi">180</span><span class="o">.</span><span class="mi">0</span>    <span class="c">(* balance now has the value ~180.0 *)</span>

<span class="c">(* Some exceptions carry extra information with them *)</span>
<span class="c">(* Here are some examples of built-in exceptions *)</span>
<span class="k">fun</span> <span class="n">failing_function</span> <span class="bp">[]</span>    <span class="o">=</span> <span class="k">raise</span> <span class="nc">Empty</span>  <span class="c">(* used for empty lists *)</span>
  <span class="o">|</span> <span class="n">failing_function</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span>   <span class="o">=</span> <span class="k">raise</span> <span class="nc">Fail</span> <span class="s2">&quot;This list is too short!&quot;</span>
  <span class="o">|</span> <span class="n">failing_function</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="k">raise</span> <span class="nc">Overflow</span>  <span class="c">(* used for arithmetic *)</span>
  <span class="o">|</span> <span class="n">failing_function</span> <span class="n">xs</span>    <span class="o">=</span> <span class="k">raise</span> <span class="nc">Fail</span> <span class="s2">&quot;This list is too long!&quot;</span>

<span class="c">(* We can pattern match in &#39;handle&#39; to make sure</span>
<span class="c">   a specific exception was raised, or grab the message *)</span>
<span class="k">val</span> <span class="n">err_msg</span> <span class="o">=</span> <span class="n">failing_function</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="n">handle</span> <span class="nc">Fail</span> <span class="o">_</span> <span class="o">=&gt;</span> <span class="s2">&quot;Fail was raised&quot;</span>
                                          <span class="o">|</span> <span class="nc">Domain</span> <span class="o">=&gt;</span> <span class="s2">&quot;Domain was raised&quot;</span>
                                          <span class="o">|</span> <span class="nc">Empty</span>  <span class="o">=&gt;</span> <span class="s2">&quot;Empty was raised&quot;</span>
                                          <span class="o">|</span> <span class="o">_</span>      <span class="o">=&gt;</span> <span class="s2">&quot;Unknown exception&quot;</span>

<span class="c">(* err_msg now has the value &quot;Unknown exception&quot; because Overflow isn&#39;t</span>
<span class="c">   listed as one of the patterns -- thus, the catch-all pattern _ is used. *)</span>

<span class="c">(* We can define our own exceptions like this *)</span>
<span class="k">exception</span> <span class="nc">MyException</span>
<span class="k">exception</span> <span class="nc">MyExceptionWithMessage</span> <span class="k">of</span> <span class="kt">string</span>
<span class="k">exception</span> <span class="nc">SyntaxError</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">*</span> <span class="o">(</span><span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>

<span class="c">(* File I/O! *)</span>
<span class="c">(* Write a nice poem to a file *)</span>
<span class="k">fun</span> <span class="n">writePoem</span><span class="o">(</span><span class="n">filename</span><span class="o">)</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">val</span> <span class="n">file</span> <span class="o">=</span> <span class="nn">TextIO</span><span class="p">.</span><span class="n">openOut</span><span class="o">(</span><span class="n">filename</span><span class="o">)</span>
        <span class="k">val</span> <span class="o">_</span> <span class="o">=</span> <span class="nn">TextIO</span><span class="p">.</span><span class="n">output</span><span class="o">(</span><span class="n">file</span><span class="o">,</span> <span class="s2">&quot;Roses are red,</span><span class="se">\n</span><span class="s2">Violets are blue.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">)</span>
        <span class="k">val</span> <span class="o">_</span> <span class="o">=</span> <span class="nn">TextIO</span><span class="p">.</span><span class="n">output</span><span class="o">(</span><span class="n">file</span><span class="o">,</span> <span class="s2">&quot;I have a gun.</span><span class="se">\n</span><span class="s2">Get in the van.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">)</span>
    <span class="k">in</span> <span class="nn">TextIO</span><span class="p">.</span><span class="n">closeOut</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
    <span class="k">end</span>

<span class="c">(* Read a nice poem from a file into a list of strings *)</span>
<span class="k">fun</span> <span class="n">readPoem</span><span class="o">(</span><span class="n">filename</span><span class="o">)</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">val</span> <span class="n">file</span> <span class="o">=</span> <span class="nn">TextIO</span><span class="p">.</span><span class="n">openIn</span> <span class="n">filename</span>
        <span class="k">val</span> <span class="n">poem</span> <span class="o">=</span> <span class="nn">TextIO</span><span class="p">.</span><span class="n">inputAll</span> <span class="n">file</span>
        <span class="k">val</span> <span class="o">_</span> <span class="o">=</span> <span class="nn">TextIO</span><span class="p">.</span><span class="n">closeIn</span> <span class="n">file</span>
    <span class="k">in</span> <span class="nn">String</span><span class="p">.</span><span class="n">tokens</span> <span class="o">(</span><span class="n">fn</span> <span class="n">c</span> <span class="o">=&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="o">#</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">)</span> <span class="n">poem</span>
    <span class="k">end</span>

<span class="k">val</span> <span class="o">_</span> <span class="o">=</span> <span class="n">writePoem</span> <span class="s2">&quot;roses.txt&quot;</span>
<span class="k">val</span> <span class="n">test_poem</span> <span class="o">=</span> <span class="n">readPoem</span> <span class="s2">&quot;roses.txt&quot;</span>  <span class="c">(* gives [ &quot;Roses are red,&quot;,</span>
<span class="c">                                                 &quot;Violets are blue.&quot;,</span>
<span class="c">                                                 &quot;I have a gun.&quot;,</span>
<span class="c">                                                 &quot;Get in the van.&quot; ] *)</span>

<span class="c">(* We can create references to data which can be updated *)</span>
<span class="k">val</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="c">(* Produce a reference with the ref function *)</span>

<span class="c">(* Assign to a reference with the assignment operator *)</span>
<span class="k">fun</span> <span class="n">set_five</span> <span class="n">reference</span> <span class="o">=</span> <span class="n">reference</span> <span class="o">:=</span> <span class="mi">5</span>

<span class="c">(* Read a reference with the dereference operator *)</span>
<span class="k">fun</span> <span class="n">equals_five</span> <span class="n">reference</span> <span class="o">=</span> <span class="o">!</span><span class="n">reference</span> <span class="o">=</span> <span class="mi">5</span>

<span class="c">(* We can use while loops for when recursion is messy *)</span>
<span class="k">fun</span> <span class="n">decrement_to_zero</span> <span class="n">r</span> <span class="o">=</span> <span class="k">if</span> <span class="o">!</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span>
                          <span class="k">then</span> <span class="n">r</span> <span class="o">:=</span> <span class="mi">0</span>
                          <span class="k">else</span> <span class="k">while</span> <span class="o">!</span><span class="n">r</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">do</span> <span class="n">r</span> <span class="o">:=</span> <span class="o">!</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span>

<span class="c">(* This returns the unit value (in practical terms, nothing, a 0-tuple) *)</span>

<span class="c">(* To allow returning a value, we can use the semicolon to sequence evaluations *)</span>
<span class="k">fun</span> <span class="n">decrement_ret</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="o">(</span><span class="n">x</span> <span class="o">:=</span> <span class="o">!</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">y</span><span class="o">)</span>
</pre></div>
<h2>Further learning</h2>

<ul>
<li>Install an interactive compiler (REPL), for example
<a href="http://www.polyml.org/">Poly/ML</a>,
<a href="http://mosml.org">Moscow ML</a>,
<a href="http://smlnj.org/">SML/NJ</a>.</li>
<li>Follow the Coursera course <a href="https://www.coursera.org/course/proglang">Programming Languages</a>.</li>
<li>Read <em><a href="https://www.cl.cam.ac.uk/~lp15/MLbook/pub-details.html">ML for the Working Programmer</a></em> by Larry C. Paulson.</li>
<li>Use <a href="http://stackoverflow.com/questions/tagged/sml">StackOverflow&rsquo;s sml tag</a>.</li>
<li>Solve exercises on <a href="https://exercism.io/tracks/sml">Exercism.io&rsquo;s Standard ML track</a>.</li>
</ul>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/standard-ml.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by Simon Shine, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/standard-ml.html.markdown">16 contributors</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="https://simonshine.dk/">Simon Shine</a>,
        <a href="https://github.com/davidpdrsn">David Pedersen</a>,
        <a href="http://www.jbaker.io/">James Baker</a>,
        <a href="http://langnostic.inaimathi.ca/">Leo Zovic</a>,
        <a href="http://sencjw.com/">Chris Wilson</a>
    </p>

    <p>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
