<!DOCTYPE html lang="en-us" xml:lang="en-us" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="en-us">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Scala in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/scala/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fscala%2F&text=Learn+X+in+Y+minutes%2C+where+X%3DScala">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="/">Learn X in Y minutes</a></h1>
  <h2>Where X=Scala</h2>
    <p class="filelink">
    Get the code:
    <a href="/docs/files/learnscala.scala">learnscala.scala</a>
    </p>
  <div id="doc">
    <p>Scala - the scalable language</p>
<div class="highlight"><pre class="highlight scala"><code><span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 0. Basics</span>
<span class="c1">/////////////////////////////////////////////////</span>
<span class="cm">/*
  Setup Scala:

  1) Download Scala - http://www.scala-lang.org/downloads
  2) Unzip/untar to your favorite location and put the bin subdir in your `PATH` environment variable
*/</span>

<span class="cm">/*
  Try the REPL

  Scala has a tool called the REPL (Read-Eval-Print Loop) that is analogous to
  commandline interpreters in many other languages. You may type any Scala
  expression, and the result will be evaluated and printed.  

  The REPL is a very handy tool to test and verify code.  Use it as you read
  this tutorial to quickly explore concepts on your own.
*/</span>

<span class="c1">// Start a Scala REPL by running `scala`. You should see the prompt:</span>
<span class="n">$</span> <span class="n">scala</span>
<span class="n">scala</span><span class="o">&gt;</span>

<span class="c1">// By default each expression you type is saved as a new numbered value</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">4</span>

<span class="c1">// Default values can be reused.  Note the value type displayed in the result..</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res0</span> <span class="o">+</span> <span class="mi">2</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">6</span>

<span class="c1">// Scala is a strongly typed language. You can use the REPL to check the type</span>
<span class="c1">// without evaluating an expression.</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="k">:type</span> <span class="o">(</span><span class="kt">true</span><span class="o">,</span> <span class="err">2</span><span class="kt">.</span><span class="err">0</span><span class="o">)</span>
<span class="o">(</span><span class="nc">Boolean</span><span class="o">,</span> <span class="nc">Double</span><span class="o">)</span>

<span class="c1">// REPL sessions can be saved</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="k">:</span><span class="kt">save</span> <span class="kt">/sites/repl-test.scala</span>

<span class="c1">// Files can be loaded into the REPL</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="k">:</span><span class="kt">load</span> <span class="kt">/sites/repl-test.scala</span>
<span class="nc">Loading</span> <span class="o">/</span><span class="n">sites</span><span class="o">/</span><span class="n">repl</span><span class="o">-</span><span class="nv">test</span><span class="o">.</span><span class="py">scala</span><span class="o">...</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">6</span>

<span class="c1">// You can search your recent history</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="k">:</span><span class="kt">h?</span>
<span class="err">1</span> <span class="err">2</span> <span class="kt">+</span> <span class="err">2</span>
<span class="err">2</span> <span class="kt">res0</span> <span class="kt">+</span> <span class="err">2</span>
<span class="err">3</span> <span class="kt">:save</span> <span class="kt">/sites/repl-test.scala</span>
<span class="mi">4</span> <span class="k">:</span><span class="kt">load</span> <span class="kt">/sites/repl-test.scala</span>
<span class="mi">5</span> <span class="k">:</span><span class="kt">h?</span>

<span class="c1">// Now that you know how to play, let's learn a little scala...</span>

<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 1. Basics</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Single-line comments start with two forward slashes</span>

<span class="cm">/*
  Multi-line comments, as you can already see from above, look like this.
*/</span>

<span class="c1">// Printing, and forcing a new line on the next print</span>
<span class="nf">println</span><span class="o">(</span><span class="s">"Hello world!"</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
<span class="c1">// Hello world!</span>
<span class="c1">// 10</span>

<span class="c1">// Printing, without forcing a new line on next print</span>
<span class="nf">print</span><span class="o">(</span><span class="s">"Hello world"</span><span class="o">)</span>
<span class="nf">print</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
<span class="c1">// Hello world10</span>

<span class="c1">// Declaring values is done using either var or val.</span>
<span class="c1">// val declarations are immutable, whereas vars are mutable. Immutability is</span>
<span class="c1">// a good thing.</span>
<span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="mi">10</span> <span class="c1">// x is now 10</span>
<span class="n">x</span> <span class="k">=</span> <span class="mi">20</span>     <span class="c1">// error: reassignment to val</span>
<span class="k">var</span> <span class="n">y</span> <span class="k">=</span> <span class="mi">10</span>
<span class="n">y</span> <span class="k">=</span> <span class="mi">20</span>     <span class="c1">// y is now 20</span>

<span class="cm">/*
  Scala is a statically typed language, yet note that in the above declarations,
  we did not specify a type. This is due to a language feature called type
  inference. In most cases, Scala compiler can guess what the type of a variable
  is, so you don't have to type it every time. We can explicitly declare the
  type of a variable like so:
*/</span>
<span class="k">val</span> <span class="nv">z</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span>
<span class="k">val</span> <span class="nv">a</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="c1">// Notice automatic conversion from Int to Double, result is 10.0, not 10</span>
<span class="k">val</span> <span class="nv">b</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mi">10</span>

<span class="c1">// Boolean values</span>
<span class="kc">true</span>
<span class="kc">false</span>

<span class="c1">// Boolean operations</span>
<span class="o">!</span><span class="kc">true</span>         <span class="c1">// false</span>
<span class="o">!</span><span class="kc">false</span>        <span class="c1">// true</span>
<span class="kc">true</span> <span class="o">==</span> <span class="kc">false</span> <span class="c1">// false</span>
<span class="mi">10</span> <span class="o">&gt;</span> <span class="mi">5</span>        <span class="c1">// true</span>

<span class="c1">// Math is as per usual</span>
<span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>   <span class="c1">// 2</span>
<span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>   <span class="c1">// 1</span>
<span class="mi">5</span> <span class="o">*</span> <span class="mi">3</span>   <span class="c1">// 15</span>
<span class="mi">6</span> <span class="o">/</span> <span class="mi">2</span>   <span class="c1">// 3</span>
<span class="mi">6</span> <span class="o">/</span> <span class="mi">4</span>   <span class="c1">// 1</span>
<span class="mf">6.0</span> <span class="o">/</span> <span class="mi">4</span> <span class="c1">// 1.5</span>
<span class="mi">6</span> <span class="o">/</span> <span class="mf">4.0</span> <span class="c1">// 1.5</span>


<span class="c1">// Evaluating an expression in the REPL gives you the type and value of the result</span>

<span class="mi">1</span> <span class="o">+</span> <span class="mi">7</span>

<span class="cm">/* The above line results in:

  scala&gt; 1 + 7
  res29: Int = 8

  This means the result of evaluating 1 + 7 is an object of type Int with a
  value of 8

  Note that "res29" is a sequentially generated variable name to store the
  results of the expressions you typed, your output may differ.
*/</span>

<span class="s">"Scala strings are surrounded by double quotes"</span>
<span class="sc">'a'</span> <span class="c1">// A Scala Char</span>
<span class="c1">// 'Single quote strings don't exist' &lt;= This causes an error</span>

<span class="c1">// Strings have the usual Java methods defined on them</span>
<span class="s">"hello world"</span><span class="o">.</span><span class="py">length</span>
<span class="s">"hello world"</span><span class="o">.</span><span class="py">substring</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>
<span class="s">"hello world"</span><span class="o">.</span><span class="py">replace</span><span class="o">(</span><span class="s">"C"</span><span class="o">,</span> <span class="s">"3"</span><span class="o">)</span>

<span class="c1">// They also have some extra Scala methods. See also: scala.collection.immutable.StringOps</span>
<span class="s">"hello world"</span><span class="o">.</span><span class="py">take</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="s">"hello world"</span><span class="o">.</span><span class="py">drop</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>

<span class="c1">// String interpolation: notice the prefix "s"</span>
<span class="k">val</span> <span class="nv">n</span> <span class="k">=</span> <span class="mi">45</span>
<span class="n">s</span><span class="s">"We have $n apples"</span> <span class="c1">// =&gt; "We have 45 apples"</span>

<span class="c1">// Expressions inside interpolated strings are also possible</span>
<span class="k">val</span> <span class="nv">a</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">11</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>
<span class="n">s</span><span class="s">"My second daughter is ${a(0) - a(2)} years old."</span>    <span class="c1">// =&gt; "My second daughter is 5 years old."</span>
<span class="n">s</span><span class="s">"We have double the amount of ${n / 2.0} in apples."</span> <span class="c1">// =&gt; "We have double the amount of 22.5 in apples."</span>
<span class="n">s</span><span class="s">"Power of 2: ${math.pow(2, 2)}"</span>                      <span class="c1">// =&gt; "Power of 2: 4"</span>

<span class="c1">// Formatting with interpolated strings with the prefix "f"</span>
<span class="n">f</span><span class="s">"Power of 5: ${math.pow(5, 2)}%1.0f"</span>         <span class="c1">// "Power of 5: 25"</span>
<span class="n">f</span><span class="s">"Square root of 122: ${math.sqrt(122)}%1.4f"</span> <span class="c1">// "Square root of 122: 11.0454"</span>

<span class="c1">// Raw strings, ignoring special characters.</span>
<span class="n">raw</span><span class="s">"New line feed: \n. Carriage return: \r."</span> <span class="c1">// =&gt; "New line feed: \n. Carriage return: \r."</span>

<span class="c1">// Some characters need to be "escaped", e.g. a double quote inside a string:</span>
<span class="s">"They stood outside the \"Rose and Crown\""</span> <span class="c1">// =&gt; "They stood outside the "Rose and Crown""</span>

<span class="c1">// Triple double-quotes let strings span multiple rows and contain quotes</span>
<span class="k">val</span> <span class="nv">html</span> <span class="k">=</span> <span class="s">"""&lt;form id="daform"&gt;
                &lt;p&gt;Press belo', Joe&lt;/p&gt;
                &lt;input type="submit"&gt;
              &lt;/form&gt;"""</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 2. Functions</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Functions are defined like so:</span>
<span class="c1">//</span>
<span class="c1">//   def functionName(args...): ReturnType = { body... }</span>
<span class="c1">//</span>
<span class="c1">// If you come from more traditional languages, notice the omission of the</span>
<span class="c1">// return keyword. In Scala, the last expression in the function block is the</span>
<span class="c1">// return value.</span>
<span class="k">def</span> <span class="nf">sumOfSquares</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">x2</span> <span class="k">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
  <span class="k">val</span> <span class="nv">y2</span> <span class="k">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span>
  <span class="n">x2</span> <span class="o">+</span> <span class="n">y2</span>
<span class="o">}</span>

<span class="c1">// The { } can be omitted if the function body is a single expression:</span>
<span class="k">def</span> <span class="nf">sumOfSquaresShort</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span>

<span class="c1">// Syntax for calling functions is familiar:</span>
<span class="nf">sumOfSquares</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>  <span class="c1">// =&gt; 25</span>

<span class="c1">// You can use parameters names to specify them in different order</span>
<span class="k">def</span> <span class="nf">subtract</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>

<span class="nf">subtract</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>     <span class="c1">// =&gt; 7</span>
<span class="nf">subtract</span><span class="o">(</span><span class="n">y</span><span class="k">=</span><span class="mi">10</span><span class="o">,</span> <span class="n">x</span><span class="k">=</span><span class="mi">3</span><span class="o">)</span> <span class="c1">// =&gt; -7</span>

<span class="c1">// In most cases (with recursive functions the most notable exception), function</span>
<span class="c1">// return type can be omitted, and the same type inference we saw with variables</span>
<span class="c1">// will work with function return values:</span>
<span class="k">def</span> <span class="nf">sq</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>  <span class="c1">// Compiler can guess return type is Int</span>

<span class="c1">// Functions can have default parameters:</span>
<span class="k">def</span> <span class="nf">addWithDefault</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="nf">addWithDefault</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="c1">// =&gt; 3</span>
<span class="nf">addWithDefault</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>    <span class="c1">// =&gt; 6</span>


<span class="c1">// Anonymous functions look like this:</span>
<span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="c1">// Unlike defs, even the input type of anonymous functions can be omitted if the</span>
<span class="c1">// context makes it clear. Notice the type "Int =&gt; Int" which means a function</span>
<span class="c1">// that takes Int and returns Int.</span>
<span class="k">val</span> <span class="nv">sq</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="c1">// Anonymous functions can be called as usual:</span>
<span class="nf">sq</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>   <span class="c1">// =&gt; 100</span>

<span class="c1">// If each argument in your anonymous function is</span>
<span class="c1">// used only once, Scala gives you an even shorter way to define them. These</span>
<span class="c1">// anonymous functions turn out to be extremely common, as will be obvious in</span>
<span class="c1">// the data structure section.</span>
<span class="k">val</span> <span class="nv">addOne</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="k">_</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">val</span> <span class="nv">weirdSum</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="k">_</span> <span class="o">*</span> <span class="mi">3</span><span class="o">)</span>

<span class="nf">addOne</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>      <span class="c1">// =&gt; 6</span>
<span class="nf">weirdSum</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span> <span class="c1">// =&gt; 16</span>


<span class="c1">// The return keyword exists in Scala, but it only returns from the inner-most</span>
<span class="c1">// def that surrounds it.</span>
<span class="c1">// WARNING: Using return in Scala is error-prone and should be avoided.</span>
<span class="c1">// It has no effect on anonymous functions. For example here you may expect foo(7) should return 17 but it returns 7:</span>
<span class="k">def</span> <span class="nf">foo</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">anonFunc</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">{</span> <span class="n">z</span> <span class="k">=&gt;</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">z</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="o">)</span>
      <span class="k">return</span> <span class="n">z</span> <span class="c1">// This line makes z the return value of foo!</span>
    <span class="k">else</span>
      <span class="n">z</span> <span class="o">+</span> <span class="mi">2</span>    <span class="c1">// This line is the return value of anonFunc</span>
  <span class="o">}</span>
  <span class="nf">anonFunc</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">+</span> <span class="mi">10</span>  <span class="c1">// This line is the return value of foo</span>
<span class="o">}</span>

<span class="nf">foo</span><span class="o">(</span><span class="mi">7</span><span class="o">)</span> <span class="c1">// =&gt; 7</span>

<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 3. Flow Control</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="mi">1</span> <span class="n">to</span> <span class="mi">5</span>
<span class="k">val</span> <span class="nv">r</span> <span class="k">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">5</span>
<span class="nv">r</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>

<span class="n">r</span> <span class="n">foreach</span> <span class="n">println</span>
<span class="c1">// NB: Scala is quite lenient when it comes to dots and brackets - study the</span>
<span class="c1">// rules separately. This helps write DSLs and APIs that read like English</span>

<span class="c1">// Why doesn't `println` need any parameters here?</span>
<span class="c1">// Stay tuned for first-class functions in the Functional Programming section below!</span>
<span class="o">(</span><span class="mi">5</span> <span class="n">to</span> <span class="mi">1</span> <span class="n">by</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="nf">foreach</span> <span class="o">(</span><span class="n">println</span><span class="o">)</span>

<span class="c1">// A while loop</span>
<span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
<span class="nf">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"i "</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">}</span>

<span class="nf">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"i "</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">}</span>   <span class="c1">// Yes, again. What happened? Why?</span>

<span class="n">i</span>    <span class="c1">// Show the value of i. Note that while is a loop in the classical sense -</span>
     <span class="c1">// it executes sequentially while changing the loop variable. while is very</span>
     <span class="c1">// fast, but using the combinators and comprehensions above is easier</span>
     <span class="c1">// to understand and parallelize</span>

<span class="c1">// A do-while loop</span>
<span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">do</span> <span class="o">{</span>
  <span class="nf">println</span><span class="o">(</span><span class="s">"i is still less than 10"</span><span class="o">)</span>
  <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="o">}</span> <span class="nf">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span>

<span class="c1">// Recursion is the idiomatic way of repeating an action in Scala (as in most</span>
<span class="c1">// other functional languages).</span>
<span class="c1">// Recursive functions need an explicit return type, the compiler can't infer it.</span>
<span class="c1">// Here it's Unit, which is analogous to a `void` return type in Java</span>
<span class="k">def</span> <span class="nf">showNumbersInRange</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="nf">print</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
  <span class="nf">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">)</span>
    <span class="nf">showNumbersInRange</span><span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
<span class="o">}</span>
<span class="nf">showNumbersInRange</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">14</span><span class="o">)</span>


<span class="c1">// Conditionals</span>

<span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="mi">10</span>

<span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="nf">println</span><span class="o">(</span><span class="s">"yeah"</span><span class="o">)</span>
<span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">10</span><span class="o">)</span> <span class="nf">println</span><span class="o">(</span><span class="s">"yeah"</span><span class="o">)</span>
<span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">11</span><span class="o">)</span> <span class="nf">println</span><span class="o">(</span><span class="s">"yeah"</span><span class="o">)</span>
<span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">11</span><span class="o">)</span> <span class="nf">println</span><span class="o">(</span><span class="s">"yeah"</span><span class="o">)</span> <span class="k">else</span> <span class="nf">println</span><span class="o">(</span><span class="s">"nay"</span><span class="o">)</span>

<span class="nf">println</span><span class="o">(</span><span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">10</span><span class="o">)</span> <span class="s">"yeah"</span> <span class="k">else</span> <span class="s">"nope"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">text</span> <span class="k">=</span> <span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">10</span><span class="o">)</span> <span class="s">"yeah"</span> <span class="k">else</span> <span class="s">"nope"</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 4. Data Structures</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="k">val</span> <span class="nv">a</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">13</span><span class="o">)</span>
<span class="nf">a</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>     <span class="c1">// Int = 1</span>
<span class="nf">a</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>     <span class="c1">// Int = 5</span>
<span class="nf">a</span><span class="o">(</span><span class="mi">21</span><span class="o">)</span>    <span class="c1">// Throws an exception</span>

<span class="k">val</span> <span class="nv">m</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"fork"</span> <span class="o">-&gt;</span> <span class="s">"tenedor"</span><span class="o">,</span> <span class="s">"spoon"</span> <span class="o">-&gt;</span> <span class="s">"cuchara"</span><span class="o">,</span> <span class="s">"knife"</span> <span class="o">-&gt;</span> <span class="s">"cuchillo"</span><span class="o">)</span>
<span class="nf">m</span><span class="o">(</span><span class="s">"fork"</span><span class="o">)</span>         <span class="c1">// java.lang.String = tenedor</span>
<span class="nf">m</span><span class="o">(</span><span class="s">"spoon"</span><span class="o">)</span>        <span class="c1">// java.lang.String = cuchara</span>
<span class="nf">m</span><span class="o">(</span><span class="s">"bottle"</span><span class="o">)</span>       <span class="c1">// Throws an exception</span>

<span class="k">val</span> <span class="nv">safeM</span> <span class="k">=</span> <span class="nv">m</span><span class="o">.</span><span class="py">withDefaultValue</span><span class="o">(</span><span class="s">"no lo se"</span><span class="o">)</span>
<span class="nf">safeM</span><span class="o">(</span><span class="s">"bottle"</span><span class="o">)</span>   <span class="c1">// java.lang.String = no lo se</span>

<span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>
<span class="nf">s</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>      <span class="c1">// Boolean = false</span>
<span class="nf">s</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>      <span class="c1">// Boolean = true</span>

<span class="cm">/* Look up the documentation of map here -
 * https://www.scala-lang.org/api/current/scala/collection/immutable/Map.html
 * and make sure you can read it
 */</span>


<span class="c1">// Tuples</span>

<span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

<span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

<span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="s">"three"</span><span class="o">)</span>

<span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="s">"three"</span><span class="o">)</span>

<span class="c1">// Why have this?</span>
<span class="k">val</span> <span class="nv">divideInts</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="o">%</span> <span class="n">y</span><span class="o">)</span>

<span class="c1">// The function divideInts gives you the result and the remainder</span>
<span class="nf">divideInts</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>    <span class="c1">// (Int, Int) = (3,1)</span>

<span class="c1">// To access the elements of a tuple, use _._n where n is the 1-based index of</span>
<span class="c1">// the element</span>
<span class="k">val</span> <span class="nv">d</span> <span class="k">=</span> <span class="nf">divideInts</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>    <span class="c1">// (Int, Int) = (3,1)</span>

<span class="nv">d</span><span class="o">.</span><span class="py">_1</span>    <span class="c1">// Int = 3</span>
<span class="nv">d</span><span class="o">.</span><span class="py">_2</span>    <span class="c1">// Int = 1</span>

<span class="c1">// Alternatively you can do multiple-variable assignment to tuple, which is more</span>
<span class="c1">// convenient and readable in many cases</span>
<span class="nf">val</span> <span class="o">(</span><span class="n">div</span><span class="o">,</span> <span class="n">mod</span><span class="o">)</span> <span class="k">=</span> <span class="nf">divideInts</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">div</span>     <span class="c1">// Int = 3</span>
<span class="n">mod</span>     <span class="c1">// Int = 1</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 5. Object Oriented Programming</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="cm">/*
  Aside: Everything we've done so far in this tutorial has been simple
  expressions (values, functions, etc). These expressions are fine to type into
  the command-line interpreter for quick tests, but they cannot exist by
  themselves in a Scala file. For example, you cannot have just "val x = 5" in
  a Scala file. Instead, the only top-level constructs allowed in Scala are:

  - objects
  - classes
  - case classes
  - traits

  And now we will explain what these are.
*/</span>

<span class="c1">// classes are similar to classes in other languages. Constructor arguments are</span>
<span class="c1">// declared after the class name, and initialization is done in the class body.</span>
<span class="k">class</span> <span class="nc">Dog</span><span class="o">(</span><span class="n">br</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// Constructor code here</span>
  <span class="k">var</span> <span class="n">breed</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">br</span>

  <span class="c1">// Define a method called bark, returning a String</span>
  <span class="k">def</span> <span class="nf">bark</span> <span class="k">=</span> <span class="s">"Woof, woof!"</span>

  <span class="c1">// Values and methods are assumed public. "protected" and "private" keywords</span>
  <span class="c1">// are also available.</span>
  <span class="k">private</span> <span class="k">def</span> <span class="nf">sleep</span><span class="o">(</span><span class="n">hours</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span>
    <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"I'm sleeping for $hours hours"</span><span class="o">)</span>

  <span class="c1">// Abstract methods are simply methods with no body. If we uncomment the</span>
  <span class="c1">// def line below, class Dog would need to be declared abstract like so:</span>
  <span class="c1">//   abstract class Dog(...) { ... }</span>
  <span class="c1">// def chaseAfter(what: String): String</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">mydog</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">(</span><span class="s">"greyhound"</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">mydog</span><span class="o">.</span><span class="py">breed</span><span class="o">)</span> <span class="c1">// =&gt; "greyhound"</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">mydog</span><span class="o">.</span><span class="py">bark</span><span class="o">)</span>  <span class="c1">// =&gt; "Woof, woof!"</span>


<span class="c1">// The "object" keyword creates a type AND a singleton instance of it. It is</span>
<span class="c1">// common for Scala classes to have a "companion object", where the per-instance</span>
<span class="c1">// behavior is captured in the classes themselves, but behavior related to all</span>
<span class="c1">// instance of that class go in objects. The difference is similar to class</span>
<span class="c1">// methods vs static methods in other languages. Note that objects and classes</span>
<span class="c1">// can have the same name.</span>
<span class="k">object</span> <span class="nc">Dog</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">allKnownBreeds</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"pitbull"</span><span class="o">,</span> <span class="s">"shepherd"</span><span class="o">,</span> <span class="s">"retriever"</span><span class="o">)</span>
  <span class="k">def</span> <span class="nf">createDog</span><span class="o">(</span><span class="n">breed</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">(</span><span class="n">breed</span><span class="o">)</span>
<span class="o">}</span>


<span class="c1">// Case classes are classes that have extra functionality built in. A common</span>
<span class="c1">// question for Scala beginners is when to use classes and when to use case</span>
<span class="c1">// classes. The line is quite fuzzy, but in general, classes tend to focus on</span>
<span class="c1">// encapsulation, polymorphism, and behavior. The values in these classes tend</span>
<span class="c1">// to be private, and only methods are exposed. The primary purpose of case</span>
<span class="c1">// classes is to hold immutable data. They often have few methods, and the</span>
<span class="c1">// methods rarely have side-effects.</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">phoneNumber</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="c1">// Create a new instance. Note cases classes don't need "new"</span>
<span class="k">val</span> <span class="nv">george</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"George"</span><span class="o">,</span> <span class="s">"1234"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">kate</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Kate"</span><span class="o">,</span> <span class="s">"4567"</span><span class="o">)</span>

<span class="c1">// With case classes, you get a few perks for free, like getters:</span>
<span class="nv">george</span><span class="o">.</span><span class="py">phoneNumber</span>  <span class="c1">// =&gt; "1234"</span>

<span class="c1">// Per field equality (no need to override .equals)</span>
<span class="nc">Person</span><span class="o">(</span><span class="s">"George"</span><span class="o">,</span> <span class="s">"1234"</span><span class="o">)</span> <span class="o">==</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Kate"</span><span class="o">,</span> <span class="s">"1236"</span><span class="o">)</span>  <span class="c1">// =&gt; false</span>

<span class="c1">// Easy way to copy</span>
<span class="c1">// otherGeorge == Person("George", "9876")</span>
<span class="k">val</span> <span class="nv">otherGeorge</span> <span class="k">=</span> <span class="nv">george</span><span class="o">.</span><span class="py">copy</span><span class="o">(</span><span class="n">phoneNumber</span> <span class="k">=</span> <span class="s">"9876"</span><span class="o">)</span>

<span class="c1">// And many others. Case classes also get pattern matching for free, see below.</span>

<span class="c1">// Traits</span>
<span class="c1">// Similar to Java interfaces, traits define an object type and method</span>
<span class="c1">// signatures. Scala allows partial implementation of those methods.</span>
<span class="c1">// Constructor parameters are not allowed. Traits can inherit from other</span>
<span class="c1">// traits or classes without parameters.</span>

<span class="k">trait</span> <span class="nc">Dog</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">breed</span><span class="k">:</span> <span class="kt">String</span>
    <span class="k">def</span> <span class="nf">color</span><span class="k">:</span> <span class="kt">String</span>
    <span class="k">def</span> <span class="nf">bark</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
    <span class="k">def</span> <span class="nf">bite</span><span class="k">:</span> <span class="kt">Boolean</span>
<span class="o">}</span>
<span class="k">class</span> <span class="nc">SaintBernard</span> <span class="k">extends</span> <span class="nc">Dog</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">breed</span> <span class="k">=</span> <span class="s">"Saint Bernard"</span>
    <span class="k">val</span> <span class="nv">color</span> <span class="k">=</span> <span class="s">"brown"</span>
    <span class="k">def</span> <span class="nf">bite</span> <span class="k">=</span> <span class="kc">false</span>
<span class="o">}</span>  

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">b</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">SaintBernard</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">SaintBernard</span> <span class="o">=</span> <span class="nc">SaintBernard</span><span class="k">@</span><span class="mi">3</span><span class="n">e57cd70</span>  
<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">b</span><span class="o">.</span><span class="py">breed</span>  
<span class="n">res1</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Saint</span> <span class="nc">Bernard</span>  
<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">b</span><span class="o">.</span><span class="py">bark</span>  
<span class="n">res2</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>  
<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">b</span><span class="o">.</span><span class="py">bite</span>  
<span class="n">res3</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>  

<span class="c1">// A trait can also be used as Mixin. The class "extends" the first trait,</span>
<span class="c1">// but the keyword "with" can add additional traits.</span>

<span class="k">trait</span> <span class="nc">Bark</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">bark</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"Woof"</span>
<span class="o">}</span>
<span class="k">trait</span> <span class="nc">Dog</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">breed</span><span class="k">:</span> <span class="kt">String</span>
    <span class="k">def</span> <span class="nf">color</span><span class="k">:</span> <span class="kt">String</span>
<span class="o">}</span>
<span class="k">class</span> <span class="nc">SaintBernard</span> <span class="k">extends</span> <span class="nc">Dog</span> <span class="k">with</span> <span class="nc">Bark</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">breed</span> <span class="k">=</span> <span class="s">"Saint Bernard"</span>
    <span class="k">val</span> <span class="nv">color</span> <span class="k">=</span> <span class="s">"brown"</span>
<span class="o">}</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">b</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">SaintBernard</span>
<span class="n">b</span><span class="k">:</span> <span class="kt">SaintBernard</span> <span class="o">=</span> <span class="nc">SaintBernard</span><span class="k">@</span><span class="mi">7</span><span class="n">b69c6ba</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">b</span><span class="o">.</span><span class="py">bark</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Woof</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 6. Pattern Matching</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Pattern matching is a powerful and commonly used feature in Scala. Here's how</span>
<span class="c1">// you pattern match a case class. NB: Unlike other languages, Scala cases do</span>
<span class="c1">// not need breaks, fall-through does not happen.</span>

<span class="k">def</span> <span class="nf">matchPerson</span><span class="o">(</span><span class="n">person</span><span class="k">:</span> <span class="kt">Person</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">person</span> <span class="k">match</span> <span class="o">{</span>
  <span class="c1">// Then you specify the patterns:</span>
  <span class="k">case</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"George"</span><span class="o">,</span> <span class="n">number</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"We found George! His number is "</span> <span class="o">+</span> <span class="n">number</span>
  <span class="k">case</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Kate"</span><span class="o">,</span> <span class="n">number</span><span class="o">)</span>   <span class="k">=&gt;</span> <span class="s">"We found Kate! Her number is "</span> <span class="o">+</span> <span class="n">number</span>
  <span class="k">case</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">number</span><span class="o">)</span>     <span class="k">=&gt;</span> <span class="s">"We matched someone : "</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">", phone : "</span> <span class="o">+</span> <span class="n">number</span>
<span class="o">}</span>

<span class="c1">// Regular expressions are also built in.</span>
<span class="c1">// Create a regex with the `r` method on a string:</span>
<span class="k">val</span> <span class="nv">email</span> <span class="k">=</span> <span class="s">"(.*)@(.*)"</span><span class="o">.</span><span class="py">r</span>

<span class="c1">// Pattern matching might look familiar to the switch statements in the C family</span>
<span class="c1">// of languages, but this is much more powerful. In Scala, you can match much</span>
<span class="c1">// more:</span>
<span class="k">def</span> <span class="nf">matchEverything</span><span class="o">(</span><span class="n">obj</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">obj</span> <span class="k">match</span> <span class="o">{</span>
  <span class="c1">// You can match values:</span>
  <span class="k">case</span> <span class="s">"Hello world"</span> <span class="k">=&gt;</span> <span class="s">"Got the string Hello world"</span>

  <span class="c1">// You can match by type:</span>
  <span class="k">case</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=&gt;</span> <span class="s">"Got a Double: "</span> <span class="o">+</span> <span class="n">x</span>

  <span class="c1">// You can specify conditions:</span>
  <span class="k">case</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span> <span class="kt">if</span> <span class="kt">x</span> <span class="kt">&gt;</span> <span class="err">10000</span> <span class="o">=&gt;</span> <span class="s">"Got a pretty big number!"</span>

  <span class="c1">// You can match case classes as before:</span>
  <span class="k">case</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">number</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"Got contact info for $name!"</span>

  <span class="c1">// You can match regular expressions:</span>
  <span class="k">case</span> <span class="nf">email</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">domain</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"Got email address $name@$domain"</span>

  <span class="c1">// You can match tuples:</span>
  <span class="nf">case</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">c</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"Got a tuple: $a, $b, $c"</span>

  <span class="c1">// You can match data structures:</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"Got a list with three elements and starts with 1: 1, $b, $c"</span>

  <span class="c1">// You can nest patterns:</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="s">"YAY"</span><span class="o">)))</span> <span class="k">=&gt;</span> <span class="s">"Got a list of list of tuple"</span>

  <span class="c1">// Match any case (default) if all previous haven't matched</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"Got unknown object"</span>
<span class="o">}</span>

<span class="c1">// In fact, you can pattern match any object with an "unapply" method. This</span>
<span class="c1">// feature is so powerful that Scala lets you define whole functions as</span>
<span class="c1">// patterns:</span>
<span class="k">val</span> <span class="nv">patternFunc</span><span class="k">:</span> <span class="kt">Person</span> <span class="o">=&gt;</span> <span class="nc">String</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"George"</span><span class="o">,</span> <span class="n">number</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"George's number: $number"</span>
  <span class="k">case</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">number</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"Random person's number: $number"</span>
<span class="o">}</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 7. Functional Programming</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Scala allows methods and functions to return, or take as parameters, other</span>
<span class="c1">// functions or methods.</span>

<span class="k">val</span> <span class="nv">add10</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="k">_</span> <span class="o">+</span> <span class="mi">10</span> <span class="c1">// A function taking an Int and returning an Int</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="n">map</span> <span class="n">add10</span> <span class="c1">// List(11, 12, 13) - add10 is applied to each element</span>

<span class="c1">// Anonymous functions can be used instead of named functions:</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">10</span><span class="o">)</span>

<span class="c1">// And the underscore symbol, can be used if there is just one argument to the</span>
<span class="c1">// anonymous function. It gets bound as the variable</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">10</span><span class="o">)</span>

<span class="c1">// If the anonymous block AND the function you are applying both take one</span>
<span class="c1">// argument, you can even omit the underscore</span>
<span class="nc">List</span><span class="o">(</span><span class="s">"Dom"</span><span class="o">,</span> <span class="s">"Bob"</span><span class="o">,</span> <span class="s">"Natalia"</span><span class="o">)</span> <span class="n">foreach</span> <span class="n">println</span>


<span class="c1">// Combinators</span>
<span class="c1">// Using `s` from above:</span>
<span class="c1">// val s = Set(1, 3, 7)</span>

<span class="nv">s</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">sq</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">sSquared</span> <span class="k">=</span> <span class="nv">s</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">sq</span><span class="o">)</span>

<span class="nv">sSquared</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="k">_</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span>

<span class="nv">sSquared</span><span class="o">.</span><span class="py">reduce</span> <span class="o">(</span><span class="k">_</span><span class="o">+</span><span class="k">_</span><span class="o">)</span>

<span class="c1">// The filter function takes a predicate (a function from A -&gt; Boolean) and</span>
<span class="c1">// selects all elements which satisfy the predicate</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="nf">filter</span> <span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="c1">// List(3)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(</span>
  <span class="nc">Person</span><span class="o">(</span><span class="n">name</span> <span class="k">=</span> <span class="s">"Dom"</span><span class="o">,</span> <span class="n">age</span> <span class="k">=</span> <span class="mi">23</span><span class="o">),</span>
  <span class="nc">Person</span><span class="o">(</span><span class="n">name</span> <span class="k">=</span> <span class="s">"Bob"</span><span class="o">,</span> <span class="n">age</span> <span class="k">=</span> <span class="mi">30</span><span class="o">)</span>
<span class="o">).</span><span class="py">filter</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">age</span> <span class="o">&gt;</span> <span class="mi">25</span><span class="o">)</span> <span class="c1">// List(Person("Bob", 30))</span>


<span class="c1">// Certain collections (such as List) in Scala have a `foreach` method,</span>
<span class="c1">// which takes as an argument a type returning Unit - that is, a void method</span>
<span class="k">val</span> <span class="nv">aListOfNumbers</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">100</span><span class="o">)</span>
<span class="n">aListOfNumbers</span> <span class="nf">foreach</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
<span class="n">aListOfNumbers</span> <span class="n">foreach</span> <span class="n">println</span>

<span class="c1">// For comprehensions</span>

<span class="k">for</span> <span class="o">{</span> <span class="n">n</span> <span class="k">&lt;-</span> <span class="n">s</span> <span class="o">}</span> <span class="k">yield</span> <span class="nf">sq</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">nSquared2</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span> <span class="n">n</span> <span class="k">&lt;-</span> <span class="n">s</span> <span class="o">}</span> <span class="k">yield</span> <span class="nf">sq</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>

<span class="k">for</span> <span class="o">{</span> <span class="n">n</span> <span class="k">&lt;-</span> <span class="n">nSquared2</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">}</span> <span class="k">yield</span> <span class="n">n</span>

<span class="k">for</span> <span class="o">{</span> <span class="n">n</span> <span class="k">&lt;-</span> <span class="n">s</span><span class="o">;</span> <span class="n">nSquared</span> <span class="k">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span> <span class="k">if</span> <span class="n">nSquared</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">}</span> <span class="k">yield</span> <span class="n">nSquared</span>

<span class="cm">/* NB Those were not for loops. The semantics of a for loop is 'repeat', whereas
   a for-comprehension defines a relationship between two sets of data. */</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 8. Implicits</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="cm">/* WARNING WARNING: Implicits are a set of powerful features of Scala, and
 * therefore it is easy to abuse them. Beginners to Scala should resist the
 * temptation to use them until they understand not only how they work, but also
 * best practices around them. We only include this section in the tutorial
 * because they are so commonplace in Scala libraries that it is impossible to
 * do anything meaningful without using a library that has implicits. This is
 * meant for you to understand and work with implicits, not declare your own.
 */</span>

<span class="c1">// Any value (vals, functions, objects, etc) can be declared to be implicit by</span>
<span class="c1">// using the, you guessed it, "implicit" keyword. Note we are using the Dog</span>
<span class="c1">// class from section 5 in these examples.</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="nv">myImplicitInt</span> <span class="k">=</span> <span class="mi">100</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="nf">myImplicitFunction</span><span class="o">(</span><span class="n">breed</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">(</span><span class="s">"Golden "</span> <span class="o">+</span> <span class="n">breed</span><span class="o">)</span>

<span class="c1">// By itself, implicit keyword doesn't change the behavior of the value, so</span>
<span class="c1">// above values can be used as usual.</span>
<span class="n">myImplicitInt</span> <span class="o">+</span> <span class="mi">2</span>                   <span class="c1">// =&gt; 102</span>
<span class="nf">myImplicitFunction</span><span class="o">(</span><span class="s">"Pitbull"</span><span class="o">).</span><span class="py">breed</span> <span class="c1">// =&gt; "Golden Pitbull"</span>

<span class="c1">// The difference is that these values are now eligible to be used when another</span>
<span class="c1">// piece of code "needs" an implicit value. One such situation is implicit</span>
<span class="c1">// function arguments:</span>
<span class="k">def</span> <span class="nf">sendGreetings</span><span class="o">(</span><span class="n">toWhom</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">howMany</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span>
  <span class="n">s</span><span class="s">"Hello $toWhom, $howMany blessings to you and yours!"</span>

<span class="c1">// If we supply a value for "howMany", the function behaves as usual</span>
<span class="nf">sendGreetings</span><span class="o">(</span><span class="s">"John"</span><span class="o">)(</span><span class="mi">1000</span><span class="o">)</span>  <span class="c1">// =&gt; "Hello John, 1000 blessings to you and yours!"</span>

<span class="c1">// But if we omit the implicit parameter, an implicit value of the same type is</span>
<span class="c1">// used, in this case, "myImplicitInt":</span>
<span class="nf">sendGreetings</span><span class="o">(</span><span class="s">"Jane"</span><span class="o">)</span>  <span class="c1">// =&gt; "Hello Jane, 100 blessings to you and yours!"</span>

<span class="c1">// Implicit function parameters enable us to simulate type classes in other</span>
<span class="c1">// functional languages. It is so often used that it gets its own shorthand. The</span>
<span class="c1">// following two lines mean the same thing:</span>
<span class="c1">// def foo[T](implicit c: C[T]) = ...</span>
<span class="c1">// def foo[T : C] = ...</span>


<span class="c1">// Another situation in which the compiler looks for an implicit is if you have</span>
<span class="c1">//   obj.method(...)</span>
<span class="c1">// but "obj" doesn't have "method" as a method. In this case, if there is an</span>
<span class="c1">// implicit conversion of type A =&gt; B, where A is the type of obj, and B has a</span>
<span class="c1">// method called "method", that conversion is applied. So having</span>
<span class="c1">// myImplicitFunction above in scope, we can say:</span>
<span class="s">"Retriever"</span><span class="o">.</span><span class="py">breed</span> <span class="c1">// =&gt; "Golden Retriever"</span>
<span class="s">"Sheperd"</span><span class="o">.</span><span class="py">bark</span>    <span class="c1">// =&gt; "Woof, woof!"</span>

<span class="c1">// Here the String is first converted to Dog using our function above, and then</span>
<span class="c1">// the appropriate method is called. This is an extremely powerful feature, but</span>
<span class="c1">// again, it is not to be used lightly. In fact, when you defined the implicit</span>
<span class="c1">// function above, your compiler should have given you a warning, that you</span>
<span class="c1">// shouldn't do this unless you really know what you're doing.</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 9. Misc</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Importing things</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable.List</span>

<span class="c1">// Import all "sub packages"</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable._</span>

<span class="c1">// Import multiple classes in one statement</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable.</span><span class="o">{</span><span class="nc">List</span><span class="o">,</span> <span class="nc">Map</span><span class="o">}</span>

<span class="c1">// Rename an import using '=&gt;'</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable.</span><span class="o">{</span><span class="nc">List</span> <span class="k">=&gt;</span> <span class="nc">ImmutableList</span><span class="o">}</span>

<span class="c1">// Import all classes, except some. The following excludes Map and Set:</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable.</span><span class="o">{</span><span class="nc">Map</span> <span class="k">=&gt;</span> <span class="k">_</span><span class="o">,</span> <span class="nc">Set</span> <span class="k">=&gt;</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">}</span>

<span class="c1">// Java classes can also be imported. Scala syntax can be used</span>
<span class="k">import</span> <span class="nn">java.swing.</span><span class="o">{</span><span class="nc">JFrame</span><span class="o">,</span> <span class="nc">JWindow</span><span class="o">}</span>

<span class="c1">// Your program's entry point is defined in a scala file using an object, with a</span>
<span class="c1">// single method, main:</span>
<span class="k">object</span> <span class="nc">Application</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="c1">// stuff goes here.</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Files can contain multiple classes and objects. Compile with scalac</span>




<span class="c1">// Input and output</span>

<span class="c1">// To read a file line by line</span>
<span class="k">import</span> <span class="nn">scala.io.Source</span>
<span class="nf">for</span><span class="o">(</span><span class="n">line</span> <span class="k">&lt;-</span> <span class="nv">Source</span><span class="o">.</span><span class="py">fromFile</span><span class="o">(</span><span class="s">"myfile.txt"</span><span class="o">).</span><span class="py">getLines</span><span class="o">())</span>
  <span class="nf">println</span><span class="o">(</span><span class="n">line</span><span class="o">)</span>

<span class="c1">// To write a file use Java's PrintWriter</span>
<span class="k">val</span> <span class="nv">writer</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PrintWriter</span><span class="o">(</span><span class="s">"myfile.txt"</span><span class="o">)</span>
<span class="nv">writer</span><span class="o">.</span><span class="py">write</span><span class="o">(</span><span class="s">"Writing line for line"</span> <span class="o">+</span> <span class="nv">util</span><span class="o">.</span><span class="py">Properties</span><span class="o">.</span><span class="py">lineSeparator</span><span class="o">)</span>
<span class="nv">writer</span><span class="o">.</span><span class="py">write</span><span class="o">(</span><span class="s">"Another line here"</span> <span class="o">+</span> <span class="nv">util</span><span class="o">.</span><span class="py">Properties</span><span class="o">.</span><span class="py">lineSeparator</span><span class="o">)</span>
<span class="nv">writer</span><span class="o">.</span><span class="py">close</span><span class="o">()</span>
</code></pre></div>
<h2>Further resources</h2>

<ul>
<li><a href="http://horstmann.com/scala/">Scala for the impatient</a></li>
<li><a href="http://twitter.github.io/scala_school/">Twitter Scala school</a></li>
<li><a href="http://docs.scala-lang.org/">The scala documentation</a></li>
<li><a href="http://scalatutorials.com/tour/">Try Scala in your browser</a></li>
<li>Join the <a href="https://groups.google.com/forum/#!forum/scala-user">Scala user group</a></li>
</ul>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/scala.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by George Petrov, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/scala.html.markdown">29 contributor(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://github.com/petrovg">George Petrov</a>,
        <a href="http://dbousamra.github.com">Dominic Bou-Samra</a>,
        <a href="http://geoffliu.me">Geoff Liu</a>,
        <a href="http://reference-error.org">Ha-Duong Nguyen</a>
    </p>

    <p>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
