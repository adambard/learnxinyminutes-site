<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="en-us" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="en-us" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="en-us" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="en-us" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="en-us">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Common Lisp in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/common-lisp/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fcommon-lisp%2F&text=Learn+X+in+Y+minutes%2C+where+X%3DCommon+Lisp">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="/">Learn X in Y minutes</a></h1>
  <h2>Where X=Common Lisp</h2>
    <p class="filelink">
    Get the code:
    <a href="/docs/files/commonlisp.lisp">commonlisp.lisp</a>
    </p>
  <div id="doc">
    <p>Common Lisp is a general-purpose, multi-paradigm programming language suited for a wide variety of
industry applications. It is frequently referred to as a programmable programming language.</p>

<p>The classic starting point is <a href="http://www.gigamonkeys.com/book/">Practical Common Lisp</a>. Another
popular and recent book is <a href="http://landoflisp.com/">Land of Lisp</a>. A new book about best practices,
<a href="http://weitz.de/cl-recipes/">Common Lisp Recipes</a>, was recently published.</p>
<div class="highlight"><pre><span></span><span class="c1">;;;-----------------------------------------------------------------------------</span>
<span class="c1">;;; 0. Syntax</span>
<span class="c1">;;;-----------------------------------------------------------------------------</span>

<span class="c1">;;; General form</span>

<span class="c1">;;; CL has two fundamental pieces of syntax: ATOM and S-EXPRESSION.</span>
<span class="c1">;;; Typically, grouped S-expressions are called `forms`.</span>

<span class="mi">10</span><span class="w">            </span><span class="c1">; an atom; it evaluates to itself</span>
<span class="ss">:thing</span><span class="w">        </span><span class="c1">; another atom; evaluating to the symbol :thing</span>
<span class="no">t</span><span class="w">             </span><span class="c1">; another atom, denoting true</span>
<span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">   </span><span class="c1">; an s-expression</span>
<span class="o">&#39;</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="ss">:foo</span><span class="w"> </span><span class="no">t</span><span class="p">)</span><span class="w">   </span><span class="c1">; another s-expression</span>


<span class="c1">;;; Comments</span>

<span class="c1">;;; Single-line comments start with a semicolon; use four for file-level</span>
<span class="c1">;;; comments, three for section descriptions, two inside definitions, and one</span>
<span class="c1">;;; for single lines. For example,</span>

<span class="c1">;;;; life.lisp</span>

<span class="c1">;;; Foo bar baz, because quu quux. Optimized for maximum krakaboom and umph.</span>
<span class="c1">;;; Needed by the function LINULUKO.</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">meaning</span><span class="w"> </span><span class="p">(</span><span class="nv">life</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Return the computed meaning of LIFE&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nv">meh</span><span class="w"> </span><span class="s">&quot;abc&quot;</span><span class="p">))</span>
<span class="w">    </span><span class="c1">;; Invoke krakaboom</span>
<span class="w">    </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="ss">:for</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="ss">:across</span><span class="w"> </span><span class="nv">meh</span>
<span class="w">       </span><span class="ss">:collect</span><span class="w"> </span><span class="nv">x</span><span class="p">)))</span><span class="w">                    </span><span class="c1">; store values into x, then return it</span>

<span class="c1">;;; Block comments, on the other hand, allow for free-form comments. They are</span>
<span class="c1">;;; delimited with #| and |#</span>

<span class="cm">#| This is a block comment which</span>
<span class="cm">   can span multiple lines and</span>
<span class="cm">    #|</span>
<span class="cm">       they can be nested!</span>
<span class="cm">    |#</span>
<span class="cm">|#</span>


<span class="c1">;;; Environment</span>

<span class="c1">;;; A variety of implementations exist; most are standards-conformant. SBCL</span>
<span class="c1">;;; is a good starting point. Third party libraries can be easily installed with</span>
<span class="c1">;;; Quicklisp</span>

<span class="c1">;;; CL is usually developed with a text editor and a Read Eval Print</span>
<span class="c1">;;; Loop (REPL) running at the same time. The REPL allows for interactive</span>
<span class="c1">;;; exploration of the program while it is running &quot;live&quot;.</span>


<span class="c1">;;;-----------------------------------------------------------------------------</span>
<span class="c1">;;; 1. Primitive datatypes and operators</span>
<span class="c1">;;;-----------------------------------------------------------------------------</span>

<span class="c1">;;; Symbols</span>

<span class="ss">&#39;foo</span><span class="w"> </span><span class="c1">; =&gt; FOO  Notice that the symbol is upper-cased automatically.</span>

<span class="c1">;;; INTERN manually creates a symbol from a string.</span>

<span class="p">(</span><span class="nb">intern</span><span class="w"> </span><span class="s">&quot;AAAA&quot;</span><span class="p">)</span><span class="w">        </span><span class="c1">; =&gt; AAAA</span>
<span class="p">(</span><span class="nb">intern</span><span class="w"> </span><span class="s">&quot;aaa&quot;</span><span class="p">)</span><span class="w">         </span><span class="c1">; =&gt; |aaa|</span>

<span class="c1">;;; Numbers</span>

<span class="mi">9999999999999999999999</span><span class="w"> </span><span class="c1">; integers</span>
<span class="mb">#b111</span><span class="w">                  </span><span class="c1">; binary =&gt; 7</span>
<span class="mo">#o111</span><span class="w">                  </span><span class="c1">; octal =&gt; 73</span>
<span class="mh">#x111</span><span class="w">                  </span><span class="c1">; hexadecimal =&gt; 273</span>
<span class="mf">3.14159s0</span><span class="w">              </span><span class="c1">; single</span>
<span class="mf">3.14159d0</span><span class="w">              </span><span class="c1">; double</span>
<span class="m">1/2</span><span class="w">                    </span><span class="c1">; ratios</span>
<span class="m">#C</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">                </span><span class="c1">; complex numbers</span>

<span class="c1">;;; Function application are written as (f x y z ...) where f is a function and</span>
<span class="c1">;;; x, y, z, ... are the arguments.</span>

<span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">                </span><span class="c1">; =&gt; 3</span>

<span class="c1">;;; If you want to create literal data, use QUOTE to prevent it from being</span>
<span class="c1">;;; evaluated</span>

<span class="p">(</span><span class="k">quote</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">        </span><span class="c1">; =&gt; (+ 1 2)</span>
<span class="p">(</span><span class="k">quote</span><span class="w"> </span><span class="nv">a</span><span class="p">)</span><span class="w">              </span><span class="c1">; =&gt; A</span>

<span class="c1">;;; The shorthand for QUOTE is &#39;</span>

<span class="o">&#39;</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">               </span><span class="c1">; =&gt; (+ 1 2)</span>
<span class="ss">&#39;a</span><span class="w">                     </span><span class="c1">; =&gt; A</span>

<span class="c1">;;; Basic arithmetic operations</span>

<span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">                </span><span class="c1">; =&gt; 2</span>
<span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">                </span><span class="c1">; =&gt; 7</span>
<span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">               </span><span class="c1">; =&gt; 20</span>
<span class="p">(</span><span class="nb">expt</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">             </span><span class="c1">; =&gt; 8</span>
<span class="p">(</span><span class="nb">mod</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">              </span><span class="c1">; =&gt; 1</span>
<span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">35</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">               </span><span class="c1">; =&gt; 7</span>
<span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">                </span><span class="c1">; =&gt; 1/3</span>
<span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="m">#C</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="m">#C</span><span class="p">(</span><span class="mi">6</span><span class="w"> </span><span class="mi">-4</span><span class="p">))</span><span class="w">   </span><span class="c1">; =&gt; #C(7 -2)</span>

<span class="c1">;;; Booleans</span>

<span class="no">t</span><span class="w">                      </span><span class="c1">; true; any non-NIL value is true</span>
<span class="no">nil</span><span class="w">                    </span><span class="c1">; false; also, the empty list: ()</span>
<span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="no">nil</span><span class="p">)</span><span class="w">              </span><span class="c1">; =&gt; T</span>
<span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="no">t</span><span class="p">)</span><span class="w">              </span><span class="c1">; =&gt; T</span>
<span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="no">nil</span><span class="p">)</span><span class="w">             </span><span class="c1">; =&gt; 0</span>

<span class="c1">;;; Characters</span>

<span class="sc">#\A</span><span class="w">                    </span><span class="c1">; =&gt; #\A</span>
<span class="sc">#\λ</span><span class="w">                    </span><span class="c1">; =&gt; #\GREEK_SMALL_LETTER_LAMDA</span>
<span class="sc">#\u03BB</span><span class="w">                </span><span class="c1">; =&gt; #\GREEK_SMALL_LETTER_LAMDA</span>

<span class="c1">;;; Strings are fixed-length arrays of characters</span>

<span class="s">&quot;Hello, world!&quot;</span>
<span class="s">&quot;Benjamin \&quot;Bugsy\&quot; Siegel&quot;</span><span class="w">   </span><span class="c1">; backslash is an escaping character</span>

<span class="c1">;;; Strings can be concatenated</span>

<span class="p">(</span><span class="nb">concatenate</span><span class="w"> </span><span class="ss">&#39;string</span><span class="w"> </span><span class="s">&quot;Hello, &quot;</span><span class="w"> </span><span class="s">&quot;world!&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; &quot;Hello, world!&quot;</span>

<span class="c1">;;; A string can be treated like a sequence of characters</span>

<span class="p">(</span><span class="nb">elt</span><span class="w"> </span><span class="s">&quot;Apple&quot;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; #\A</span>

<span class="c1">;;; FORMAT is used to create formatted output, which ranges from simple string</span>
<span class="c1">;;; interpolation to loops and conditionals. The first argument to FORMAT</span>
<span class="c1">;;; determines where will the formatted string go. If it is NIL, FORMAT</span>
<span class="c1">;;; simply returns the formatted string as a value; if it is T, FORMAT outputs</span>
<span class="c1">;;; to the standard output, usually the screen, then it returns NIL.</span>

<span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">nil</span><span class="w"> </span><span class="s">&quot;~A, ~A!&quot;</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span><span class="w"> </span><span class="s">&quot;world&quot;</span><span class="p">)</span><span class="w">   </span><span class="c1">; =&gt; &quot;Hello, world!&quot;</span>
<span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="s">&quot;~A, ~A!&quot;</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span><span class="w"> </span><span class="s">&quot;world&quot;</span><span class="p">)</span><span class="w">     </span><span class="c1">; =&gt; NIL</span>


<span class="c1">;;;-----------------------------------------------------------------------------</span>
<span class="c1">;;; 2. Variables</span>
<span class="c1">;;;-----------------------------------------------------------------------------</span>

<span class="c1">;;; You can create a global (dynamically scoped) variable using DEFVAR and</span>
<span class="c1">;;; DEFPARAMETER. The variable name can use any character except: ()&quot;,&#39;`;#|\</span>

<span class="c1">;;; The difference between DEFVAR and DEFPARAMETER is that re-evaluating a</span>
<span class="c1">;;; DEFVAR expression doesn&#39;t change the value of the variable. DEFPARAMETER,</span>
<span class="c1">;;; on the other hand, does.</span>

<span class="c1">;;; By convention, dynamically scoped variables have earmuffs in their name.</span>

<span class="p">(</span><span class="nb">defparameter</span><span class="w"> </span><span class="vg">*some-var*</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span>
<span class="vg">*some-var*</span><span class="w"> </span><span class="c1">; =&gt; 5</span>

<span class="c1">;;; You can also use unicode characters.</span>
<span class="p">(</span><span class="nb">defparameter</span><span class="w"> </span><span class="vg">*AΛB*</span><span class="w"> </span><span class="no">nil</span><span class="p">)</span>

<span class="c1">;;; Accessing a previously unbound variable results in an UNBOUND-VARIABLE</span>
<span class="c1">;;; error, however it is defined behavior. Don&#39;t do it.</span>

<span class="c1">;;; You can create local bindings with LET. In the following snippet, `me` is</span>
<span class="c1">;;; bound to &quot;dance with you&quot; only within the (let ...). LET always returns</span>
<span class="c1">;;; the value of the last `form` in the LET form.</span>

<span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nv">me</span><span class="w"> </span><span class="s">&quot;dance with you&quot;</span><span class="p">))</span><span class="w"> </span><span class="nv">me</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; &quot;dance with you&quot;</span>


<span class="c1">;;;-----------------------------------------------------------------------------;</span>
<span class="c1">;;; 3. Structs and collections</span>
<span class="c1">;;;-----------------------------------------------------------------------------;</span>


<span class="c1">;;; Structs</span>

<span class="p">(</span><span class="nb">defstruct</span><span class="w"> </span><span class="nv">dog</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="nv">breed</span><span class="w"> </span><span class="nv">age</span><span class="p">)</span>
<span class="p">(</span><span class="nb">defparameter</span><span class="w"> </span><span class="vg">*rover*</span>
<span class="w">    </span><span class="p">(</span><span class="nv">make-dog</span><span class="w"> </span><span class="ss">:name</span><span class="w"> </span><span class="s">&quot;rover&quot;</span>
<span class="w">              </span><span class="ss">:breed</span><span class="w"> </span><span class="s">&quot;collie&quot;</span>
<span class="w">              </span><span class="ss">:age</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span>
<span class="vg">*rover*</span><span class="w">            </span><span class="c1">; =&gt; #S(DOG :NAME &quot;rover&quot; :BREED &quot;collie&quot; :AGE 5)</span>
<span class="p">(</span><span class="nv">dog-p</span><span class="w"> </span><span class="vg">*rover*</span><span class="p">)</span><span class="w">    </span><span class="c1">; =&gt; T</span>
<span class="p">(</span><span class="nv">dog-name</span><span class="w"> </span><span class="vg">*rover*</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; &quot;rover&quot;</span>

<span class="c1">;;; DOG-P, MAKE-DOG, and DOG-NAME are all automatically created by DEFSTRUCT</span>


<span class="c1">;;; Pairs</span>

<span class="c1">;;; CONS constructs pairs. CAR and CDR return the head and tail of a CONS-pair.</span>

<span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="ss">&#39;SUBJECT</span><span class="w"> </span><span class="ss">&#39;VERB</span><span class="p">)</span><span class="w">         </span><span class="c1">; =&gt; &#39;(SUBJECT . VERB)</span>
<span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="ss">&#39;SUBJECT</span><span class="w"> </span><span class="ss">&#39;VERB</span><span class="p">))</span><span class="w">   </span><span class="c1">; =&gt; SUBJECT</span>
<span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="ss">&#39;SUBJECT</span><span class="w"> </span><span class="ss">&#39;VERB</span><span class="p">))</span><span class="w">   </span><span class="c1">; =&gt; VERB</span>


<span class="c1">;;; Lists</span>

<span class="c1">;;; Lists are linked-list data structures, made of CONS pairs and end with a</span>
<span class="c1">;;; NIL (or &#39;()) to mark the end of the list</span>

<span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="no">nil</span><span class="p">)))</span><span class="w">     </span><span class="c1">; =&gt; &#39;(1 2 3)</span>

<span class="c1">;;; LIST is a convenience variadic constructor for lists</span>

<span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">                       </span><span class="c1">; =&gt; &#39;(1 2 3)</span>

<span class="c1">;;; When the first argument to CONS is an atom and the second argument is a</span>
<span class="c1">;;; list, CONS returns a new CONS-pair with the first argument as the first</span>
<span class="c1">;;; item and the second argument as the rest of the CONS-pair</span>

<span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w">                  </span><span class="c1">; =&gt; &#39;(4 1 2 3)</span>

<span class="c1">;;; Use APPEND to join lists</span>

<span class="p">(</span><span class="nb">append</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w">             </span><span class="c1">; =&gt; &#39;(1 2 3 4)</span>

<span class="c1">;;; Or CONCATENATE</span>

<span class="p">(</span><span class="nb">concatenate</span><span class="w"> </span><span class="ss">&#39;list</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w">  </span><span class="c1">; =&gt; &#39;(1 2 3 4)</span>

<span class="c1">;;; Lists are a very central type, so there is a wide variety of functionality for</span>
<span class="c1">;;; them, a few examples:</span>

<span class="p">(</span><span class="nb">mapcar</span><span class="w"> </span><span class="nf">#&#39;</span><span class="nb">1+</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w">             </span><span class="c1">; =&gt; &#39;(2 3 4)</span>
<span class="p">(</span><span class="nb">mapcar</span><span class="w"> </span><span class="nf">#&#39;</span><span class="nb">+</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">10</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="mi">30</span><span class="p">))</span><span class="w">  </span><span class="c1">; =&gt; &#39;(11 22 33)</span>
<span class="p">(</span><span class="nb">remove-if-not</span><span class="w"> </span><span class="nf">#&#39;</span><span class="nb">evenp</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="c1">; =&gt; &#39;(2 4)</span>
<span class="p">(</span><span class="nb">every</span><span class="w"> </span><span class="nf">#&#39;</span><span class="nb">evenp</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w">         </span><span class="c1">; =&gt; NIL</span>
<span class="p">(</span><span class="nb">some</span><span class="w"> </span><span class="nf">#&#39;</span><span class="nb">oddp</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w">           </span><span class="c1">; =&gt; T</span>
<span class="p">(</span><span class="nb">butlast</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">subject</span><span class="w"> </span><span class="nv">verb</span><span class="w"> </span><span class="nv">object</span><span class="p">))</span><span class="w">   </span><span class="c1">; =&gt; (SUBJECT VERB)</span>


<span class="c1">;;; Vectors</span>

<span class="c1">;;; Vector&#39;s literals are fixed-length arrays</span>

<span class="o">#(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; #(1 2 3)</span>

<span class="c1">;;; Use CONCATENATE to add vectors together</span>

<span class="p">(</span><span class="nb">concatenate</span><span class="w"> </span><span class="ss">&#39;vector</span><span class="w"> </span><span class="o">#(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">#(</span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="p">))</span><span class="w"> </span><span class="c1">; =&gt; #(1 2 3 4 5 6)</span>


<span class="c1">;;; Arrays</span>

<span class="c1">;;; Both vectors and strings are special-cases of arrays.</span>

<span class="c1">;;; 2D arrays</span>

<span class="p">(</span><span class="nb">make-array</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">         </span><span class="c1">; =&gt; #2A((0 0) (0 0))</span>
<span class="p">(</span><span class="nb">make-array</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">             </span><span class="c1">; =&gt; #2A((0 0) (0 0))</span>
<span class="p">(</span><span class="nb">make-array</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">       </span><span class="c1">; =&gt; #3A(((0 0) (0 0)) ((0 0) (0 0)))</span>

<span class="c1">;;; Caution: the default initial values of MAKE-ARRAY are implementation-defined.</span>
<span class="c1">;;; To explicitly specify them:</span>

<span class="p">(</span><span class="nb">make-array</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="ss">:initial-element</span><span class="w"> </span><span class="ss">&#39;unset</span><span class="p">)</span><span class="w">  </span><span class="c1">; =&gt; #(UNSET UNSET)</span>

<span class="c1">;;; To access the element at 1, 1, 1:</span>

<span class="p">(</span><span class="nb">aref</span><span class="w"> </span><span class="p">(</span><span class="nb">make-array</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">     </span><span class="c1">;  =&gt; 0</span>
<span class="c1">;;; This value is implementation-defined:</span>
<span class="c1">;;; NIL on ECL, 0 on SBCL and CCL.</span>

<span class="c1">;;; Adjustable vectors</span>

<span class="c1">;;; Adjustable vectors have the same printed representation as</span>
<span class="c1">;;; fixed-length vector&#39;s literals.</span>

<span class="p">(</span><span class="nb">defparameter</span><span class="w"> </span><span class="vg">*adjvec*</span><span class="w"> </span><span class="p">(</span><span class="nb">make-array</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="ss">:initial-contents</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
<span class="w">                                   </span><span class="ss">:adjustable</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="ss">:fill-pointer</span><span class="w"> </span><span class="no">t</span><span class="p">))</span>
<span class="vg">*adjvec*</span><span class="w"> </span><span class="c1">; =&gt; #(1 2 3)</span>

<span class="c1">;;; Adding new elements</span>

<span class="p">(</span><span class="nb">vector-push-extend</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="vg">*adjvec*</span><span class="p">)</span><span class="w">   </span><span class="c1">; =&gt; 3</span>
<span class="vg">*adjvec*</span><span class="w">                          </span><span class="c1">; =&gt; #(1 2 3 4)</span>


<span class="c1">;;; Sets, naively, are just lists:</span>

<span class="p">(</span><span class="nb">set-difference</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="p">))</span><span class="w">   </span><span class="c1">; =&gt; (3 2 1)</span>
<span class="p">(</span><span class="nb">intersection</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="p">))</span><span class="w">     </span><span class="c1">; =&gt; 4</span>
<span class="p">(</span><span class="nb">union</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="p">))</span><span class="w">            </span><span class="c1">; =&gt; (3 2 1 4 5 6 7)</span>
<span class="p">(</span><span class="nb">adjoin</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w">                    </span><span class="c1">; =&gt; (1 2 3 4)</span>

<span class="c1">;;; However, you&#39;ll need a better data structure than linked lists when working</span>
<span class="c1">;;; with larger data sets</span>

<span class="c1">;;; Dictionaries are implemented as hash tables.</span>

<span class="c1">;;; Create a hash table</span>

<span class="p">(</span><span class="nb">defparameter</span><span class="w"> </span><span class="vg">*m*</span><span class="w"> </span><span class="p">(</span><span class="nb">make-hash-table</span><span class="p">))</span>

<span class="c1">;;; Set value</span>

<span class="p">(</span><span class="nb">setf</span><span class="w"> </span><span class="p">(</span><span class="nb">gethash</span><span class="w"> </span><span class="ss">&#39;a</span><span class="w"> </span><span class="vg">*m*</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="c1">;;; Retrieve value</span>

<span class="p">(</span><span class="nb">gethash</span><span class="w"> </span><span class="ss">&#39;a</span><span class="w"> </span><span class="vg">*m*</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; 1, T</span>

<span class="c1">;;; CL expressions have the ability to return multiple values.</span>

<span class="p">(</span><span class="nb">values</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; 1, 2</span>

<span class="c1">;;; which can be bound with MULTIPLE-VALUE-BIND</span>

<span class="p">(</span><span class="nb">multiple-value-bind</span><span class="w"> </span><span class="p">(</span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">values</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">y</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span>

<span class="c1">; =&gt; &#39;(2 1)</span>

<span class="c1">;;; GETHASH is an example of a function that returns multiple values. The first</span>
<span class="c1">;;; value it return is the value of the key in the hash table; if the key is</span>
<span class="c1">;;; not found it returns NIL.</span>

<span class="c1">;;; The second value determines if that key is indeed present in the hash</span>
<span class="c1">;;; table. If a key is not found in the table it returns NIL. This behavior</span>
<span class="c1">;;; allows us to check if the value of a key is actually NIL.</span>

<span class="c1">;;; Retrieving a non-present value returns nil</span>

<span class="p">(</span><span class="nb">gethash</span><span class="w"> </span><span class="ss">&#39;d</span><span class="w"> </span><span class="vg">*m*</span><span class="p">)</span><span class="w"> </span><span class="c1">;=&gt; NIL, NIL</span>

<span class="c1">;;; You can provide a default value for missing keys</span>

<span class="p">(</span><span class="nb">gethash</span><span class="w"> </span><span class="ss">&#39;d</span><span class="w"> </span><span class="vg">*m*</span><span class="w"> </span><span class="ss">:not-found</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; :NOT-FOUND</span>

<span class="c1">;;; Let&#39;s handle the multiple return values here in code.</span>

<span class="p">(</span><span class="nb">multiple-value-bind</span><span class="w"> </span><span class="p">(</span><span class="nv">a</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">gethash</span><span class="w"> </span><span class="ss">&#39;d</span><span class="w"> </span><span class="vg">*m*</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">b</span><span class="p">))</span>
<span class="c1">; =&gt; (NIL NIL)</span>

<span class="p">(</span><span class="nb">multiple-value-bind</span><span class="w"> </span><span class="p">(</span><span class="nv">a</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">gethash</span><span class="w"> </span><span class="ss">&#39;a</span><span class="w"> </span><span class="vg">*m*</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">b</span><span class="p">))</span>
<span class="c1">; =&gt; (1 T)</span>


<span class="c1">;;;-----------------------------------------------------------------------------</span>
<span class="c1">;;; 3. Functions</span>
<span class="c1">;;;-----------------------------------------------------------------------------</span>

<span class="c1">;;; Use LAMBDA to create anonymous functions. Functions always returns the</span>
<span class="c1">;;; value of the last expression. The exact printable representation of a</span>
<span class="c1">;;; function varies between implementations.</span>

<span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; #&lt;FUNCTION (LAMBDA ()) {1004E7818B}&gt;</span>

<span class="c1">;;; Use FUNCALL to call anonymous functions</span>

<span class="p">(</span><span class="nb">funcall</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">))</span><span class="w">   </span><span class="c1">; =&gt; &quot;Hello World&quot;</span>
<span class="p">(</span><span class="nb">funcall</span><span class="w"> </span><span class="nf">#&#39;</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">                   </span><span class="c1">; =&gt; 6</span>

<span class="c1">;;; A call to FUNCALL is also implied when the lambda expression is the CAR of</span>
<span class="c1">;;; an unquoted list</span>

<span class="p">((</span><span class="k">lambda</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">))</span><span class="w">           </span><span class="c1">; =&gt; &quot;Hello World&quot;</span>
<span class="p">((</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nv">val</span><span class="p">)</span><span class="w"> </span><span class="nv">val</span><span class="p">)</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">)</span><span class="w">    </span><span class="c1">; =&gt; &quot;Hello World&quot;</span>

<span class="c1">;;; FUNCALL is used when the arguments are known beforehand. Otherwise, use APPLY</span>

<span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nf">#&#39;</span><span class="nb">+</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w">   </span><span class="c1">; =&gt; 6</span>
<span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">)</span><span class="w"> </span><span class="no">nil</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; &quot;Hello World&quot;</span>

<span class="c1">;;; To name a function, use DEFUN</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">hello-world</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nv">hello-world</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; &quot;Hello World&quot;</span>

<span class="c1">;;; The () in the definition above is the list of arguments</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">hello</span><span class="w"> </span><span class="p">(</span><span class="nv">name</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">nil</span><span class="w"> </span><span class="s">&quot;Hello, ~A&quot;</span><span class="w"> </span><span class="nv">name</span><span class="p">))</span>
<span class="p">(</span><span class="nv">hello</span><span class="w"> </span><span class="s">&quot;Steve&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; &quot;Hello, Steve&quot;</span>

<span class="c1">;;; Functions can have optional arguments; they default to NIL</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">hello</span><span class="w"> </span><span class="p">(</span><span class="nv">name</span><span class="w"> </span><span class="k">&amp;optional</span><span class="w"> </span><span class="nv">from</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">from</span>
<span class="w">      </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="s">&quot;Hello, ~A, from ~A&quot;</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="nv">from</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="s">&quot;Hello, ~A&quot;</span><span class="w"> </span><span class="nv">name</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">hello</span><span class="w"> </span><span class="s">&quot;Jim&quot;</span><span class="w"> </span><span class="s">&quot;Alpacas&quot;</span><span class="p">)</span><span class="w">       </span><span class="c1">; =&gt; Hello, Jim, from Alpacas</span>

<span class="c1">;;; The default values can also be specified</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">hello</span><span class="w"> </span><span class="p">(</span><span class="nv">name</span><span class="w"> </span><span class="k">&amp;optional</span><span class="w"> </span><span class="p">(</span><span class="nv">from</span><span class="w"> </span><span class="s">&quot;The world&quot;</span><span class="p">))</span>
<span class="w">   </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">nil</span><span class="w"> </span><span class="s">&quot;Hello, ~A, from ~A&quot;</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="nv">from</span><span class="p">))</span>

<span class="p">(</span><span class="nv">hello</span><span class="w"> </span><span class="s">&quot;Steve&quot;</span><span class="p">)</span><span class="w">               </span><span class="c1">; =&gt; Hello, Steve, from The world</span>
<span class="p">(</span><span class="nv">hello</span><span class="w"> </span><span class="s">&quot;Steve&quot;</span><span class="w"> </span><span class="s">&quot;the alpacas&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; Hello, Steve, from the alpacas</span>

<span class="c1">;;; Functions also have keyword arguments to allow non-positional arguments</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">generalized-greeter</span><span class="w"> </span><span class="p">(</span><span class="nv">name</span><span class="w"> </span><span class="k">&amp;key</span><span class="w"> </span><span class="p">(</span><span class="nv">from</span><span class="w"> </span><span class="s">&quot;the world&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">honorific</span><span class="w"> </span><span class="s">&quot;Mx&quot;</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="s">&quot;Hello, ~A ~A, from ~A&quot;</span><span class="w"> </span><span class="nv">honorific</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="nv">from</span><span class="p">))</span>

<span class="p">(</span><span class="nv">generalized-greeter</span><span class="w"> </span><span class="s">&quot;Jim&quot;</span><span class="p">)</span>
<span class="c1">; =&gt; Hello, Mx Jim, from the world</span>

<span class="p">(</span><span class="nv">generalized-greeter</span><span class="w"> </span><span class="s">&quot;Jim&quot;</span><span class="w"> </span><span class="ss">:from</span><span class="w"> </span><span class="s">&quot;the alpacas you met last summer&quot;</span><span class="w"> </span><span class="ss">:honorific</span><span class="w"> </span><span class="s">&quot;Mr&quot;</span><span class="p">)</span>
<span class="c1">; =&gt; Hello, Mr Jim, from the alpacas you met last summer</span>


<span class="c1">;;;-----------------------------------------------------------------------------</span>
<span class="c1">;;; 4. Equality</span>
<span class="c1">;;;-----------------------------------------------------------------------------</span>

<span class="c1">;;; CL has a sophisticated equality system. Some are covered here.</span>

<span class="c1">;;; For numbers, use `=&#39;</span>
<span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mf">3.0</span><span class="p">)</span><span class="w">               </span><span class="c1">; =&gt; T</span>
<span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">                 </span><span class="c1">; =&gt; NIL</span>

<span class="c1">;;; For object identity (approximately) use EQL</span>
<span class="p">(</span><span class="nb">eql</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">               </span><span class="c1">; =&gt; T</span>
<span class="p">(</span><span class="nb">eql</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mf">3.0</span><span class="p">)</span><span class="w">             </span><span class="c1">; =&gt; NIL</span>
<span class="p">(</span><span class="nb">eql</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="c1">; =&gt; NIL</span>

<span class="c1">;;; for lists, strings, and bit-vectors use EQUAL</span>
<span class="p">(</span><span class="nb">equal</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">&#39;a</span><span class="w"> </span><span class="ss">&#39;b</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">&#39;a</span><span class="w"> </span><span class="ss">&#39;b</span><span class="p">))</span><span class="w"> </span><span class="c1">; =&gt; T</span>
<span class="p">(</span><span class="nb">equal</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">&#39;a</span><span class="w"> </span><span class="ss">&#39;b</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">&#39;b</span><span class="w"> </span><span class="ss">&#39;a</span><span class="p">))</span><span class="w"> </span><span class="c1">; =&gt; NIL</span>


<span class="c1">;;;-----------------------------------------------------------------------------</span>
<span class="c1">;;; 5. Control Flow</span>
<span class="c1">;;;-----------------------------------------------------------------------------</span>

<span class="c1">;;; Conditionals</span>

<span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="no">t</span><span class="w">                </span><span class="c1">; test expression</span>
<span class="w">    </span><span class="s">&quot;this is true&quot;</span><span class="w">   </span><span class="c1">; then expression</span>
<span class="w">    </span><span class="s">&quot;this is false&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; else expression</span>
<span class="c1">; =&gt; &quot;this is true&quot;</span>

<span class="c1">;;; In conditionals, all non-NIL values are treated as true</span>

<span class="p">(</span><span class="nb">member</span><span class="w"> </span><span class="ss">&#39;Groucho</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">Harpo</span><span class="w"> </span><span class="nv">Groucho</span><span class="w"> </span><span class="nv">Zeppo</span><span class="p">))</span><span class="w"> </span><span class="c1">; =&gt; &#39;(GROUCHO ZEPPO)</span>
<span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">member</span><span class="w"> </span><span class="ss">&#39;Groucho</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">Harpo</span><span class="w"> </span><span class="nv">Groucho</span><span class="w"> </span><span class="nv">Zeppo</span><span class="p">))</span>
<span class="w">    </span><span class="ss">&#39;yep</span>
<span class="w">    </span><span class="ss">&#39;nope</span><span class="p">)</span>
<span class="c1">; =&gt; &#39;YEP</span>

<span class="c1">;;; COND chains a series of tests to select a result</span>
<span class="p">(</span><span class="nb">cond</span><span class="w"> </span><span class="p">((</span><span class="nb">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s">&quot;wrong!&quot;</span><span class="p">))</span>
<span class="w">      </span><span class="p">((</span><span class="nb">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s">&quot;wrong again!&quot;</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="no">t</span><span class="w"> </span><span class="ss">&#39;ok</span><span class="p">))</span><span class="w"> </span><span class="c1">; =&gt; &#39;OK</span>

<span class="c1">;;; TYPECASE switches on the type of the value</span>
<span class="p">(</span><span class="nb">typecase</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="p">(</span><span class="nb">string</span><span class="w"> </span><span class="ss">:string</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nc">integer</span><span class="w"> </span><span class="ss">:int</span><span class="p">))</span>
<span class="c1">; =&gt; :int</span>


<span class="c1">;;; Looping</span>

<span class="c1">;;; Recursion</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">fact</span><span class="w"> </span><span class="p">(</span><span class="nv">n</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">      </span><span class="mi">1</span>
<span class="w">    </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="p">(</span><span class="nv">fact</span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="mi">1</span><span class="p">)))))</span>

<span class="p">(</span><span class="nv">fact</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; 120</span>

<span class="c1">;;; Iteration</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">fact</span><span class="w"> </span><span class="p">(</span><span class="nv">n</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="ss">:for</span><span class="w"> </span><span class="nv">result</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ss">:then</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="nv">result</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span>
<span class="w">     </span><span class="ss">:for</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="ss">:from</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ss">:to</span><span class="w"> </span><span class="nv">n</span>
<span class="w">     </span><span class="ss">:finally</span><span class="w"> </span><span class="p">(</span><span class="nb">return</span><span class="w"> </span><span class="nv">result</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">fact</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; 120</span>

<span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="ss">:for</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="ss">:across</span><span class="w"> </span><span class="s">&quot;abcd&quot;</span><span class="w"> </span><span class="ss">:collect</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span>
<span class="c1">; =&gt; (#\a #\b #\c #\d)</span>

<span class="p">(</span><span class="nb">dolist</span><span class="w"> </span><span class="p">(</span><span class="nv">i</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="s">&quot;~A&quot;</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span>
<span class="c1">; =&gt; 1234</span>


<span class="c1">;;;-----------------------------------------------------------------------------</span>
<span class="c1">;;; 6. Mutation</span>
<span class="c1">;;;-----------------------------------------------------------------------------</span>

<span class="c1">;;; Use SETF to assign a new value to an existing variable. This was</span>
<span class="c1">;;; demonstrated earlier in the hash table example.</span>

<span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nv">variable</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">setf</span><span class="w"> </span><span class="nv">variable</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span>
<span class="c1">; =&gt; 2</span>

<span class="c1">;;; Good Lisp style is to minimize the use of destructive functions and to avoid</span>
<span class="c1">;;; mutation when reasonable.</span>


<span class="c1">;;;-----------------------------------------------------------------------------</span>
<span class="c1">;;; 7. Classes and objects</span>
<span class="c1">;;;-----------------------------------------------------------------------------</span>

<span class="c1">;;; No more animal classes. Let&#39;s have Human-Powered Mechanical</span>
<span class="c1">;;; Conveyances.</span>

<span class="p">(</span><span class="nb">defclass</span><span class="w"> </span><span class="nv">human-powered-conveyance</span><span class="w"> </span><span class="p">()</span>
<span class="w">  </span><span class="p">((</span><span class="nv">velocity</span>
<span class="w">    </span><span class="ss">:accessor</span><span class="w"> </span><span class="nv">velocity</span>
<span class="w">    </span><span class="ss">:initarg</span><span class="w"> </span><span class="ss">:velocity</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nv">average-efficiency</span>
<span class="w">    </span><span class="ss">:accessor</span><span class="w"> </span><span class="nv">average-efficiency</span>
<span class="w">   </span><span class="ss">:initarg</span><span class="w"> </span><span class="ss">:average-efficiency</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="ss">:documentation</span><span class="w"> </span><span class="s">&quot;A human powered conveyance&quot;</span><span class="p">))</span>

<span class="c1">;;; The arguments to DEFCLASS, in order are:</span>
<span class="c1">;;; 1. class name</span>
<span class="c1">;;; 2. superclass list</span>
<span class="c1">;;; 3. slot list</span>
<span class="c1">;;; 4. optional specifiers</span>

<span class="c1">;;; When no superclass list is set, the empty list defaults to the</span>
<span class="c1">;;; standard-object class. This *can* be changed, but not until you</span>
<span class="c1">;;; know what you&#39;re doing. Look up the Art of the Metaobject Protocol</span>
<span class="c1">;;; for more information.</span>

<span class="p">(</span><span class="nb">defclass</span><span class="w"> </span><span class="nv">bicycle</span><span class="w"> </span><span class="p">(</span><span class="nv">human-powered-conveyance</span><span class="p">)</span>
<span class="w">  </span><span class="p">((</span><span class="nv">wheel-size</span>
<span class="w">    </span><span class="ss">:accessor</span><span class="w"> </span><span class="nv">wheel-size</span>
<span class="w">    </span><span class="ss">:initarg</span><span class="w"> </span><span class="ss">:wheel-size</span>
<span class="w">    </span><span class="ss">:documentation</span><span class="w"> </span><span class="s">&quot;Diameter of the wheel.&quot;</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nv">height</span>
<span class="w">    </span><span class="ss">:accessor</span><span class="w"> </span><span class="nv">height</span>
<span class="w">    </span><span class="ss">:initarg</span><span class="w"> </span><span class="ss">:height</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defclass</span><span class="w"> </span><span class="nv">recumbent</span><span class="w"> </span><span class="p">(</span><span class="nv">bicycle</span><span class="p">)</span>
<span class="w">  </span><span class="p">((</span><span class="nv">chain-type</span>
<span class="w">    </span><span class="ss">:accessor</span><span class="w"> </span><span class="nv">chain-type</span>
<span class="w">    </span><span class="ss">:initarg</span><span class="w"> </span><span class="ss">:chain-type</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defclass</span><span class="w"> </span><span class="nv">unicycle</span><span class="w"> </span><span class="p">(</span><span class="nv">human-powered-conveyance</span><span class="p">)</span><span class="w"> </span><span class="no">nil</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defclass</span><span class="w"> </span><span class="nv">canoe</span><span class="w"> </span><span class="p">(</span><span class="nv">human-powered-conveyance</span><span class="p">)</span>
<span class="w">  </span><span class="p">((</span><span class="nv">number-of-rowers</span>
<span class="w">    </span><span class="ss">:accessor</span><span class="w"> </span><span class="nv">number-of-rowers</span>
<span class="w">    </span><span class="ss">:initarg</span><span class="w"> </span><span class="ss">:number-of-rowers</span><span class="p">)))</span>

<span class="c1">;;; Calling DESCRIBE on the HUMAN-POWERED-CONVEYANCE class in the REPL gives:</span>

<span class="p">(</span><span class="nb">describe</span><span class="w"> </span><span class="ss">&#39;human-powered-conveyance</span><span class="p">)</span>

<span class="c1">; COMMON-LISP-USER::HUMAN-POWERED-CONVEYANCE</span>
<span class="c1">;  [symbol]</span>
<span class="c1">;</span>
<span class="c1">; HUMAN-POWERED-CONVEYANCE names the standard-class #&lt;STANDARD-CLASS</span>
<span class="c1">;                                                    HUMAN-POWERED-CONVEYANCE&gt;:</span>
<span class="c1">;  Documentation:</span>
<span class="c1">;    A human powered conveyance</span>
<span class="c1">;  Direct superclasses: STANDARD-OBJECT</span>
<span class="c1">;  Direct subclasses: UNICYCLE, BICYCLE, CANOE</span>
<span class="c1">;  Not yet finalized.</span>
<span class="c1">;  Direct slots:</span>
<span class="c1">;    VELOCITY</span>
<span class="c1">;      Readers: VELOCITY</span>
<span class="c1">;      Writers: (SETF VELOCITY)</span>
<span class="c1">;    AVERAGE-EFFICIENCY</span>
<span class="c1">;      Readers: AVERAGE-EFFICIENCY</span>
<span class="c1">;      Writers: (SETF AVERAGE-EFFICIENCY)</span>

<span class="c1">;;; Note the reflective behavior available. CL was designed to be an</span>
<span class="c1">;;; interactive system</span>

<span class="c1">;;; To define a method, let&#39;s find out what our circumference of the</span>
<span class="c1">;;; bike wheel turns out to be using the equation: C = d * pi</span>

<span class="p">(</span><span class="nb">defmethod</span><span class="w"> </span><span class="nv">circumference</span><span class="w"> </span><span class="p">((</span><span class="nv">object</span><span class="w"> </span><span class="nv">bicycle</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="nv">pi</span><span class="w"> </span><span class="p">(</span><span class="nv">wheel-size</span><span class="w"> </span><span class="nv">object</span><span class="p">)))</span>

<span class="c1">;;; PI is defined as a built-in in CL</span>

<span class="c1">;;; Let&#39;s suppose we find out that the efficiency value of the number</span>
<span class="c1">;;; of rowers in a canoe is roughly logarithmic. This should probably be set</span>
<span class="c1">;;; in the constructor/initializer.</span>

<span class="c1">;;; To initialize your instance after CL gets done constructing it:</span>

<span class="p">(</span><span class="nb">defmethod</span><span class="w"> </span><span class="nb">initialize-instance</span><span class="w"> </span><span class="ss">:after</span><span class="w"> </span><span class="p">((</span><span class="nv">object</span><span class="w"> </span><span class="nv">canoe</span><span class="p">)</span><span class="w"> </span><span class="k">&amp;rest</span><span class="w"> </span><span class="nv">args</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">setf</span><span class="w"> </span><span class="p">(</span><span class="nv">average-efficiency</span><span class="w"> </span><span class="nv">object</span><span class="p">)</span><span class="w">  </span><span class="p">(</span><span class="nb">log</span><span class="w"> </span><span class="p">(</span><span class="nb">1+</span><span class="w"> </span><span class="p">(</span><span class="nv">number-of-rowers</span><span class="w"> </span><span class="nv">object</span><span class="p">)))))</span>

<span class="c1">;;; Then to construct an instance and check the average efficiency...</span>

<span class="p">(</span><span class="nv">average-efficiency</span><span class="w"> </span><span class="p">(</span><span class="nb">make-instance</span><span class="w"> </span><span class="ss">&#39;canoe</span><span class="w"> </span><span class="ss">:number-of-rowers</span><span class="w"> </span><span class="mi">15</span><span class="p">))</span>
<span class="c1">; =&gt; 2.7725887</span>


<span class="c1">;;;-----------------------------------------------------------------------------</span>
<span class="c1">;;; 8. Macros</span>
<span class="c1">;;;-----------------------------------------------------------------------------</span>

<span class="c1">;;; Macros let you extend the syntax of the language. CL doesn&#39;t come</span>
<span class="c1">;;; with a WHILE loop, however, it&#39;s trivial to write one. If we obey our</span>
<span class="c1">;;; assembler instincts, we wind up with:</span>

<span class="p">(</span><span class="nb">defmacro</span><span class="w"> </span><span class="nv">while</span><span class="w"> </span><span class="p">(</span><span class="kt">condition</span><span class="w"> </span><span class="k">&amp;body</span><span class="w"> </span><span class="nv">body</span><span class="p">)</span>
<span class="w">    </span><span class="s">&quot;While `condition` is true, `body` is executed.</span>
<span class="s">`condition` is tested prior to each execution of `body`&quot;</span>
<span class="w">    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nv">block-name</span><span class="w"> </span><span class="p">(</span><span class="nb">gensym</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nv">done</span><span class="w"> </span><span class="p">(</span><span class="nb">gensym</span><span class="p">)))</span>
<span class="w">        </span><span class="o">`</span><span class="p">(</span><span class="k">tagbody</span>
<span class="w">           </span><span class="o">,</span><span class="nv">block-name</span>
<span class="w">           </span><span class="p">(</span><span class="nb">unless</span><span class="w"> </span><span class="o">,</span><span class="kt">condition</span>
<span class="w">               </span><span class="p">(</span><span class="k">go</span><span class="w"> </span><span class="o">,</span><span class="nv">done</span><span class="p">))</span>
<span class="w">           </span><span class="p">(</span><span class="k">progn</span>
<span class="w">           </span><span class="o">,@</span><span class="nv">body</span><span class="p">)</span>
<span class="w">           </span><span class="p">(</span><span class="k">go</span><span class="w"> </span><span class="o">,</span><span class="nv">block-name</span><span class="p">)</span>
<span class="w">           </span><span class="o">,</span><span class="nv">done</span><span class="p">)))</span>

<span class="c1">;;; Let&#39;s look at the high-level version of this:</span>

<span class="p">(</span><span class="nb">defmacro</span><span class="w"> </span><span class="nv">while</span><span class="w"> </span><span class="p">(</span><span class="kt">condition</span><span class="w"> </span><span class="k">&amp;body</span><span class="w"> </span><span class="nv">body</span><span class="p">)</span>
<span class="w">    </span><span class="s">&quot;While `condition` is true, `body` is executed.</span>
<span class="s">`condition` is tested prior to each execution of `body`&quot;</span>
<span class="w">  </span><span class="o">`</span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="nv">while</span><span class="w"> </span><span class="o">,</span><span class="kt">condition</span>
<span class="w">         </span><span class="nb">do</span>
<span class="w">         </span><span class="p">(</span><span class="k">progn</span>
<span class="w">            </span><span class="o">,@</span><span class="nv">body</span><span class="p">)))</span>

<span class="c1">;;; However, with a modern compiler, this is not required; the LOOP form</span>
<span class="c1">;;; compiles equally well and is easier to read.</span>

<span class="c1">;;; Note that ``` is used, as well as `,` and `@`. ``` is a quote-type operator</span>
<span class="c1">;;; known as quasiquote; it allows the use of `,` . `,` allows &quot;unquoting&quot;</span>
<span class="c1">;;; variables. @ interpolates lists.</span>

<span class="c1">;;; GENSYM creates a unique symbol guaranteed to not exist elsewhere in</span>
<span class="c1">;;; the system. This is because macros are expanded at compile time and</span>
<span class="c1">;;; variables declared in the macro can collide with variables used in</span>
<span class="c1">;;; regular code.</span>

<span class="c1">;;; See Practical Common Lisp and On Lisp for more information on macros.</span>
</pre></div>
<h2>Further reading</h2>

<ul>
<li><a href="http://www.gigamonkeys.com/book/">Practical Common Lisp</a></li>
<li><a href="https://www.cs.cmu.edu/~dst/LispBook/book.pdf">Common Lisp: A Gentle Introduction to Symbolic Computation</a></li>
</ul>

<h2>Extra information</h2>

<ul>
<li><a href="http://www.cliki.net/">CLiki</a></li>
<li><a href="https://common-lisp.net/">common-lisp.net</a></li>
<li><a href="https://github.com/CodyReichert/awesome-cl">Awesome Common Lisp</a></li>
<li><a href="http://lisp-lang.org/">Lisp Lang</a></li>
</ul>

<h2>Credits</h2>

<p>Lots of thanks to the Scheme people for rolling up a great starting
point which could be easily moved to Common Lisp.</p>

<ul>
<li><a href="https://github.com/pkhuong">Paul Khuong</a> for some great reviewing.</li>
</ul>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/common-lisp.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by Paul Nathan, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/common-lisp.html.markdown">10 contributors</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="https://github.com/pnathan">Paul Nathan</a>,
        <a href="https://ebzzry.io">Rommel Martinez</a>
    </p>

    <p>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
