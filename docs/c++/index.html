<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="en-us" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="en-us" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="en-us" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="en-us" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="en-us">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn C++ in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/c++/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fc%2B%2B%2F&text=Learn+X+in+Y+minutes%2C+where+X%3DC%2B%2B">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="/">Learn X in Y minutes</a></h1>
  <h2>Where X=C++</h2>
    <p class="filelink">
    Get the code:
    <a href="/docs/files/learncpp.cpp">learncpp.cpp</a>
    </p>
  <div id="doc">
    <p>C++ is a systems programming language that,
<a href="https://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">according to its inventor Bjarne Stroustrup</a>,
was designed to</p>

<ul>
<li>be a &ldquo;better C&rdquo;</li>
<li>support data abstraction</li>
<li>support object-oriented programming</li>
<li>support generic programming</li>
</ul>

<p>Though its syntax can be more difficult or complex than newer languages,
it is widely used because it compiles to native instructions that can be
directly run by the processor and offers tight control over hardware (like C)
while offering high-level features such as generics, exceptions, and classes.
This combination of speed and functionality makes C++
one of the most widely-used programming languages.</p>
<div class="highlight"><pre><span></span><span class="c1">//////////////////</span>
<span class="c1">// Comparison to C</span>
<span class="c1">//////////////////</span>

<span class="c1">// C++ is _almost_ a superset of C and shares its basic syntax for</span>
<span class="c1">// variable declarations, primitive types, and functions.</span>

<span class="c1">// Just like in C, your program&#39;s entry point is a function called</span>
<span class="c1">// main with an integer return type.</span>
<span class="c1">// This value serves as the program&#39;s exit status.</span>
<span class="c1">// See https://en.wikipedia.org/wiki/Exit_status for more information.</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Command line arguments are passed in by argc and argv in the same way</span>
<span class="w">    </span><span class="c1">// they are in C.</span>
<span class="w">    </span><span class="c1">// argc indicates the number of arguments,</span>
<span class="w">    </span><span class="c1">// and argv is an array of C-style strings (char*)</span>
<span class="w">    </span><span class="c1">// representing the arguments.</span>
<span class="w">    </span><span class="c1">// The first argument is the name by which the program was called.</span>
<span class="w">    </span><span class="c1">// argc and argv can be omitted if you do not care about arguments,</span>
<span class="w">    </span><span class="c1">// giving the function signature of int main()</span>

<span class="w">    </span><span class="c1">// An exit status of 0 indicates success.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// However, C++ varies in some of the following ways:</span>

<span class="c1">// In C++, character literals are chars</span>
<span class="k">sizeof</span><span class="p">(</span><span class="sc">&#39;c&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span>

<span class="c1">// In C, character literals are ints</span>
<span class="k">sizeof</span><span class="p">(</span><span class="sc">&#39;c&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>


<span class="c1">// C++ has strict prototyping</span>
<span class="kt">void</span><span class="w"> </span><span class="n">func</span><span class="p">();</span><span class="w"> </span><span class="c1">// function which accepts no arguments</span>

<span class="c1">// In C</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">();</span><span class="w"> </span><span class="c1">// function which may accept any number of arguments</span>

<span class="c1">// Use nullptr instead of NULL in C++</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="c1">// C standard headers are available in C++.</span>
<span class="c1">// C headers end in .h, while</span>
<span class="c1">// C++ headers are prefixed with &quot;c&quot; and have no &quot;.h&quot; suffix.</span>

<span class="c1">// The C++ standard version:</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdio&gt;</span>

<span class="c1">// The C standard version:</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, world!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">///////////////////////</span>
<span class="c1">// Function overloading</span>
<span class="c1">///////////////////////</span>

<span class="c1">// C++ supports function overloading</span>
<span class="c1">// provided each function takes different parameters.</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">myString</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;String %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">myString</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">myInt</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;My int is %d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">myInt</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Resolves to void print(const char*)</span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span><span class="w"> </span><span class="c1">// Resolves to void print(int)</span>
<span class="p">}</span>

<span class="c1">/////////////////////////////</span>
<span class="c1">// Default function arguments</span>
<span class="c1">/////////////////////////////</span>

<span class="c1">// You can provide default arguments for a function</span>
<span class="c1">// if they are not provided by the caller.</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">doSomethingWithInts</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Do something with the ints here</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">doSomethingWithInts</span><span class="p">();</span><span class="w">      </span><span class="c1">// a = 1,  b = 4</span>
<span class="w">    </span><span class="n">doSomethingWithInts</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w">    </span><span class="c1">// a = 20, b = 4</span>
<span class="w">    </span><span class="n">doSomethingWithInts</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// a = 20, b = 5</span>
<span class="p">}</span>

<span class="c1">// Default arguments must be at the end of the arguments list.</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">invalidDeclaration</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="c1">// Error!</span>
<span class="p">{</span>
<span class="p">}</span>


<span class="c1">/////////////</span>
<span class="c1">// Namespaces</span>
<span class="c1">/////////////</span>

<span class="c1">// Namespaces provide separate scopes for variable, function,</span>
<span class="c1">// and other declarations.</span>
<span class="c1">// Namespaces can be nested.</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">First</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Nested</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;This is First::Nested::foo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// end namespace Nested</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// end namespace First</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">Second</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;This is Second::foo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;This is Second::bar</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;This is global foo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Includes all symbols from namespace Second into the current scope. Note</span>
<span class="w">    </span><span class="c1">// that while bar() works, simply using foo() no longer works, since it is</span>
<span class="w">    </span><span class="c1">// now ambiguous whether we&#39;re calling the foo in namespace Second or the</span>
<span class="w">    </span><span class="c1">// top level.</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Second</span><span class="p">;</span>

<span class="w">    </span><span class="n">bar</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &quot;This is Second::bar&quot;</span>
<span class="w">    </span><span class="n">Second</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &quot;This is Second::foo&quot;</span>
<span class="w">    </span><span class="n">First</span><span class="o">::</span><span class="n">Nested</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &quot;This is First::Nested::foo&quot;</span>
<span class="w">    </span><span class="o">::</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &quot;This is global foo&quot;</span>
<span class="p">}</span>

<span class="c1">///////////////</span>
<span class="c1">// Input/Output</span>
<span class="c1">///////////////</span>

<span class="c1">// C++ input and output uses streams</span>
<span class="c1">// cin, cout, and cerr represent stdin, stdout, and stderr.</span>
<span class="c1">// &lt;&lt; is the insertion operator and &gt;&gt; is the extraction operator.</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="c1"> // Include for I/O streams</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"> </span><span class="c1">// Streams are in the std namespace (standard library)</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">myInt</span><span class="p">;</span>

<span class="w">   </span><span class="c1">// Prints to stdout (or terminal/screen)</span>
<span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Enter your favorite number:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">   </span><span class="c1">// Takes in input</span>
<span class="w">   </span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">myInt</span><span class="p">;</span>

<span class="w">   </span><span class="c1">// cout can also be formatted</span>
<span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Your favorite number is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myInt</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="w">   </span><span class="c1">// prints &quot;Your favorite number is &lt;myInt&gt;&quot;</span>

<span class="w">   </span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Used for error messages&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//////////</span>
<span class="c1">// Strings</span>
<span class="c1">//////////</span>

<span class="c1">// Strings in C++ are objects and have many member functions</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"> </span><span class="c1">// Strings are also in the namespace std (standard library)</span>

<span class="n">string</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span><span class="p">;</span>
<span class="n">string</span><span class="w"> </span><span class="n">myOtherString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot; World&quot;</span><span class="p">;</span>

<span class="c1">// + is used for concatenation.</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">myOtherString</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;Hello World&quot;</span>

<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; You&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;Hello You&quot;</span>

<span class="c1">// C++ string length can be found from either string::length() or string::size()</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myString</span><span class="p">.</span><span class="n">length</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">myOtherString</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="c1">// Outputs 11 (= 5 + 6).</span>

<span class="c1">// C++ strings are mutable.</span>
<span class="n">myString</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot; Dog&quot;</span><span class="p">);</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myString</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;Hello Dog&quot;</span>

<span class="c1">// C++ can handle C-style strings with related functions using cstrings</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstring&gt;</span>

<span class="kt">char</span><span class="w"> </span><span class="n">myOldString</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello CPP&quot;</span><span class="p">;</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myOldString</span><span class="p">;</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Length = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">myOldString</span><span class="p">);</span><span class="w"> </span><span class="c1">// Length = 9</span>

<span class="c1">/////////////</span>
<span class="c1">// References</span>
<span class="c1">/////////////</span>

<span class="c1">// In addition to pointers like the ones in C,</span>
<span class="c1">// C++ has _references_.</span>
<span class="c1">// These are pointer types that cannot be reassigned once set</span>
<span class="c1">// and cannot be null.</span>
<span class="c1">// They also have the same syntax as the variable itself:</span>
<span class="c1">// No * is needed for dereferencing and</span>
<span class="c1">// &amp; (address of) is not used for assignment.</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="n">string</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;I am foo&quot;</span><span class="p">;</span>
<span class="n">string</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;I am bar&quot;</span><span class="p">;</span>


<span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">fooRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w"> </span><span class="c1">// This creates a reference to foo.</span>
<span class="n">fooRef</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;. Hi!&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Modifies foo through the reference</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fooRef</span><span class="p">;</span><span class="w"> </span><span class="c1">// Prints &quot;I am foo. Hi!&quot;</span>

<span class="c1">// Doesn&#39;t reassign &quot;fooRef&quot;. This is the same as &quot;foo = bar&quot;, and</span>
<span class="c1">//   foo == &quot;I am bar&quot;</span>
<span class="c1">// after this line.</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fooRef</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">//Prints the address of foo</span>
<span class="n">fooRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fooRef</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">//Still prints the address of foo</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fooRef</span><span class="p">;</span><span class="w">  </span><span class="c1">// Prints &quot;I am bar&quot;</span>

<span class="c1">// The address of fooRef remains the same, i.e. it is still referring to foo.</span>


<span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">barRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span><span class="w"> </span><span class="c1">// Create a const reference to bar.</span>
<span class="c1">// Like C, const values (and pointers and references) cannot be modified.</span>
<span class="n">barRef</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;. Hi!&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Error, const references cannot be modified.</span>

<span class="c1">// Sidetrack: Before we talk more about references, we must introduce a concept</span>
<span class="c1">// called a temporary object. Suppose we have the following code:</span>
<span class="n">string</span><span class="w"> </span><span class="nf">tempObjectFun</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="n">string</span><span class="w"> </span><span class="n">retVal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tempObjectFun</span><span class="p">();</span>

<span class="c1">// What happens in the second line is actually:</span>
<span class="c1">//   - a string object is returned from tempObjectFun</span>
<span class="c1">//   - a new string is constructed with the returned object as argument to the</span>
<span class="c1">//     constructor</span>
<span class="c1">//   - the returned object is destroyed</span>
<span class="c1">// The returned object is called a temporary object. Temporary objects are</span>
<span class="c1">// created whenever a function returns an object, and they are destroyed at the</span>
<span class="c1">// end of the evaluation of the enclosing expression (Well, this is what the</span>
<span class="c1">// standard says, but compilers are allowed to change this behavior. Look up</span>
<span class="c1">// &quot;return value optimization&quot; if you&#39;re into this kind of details). So in this</span>
<span class="c1">// code:</span>
<span class="n">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">(</span><span class="n">tempObjectFun</span><span class="p">()))</span>

<span class="c1">// assuming foo and bar exist, the object returned from tempObjectFun is</span>
<span class="c1">// passed to bar, and it is destroyed before foo is called.</span>

<span class="c1">// Now back to references. The exception to the &quot;at the end of the enclosing</span>
<span class="c1">// expression&quot; rule is if a temporary object is bound to a const reference, in</span>
<span class="c1">// which case its life gets extended to the current scope:</span>

<span class="kt">void</span><span class="w"> </span><span class="n">constReferenceTempObjectFun</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// constRef gets the temporary object, and it is valid until the end of this</span>
<span class="w">  </span><span class="c1">// function.</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">constRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tempObjectFun</span><span class="p">();</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>

<span class="c1">// Another kind of reference introduced in C++11 is specifically for temporary</span>
<span class="c1">// objects. You cannot have a variable of its type, but it takes precedence in</span>
<span class="c1">// overload resolution:</span>

<span class="kt">void</span><span class="w"> </span><span class="n">someFun</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">  </span><span class="c1">// Regular reference</span>
<span class="kt">void</span><span class="w"> </span><span class="n">someFun</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">  </span><span class="c1">// Reference to temporary object</span>

<span class="n">string</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>
<span class="n">someFun</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span><span class="w">  </span><span class="c1">// Calls the version with regular reference</span>
<span class="n">someFun</span><span class="p">(</span><span class="n">tempObjectFun</span><span class="p">());</span><span class="w">  </span><span class="c1">// Calls the version with temporary reference</span>

<span class="c1">// For example, you will see these two versions of constructors for</span>
<span class="c1">// std::basic_string:</span>
<span class="n">basic_string</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">basic_string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
<span class="n">basic_string</span><span class="p">(</span><span class="n">basic_string</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>

<span class="c1">// Idea being if we are constructing a new string from a temporary object (which</span>
<span class="c1">// is going to be destroyed soon anyway), we can have a more efficient</span>
<span class="c1">// constructor that &quot;salvages&quot; parts of that temporary string. You will see this</span>
<span class="c1">// concept referred to as &quot;move semantics&quot;.</span>

<span class="c1">/////////////////////</span>
<span class="c1">// Enums</span>
<span class="c1">/////////////////////</span>

<span class="c1">// Enums are a way to assign a value to a constant most commonly used for</span>
<span class="c1">// easier visualization and reading of code</span>
<span class="k">enum</span><span class="w"> </span><span class="nc">ECarTypes</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Sedan</span><span class="p">,</span>
<span class="w">  </span><span class="n">Hatchback</span><span class="p">,</span>
<span class="w">  </span><span class="n">SUV</span><span class="p">,</span>
<span class="w">  </span><span class="n">Wagon</span>
<span class="p">};</span>

<span class="n">ECarTypes</span><span class="w"> </span><span class="nf">GetPreferredCarType</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ECarTypes</span><span class="o">::</span><span class="n">Hatchback</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// As of C++11 there is an easy way to assign a type to the enum which can be</span>
<span class="c1">// useful in serialization of data and converting enums back-and-forth between</span>
<span class="c1">// the desired type and their respective constants</span>
<span class="k">enum</span><span class="w"> </span><span class="nc">ECarTypes</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">uint8_t</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Sedan</span><span class="p">,</span><span class="w"> </span><span class="c1">// 0</span>
<span class="w">  </span><span class="n">Hatchback</span><span class="p">,</span><span class="w"> </span><span class="c1">// 1</span>
<span class="w">  </span><span class="n">SUV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">254</span><span class="p">,</span><span class="w"> </span><span class="c1">// 254</span>
<span class="w">  </span><span class="n">Hybrid</span><span class="w"> </span><span class="c1">// 255</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">WriteByteToFile</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">InputValue</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Serialize the InputValue to a file</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">WritePreferredCarTypeToFile</span><span class="p">(</span><span class="n">ECarTypes</span><span class="w"> </span><span class="n">InputCarType</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// The enum is implicitly converted to a uint8_t due to its declared enum type</span>
<span class="w">    </span><span class="n">WriteByteToFile</span><span class="p">(</span><span class="n">InputCarType</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// On the other hand you may not want enums to be accidentally cast to an integer</span>
<span class="c1">// type or to other enums so it is instead possible to create an enum class which</span>
<span class="c1">// won&#39;t be implicitly converted</span>
<span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">ECarTypes</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">uint8_t</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Sedan</span><span class="p">,</span><span class="w"> </span><span class="c1">// 0</span>
<span class="w">  </span><span class="n">Hatchback</span><span class="p">,</span><span class="w"> </span><span class="c1">// 1</span>
<span class="w">  </span><span class="n">SUV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">254</span><span class="p">,</span><span class="w"> </span><span class="c1">// 254</span>
<span class="w">  </span><span class="n">Hybrid</span><span class="w"> </span><span class="c1">// 255</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">WriteByteToFile</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">InputValue</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Serialize the InputValue to a file</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">WritePreferredCarTypeToFile</span><span class="p">(</span><span class="n">ECarTypes</span><span class="w"> </span><span class="n">InputCarType</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Won&#39;t compile even though ECarTypes is a uint8_t due to the enum</span>
<span class="w">    </span><span class="c1">// being declared as an &quot;enum class&quot;!</span>
<span class="w">    </span><span class="n">WriteByteToFile</span><span class="p">(</span><span class="n">InputCarType</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//////////////////////////////////////////</span>
<span class="c1">// Classes and object-oriented programming</span>
<span class="c1">//////////////////////////////////////////</span>

<span class="c1">// First example of classes</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="c1">// Declare a class.</span>
<span class="c1">// Classes are usually declared in header (.h or .hpp) files.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Dog</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Member variables and functions are private by default.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">weight</span><span class="p">;</span>

<span class="c1">// All members following this are public</span>
<span class="c1">// until &quot;private:&quot; or &quot;protected:&quot; is found.</span>
<span class="k">public</span><span class="o">:</span>

<span class="w">    </span><span class="c1">// Default constructor</span>
<span class="w">    </span><span class="n">Dog</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Member function declarations (implementations to follow)</span>
<span class="w">    </span><span class="c1">// Note that we use std::string here instead of placing</span>
<span class="w">    </span><span class="c1">// using namespace std;</span>
<span class="w">    </span><span class="c1">// above.</span>
<span class="w">    </span><span class="c1">// Never put a &quot;using namespace&quot; statement in a header.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">setName</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dogsName</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">setWeight</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">dogsWeight</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Functions that do not modify the state of the object</span>
<span class="w">    </span><span class="c1">// should be marked as const.</span>
<span class="w">    </span><span class="c1">// This allows you to call them if given a const reference to the object.</span>
<span class="w">    </span><span class="c1">// Also note the functions must be explicitly declared as _virtual_</span>
<span class="w">    </span><span class="c1">// in order to be overridden in derived classes.</span>
<span class="w">    </span><span class="c1">// Functions are not virtual by default for performance reasons.</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Functions can also be defined inside the class body.</span>
<span class="w">    </span><span class="c1">// Functions defined as such are automatically inlined.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">bark</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; barks!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Along with constructors, C++ provides destructors.</span>
<span class="w">    </span><span class="c1">// These are called when an object is deleted or falls out of scope.</span>
<span class="w">    </span><span class="c1">// This enables powerful paradigms such as RAII</span>
<span class="w">    </span><span class="c1">// (see below)</span>
<span class="w">    </span><span class="c1">// The destructor should be virtual if a class is to be derived from;</span>
<span class="w">    </span><span class="c1">// if it is not virtual, then the derived class&#39; destructor will</span>
<span class="w">    </span><span class="c1">// not be called if the object is destroyed through a base-class reference</span>
<span class="w">    </span><span class="c1">// or pointer.</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Dog</span><span class="p">();</span>

<span class="p">};</span><span class="w"> </span><span class="c1">// A semicolon must follow the class definition.</span>

<span class="c1">// Class member functions are usually implemented in .cpp files.</span>
<span class="n">Dog</span><span class="o">::</span><span class="n">Dog</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;A dog has been constructed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Objects (such as strings) should be passed by reference</span>
<span class="c1">// if you are modifying them or const reference if you are not.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">Dog</span><span class="o">::</span><span class="n">setName</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dogsName</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dogsName</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">Dog</span><span class="o">::</span><span class="n">setWeight</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">dogsWeight</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dogsWeight</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Notice that &quot;virtual&quot; is only needed in the declaration, not the definition.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">Dog</span><span class="o">::</span><span class="n">print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Dog is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; and weighs &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;kg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Dog</span><span class="o">::~</span><span class="n">Dog</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Goodbye &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Dog</span><span class="w"> </span><span class="n">myDog</span><span class="p">;</span><span class="w"> </span><span class="c1">// prints &quot;A dog has been constructed&quot;</span>
<span class="w">    </span><span class="n">myDog</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">&quot;Barkley&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">myDog</span><span class="p">.</span><span class="n">setWeight</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="n">myDog</span><span class="p">.</span><span class="n">print</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &quot;Dog is Barkley and weighs 10 kg&quot;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// prints &quot;Goodbye Barkley&quot;</span>

<span class="c1">// Inheritance:</span>

<span class="c1">// This class inherits everything public and protected from the Dog class</span>
<span class="c1">// as well as private but may not directly access private members/methods</span>
<span class="c1">// without a public or protected method for doing so</span>
<span class="k">class</span><span class="w"> </span><span class="nc">OwnedDog</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Dog</span><span class="w"> </span><span class="p">{</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">setOwner</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dogsOwner</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Override the behavior of the print function for all OwnedDogs. See</span>
<span class="w">    </span><span class="c1">// https://en.wikipedia.org/wiki/Polymorphism_(computer_science)#Subtyping</span>
<span class="w">    </span><span class="c1">// for a more general introduction if you are unfamiliar with</span>
<span class="w">    </span><span class="c1">// subtype polymorphism.</span>
<span class="w">    </span><span class="c1">// The override keyword is optional but makes sure you are actually</span>
<span class="w">    </span><span class="c1">// overriding the method in a base class.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">owner</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Meanwhile, in the corresponding .cpp file:</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">OwnedDog::setOwner</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dogsOwner</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dogsOwner</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">OwnedDog::print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Dog</span><span class="o">::</span><span class="n">print</span><span class="p">();</span><span class="w"> </span><span class="c1">// Call the print function in the base Dog class</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Dog is owned by &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">owner</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Prints &quot;Dog is &lt;name&gt; and weights &lt;weight&gt;&quot;</span>
<span class="w">    </span><span class="c1">//        &quot;Dog is owned by &lt;owner&gt;&quot;</span>
<span class="p">}</span>

<span class="c1">//////////////////////////////////////////</span>
<span class="c1">// Initialization and Operator Overloading</span>
<span class="c1">//////////////////////////////////////////</span>

<span class="c1">// In C++ you can overload the behavior of operators such as +, -, *, /, etc.</span>
<span class="c1">// This is done by defining a function which is called</span>
<span class="c1">// whenever the operator is used.</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Point</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// Member variables can be given default values in this manner.</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Define a default constructor which does nothing</span>
<span class="w">    </span><span class="c1">// but initialize the Point to the default value (0, 0)</span>
<span class="w">    </span><span class="n">Point</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// The following syntax is known as an initialization list</span>
<span class="w">    </span><span class="c1">// and is the proper way to initialize class member values</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">        </span><span class="n">x</span><span class="p">(</span><span class="n">a</span><span class="p">),</span>
<span class="w">        </span><span class="n">y</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="cm">/* Do nothing except initialize the values */</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Overload the + operator.</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Overload the += operator</span>
<span class="w">    </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// It would also make sense to add the - and -= operators,</span>
<span class="w">    </span><span class="c1">// but we will skip those for brevity.</span>
<span class="p">};</span>

<span class="n">Point</span><span class="w"> </span><span class="n">Point</span><span class="o">::</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Create a new point that is the sum of this one and rhs.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// It&#39;s good practice to return a reference to the leftmost variable of</span>
<span class="c1">// an assignment. `(a += b) == c` will work this way.</span>
<span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Point</span><span class="o">::</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// `this` is a pointer to the object, on which a method is called.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="nf">up</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="nf">right</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// This calls the Point + operator</span>
<span class="w">    </span><span class="c1">// Point up calls the + (function) with right as its parameter</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Prints &quot;Result is upright (1,1)&quot;</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Result is upright (&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;,&#39;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/////////////////////</span>
<span class="c1">// Templates</span>
<span class="c1">/////////////////////</span>

<span class="c1">// Templates in C++ are mostly used for generic programming, though they are</span>
<span class="c1">// much more powerful than generic constructs in other languages. They also</span>
<span class="c1">// support explicit and partial specialization and functional-style type</span>
<span class="c1">// classes; in fact, they are a Turing-complete functional language embedded</span>
<span class="c1">// in C++!</span>

<span class="c1">// We start with the kind of generic programming you might be familiar with. To</span>
<span class="c1">// define a class or function that takes a type parameter:</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Box</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// In this class, T can be used as any other type.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// During compilation, the compiler actually generates copies of each template</span>
<span class="c1">// with parameters substituted, so the full definition of the class must be</span>
<span class="c1">// present at each invocation. This is why you will see template classes defined</span>
<span class="c1">// entirely in header files.</span>

<span class="c1">// To instantiate a template class on the stack:</span>
<span class="n">Box</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">intBox</span><span class="p">;</span>

<span class="c1">// and you can use it as you would expect:</span>
<span class="n">intBox</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>

<span class="c1">// You can, of course, nest templates:</span>
<span class="n">Box</span><span class="o">&lt;</span><span class="n">Box</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">boxOfBox</span><span class="p">;</span>
<span class="n">boxOfBox</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">intBox</span><span class="p">);</span>

<span class="c1">// Until C++11, you had to place a space between the two &#39;&gt;&#39;s, otherwise &#39;&gt;&gt;&#39;</span>
<span class="c1">// would be parsed as the right shift operator.</span>

<span class="c1">// You will sometimes see</span>
<span class="c1">//   template&lt;typename T&gt;</span>
<span class="c1">// instead. The &#39;class&#39; keyword and &#39;typename&#39; keywords are _mostly_</span>
<span class="c1">// interchangeable in this case. For the full explanation, see</span>
<span class="c1">//   https://en.wikipedia.org/wiki/Typename</span>
<span class="c1">// (yes, that keyword has its own Wikipedia page).</span>

<span class="c1">// Similarly, a template function:</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">barkThreeTimes</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">input</span><span class="p">.</span><span class="n">bark</span><span class="p">();</span>
<span class="w">    </span><span class="n">input</span><span class="p">.</span><span class="n">bark</span><span class="p">();</span>
<span class="w">    </span><span class="n">input</span><span class="p">.</span><span class="n">bark</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Notice that nothing is specified about the type parameters here. The compiler</span>
<span class="c1">// will generate and then type-check every invocation of the template, so the</span>
<span class="c1">// above function works with any type &#39;T&#39; that has a const &#39;bark&#39; method!</span>

<span class="n">Dog</span><span class="w"> </span><span class="n">fluffy</span><span class="p">;</span>
<span class="n">fluffy</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">&quot;Fluffy&quot;</span><span class="p">)</span>
<span class="n">barkThreeTimes</span><span class="p">(</span><span class="n">fluffy</span><span class="p">);</span><span class="w"> </span><span class="c1">// Prints &quot;Fluffy barks&quot; three times.</span>

<span class="c1">// Template parameters don&#39;t have to be classes:</span>
<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">Y</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">printMessage</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Learn C++ in &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; minutes!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// And you can explicitly specialize templates for more efficient code. Of</span>
<span class="c1">// course, most real-world uses of specialization are not as trivial as this.</span>
<span class="c1">// Note that you still need to declare the function (or class) as a template</span>
<span class="c1">// even if you explicitly specified all parameters.</span>
<span class="k">template</span><span class="o">&lt;&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">printMessage</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Learn C++ faster in only 10 minutes!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">printMessage</span><span class="o">&lt;</span><span class="mi">20</span><span class="o">&gt;</span><span class="p">();</span><span class="w">  </span><span class="c1">// Prints &quot;Learn C++ in 20 minutes!&quot;</span>
<span class="n">printMessage</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span><span class="p">();</span><span class="w">  </span><span class="c1">// Prints &quot;Learn C++ faster in only 10 minutes!&quot;</span>


<span class="c1">/////////////////////</span>
<span class="c1">// Exception Handling</span>
<span class="c1">/////////////////////</span>

<span class="c1">// The standard library provides a few exception types</span>
<span class="c1">// (see https://en.cppreference.com/w/cpp/error/exception)</span>
<span class="c1">// but any type can be thrown as an exception</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exception&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdexcept&gt;</span>

<span class="c1">// All exceptions thrown inside the _try_ block can be caught by subsequent</span>
<span class="c1">// _catch_ handlers.</span>
<span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Do not allocate exceptions on the heap using _new_.</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;A problem occurred&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Catch exceptions by const reference if they are objects</span>
<span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Catches any exception not caught by previous _catch_ blocks</span>
<span class="k">catch</span><span class="w"> </span><span class="p">(...)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Unknown exception caught&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">throw</span><span class="p">;</span><span class="w"> </span><span class="c1">// Re-throws the exception</span>
<span class="p">}</span>

<span class="c1">///////</span>
<span class="c1">// RAII</span>
<span class="c1">///////</span>

<span class="c1">// RAII stands for &quot;Resource Acquisition Is Initialization&quot;.</span>
<span class="c1">// It is often considered the most powerful paradigm in C++</span>
<span class="c1">// and is the simple concept that a constructor for an object</span>
<span class="c1">// acquires that object&#39;s resources and the destructor releases them.</span>

<span class="c1">// To understand how this is useful,</span>
<span class="c1">// consider a function that uses a C file handle:</span>
<span class="kt">void</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// To begin with, assume nothing can fail.</span>

<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Open the file in read mode.</span>

<span class="w">    </span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Close the file handle.</span>
<span class="p">}</span>

<span class="c1">// Unfortunately, things are quickly complicated by error handling.</span>
<span class="c1">// Suppose fopen can fail, and that doSomethingWithTheFile and</span>
<span class="c1">// doSomethingElseWithIt return error codes if they fail.</span>
<span class="c1">//  (Exceptions are the preferred way of handling failure,</span>
<span class="c1">//   but some programmers, especially those with a C background,</span>
<span class="c1">//   disagree on the utility of exceptions).</span>
<span class="c1">// We now have to check each call for failure and close the file handle</span>
<span class="c1">// if a problem occurred.</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Open the file in read mode</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fh</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="c1">// The returned pointer is null on failure.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Report that failure to the caller.</span>

<span class="w">    </span><span class="c1">// Assume each function returns false if it failed</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Close the file handle so it doesn&#39;t leak.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Propagate the error.</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Close the file handle so it doesn&#39;t leak.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Propagate the error.</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Close the file handle so it doesn&#39;t leak.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// Indicate success</span>
<span class="p">}</span>

<span class="c1">// C programmers often clean this up a little bit using goto:</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fh</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">failure</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">failure</span><span class="p">;</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Close the file</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// Indicate success</span>

<span class="nl">failure</span><span class="p">:</span>
<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Propagate the error</span>
<span class="p">}</span>

<span class="c1">// If the functions indicate errors using exceptions,</span>
<span class="c1">// things are a little cleaner, but still sub-optimal.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Open the file in shared_ptrread mode</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fh</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Could not open the file.&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">        </span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">catch</span><span class="w"> </span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Be sure to close the file if an error occurs.</span>
<span class="w">        </span><span class="k">throw</span><span class="p">;</span><span class="w"> </span><span class="c1">// Then re-throw the exception.</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Close the file</span>
<span class="w">    </span><span class="c1">// Everything succeeded</span>
<span class="p">}</span>

<span class="c1">// Compare this to the use of C++&#39;s file stream class (fstream)</span>
<span class="c1">// fstream uses its destructor to close the file.</span>
<span class="c1">// Recall from above that destructors are automatically called</span>
<span class="c1">// whenever an object falls out of scope.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// ifstream is short for input file stream</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span><span class="w"> </span><span class="nf">fh</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span><span class="w"> </span><span class="c1">// Open the file</span>

<span class="w">    </span><span class="c1">// Do things with the file</span>
<span class="w">    </span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// The file is automatically closed here by the destructor</span>

<span class="c1">// This has _massive_ advantages:</span>
<span class="c1">// 1. No matter what happens,</span>
<span class="c1">//    the resource (in this case the file handle) will be cleaned up.</span>
<span class="c1">//    Once you write the destructor correctly,</span>
<span class="c1">//    It is _impossible_ to forget to close the handle and leak the resource.</span>
<span class="c1">// 2. Note that the code is much cleaner.</span>
<span class="c1">//    The destructor handles closing the file behind the scenes</span>
<span class="c1">//    without you having to worry about it.</span>
<span class="c1">// 3. The code is exception safe.</span>
<span class="c1">//    An exception can be thrown anywhere in the function and cleanup</span>
<span class="c1">//    will still occur.</span>

<span class="c1">// All idiomatic C++ code uses RAII extensively for all resources.</span>
<span class="c1">// Additional examples include</span>
<span class="c1">// - Memory using unique_ptr and shared_ptr</span>
<span class="c1">// - Containers - the standard library linked list,</span>
<span class="c1">//   vector (i.e. self-resizing array), hash maps, and so on</span>
<span class="c1">//   all automatically destroy their contents when they fall out of scope.</span>
<span class="c1">// - Mutexes using lock_guard and unique_lock</span>


<span class="c1">/////////////////////</span>
<span class="c1">// Smart Pointer</span>
<span class="c1">/////////////////////</span>

<span class="c1">// Generally a smart pointer is a class which wraps a &quot;raw pointer&quot; (usage of &quot;new&quot;</span>
<span class="c1">// respectively malloc/calloc in C). The goal is to be able to</span>
<span class="c1">// manage the lifetime of the object being pointed to without ever needing to explicitly delete </span>
<span class="c1">// the object. The term itself simply describes a set of pointers with the</span>
<span class="c1">// mentioned abstraction.</span>
<span class="c1">// Smart pointers should preferred over raw pointers, to prevent</span>
<span class="c1">// risky memory leaks, which happen if you forget to delete an object.</span>

<span class="c1">// Usage of a raw pointer:</span>
<span class="n">Dog</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Dog</span><span class="p">();</span>
<span class="n">ptr</span><span class="o">-&gt;</span><span class="n">bark</span><span class="p">();</span>
<span class="k">delete</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span>

<span class="c1">// By using a smart pointer, you don&#39;t have to worry about the deletion</span>
<span class="c1">// of the object anymore.</span>
<span class="c1">// A smart pointer describes a policy, to count the references to the</span>
<span class="c1">// pointer. The object gets destroyed when the last</span>
<span class="c1">// reference to the object gets destroyed.</span>

<span class="c1">// Usage of &quot;std::shared_ptr&quot;:</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">// It&#39;s no longer necessary to delete the Dog.</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;</span><span class="w"> </span><span class="n">doggo</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Dog</span><span class="p">());</span>
<span class="n">doggo</span><span class="o">-&gt;</span><span class="n">bark</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Beware of possible circular references!!!</span>
<span class="c1">// There will be always a reference, so it will be never destroyed!</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;</span><span class="w"> </span><span class="n">doggo_one</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Dog</span><span class="p">());</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;</span><span class="w"> </span><span class="n">doggo_two</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Dog</span><span class="p">());</span>
<span class="n">doggo_one</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">doggo_two</span><span class="p">;</span><span class="w"> </span><span class="c1">// p1 references p2</span>
<span class="n">doggo_two</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">doggo_one</span><span class="p">;</span><span class="w"> </span><span class="c1">// p2 references p1</span>

<span class="c1">// There are several kinds of smart pointers. </span>
<span class="c1">// The way you have to use them is always the same.</span>
<span class="c1">// This leads us to the question: when should we use each kind of smart pointer?</span>
<span class="c1">// std::unique_ptr - use it when you just want to hold one reference to</span>
<span class="c1">// the object.</span>
<span class="c1">// std::shared_ptr - use it when you want to hold multiple references to the</span>
<span class="c1">// same object and want to make sure that it&#39;s deallocated</span>
<span class="c1">// when all references are gone.</span>
<span class="c1">// std::weak_ptr - use it when you want to access</span>
<span class="c1">// the underlying object of a std::shared_ptr without causing that object to stay allocated.</span>
<span class="c1">// Weak pointers are used to prevent circular referencing.</span>


<span class="c1">/////////////////////</span>
<span class="c1">// Containers</span>
<span class="c1">/////////////////////</span>

<span class="c1">// Containers or the Standard Template Library are some predefined templates.</span>
<span class="c1">// They manage the storage space for its elements and provide</span>
<span class="c1">// member functions to access and manipulate them.</span>

<span class="c1">// Few containers are as follows:</span>

<span class="c1">// Vector (Dynamic array)</span>
<span class="c1">// Allow us to Define the Array or list of objects at run time</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<span class="n">string</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">my_vector</span><span class="p">;</span><span class="w"> </span><span class="c1">// initialize the vector</span>
<span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="n">my_vector</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">val</span><span class="p">);</span><span class="w"> </span><span class="c1">// will push the value of &#39;val&#39; into vector (&quot;array&quot;) my_vector</span>
<span class="n">my_vector</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">val</span><span class="p">);</span><span class="w"> </span><span class="c1">// will push the value into the vector again (now having two elements)</span>

<span class="c1">// To iterate through a vector we have 2 choices:</span>
<span class="c1">// Either classic looping (iterating through the vector from index 0 to its last index):</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">my_vector</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">my_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// for accessing a vector&#39;s element we can use the operator []</span>
<span class="p">}</span>

<span class="c1">// or using an iterator:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="p">;</span><span class="w"> </span><span class="c1">// initialize the iterator for vector</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_vector</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">my_vector</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="w">  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Set</span>
<span class="c1">// Sets are containers that store unique elements following a specific order.</span>
<span class="c1">// Set is a very useful container to store unique values in sorted order</span>
<span class="c1">// without any other functions or code.</span>

<span class="cp">#include</span><span class="cpf">&lt;set&gt;</span>
<span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ST</span><span class="p">;</span><span class="w">    </span><span class="c1">// Will initialize the set of int data type</span>
<span class="n">ST</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span><span class="w">  </span><span class="c1">// Will insert the value 30 in set ST</span>
<span class="n">ST</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w">  </span><span class="c1">// Will insert the value 10 in set ST</span>
<span class="n">ST</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w">  </span><span class="c1">// Will insert the value 20 in set ST</span>
<span class="n">ST</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span><span class="w">  </span><span class="c1">// Will insert the value 30 in set ST</span>
<span class="c1">// Now elements of sets are as follows</span>
<span class="c1">//  10 20 30</span>

<span class="c1">// To erase an element</span>
<span class="n">ST</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w">  </span><span class="c1">// Will erase element with value 20</span>
<span class="c1">// Set ST: 10 30</span>
<span class="c1">// To iterate through Set we use iterators</span>
<span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="n">it</span><span class="o">=</span><span class="n">ST</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="n">it</span><span class="o">!=</span><span class="n">ST</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="n">it</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// Output:</span>
<span class="c1">// 10</span>
<span class="c1">// 30</span>

<span class="c1">// To clear the complete container we use Container_name.clear()</span>
<span class="n">ST</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ST</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w">  </span><span class="c1">// will print the size of set ST</span>
<span class="c1">// Output: 0</span>

<span class="c1">// NOTE: for duplicate elements we can use multiset</span>
<span class="c1">// NOTE: For hash sets, use unordered_set. They are more efficient but</span>
<span class="c1">// do not preserve order. unordered_set is available since C++11</span>

<span class="c1">// Map</span>
<span class="c1">// Maps store elements formed by a combination of a key value</span>
<span class="c1">// and a mapped value, following a specific order.</span>

<span class="cp">#include</span><span class="cpf">&lt;map&gt;</span>
<span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mymap</span><span class="p">;</span><span class="w">  </span><span class="c1">// Will initialize the map with key as char and value as int</span>

<span class="n">mymap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="sc">&#39;A&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
<span class="c1">// Will insert value 1 for key A</span>
<span class="n">mymap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="sc">&#39;Z&#39;</span><span class="p">,</span><span class="mi">26</span><span class="p">));</span>
<span class="c1">// Will insert value 26 for key Z</span>

<span class="c1">// To iterate</span>
<span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">it</span><span class="o">=</span><span class="n">mymap</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="o">!=</span><span class="n">mymap</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;-&gt;&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="c1">// Output:</span>
<span class="c1">// A-&gt;1</span>
<span class="c1">// Z-&gt;26</span>

<span class="c1">// To find the value corresponding to a key</span>
<span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mymap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39;Z&#39;</span><span class="p">);</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>

<span class="c1">// Output: 26</span>

<span class="c1">// NOTE: For hash maps, use unordered_map. They are more efficient but do</span>
<span class="c1">// not preserve order. unordered_map is available since C++11.</span>

<span class="c1">// Containers with object keys of non-primitive values (custom classes) require</span>
<span class="c1">// compare function in the object itself or as a function pointer. Primitives</span>
<span class="c1">// have default comparators, but you can override it.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">    </span><span class="n">Foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">j</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">compareFunction</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">Foo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Foo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">j</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="c1">// this isn&#39;t allowed (although it can vary depending on compiler)</span>
<span class="c1">// std::map&lt;Foo, int&gt; fooMap;</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">compareFunction</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fooMap</span><span class="p">;</span>
<span class="n">fooMap</span><span class="p">[</span><span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">fooMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w"> </span><span class="c1">//true</span>


<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Lambda Expressions (C++11 and above)</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// lambdas are a convenient way of defining an anonymous function</span>
<span class="c1">// object right at the location where it is invoked or passed as</span>
<span class="c1">// an argument to a function.</span>

<span class="c1">// For example, consider sorting a vector of pairs using the second</span>
<span class="c1">// value of the pair</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">tester</span><span class="p">;</span>
<span class="n">tester</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">));</span>
<span class="n">tester</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">));</span>
<span class="n">tester</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span>

<span class="c1">// Pass a lambda expression as third argument to the sort function</span>
<span class="c1">// sort is from the &lt;algorithm&gt; header</span>

<span class="n">sort</span><span class="p">(</span><span class="n">tester</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">tester</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">lhs</span><span class="p">.</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<span class="w">    </span><span class="p">});</span>

<span class="c1">// Notice the syntax of the lambda expression,</span>
<span class="c1">// [] in the lambda is used to &quot;capture&quot; variables</span>
<span class="c1">// The &quot;Capture List&quot; defines what from the outside of the lambda should be available inside the function body and how.</span>
<span class="c1">// It can be either:</span>
<span class="c1">//     1. a value : [x]</span>
<span class="c1">//     2. a reference : [&amp;x]</span>
<span class="c1">//     3. any variable currently in scope by reference [&amp;]</span>
<span class="c1">//     4. same as 3, but by value [=]</span>
<span class="c1">// Example:</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dog_ids</span><span class="p">;</span>
<span class="c1">// number_of_dogs = 3;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">dog_ids</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">weight</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">30</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">};</span>

<span class="c1">// Say you want to sort dog_ids according to the dogs&#39; weights</span>
<span class="c1">// So dog_ids should in the end become: [2, 0, 1]</span>

<span class="c1">// Here&#39;s where lambda expressions come in handy</span>

<span class="n">sort</span><span class="p">(</span><span class="n">dog_ids</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">dog_ids</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">weight</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">weight</span><span class="p">[</span><span class="n">lhs</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">weight</span><span class="p">[</span><span class="n">rhs</span><span class="p">];</span>
<span class="w">    </span><span class="p">});</span>
<span class="c1">// Note we captured &quot;weight&quot; by reference in the above example.</span>
<span class="c1">// More on Lambdas in C++ : https://stackoverflow.com/questions/7627098/what-is-a-lambda-expression-in-c11</span>

<span class="c1">///////////////////////////////</span>
<span class="c1">// Range For (C++11 and above)</span>
<span class="c1">///////////////////////////////</span>

<span class="c1">// You can use a range for loop to iterate over a container</span>
<span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span>

<span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">elem</span><span class="o">:</span><span class="w"> </span><span class="n">arr</span><span class="p">){</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// You can use &quot;auto&quot; and not worry about the type of the elements of the container</span>
<span class="c1">// For example:</span>

<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">elem</span><span class="o">:</span><span class="w"> </span><span class="n">arr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Do something with each element of arr</span>
<span class="p">}</span>

<span class="c1">/////////////////////</span>
<span class="c1">// Fun stuff</span>
<span class="c1">/////////////////////</span>

<span class="c1">// Aspects of C++ that may be surprising to newcomers (and even some veterans).</span>
<span class="c1">// This section is, unfortunately, wildly incomplete; C++ is one of the easiest</span>
<span class="c1">// languages with which to shoot yourself in the foot.</span>

<span class="c1">// You can override private methods!</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">();</span>
<span class="p">};</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FooSub</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">();</span><span class="w">  </span><span class="c1">// Overrides Foo::bar!</span>
<span class="p">};</span>


<span class="c1">// 0 == false == NULL (most of the time)!</span>
<span class="kt">bool</span><span class="o">*</span><span class="w"> </span><span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">bool</span><span class="p">;</span>
<span class="o">*</span><span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// Sets the value points by &#39;pt&#39; to false.</span>
<span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// Sets &#39;pt&#39; to the null pointer. Both lines compile without warnings.</span>

<span class="c1">// nullptr is supposed to fix some of that issue:</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">pt2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>
<span class="o">*</span><span class="n">pt2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"> </span><span class="c1">// Doesn&#39;t compile</span>
<span class="n">pt2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w">  </span><span class="c1">// Sets pt2 to null.</span>

<span class="c1">// There is an exception made for bools.</span>
<span class="c1">// This is to allow you to test for null pointers with if(!ptr),</span>
<span class="c1">// but as a consequence you can assign nullptr to a bool directly!</span>
<span class="o">*</span><span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w">  </span><span class="c1">// This still compiles, even though &#39;*pt&#39; is a bool!</span>


<span class="c1">// &#39;=&#39; != &#39;=&#39; != &#39;=&#39;!</span>
<span class="c1">// Calls Foo::Foo(const Foo&amp;) or some variant (see move semantics) copy</span>
<span class="c1">// constructor.</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span>

<span class="c1">// Calls Foo::Foo(const Foo&amp;) or variant, but only copies the &#39;Foo&#39; part of</span>
<span class="c1">// &#39;fooSub&#39;. Any extra members of &#39;fooSub&#39; are discarded. This sometimes</span>
<span class="c1">// horrifying behavior is called &quot;object slicing.&quot;</span>
<span class="n">FooSub</span><span class="w"> </span><span class="n">fooSub</span><span class="p">;</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fooSub</span><span class="p">;</span>

<span class="c1">// Calls Foo::operator=(Foo&amp;) or variant.</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f1</span><span class="p">;</span>
<span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span>


<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Tuples (C++11 and above)</span>
<span class="c1">///////////////////////////////////////</span>

<span class="cp">#include</span><span class="cpf">&lt;tuple&gt;</span>

<span class="c1">// Conceptually, Tuples are similar to old data structures (C-like structs)</span>
<span class="c1">// but instead of having named data members,</span>
<span class="c1">// its elements are accessed by their order in the tuple.</span>

<span class="c1">// We start with constructing a tuple.</span>
<span class="c1">// Packing values into tuple</span>
<span class="k">auto</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;A&#39;</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maxN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1e9</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maxL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">15</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_tuple</span><span class="p">(</span><span class="n">maxN</span><span class="p">,</span><span class="w"> </span><span class="n">maxL</span><span class="p">);</span>

<span class="c1">// Printing elements of &#39;first&#39; tuple</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">first</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">first</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">//prints : 10 A</span>

<span class="c1">// Printing elements of &#39;second&#39; tuple</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">second</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">second</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// prints: 1000000000 15</span>

<span class="c1">// Unpacking tuple into variables</span>

<span class="kt">int</span><span class="w"> </span><span class="n">first_int</span><span class="p">;</span>
<span class="kt">char</span><span class="w"> </span><span class="n">first_char</span><span class="p">;</span>
<span class="n">tie</span><span class="p">(</span><span class="n">first_int</span><span class="p">,</span><span class="w"> </span><span class="n">first_char</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first</span><span class="p">;</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">first_int</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">first_char</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span><span class="w">  </span><span class="c1">// prints : 10 A</span>

<span class="c1">// We can also create tuple like this.</span>

<span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">third</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;A&#39;</span><span class="p">,</span><span class="w"> </span><span class="mf">3.14141</span><span class="p">);</span>
<span class="c1">// tuple_size returns number of elements in a tuple (as a constexpr)</span>

<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">tuple_size</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">third</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// prints: 3</span>

<span class="c1">// tuple_cat concatenates the elements of all the tuples in the same order.</span>

<span class="k">auto</span><span class="w"> </span><span class="n">concatenated_tuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tuple_cat</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">second</span><span class="p">,</span><span class="w"> </span><span class="n">third</span><span class="p">);</span>
<span class="c1">// concatenated_tuple becomes = (10, &#39;A&#39;, 1e9, 15, 11, &#39;A&#39;, 3.14141)</span>

<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">concatenated_tuple</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// prints: 10</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">concatenated_tuple</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// prints: 15</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">&gt;</span><span class="p">(</span><span class="n">concatenated_tuple</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// prints: &#39;A&#39;</span>


<span class="c1">///////////////////////////////////</span>
<span class="c1">// Logical and Bitwise operators</span>
<span class="c1">//////////////////////////////////</span>

<span class="c1">// Most of the operators in C++ are same as in other languages</span>

<span class="c1">// Logical operators</span>

<span class="c1">// C++ uses Short-circuit evaluation for boolean expressions, i.e, the second argument is executed or</span>
<span class="c1">// evaluated only if the first argument does not suffice to determine the value of the expression</span>

<span class="nb">true</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="c1">// Performs **logical and** to yield false</span>
<span class="nb">true</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="c1">// Performs **logical or** to yield true</span>
<span class="o">!</span><span class="w"> </span><span class="nb">true</span><span class="w">        </span><span class="c1">// Performs **logical not** to yield false</span>

<span class="c1">// Instead of using symbols equivalent keywords can be used</span>
<span class="nb">true</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="c1">// Performs **logical and** to yield false</span>
<span class="nb">true</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="nb">false</span><span class="w">  </span><span class="c1">// Performs **logical or** to yield true</span>
<span class="n">not</span><span class="w"> </span><span class="nb">true</span><span class="w">       </span><span class="c1">// Performs **logical not** to yield false</span>

<span class="c1">// Bitwise operators</span>

<span class="c1">// **&lt;&lt;** Left Shift Operator</span>
<span class="c1">// &lt;&lt; shifts bits to the left</span>
<span class="mi">4</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// Shifts bits of 4 to left by 1 to give 8</span>
<span class="c1">// x &lt;&lt; n can be thought as x * 2^n</span>


<span class="c1">// **&gt;&gt;** Right Shift Operator</span>
<span class="c1">// &gt;&gt; shifts bits to the right</span>
<span class="mi">4</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// Shifts bits of 4 to right by 1 to give 2</span>
<span class="c1">// x &gt;&gt; n can be thought as x / 2^n</span>

<span class="o">~</span><span class="mi">4</span><span class="w">    </span><span class="c1">// Performs a bitwise not</span>
<span class="mi">4</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">// Performs bitwise or</span>
<span class="mi">4</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">// Performs bitwise and</span>
<span class="mi">4</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">// Performs bitwise xor</span>

<span class="c1">// Equivalent keywords are</span>
<span class="n">compl</span><span class="w"> </span><span class="mi">4</span><span class="w">    </span><span class="c1">// Performs a bitwise not</span>
<span class="mi">4</span><span class="w"> </span><span class="n">bitor</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="c1">// Performs bitwise or</span>
<span class="mi">4</span><span class="w"> </span><span class="n">bitand</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">// Performs bitwise and</span>
<span class="mi">4</span><span class="w"> </span><span class="n">xor</span><span class="w"> </span><span class="mi">3</span><span class="w">    </span><span class="c1">// Performs bitwise xor</span>
</pre></div>
<p>Further Reading:</p>

<ul>
<li>An up-to-date language reference can be found at <a href="http://cppreference.com/w/cpp">CPP Reference</a>.</li>
<li>A tutorial  for beginners or experts, covering many modern features and good practices: <a href="https://www.learncpp.com/">LearnCpp.com</a></li>
<li>A tutorial covering basics of language and setting up coding environment is available at <a href="https://www.youtube.com/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb">TheChernoProject - C++</a>.</li>
<li>Additional resources may be found at <a href="http://cplusplus.com">CPlusPlus</a>.</li>
</ul>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the GitHub Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/c++.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by Steven Basart, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/c++.html.markdown">44 contributors</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="https://github.com/xksteven">Steven Basart</a>,
        <a href="https://github.com/mrkline">Matt Kline</a>,
        <a href="http://geoffliu.me">Geoff Liu</a>,
        <a href="https://github.com/connorwaters">Connor Waters</a>,
        <a href="https://github.com/ankushg07">Ankush Goyal</a>,
        <a href="https://github.com/jatindhankhar">Jatin Dhankhar</a>
    </p>

    <p>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
