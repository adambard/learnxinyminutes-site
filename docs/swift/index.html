<!DOCTYPE html lang="en-us" xml:lang="en-us" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="en-us">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn swift in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/swift/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fswift%2F&text=Learn+X+in+Y+minutes%2C+where+X%3Dswift">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="/">Learn X in Y minutes</a></h1>
  <h2>Where X=swift</h2>
    <p class="filelink">
    Get the code:
    <a href="/docs/files/learnswift.swift">learnswift.swift</a>
    </p>
  <div id="doc">
    <p>Swift is a programming language for iOS and macOS development created by Apple. Designed to coexist with Objective-C and to be more resilient against erroneous code, Swift was introduced in 2014 at Apple&rsquo;s developer conference WWDC. It is built with the LLVM compiler included in Xcode 6+.</p>

<p>The official <em><a href="https://itunes.apple.com/us/book/swift-programming-language/id881256329">Swift Programming Language</a></em> book from Apple is now available via Apple Books. It goes into much more detail than this guide, and if you have the time and patience to read it, it&rsquo;s recommended. Some of these examples are from that book.</p>

<p>Another great reference is <em>About Swift</em> on Swift&rsquo;s <a href="https://docs.swift.org/swift-book/">website</a>.</p>
<div class="highlight"><pre class="highlight swift"><code><span class="c1">// import a module</span>
<span class="kd">import</span> <span class="kt">Foundation</span>

<span class="c1">// Single-line comments are prefixed with //</span>
<span class="c1">// Multi-line comments start with /* and end with */</span>
<span class="cm">/* Nested multiline comments
 /* ARE */
 allowed
 */</span>

<span class="c1">// Xcode supports landmarks to annotate your code and lists them in the jump bar</span>
<span class="c1">// MARK: Section mark</span>
<span class="c1">// MARK: - Section mark with a separator line</span>
<span class="c1">// TODO: Do something soon</span>
<span class="c1">// FIXME: Fix this code</span>

<span class="c1">//MARK: Hello, World</span>
<span class="c1">// From Swift 3 on, to print, just use the `print` method.</span>
<span class="c1">// It automatically appends a new line.</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Hello, world"</span><span class="p">)</span>

<span class="c1">//</span>
<span class="c1">// MARK: - Variables</span>
<span class="c1">//</span>


<span class="c1">//Use `let` to declare a constant and `var` to declare a variable.</span>
<span class="k">let</span> <span class="nv">theAnswer</span> <span class="o">=</span> <span class="mi">42</span>
<span class="k">var</span> <span class="nv">theQuestion</span> <span class="o">=</span> <span class="s">"What is the Answer?"</span>
<span class="n">theQuestion</span> <span class="o">=</span> <span class="s">"How many roads must a man walk down?"</span>
<span class="n">theQuestion</span> <span class="o">=</span> <span class="s">"What is six by nine?"</span>
<span class="c1">// Atttempting to reassign a constant throws a compile-time error</span>
<span class="c1">//theAnswer = 54</span>

<span class="c1">// Both variables and constants can be declared before they are given a value,</span>
<span class="c1">//   but must be given a value before they are used</span>
<span class="k">let</span> <span class="nv">someConstant</span><span class="p">:</span> <span class="kt">Int</span>
<span class="k">var</span> <span class="nv">someVariable</span><span class="p">:</span> <span class="kt">String</span>
<span class="c1">// These lines will throw errors:</span>
<span class="c1">//print(someConstant)</span>
<span class="c1">//print(someVariable)</span>
<span class="n">someConstant</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">someVariable</span> <span class="o">=</span> <span class="s">"0"</span>
<span class="c1">// These lines are now valid:</span>
<span class="nf">print</span><span class="p">(</span><span class="n">someConstant</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">someVariable</span><span class="p">)</span>

<span class="c1">// As you can see above, variable types are automatically inferred.</span>
<span class="c1">//   To explicitly declare the type, write it after the variable name,</span>
<span class="c1">//   separated by a colon.</span>
<span class="k">let</span> <span class="nv">aString</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"A string"</span>
<span class="k">let</span> <span class="nv">aDouble</span><span class="p">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1">// Values are never implicitly converted to another type.</span>
<span class="c1">// Explicitly make instances of the desired type.</span>
<span class="k">let</span> <span class="nv">stringWithDouble</span> <span class="o">=</span> <span class="n">aString</span> <span class="o">+</span> <span class="kt">String</span><span class="p">(</span><span class="n">aDouble</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">intFromDouble</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="n">aDouble</span><span class="p">)</span>

<span class="c1">// For strings, use string interpolation</span>
<span class="k">let</span> <span class="nv">descriptionString</span> <span class="o">=</span> <span class="s">"The value of aDouble is </span><span class="se">\(</span><span class="n">aDouble</span><span class="se">)</span><span class="s">"</span>
<span class="c1">// You can put any expression inside string interpolation.</span>
<span class="k">let</span> <span class="nv">equation</span> <span class="o">=</span> <span class="s">"Six by nine is </span><span class="se">\(</span><span class="mi">6</span> <span class="o">*</span> <span class="mi">9</span><span class="se">)</span><span class="s">, not 42!"</span>
<span class="c1">// To avoid escaping double quotes and backslashes, change the string delimiter</span>
<span class="k">let</span> <span class="nv">explanationString</span> <span class="o">=</span> <span class="err">#</span><span class="s">"The string I used was "</span><span class="kt">The</span> <span class="n">value</span> <span class="n">of</span> <span class="n">aDouble</span> <span class="k">is</span> <span class="p">\(</span><span class="n">aDouble</span><span class="p">)</span><span class="s">" and the result was </span><span class="err">\</span><span class="s">#(descriptionString)"</span><span class="err">#</span>
<span class="c1">// You can put as many number signs as you want before the opening quote,</span>
<span class="c1">//   just match them at the ending quote. They also change the escape character</span>
<span class="c1">//   to a backslash followed by the same number of number signs.</span>

<span class="k">let</span> <span class="nv">multiLineString</span> <span class="o">=</span> <span class="s">"""
    This is a multi-line string.
    It's called that because it takes up multiple lines (wow!)
        Any indentation beyond the closing quotation marks is kept, the rest is discarded.
    You can include "</span> <span class="n">or</span> <span class="s">""</span> <span class="k">in</span> <span class="n">multi</span><span class="o">-</span><span class="n">line</span> <span class="n">strings</span> <span class="n">because</span> <span class="n">the</span> <span class="n">delimiter</span> <span class="k">is</span> <span class="n">three</span> <span class="s">"s.
    """</span>

<span class="c1">// Arrays</span>
<span class="k">let</span> <span class="nv">shoppingList</span> <span class="o">=</span> <span class="p">[</span><span class="s">"catfish"</span><span class="p">,</span> <span class="s">"water"</span><span class="p">,</span> <span class="s">"tulips"</span><span class="p">,]</span> <span class="c1">//commas are allowed after the last element</span>
<span class="k">let</span> <span class="nv">secondElement</span> <span class="o">=</span> <span class="n">shoppingList</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// Arrays are 0-indexed</span>

<span class="c1">// Arrays declared with let are immutable; the following line throws a compile-time error</span>
<span class="c1">//shoppingList[2] = "mango"</span>

<span class="c1">// Arrays are structs (more on that later), so this creates a copy instead of referencing the same object</span>
<span class="k">var</span> <span class="nv">mutableShoppingList</span> <span class="o">=</span> <span class="n">shoppingList</span>
<span class="n">mutableShoppingList</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">"mango"</span>

<span class="c1">// == is equality</span>
<span class="n">shoppingList</span> <span class="o">==</span> <span class="n">mutableShoppingList</span> <span class="c1">// false</span>

<span class="c1">// Dictionaries declared with let are also immutable</span>
<span class="k">var</span> <span class="nv">occupations</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">"Malcolm"</span><span class="p">:</span> <span class="s">"Captain"</span><span class="p">,</span>
    <span class="s">"Kaylee"</span><span class="p">:</span> <span class="s">"Mechanic"</span>
<span class="p">]</span>
<span class="n">occupations</span><span class="p">[</span><span class="s">"Jayne"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Public Relations"</span>
<span class="c1">// Dictionaries are also structs, so this also creates a copy</span>
<span class="k">let</span> <span class="nv">immutableOccupations</span> <span class="o">=</span> <span class="n">occupations</span>

<span class="n">immutableOccupations</span> <span class="o">==</span> <span class="n">occupations</span> <span class="c1">// true</span>

<span class="c1">// Arrays and dictionaries both automatically grow as you add elements</span>
<span class="n">mutableShoppingList</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="s">"blue paint"</span><span class="p">)</span>
<span class="n">occupations</span><span class="p">[</span><span class="s">"Tim"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"CEO"</span>

<span class="c1">// They can both be set to empty</span>
<span class="n">mutableShoppingList</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">occupations</span> <span class="o">=</span> <span class="p">[:]</span>

<span class="k">let</span> <span class="nv">emptyArray</span> <span class="o">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">]()</span>
<span class="k">let</span> <span class="nv">emptyArray2</span> <span class="o">=</span> <span class="kt">Array</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span><span class="p">()</span> <span class="c1">// same as above</span>
<span class="c1">// [T] is shorthand for Array&lt;T&gt;</span>
<span class="k">let</span> <span class="nv">emptyArray3</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">// Declaring the type explicitly allows you to set it to an empty array</span>
<span class="k">let</span> <span class="nv">emptyArray4</span><span class="p">:</span> <span class="kt">Array</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">// same as above</span>

<span class="c1">// [Key: Value] is shorthand for Dictionary&lt;Key, Value&gt;</span>
<span class="k">let</span> <span class="nv">emptyDictionary</span> <span class="o">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">Double</span><span class="p">]()</span>
<span class="k">let</span> <span class="nv">emptyDictionary2</span> <span class="o">=</span> <span class="kt">Dictionary</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Double</span><span class="o">&gt;</span><span class="p">()</span> <span class="c1">// same as above</span>
<span class="k">var</span> <span class="nv">emptyMutableDictionary</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">Double</span><span class="p">]</span> <span class="o">=</span> <span class="p">[:]</span>
<span class="k">var</span> <span class="nv">explicitEmptyMutableDictionary</span><span class="p">:</span> <span class="kt">Dictionary</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Double</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[:]</span> <span class="c1">// same as above</span>

<span class="c1">// MARK: Other variables</span>
<span class="k">let</span> <span class="nv">Ã¸Ï€Î©</span> <span class="o">=</span> <span class="s">"value"</span> <span class="c1">// unicode variable names</span>
<span class="k">let</span> <span class="nv">ðŸ¤¯</span> <span class="o">=</span> <span class="s">"wow"</span> <span class="c1">// emoji variable names</span>

<span class="c1">// Keywords can be used as variable names</span>
<span class="c1">// These are contextual keywords that wouldn't be used now, so are allowed</span>
<span class="k">let</span> <span class="nv">convenience</span> <span class="o">=</span> <span class="s">"keyword"</span>
<span class="k">let</span> <span class="nv">weak</span> <span class="o">=</span> <span class="s">"another keyword"</span>
<span class="k">let</span> <span class="nv">override</span> <span class="o">=</span> <span class="s">"another keyword"</span>

<span class="c1">// Using backticks allows keywords to be used as variable names even if they wouldn't be allowed normally</span>
<span class="kd">let</span> <span class="p">`</span><span class="nv">class</span><span class="p">`</span> <span class="o">=</span> <span class="s">"keyword"</span>

<span class="c1">// MARK: - Optionals</span>

<span class="cm">/*
 Optionals are a Swift language feature that either contains a value,
 or contains nil (no value) to indicate that a value is missing.
 Nil is roughly equivalent to `null` in other languages.
 A question mark (?) after the type marks the value as optional of that type.

 If a type is not optional, it is guaranteed to have a value.

 Because Swift requires every property to have a type, even nil must be
 explicitly stored as an Optional value.

 Optional&lt;T&gt; is an enum, with the cases .none (nil) and .some(T) (the value)
 */</span>

<span class="k">var</span> <span class="nv">someOptionalString</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span> <span class="o">=</span> <span class="s">"optional"</span> <span class="c1">// Can be nil</span>
<span class="c1">// T? is shorthand for Optional&lt;T&gt; â€” ? is a postfix operator (syntax candy)</span>
<span class="k">let</span> <span class="nv">someOptionalString2</span><span class="p">:</span> <span class="kt">Optional</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kc">nil</span>
<span class="k">let</span> <span class="nv">someOptionalString3</span> <span class="o">=</span> <span class="kt">String</span><span class="p">?</span><span class="o">.</span><span class="nf">some</span><span class="p">(</span><span class="s">"optional"</span><span class="p">)</span> <span class="c1">// same as the first one</span>
<span class="k">let</span> <span class="nv">someOptionalString4</span> <span class="o">=</span> <span class="kt">String</span><span class="p">?</span><span class="o">.</span><span class="k">none</span> <span class="c1">//nil</span>

<span class="cm">/*
 To access the value of an optional that has a value, use the postfix
 operator !, which force-unwraps it. Force-unwrapping is like saying, "I
 know that this optional definitely has a value, please give it to me."

 Trying to use ! to access a non-existent optional value triggers a
 runtime error. Always make sure that an optional contains a non-nil
 value before using ! to force-unwrap its value.
 */</span>

<span class="k">if</span> <span class="n">someOptionalString</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="c1">// I am not nil</span>
    <span class="k">if</span> <span class="n">someOptionalString</span><span class="o">!.</span><span class="nf">hasPrefix</span><span class="p">(</span><span class="s">"opt"</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"has the prefix"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Swift supports "optional chaining," which means that you can call functions</span>
<span class="c1">//   or get properties of optional values and they are optionals of the appropriate type.</span>
<span class="c1">// You can even do this multiple times, hence the name "chaining."</span>

<span class="k">let</span> <span class="nv">empty</span> <span class="o">=</span> <span class="n">someOptionalString</span><span class="p">?</span><span class="o">.</span><span class="n">isEmpty</span> <span class="c1">// Bool?</span>

<span class="c1">// if-let structure -</span>
<span class="c1">// if-let is a special structure in Swift that allows you to check</span>
<span class="c1">//   if an Optional rhs holds a value, and if it does unwrap</span>
<span class="c1">//   and assign it to the lhs.</span>
<span class="k">if</span> <span class="k">let</span> <span class="nv">someNonOptionalStringConstant</span> <span class="o">=</span> <span class="n">someOptionalString</span> <span class="p">{</span>
    <span class="c1">// has `Some` value, non-nil</span>
    <span class="c1">// someOptionalStringConstant is of type String, not type String?</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">someNonOptionalStringConstant</span><span class="o">.</span><span class="nf">hasPrefix</span><span class="p">(</span><span class="s">"ok"</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// does not have the prefix</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//if-var is allowed too!</span>
<span class="k">if</span> <span class="k">var</span> <span class="nv">someNonOptionalString</span> <span class="o">=</span> <span class="n">someOptionalString</span> <span class="p">{</span>
    <span class="n">someNonOptionalString</span> <span class="o">=</span> <span class="s">"Non optional AND mutable"</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">someNonOptionalString</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// You can bind multiple optional values in one if-let statement.</span>
<span class="c1">//   If any of the bound values are nil, the if statement does not execute.</span>
<span class="k">if</span> <span class="k">let</span> <span class="nv">first</span> <span class="o">=</span> <span class="n">someOptionalString</span><span class="p">,</span> <span class="k">let</span> <span class="nv">second</span> <span class="o">=</span> <span class="n">someOptionalString2</span><span class="p">,</span>
    <span class="k">let</span> <span class="nv">third</span> <span class="o">=</span> <span class="n">someOptionalString3</span><span class="p">,</span> <span class="k">let</span> <span class="nv">fourth</span> <span class="o">=</span> <span class="n">someOptionalString4</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">first</span><span class="se">)</span><span class="s">, </span><span class="se">\(</span><span class="n">second</span><span class="se">)</span><span class="s">, </span><span class="se">\(</span><span class="n">third</span><span class="se">)</span><span class="s">, and </span><span class="se">\(</span><span class="n">fourth</span><span class="se">)</span><span class="s"> are all not nil"</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//if-let supports "," (comma) clauses, which can be used to</span>
<span class="c1">//   enforce conditions on newly-bound optional values.</span>
<span class="c1">// Both the assignment and the "," clause must pass.</span>
<span class="k">let</span> <span class="nv">someNumber</span><span class="p">:</span> <span class="kt">Int</span><span class="p">?</span> <span class="o">=</span> <span class="mi">7</span>
<span class="k">if</span> <span class="k">let</span> <span class="nv">num</span> <span class="o">=</span> <span class="n">someNumber</span><span class="p">,</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"num is not nil and is greater than 3"</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Implicitly unwrapped optional â€” An optional value that doesn't need to be unwrapped</span>
<span class="k">let</span> <span class="nv">unwrappedString</span><span class="p">:</span> <span class="kt">String</span><span class="o">!</span> <span class="o">=</span> <span class="s">"Value is expected."</span>

<span class="c1">// Here's the difference:</span>
<span class="k">let</span> <span class="nv">forcedString</span> <span class="o">=</span> <span class="n">someOptionalString</span><span class="o">!</span> <span class="c1">// requires an exclamation mark</span>
<span class="k">let</span> <span class="nv">implicitString</span> <span class="o">=</span> <span class="n">unwrappedString</span> <span class="c1">// doesn't require an exclamation mark</span>

<span class="cm">/*
 You can think of an implicitly unwrapped optional as giving permission
 for the optional to be unwrapped automatically whenever it's used.
 Rather than placing an exclamation mark after the optional's name each time you use it,
 you place an exclamation mark after the optional's type when you declare it.
 */</span>

<span class="c1">// Otherwise, you can treat an implicitly unwrapped optional the same way the you treat a normal optional</span>
<span class="c1">//   (i.e., if-let, != nil, etc.)</span>

<span class="c1">// Pre-Swift 5, T! was shorthand for ImplicitlyUnwrappedOptional&lt;T&gt;</span>
<span class="c1">// Swift 5 and later, using ImplicitlyUnwrappedOptional throws a compile-time error.</span>
<span class="c1">//var unwrappedString2: ImplicitlyUnwrappedOptional&lt;String&gt; = "Value is expected." //error</span>

<span class="c1">// The nil-coalescing operator ?? unwraps an optional if it contains a non-nil value, or returns a default value.</span>
<span class="n">someOptionalString</span> <span class="o">=</span> <span class="kc">nil</span>
<span class="k">let</span> <span class="nv">someString</span> <span class="o">=</span> <span class="n">someOptionalString</span> <span class="p">??</span> <span class="s">"abc"</span>
<span class="nf">print</span><span class="p">(</span><span class="n">someString</span><span class="p">)</span> <span class="c1">// abc</span>
<span class="c1">// a ?? b is shorthand for a != nil ? a! : b</span>

<span class="c1">// MARK: - Control Flow</span>

<span class="k">let</span> <span class="nv">condition</span> <span class="o">=</span> <span class="kc">true</span>
<span class="k">if</span> <span class="n">condition</span> <span class="p">{</span> <span class="nf">print</span><span class="p">(</span><span class="s">"condition is true"</span><span class="p">)</span> <span class="p">}</span> <span class="c1">// can't omit the braces</span>

<span class="k">if</span> <span class="n">theAnswer</span> <span class="o">&gt;</span> <span class="mi">50</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"theAnswer &gt; 50"</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">condition</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"condition is true"</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Neither are true"</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// The condition in an `if` statement must be a `Bool`, so the following code is an error, not an implicit comparison to zero</span>
<span class="c1">//if 5 {</span>
<span class="c1">//    print("5 is not zero")</span>
<span class="c1">//}</span>

<span class="c1">// Switch</span>
<span class="c1">// Must be exhaustive</span>
<span class="c1">// Does not implicitly fall through, use the fallthrough keyword</span>
<span class="c1">// Very powerful, think `if` statements with syntax candy</span>
<span class="c1">// They support String, object instances, and primitives (Int, Double, etc)</span>
<span class="k">let</span> <span class="nv">vegetable</span> <span class="o">=</span> <span class="s">"red pepper"</span>
<span class="k">let</span> <span class="nv">vegetableComment</span><span class="p">:</span> <span class="kt">String</span>
<span class="k">switch</span> <span class="n">vegetable</span> <span class="p">{</span>
<span class="k">case</span> <span class="s">"celery"</span><span class="p">:</span>
    <span class="n">vegetableComment</span> <span class="o">=</span> <span class="s">"Add some raisins and make ants on a log."</span>
<span class="k">case</span> <span class="s">"cucumber"</span><span class="p">,</span> <span class="s">"watercress"</span><span class="p">:</span> <span class="c1">// match multiple values</span>
    <span class="n">vegetableComment</span> <span class="o">=</span> <span class="s">"That would make a good tea sandwich."</span>
<span class="k">case</span> <span class="k">let</span> <span class="nv">localScopeValue</span> <span class="k">where</span> <span class="n">localScopeValue</span><span class="o">.</span><span class="nf">hasSuffix</span><span class="p">(</span><span class="s">"pepper"</span><span class="p">):</span>
    <span class="n">vegetableComment</span> <span class="o">=</span> <span class="s">"Is it a spicy </span><span class="se">\(</span><span class="n">localScopeValue</span><span class="se">)</span><span class="s">?"</span>
<span class="k">default</span><span class="p">:</span> <span class="c1">// required (in order to cover all possible input)</span>
    <span class="n">vegetableComment</span> <span class="o">=</span> <span class="s">"Everything tastes good in soup."</span>
<span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="n">vegetableComment</span><span class="p">)</span>

<span class="c1">// You use the `for-in` loop to iterate over a sequence, such as an array, dictionary, range, etc.</span>
<span class="k">for</span> <span class="n">element</span> <span class="k">in</span> <span class="n">shoppingList</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="c1">// shoppingList is of type `[String]`, so element is of type `String`</span>
<span class="p">}</span>
<span class="c1">//Iterating through a dictionary does not guarantee any specific order</span>
<span class="k">for</span> <span class="p">(</span><span class="n">person</span><span class="p">,</span> <span class="n">job</span><span class="p">)</span> <span class="k">in</span> <span class="n">immutableOccupations</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">person</span><span class="se">)</span><span class="s">'s job is </span><span class="se">\(</span><span class="n">job</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">...</span><span class="mi">5</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nv">terminator</span><span class="p">:</span> <span class="s">" "</span><span class="p">)</span> <span class="c1">// Prints "1 2 3 4 5"</span>
<span class="p">}</span>
<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="mi">5</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nv">terminator</span><span class="p">:</span> <span class="s">" "</span><span class="p">)</span> <span class="c1">// Prints "0 1 2 3 4"</span>
<span class="p">}</span>
<span class="c1">//for index in range can replace a C-style for loop:</span>
<span class="c1">//    for (int i = 0; i &lt; 10; i++) {</span>
<span class="c1">//        //code</span>
<span class="c1">//    }</span>
<span class="c1">//becomes:</span>
<span class="c1">//    for i in 0..&lt;10 {</span>
<span class="c1">//        //code</span>
<span class="c1">//    }</span>
<span class="c1">//To step by more than one, use the stride(from:to:by:) or stride(from:through:by) functions</span>
<span class="c1">//`for i in stride(from: 0, to: 10, by: 2)` is the same as `for (int i = 0; i &lt; 10; i += 2)`</span>
<span class="c1">//`for i in stride(from: 0, through: 10, by: 2)` is the same as `for (int i = 0; i &lt;= 10; i += 2)</span>

<span class="c1">// while loops are just like most languages</span>
<span class="k">var</span> <span class="nv">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="kt">Bool</span><span class="o">.</span><span class="nf">random</span><span class="p">()</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// This is like a do-while loop in other languages â€” the body of the loop executes a minimum of once</span>
<span class="k">repeat</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="kt">Int</span><span class="o">.</span><span class="nf">random</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="mi">0</span><span class="o">...</span><span class="mi">3</span><span class="p">)</span>
<span class="p">}</span> <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span>

<span class="c1">// The continue statement continues executing a loop at the next iteration</span>
<span class="c1">// The break statement ends a loop immediately</span>

<span class="c1">// MARK: - Functions</span>

<span class="c1">// Functions are a first-class type, meaning they can be nested in functions and can be passed around.</span>

<span class="c1">// Function with Swift header docs (format as Swift-modified Markdown syntax)</span>

<span class="c1">/// A greet operation.</span>
<span class="c1">///</span>
<span class="c1">/// - Parameters:</span>
<span class="c1">///   - name: A name.</span>
<span class="c1">///   - day: A day.</span>
<span class="c1">/// - Returns: A string containing the name and day value.</span>
<span class="kd">func</span> <span class="nf">greet</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="nv">day</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">"Hello </span><span class="se">\(</span><span class="n">name</span><span class="se">)</span><span class="s">, today is </span><span class="se">\(</span><span class="n">day</span><span class="se">)</span><span class="s">."</span>
<span class="p">}</span>
<span class="nf">greet</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Bob"</span><span class="p">,</span> <span class="nv">day</span><span class="p">:</span> <span class="s">"Tuesday"</span><span class="p">)</span>

<span class="c1">// Ideally, function names and parameter labels combine to make function calls similar to sentences.</span>
<span class="kd">func</span> <span class="nf">sayHello</span><span class="p">(</span><span class="n">to</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">onDay</span> <span class="nv">day</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">"Hello </span><span class="se">\(</span><span class="n">name</span><span class="se">)</span><span class="s">, the day is </span><span class="se">\(</span><span class="n">day</span><span class="se">)</span><span class="s">"</span>
<span class="p">}</span>
<span class="nf">sayHello</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="s">"John"</span><span class="p">,</span> <span class="nv">onDay</span><span class="p">:</span> <span class="s">"Sunday"</span><span class="p">)</span>

<span class="c1">//Functions that don't return anything can omit the return arrow; they don't need to say that they return Void (although they can).</span>
<span class="kd">func</span> <span class="nf">helloWorld</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Hello, World!"</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Argument labels can be blank</span>
<span class="kd">func</span> <span class="nf">say</span><span class="p">(</span><span class="n">_</span> <span class="nv">message</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="err">#</span><span class="s">"I say "</span><span class="p">\</span><span class="err">#</span><span class="p">(</span><span class="n">message</span><span class="p">)</span><span class="s">""</span><span class="err">#</span><span class="p">)</span>
<span class="p">}</span>
<span class="nf">say</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">)</span>

<span class="c1">// Default parameters can be omitted when calling the function.</span>
<span class="kd">func</span> <span class="nf">printParameters</span><span class="p">(</span><span class="n">requiredParameter</span> <span class="nv">r</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">optionalParameter</span> <span class="nv">o</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"The required parameter was </span><span class="se">\(</span><span class="n">r</span><span class="se">)</span><span class="s"> and the optional parameter was </span><span class="se">\(</span><span class="n">o</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
<span class="nf">printParameters</span><span class="p">(</span><span class="nv">requiredParameter</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
<span class="nf">printParameters</span><span class="p">(</span><span class="nv">requiredParameter</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nv">optionalParameter</span><span class="p">:</span> <span class="mi">6</span><span class="p">)</span>

<span class="c1">// Variadic args â€” only one set per function.</span>
<span class="kd">func</span> <span class="nf">setup</span><span class="p">(</span><span class="nv">numbers</span><span class="p">:</span> <span class="kt">Int</span><span class="o">...</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// it's an array</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="n">count</span>
<span class="p">}</span>

<span class="c1">// pass by ref</span>
<span class="kd">func</span> <span class="nf">swapTwoInts</span><span class="p">(</span><span class="nv">a</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">b</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">tempA</span> <span class="o">=</span> <span class="n">a</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">tempA</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">someIntA</span> <span class="o">=</span> <span class="mi">7</span>
<span class="k">var</span> <span class="nv">someIntB</span> <span class="o">=</span> <span class="mi">3</span>
<span class="nf">swapTwoInts</span><span class="p">(</span><span class="nv">a</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">someIntA</span><span class="p">,</span> <span class="nv">b</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">someIntB</span><span class="p">)</span> <span class="c1">//must be called with an &amp; before the variable name.</span>
<span class="nf">print</span><span class="p">(</span><span class="n">someIntB</span><span class="p">)</span> <span class="c1">// 7</span>

<span class="nf">type</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">greet</span><span class="p">)</span> <span class="c1">// (String, String) -&gt; String</span>
<span class="nf">type</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">helloWorld</span><span class="p">)</span> <span class="c1">// () -&gt; Void</span>

<span class="c1">// Passing and returning functions</span>
<span class="kd">func</span> <span class="nf">makeIncrementer</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">((</span><span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">addOne</span><span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">number</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">addOne</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">increment</span> <span class="o">=</span> <span class="nf">makeIncrementer</span><span class="p">()</span>
<span class="nf">increment</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">performFunction</span><span class="p">(</span><span class="n">_</span> <span class="nv">function</span><span class="p">:</span> <span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">,</span> <span class="n">on</span> <span class="nv">string1</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">and</span> <span class="nv">string2</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="nf">function</span><span class="p">(</span><span class="n">string1</span><span class="p">,</span> <span class="n">string2</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"The result of calling the function on </span><span class="se">\(</span><span class="n">string1</span><span class="se">)</span><span class="s"> and </span><span class="se">\(</span><span class="n">string2</span><span class="se">)</span><span class="s"> was </span><span class="se">\(</span><span class="n">result</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Function that returns multiple items in a tuple</span>
<span class="kd">func</span> <span class="nf">getGasPrices</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Double</span><span class="p">,</span> <span class="kt">Double</span><span class="p">,</span> <span class="kt">Double</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">return</span> <span class="p">(</span><span class="mf">3.59</span><span class="p">,</span> <span class="mf">3.69</span><span class="p">,</span> <span class="mf">3.79</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">pricesTuple</span> <span class="o">=</span> <span class="nf">getGasPrices</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">price</span> <span class="o">=</span> <span class="n">pricesTuple</span><span class="o">.</span><span class="mi">2</span> <span class="c1">// 3.79</span>
<span class="c1">// Ignore Tuple (or other) values by using _ (underscore)</span>
<span class="k">let</span> <span class="p">(</span><span class="nv">_</span><span class="p">,</span> <span class="nv">price1</span><span class="p">,</span> <span class="nv">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">pricesTuple</span> <span class="c1">// price1 == 3.69</span>
<span class="nf">print</span><span class="p">(</span><span class="n">price1</span> <span class="o">==</span> <span class="n">pricesTuple</span><span class="o">.</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Gas price: </span><span class="se">\(</span><span class="n">price</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>

<span class="c1">// Labeled/named tuple params</span>
<span class="kd">func</span> <span class="nf">getGasPrices2</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nv">lowestPrice</span><span class="p">:</span> <span class="kt">Double</span><span class="p">,</span> <span class="nv">highestPrice</span><span class="p">:</span> <span class="kt">Double</span><span class="p">,</span> <span class="nv">midPrice</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">return</span> <span class="p">(</span><span class="mf">1.77</span><span class="p">,</span> <span class="mf">37.70</span><span class="p">,</span> <span class="mf">7.37</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">pricesTuple2</span> <span class="o">=</span> <span class="nf">getGasPrices2</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">price2</span> <span class="o">=</span> <span class="n">pricesTuple2</span><span class="o">.</span><span class="n">lowestPrice</span>
<span class="k">let</span> <span class="p">(</span><span class="nv">_</span><span class="p">,</span> <span class="nv">price3</span><span class="p">,</span> <span class="nv">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">pricesTuple2</span>
<span class="nf">print</span><span class="p">(</span><span class="n">pricesTuple2</span><span class="o">.</span><span class="n">highestPrice</span> <span class="o">==</span> <span class="n">pricesTuple2</span><span class="o">.</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Highest gas price: </span><span class="se">\(</span><span class="n">pricesTuple2</span><span class="o">.</span><span class="n">highestPrice</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>

<span class="c1">// guard statements</span>
<span class="kd">func</span> <span class="nf">testGuard</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// guards provide early exits or breaks, placing the error handler code near the conditions.</span>
    <span class="c1">// it places variables it declares in the same scope as the guard statement.</span>
    <span class="c1">// They make it easier to avoid the "pyramid of doom"</span>
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">aNumber</span> <span class="o">=</span> <span class="kt">Optional</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="c1">// guard statements MUST exit the scope that they are in.</span>
        <span class="c1">// They generally use `return` or `throw`.</span>
    <span class="p">}</span>

    <span class="nf">print</span><span class="p">(</span><span class="s">"number is </span><span class="se">\(</span><span class="n">aNumber</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
<span class="nf">testGuard</span><span class="p">()</span>

<span class="c1">// Note that the print function is declared like so:</span>
<span class="c1">//     func print(_ input: Any..., separator: String = " ", terminator: String = "\n")</span>
<span class="c1">// To print without a newline:</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"No newline"</span><span class="p">,</span> <span class="nv">terminator</span><span class="p">:</span> <span class="s">""</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"!"</span><span class="p">)</span>

<span class="c1">// MARK: - Closures</span>

<span class="k">var</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>

<span class="c1">// Functions are special case closures ({})</span>

<span class="c1">// Closure example.</span>
<span class="c1">// `-&gt;` separates the arguments and return type</span>
<span class="c1">// `in` separates the closure header from the closure body</span>
<span class="n">numbers</span><span class="o">.</span><span class="nf">map</span><span class="p">({</span>
    <span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="k">in</span>
    <span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">number</span>
    <span class="k">return</span> <span class="n">result</span>
<span class="p">})</span>

<span class="c1">// When the type is known, like above, we can do this</span>
<span class="n">numbers</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="nf">map</span><span class="p">({</span> <span class="n">number</span> <span class="k">in</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">number</span> <span class="p">})</span>
<span class="c1">// Or even this</span>
<span class="c1">//numbers = numbers.map({ $0 * 3 })</span>

<span class="nf">print</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="c1">// [3, 6, 18]</span>

<span class="c1">// Trailing closure</span>
<span class="n">numbers</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="n">sorted</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&gt;</span> <span class="nv">$1</span> <span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="c1">// [18, 6, 3]</span>

<span class="c1">// MARK: - Enums</span>

<span class="c1">// Enums can optionally be of a specific type or on their own.</span>
<span class="c1">// They can contain methods like classes.</span>

<span class="kd">enum</span> <span class="kt">Suit</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">spades</span><span class="p">,</span> <span class="n">hearts</span><span class="p">,</span> <span class="n">diamonds</span><span class="p">,</span> <span class="n">clubs</span>
    <span class="k">var</span> <span class="nv">icon</span><span class="p">:</span> <span class="kt">Character</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="k">self</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">spades</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"â™¤"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">hearts</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"â™¡"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">diamonds</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"â™¢"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">clubs</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"â™§"</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Enum values allow short hand syntax, no need to type the enum type</span>
<span class="c1">// when the variable is explicitly declared</span>
<span class="k">var</span> <span class="nv">suitValue</span><span class="p">:</span> <span class="kt">Suit</span> <span class="o">=</span> <span class="o">.</span><span class="n">hearts</span>

<span class="c1">// Conforming to the CaseIterable protocol automatically synthesizes the allCases property,</span>
<span class="c1">//   which contains all the values. It works on enums without associated values or @available attributes.</span>
<span class="kd">enum</span> <span class="kt">Rank</span><span class="p">:</span> <span class="kt">CaseIterable</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">ace</span>
    <span class="k">case</span> <span class="n">two</span><span class="p">,</span> <span class="n">three</span><span class="p">,</span> <span class="n">four</span><span class="p">,</span> <span class="n">five</span><span class="p">,</span> <span class="n">six</span><span class="p">,</span> <span class="n">seven</span><span class="p">,</span> <span class="n">eight</span><span class="p">,</span> <span class="n">nine</span><span class="p">,</span> <span class="n">ten</span>
    <span class="k">case</span> <span class="n">jack</span><span class="p">,</span> <span class="n">queen</span><span class="p">,</span> <span class="n">king</span>
    <span class="k">var</span> <span class="nv">icon</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="k">self</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">ace</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"A"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">two</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"2"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">three</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"3"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">four</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"4"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">five</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"5"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">six</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"6"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">seven</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"7"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">eight</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"8"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">nine</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"9"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">ten</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"10"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">jack</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"J"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">queen</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"Q"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">king</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"K"</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">suit</span> <span class="k">in</span> <span class="p">[</span><span class="kt">Suit</span><span class="o">.</span><span class="n">clubs</span><span class="p">,</span> <span class="o">.</span><span class="n">diamonds</span><span class="p">,</span> <span class="o">.</span><span class="n">hearts</span><span class="p">,</span> <span class="o">.</span><span class="n">spades</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">rank</span> <span class="k">in</span> <span class="kt">Rank</span><span class="o">.</span><span class="n">allCases</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">rank</span><span class="o">.</span><span class="n">icon</span><span class="se">)\(</span><span class="n">suit</span><span class="o">.</span><span class="n">icon</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// String enums can have direct raw value assignments</span>
<span class="c1">// or their raw values will be derived from the Enum field</span>
<span class="kd">enum</span> <span class="kt">BookName</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">john</span>
    <span class="k">case</span> <span class="n">luke</span> <span class="o">=</span> <span class="s">"Luke"</span>
<span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Name: </span><span class="se">\(</span><span class="kt">BookName</span><span class="o">.</span><span class="n">john</span><span class="o">.</span><span class="n">rawValue</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>

<span class="c1">// Enum with associated Values</span>
<span class="kd">enum</span> <span class="kt">Furniture</span> <span class="p">{</span>
    <span class="c1">// Associate with Int</span>
    <span class="k">case</span> <span class="nf">desk</span><span class="p">(</span><span class="nv">height</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>
    <span class="c1">// Associate with String and Int</span>
    <span class="k">case</span> <span class="nf">chair</span><span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span>

    <span class="kd">func</span> <span class="nf">description</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="c1">//either placement of let is acceptable</span>
        <span class="k">switch</span> <span class="k">self</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nf">desk</span><span class="p">(</span><span class="k">let</span> <span class="nv">height</span><span class="p">):</span>
            <span class="k">return</span> <span class="s">"Desk with </span><span class="se">\(</span><span class="n">height</span><span class="se">)</span><span class="s"> cm"</span>
        <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">chair</span><span class="p">(</span><span class="n">brand</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
            <span class="k">return</span> <span class="s">"Chair of </span><span class="se">\(</span><span class="n">brand</span><span class="se">)</span><span class="s"> with </span><span class="se">\(</span><span class="n">height</span><span class="se">)</span><span class="s"> cm"</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">desk</span><span class="p">:</span> <span class="kt">Furniture</span> <span class="o">=</span> <span class="o">.</span><span class="nf">desk</span><span class="p">(</span><span class="nv">height</span><span class="p">:</span> <span class="mi">80</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">desk</span><span class="o">.</span><span class="nf">description</span><span class="p">())</span>     <span class="c1">// "Desk with 80 cm"</span>
<span class="k">var</span> <span class="nv">chair</span> <span class="o">=</span> <span class="kt">Furniture</span><span class="o">.</span><span class="nf">chair</span><span class="p">(</span><span class="s">"Foo"</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">chair</span><span class="o">.</span><span class="nf">description</span><span class="p">())</span>    <span class="c1">// "Chair of Foo with 40 cm"</span>

<span class="c1">// MARK: - Structures &amp; Classes</span>

<span class="cm">/*
 Structures and classes in Swift have many things in common. Both can:
 - Define properties to store values
 - Define methods to provide functionality
 - Define subscripts to provide access to their values using subscript syntax
 - Define initializers to set up their initial state
 - Be extended to expand their functionality beyond a default implementation
 - Conform to protocols to provide standard functionality of a certain kind

 Classes have additional capabilities that structures don't have:
 - Inheritance enables one class to inherit the characteristics of another.
 - Type casting enables you to check and interpret the type of a class instance at runtime.
 - Deinitializers enable an instance of a class to free up any resources it has assigned.
 - Reference counting allows more than one reference to a class instance.

 Unless you need to use a class for one of these reasons, use a struct.

 Structures are value types, while classes are reference types.
 */</span>

<span class="c1">// MARK: Structures</span>

<span class="kd">struct</span> <span class="kt">NamesTable</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">names</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>

    <span class="c1">// Custom subscript</span>
    <span class="nf">subscript</span><span class="p">(</span><span class="nv">index</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">names</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Structures have an auto-generated (implicit) designated "memberwise" initializer</span>
<span class="k">let</span> <span class="nv">namesTable</span> <span class="o">=</span> <span class="kt">NamesTable</span><span class="p">(</span><span class="nv">names</span><span class="p">:</span> <span class="p">[</span><span class="s">"Me"</span><span class="p">,</span> <span class="s">"Them"</span><span class="p">])</span>
<span class="k">let</span> <span class="nv">name</span> <span class="o">=</span> <span class="n">namesTable</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Name is </span><span class="se">\(</span><span class="n">name</span><span class="se">)</span><span class="s">"</span><span class="p">)</span> <span class="c1">// Name is Them</span>

<span class="c1">// MARK: Classes</span>

<span class="kd">class</span> <span class="kt">Shape</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">getArea</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">Rect</span><span class="p">:</span> <span class="kt">Shape</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">sideLength</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1">// Custom getter and setter property</span>
    <span class="k">var</span> <span class="nv">perimeter</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">sideLength</span>
        <span class="p">}</span>
        <span class="k">set</span> <span class="p">{</span>
            <span class="c1">// `newValue` is an implicit variable available to setters</span>
            <span class="n">sideLength</span> <span class="o">=</span> <span class="n">newValue</span> <span class="o">/</span> <span class="mi">4</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Computed properties must be declared as `var`, you know, cause' they can change</span>
    <span class="k">var</span> <span class="nv">smallestSideLength</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">self</span><span class="o">.</span><span class="n">sideLength</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="p">}</span>

    <span class="c1">// Lazily load a property</span>
    <span class="c1">// subShape remains nil (uninitialized) until getter called</span>
    <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">subShape</span> <span class="o">=</span> <span class="kt">Rect</span><span class="p">(</span><span class="nv">sideLength</span><span class="p">:</span> <span class="mi">4</span><span class="p">)</span>

    <span class="c1">// If you don't need a custom getter and setter,</span>
    <span class="c1">// but still want to run code before and after getting or setting</span>
    <span class="c1">// a property, you can use `willSet` and `didSet`</span>
    <span class="k">var</span> <span class="nv">identifier</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"defaultID"</span> <span class="p">{</span>
        <span class="c1">// the `someIdentifier` arg will be the variable name for the new value</span>
        <span class="nf">willSet</span><span class="p">(</span><span class="n">someIdentifier</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="n">someIdentifier</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">sideLength</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">sideLength</span> <span class="o">=</span> <span class="n">sideLength</span>
        <span class="c1">// always super.init last when init custom properties</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">shrink</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">sideLength</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">sideLength</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">override</span> <span class="kd">func</span> <span class="nf">getArea</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">sideLength</span> <span class="o">*</span> <span class="n">sideLength</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// A simple class `Square` extends `Rect`</span>
<span class="kd">class</span> <span class="kt">Square</span><span class="p">:</span> <span class="kt">Rect</span> <span class="p">{</span>
    <span class="c1">// Use a convenience initializer to make calling a designated initializer faster and more "convenient".</span>
    <span class="c1">// Convenience initializers call other initializers in the same class and pass default values to one or more of their parameters.</span>
    <span class="c1">// Convenience initializers can have parameters as well, which are useful to customize the called initializer parameters or choose a proper initializer based on the value passed.</span>
    <span class="kd">convenience</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">sideLength</span><span class="p">:</span> <span class="mi">5</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">mySquare</span> <span class="o">=</span> <span class="kt">Square</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="n">mySquare</span><span class="o">.</span><span class="nf">getArea</span><span class="p">())</span> <span class="c1">// 25</span>
<span class="n">mySquare</span><span class="o">.</span><span class="nf">shrink</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="n">mySquare</span><span class="o">.</span><span class="n">sideLength</span><span class="p">)</span> <span class="c1">// 4</span>

<span class="c1">// cast instance</span>
<span class="k">let</span> <span class="nv">aShape</span> <span class="o">=</span> <span class="n">mySquare</span> <span class="k">as</span> <span class="kt">Shape</span>

<span class="c1">// downcast instance: </span>
<span class="c1">// Because downcasting can fail, the result can be an optional (as?) or an implicitly unwrpped optional (as!).  </span>
<span class="k">let</span> <span class="nv">anOptionalSquare</span> <span class="o">=</span> <span class="n">aShape</span> <span class="k">as?</span> <span class="kt">Square</span> <span class="c1">// This will return nil if aShape is not a Square</span>
<span class="k">let</span> <span class="nv">aSquare</span> <span class="o">=</span> <span class="n">aShape</span> <span class="k">as!</span> <span class="kt">Square</span> <span class="c1">// This will throw a runtime error if aShape is not a Square</span>

<span class="c1">// compare instances, not the same as == which compares objects (equal to)</span>
<span class="k">if</span> <span class="n">mySquare</span> <span class="o">===</span> <span class="n">mySquare</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Yep, it's mySquare"</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Optional init</span>
<span class="kd">class</span> <span class="kt">Circle</span><span class="p">:</span> <span class="kt">Shape</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">radius</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">getArea</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">radius</span>
    <span class="p">}</span>

    <span class="c1">// Place a question mark postfix after `init` is an optional init</span>
    <span class="c1">// which can return nil</span>
    <span class="nf">init</span><span class="p">?(</span><span class="nv">radius</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">radius</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">myCircle</span> <span class="o">=</span> <span class="kt">Circle</span><span class="p">(</span><span class="nv">radius</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">myCircle</span><span class="p">?</span><span class="o">.</span><span class="nf">getArea</span><span class="p">())</span>    <span class="c1">// Optional(3)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">myCircle</span><span class="o">!.</span><span class="nf">getArea</span><span class="p">())</span>    <span class="c1">// 3</span>
<span class="k">var</span> <span class="nv">myEmptyCircle</span> <span class="o">=</span> <span class="kt">Circle</span><span class="p">(</span><span class="nv">radius</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">myEmptyCircle</span><span class="p">?</span><span class="o">.</span><span class="nf">getArea</span><span class="p">())</span>    <span class="c1">// "nil"</span>
<span class="k">if</span> <span class="k">let</span> <span class="nv">circle</span> <span class="o">=</span> <span class="n">myEmptyCircle</span> <span class="p">{</span>
    <span class="c1">// will not execute since myEmptyCircle is nil</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"circle is not nil"</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// MARK: - Protocols</span>

<span class="c1">// protocols are also known as interfaces in some other languages</span>

<span class="c1">// `protocol`s can require that conforming types have specific</span>
<span class="c1">// instance properties, instance methods, type methods,</span>
<span class="c1">// operators, and subscripts.</span>

<span class="kd">protocol</span> <span class="kt">ShapeGenerator</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">enabled</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span> <span class="k">get</span> <span class="k">set</span> <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">buildShape</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Shape</span>
<span class="p">}</span>

<span class="c1">// MARK: - Other</span>

<span class="c1">// MARK: Typealiases</span>

<span class="c1">// Typealiases allow one type (or composition of types) to be referred to by another name</span>
<span class="kd">typealias</span> <span class="kt">Integer</span> <span class="o">=</span> <span class="kt">Int</span>
<span class="k">let</span> <span class="nv">myInteger</span><span class="p">:</span> <span class="kt">Integer</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1">// MARK: = Operator</span>

<span class="c1">// Assignment does not return a value. This means it can't be used in conditional statements,</span>
<span class="c1">//   and the following statement is also illegal</span>
<span class="c1">//    let multipleAssignment = theQuestion = "No questions asked"</span>
<span class="c1">//But you can do this:</span>
<span class="k">let</span> <span class="nv">multipleAssignment</span> <span class="o">=</span> <span class="s">"No questions asked"</span><span class="p">,</span> <span class="n">secondConstant</span> <span class="o">=</span> <span class="s">"No answers given"</span>

<span class="c1">// MARK: Ranges</span>

<span class="c1">// The ..&lt; and ... operators create ranges.</span>

<span class="c1">// ... is inclusive on both ends (a "closed range") â€” mathematically, [0, 10]</span>
<span class="k">let</span> <span class="nv">_0to10</span> <span class="o">=</span> <span class="mi">0</span><span class="o">...</span><span class="mi">10</span>
<span class="c1">// ..&lt; is inclusive on the left, exclusive on the right (a "range") â€” mathematically, [0, 10)</span>
<span class="k">let</span> <span class="nv">singleDigitNumbers</span> <span class="o">=</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="mi">10</span>
<span class="c1">// You can omit one end (a "PartialRangeFrom") â€” mathematically, [0, âˆž)</span>
<span class="k">let</span> <span class="nv">toInfinityAndBeyond</span> <span class="o">=</span> <span class="mi">0</span><span class="o">...</span>
<span class="c1">// Or the other end (a "PartialRangeTo") â€” mathematically, (-âˆž, 0)</span>
<span class="k">let</span> <span class="nv">negativeInfinityToZero</span> <span class="o">=</span> <span class="o">..&lt;</span><span class="mi">0</span>
<span class="c1">// (a "PartialRangeThrough") â€” mathematically, (-âˆž, 0]</span>
<span class="k">let</span> <span class="nv">negativeInfinityThroughZero</span> <span class="o">=</span> <span class="o">...</span><span class="mi">0</span>

<span class="c1">// MARK: Wildcard operator</span>

<span class="c1">// In Swift, _ (underscore) is the wildcard operator, which allows values to be ignored</span>

<span class="c1">// It allows functions to be declared without argument labels:</span>
<span class="kd">func</span> <span class="nf">function</span><span class="p">(</span><span class="n">_</span> <span class="nv">labelLessParameter</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">label</span> <span class="nv">labeledParameter</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">labelAndParameterName</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">labelLessParameter</span><span class="p">,</span> <span class="n">labeledParameter</span><span class="p">,</span> <span class="n">labelAndParameterName</span><span class="p">)</span>
<span class="p">}</span>
<span class="nf">function</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nv">label</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">labelAndParameterName</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1">// You can ignore the return values of functions</span>
<span class="kd">func</span> <span class="nf">printAndReturn</span><span class="p">(</span><span class="n">_</span> <span class="nv">str</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">str</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="nf">printAndReturn</span><span class="p">(</span><span class="s">"Some String"</span><span class="p">)</span>

<span class="c1">// You can ignore part of a tuple and keep part of it</span>
<span class="kd">func</span> <span class="nf">returnsTuple</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">let</span> <span class="p">(</span><span class="nv">_</span><span class="p">,</span> <span class="nv">two</span><span class="p">)</span> <span class="o">=</span> <span class="nf">returnsTuple</span><span class="p">()</span>

<span class="c1">// You can ignore closure parameters</span>
<span class="k">let</span> <span class="nv">closure</span><span class="p">:</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="o">=</span> <span class="p">{</span> <span class="n">someInt</span><span class="p">,</span> <span class="n">_</span> <span class="k">in</span>
    <span class="k">return</span> <span class="s">"</span><span class="se">\(</span><span class="n">someInt</span><span class="se">)</span><span class="s">"</span>
<span class="p">}</span>
<span class="nf">closure</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// returns 1</span>

<span class="c1">// You can ignore the value in a for loop</span>
<span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="mi">10</span> <span class="p">{</span>
    <span class="c1">// Code to execute 10 times</span>
<span class="p">}</span>

<span class="c1">// MARK: Access Control</span>

<span class="cm">/*
 Swift has five levels of access control:
 - Open: Accessible *and subclassible* in any module that imports it.
 - Public: Accessible in any module that imports it, subclassible in the module it is declared in.
 - Internal: Accessible and subclassible in the module it is declared in.
 - Fileprivate: Accessible and subclassible in the file it is declared in.
 - Private: Accessible and subclassible in the enclosing declaration (think inner classes/structs/enums)

 See more here: https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html
 */</span>

<span class="c1">// MARK: Preventing Overrides</span>

<span class="c1">// You can add keyword `final` before a class or instance method, or a property to prevent it from being overridden</span>
<span class="kd">class</span> <span class="kt">Shape</span> <span class="p">{</span>
    <span class="kd">final</span> <span class="k">var</span> <span class="nv">finalInteger</span> <span class="o">=</span> <span class="mi">10</span>
<span class="p">}</span>

<span class="c1">// Prevent a class from being subclassed</span>
<span class="kd">final</span> <span class="kd">class</span> <span class="kt">ViewManager</span> <span class="p">{</span>
<span class="p">}</span>

<span class="c1">// MARK: Conditional Compilation, Compile-Time Diagnostics, &amp; Availability Conditions</span>

<span class="c1">// Conditional Compilation</span>
<span class="cp">#if false</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"This code will not be compiled"</span><span class="p">)</span>
<span class="cp">#else</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"This code will be compiled"</span><span class="p">)</span>
<span class="cp">#endif</span>
<span class="cm">/*
 Options are:
 os()                   macOS, iOS, watchOS, tvOS, Linux
 arch()                 i386, x86_64, arm, arm64
 swift()                &gt;= or &lt; followed by a version number
 compiler()             &gt;= or &lt; followed by a version number
 canImport()            A module name
 targetEnvironment()    simulator
 */</span>
<span class="cp">#if swift(&lt;3)</span>
<span class="nf">println</span><span class="p">()</span>
<span class="cp">#endif</span>

<span class="c1">// Compile-Time Diagnostics</span>
<span class="c1">// You can use #warning(message) and #error(message) to have the compiler emit warnings and/or errors</span>
<span class="cp">#warning("This will be a compile-time warning")</span>
<span class="c1">//  #error("This would be a compile-time error")</span>

<span class="c1">//Availability Conditions</span>
<span class="k">if</span> <span class="kd">#available(iOSMac 10.15, *)</span> <span class="p">{</span>
    <span class="c1">// macOS 10.15 is available, you can use it here</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// macOS 10.15 is not available, use alternate APIs</span>
<span class="p">}</span>

<span class="c1">// MARK: Any and AnyObject</span>

<span class="c1">// Swift has support for storing a value of any type.</span>
<span class="c1">// For that purpose there are two keywords: `Any` and `AnyObject`</span>
<span class="c1">// `AnyObject` == `id` from Objective-C</span>
<span class="c1">// `Any` works with any values (class, Int, struct, etc.)</span>
<span class="k">var</span> <span class="nv">anyVar</span><span class="p">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="mi">7</span>
<span class="n">anyVar</span> <span class="o">=</span> <span class="s">"Changed value to a string, not good practice, but possible."</span>
<span class="k">let</span> <span class="nv">anyObjectVar</span><span class="p">:</span> <span class="kt">AnyObject</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="kt">NSNumber</span>

<span class="c1">// MARK: Extensions</span>

<span class="c1">// Extensions allow you to add extra functionality to an already-declared type, even one that you don't have the source code for.</span>

<span class="c1">// Square now "conforms" to the `CustomStringConvertible` protocol</span>
<span class="kd">extension</span> <span class="kt">Square</span><span class="p">:</span> <span class="kt">CustomStringConvertible</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">description</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">"Area: </span><span class="se">\(</span><span class="k">self</span><span class="o">.</span><span class="nf">getArea</span><span class="p">()</span><span class="se">)</span><span class="s"> - ID: </span><span class="se">\(</span><span class="k">self</span><span class="o">.</span><span class="n">identifier</span><span class="se">)</span><span class="s">"</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Square: </span><span class="se">\(</span><span class="n">mySquare</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>

<span class="c1">// You can also extend built-in types</span>
<span class="kd">extension</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">doubled</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">self</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">multipliedBy</span><span class="p">(</span><span class="nv">num</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">num</span> <span class="o">*</span> <span class="k">self</span>
    <span class="p">}</span>

    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">multiplyBy</span><span class="p">(</span><span class="nv">num</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span> <span class="o">*=</span> <span class="n">num</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="mi">7</span><span class="o">.</span><span class="n">doubled</span><span class="p">)</span> <span class="c1">// 14</span>
<span class="nf">print</span><span class="p">(</span><span class="mi">7</span><span class="o">.</span><span class="n">doubled</span><span class="o">.</span><span class="nf">multipliedBy</span><span class="p">(</span><span class="nv">num</span><span class="p">:</span> <span class="mi">3</span><span class="p">))</span> <span class="c1">// 42</span>

<span class="c1">// MARK: Generics</span>

<span class="c1">// Generics: Similar to Java and C#. Use the `where` keyword to specify the</span>
<span class="c1">//   requirements of the generics.</span>

<span class="kd">func</span> <span class="n">findIndex</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">Equatable</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">array</span><span class="p">:</span> <span class="p">[</span><span class="kt">T</span><span class="p">],</span> <span class="nv">valueToFind</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">in</span> <span class="n">array</span><span class="o">.</span><span class="nf">enumerated</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="n">valueToFind</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">index</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
<span class="nf">findIndex</span><span class="p">(</span><span class="nv">array</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="nv">valueToFind</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// Optional(2)</span>

<span class="c1">// You can extend types with generics as well</span>
<span class="kd">extension</span> <span class="kt">Array</span> <span class="k">where</span> <span class="kt">Array</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">sum</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">var</span> <span class="nv">total</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">el</span> <span class="k">in</span> <span class="k">self</span> <span class="p">{</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">el</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">total</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// MARK: Operators</span>

<span class="c1">// Custom operators can start with the characters:</span>
<span class="c1">//      / = - + * % &lt; &gt; ! &amp; | ^ . ~</span>
<span class="c1">// or</span>
<span class="c1">// Unicode math, symbol, arrow, dingbat, and line/box drawing characters.</span>
<span class="k">prefix</span> <span class="k">operator</span> <span class="o">!!!</span>

<span class="c1">// A prefix operator that triples the side length when used</span>
<span class="k">prefix</span> <span class="kd">func</span> <span class="o">!!!</span> <span class="p">(</span><span class="nv">shape</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">Square</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Square</span> <span class="p">{</span>
    <span class="n">shape</span><span class="o">.</span><span class="n">sideLength</span> <span class="o">*=</span> <span class="mi">3</span>
    <span class="k">return</span> <span class="n">shape</span>
<span class="p">}</span>

<span class="c1">// current value</span>
<span class="nf">print</span><span class="p">(</span><span class="n">mySquare</span><span class="o">.</span><span class="n">sideLength</span><span class="p">)</span> <span class="c1">// 4</span>

<span class="c1">// change side length using custom !!! operator, increases size by 3</span>
<span class="o">!!!</span><span class="n">mySquare</span>
<span class="nf">print</span><span class="p">(</span><span class="n">mySquare</span><span class="o">.</span><span class="n">sideLength</span><span class="p">)</span> <span class="c1">// 12</span>

<span class="c1">// Operators can also be generics</span>
<span class="k">infix</span> <span class="k">operator</span> <span class="o">&lt;-&gt;</span>
<span class="kd">func</span> <span class="o">&lt;-&gt;&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">Equatable</span><span class="o">&gt;</span> <span class="p">(</span><span class="nv">a</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">T</span><span class="p">,</span> <span class="nv">b</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">c</span> <span class="o">=</span> <span class="n">a</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">c</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">foo</span><span class="p">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mi">10</span>
<span class="k">var</span> <span class="nv">bar</span><span class="p">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mi">20</span>

<span class="n">foo</span> <span class="o">&lt;-&gt;</span> <span class="n">bar</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"foo is </span><span class="se">\(</span><span class="n">foo</span><span class="se">)</span><span class="s">, bar is </span><span class="se">\(</span><span class="n">bar</span><span class="se">)</span><span class="s">"</span><span class="p">)</span> <span class="c1">// "foo is 20.0, bar is 10.0"</span>

<span class="c1">// MARK: - Error Handling</span>

<span class="c1">// The `Error` protocol is used when throwing errors to catch</span>
<span class="kd">enum</span> <span class="kt">MyError</span><span class="p">:</span> <span class="kt">Error</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nf">badValue</span><span class="p">(</span><span class="nv">msg</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span>
    <span class="k">case</span> <span class="nf">reallyBadValue</span><span class="p">(</span><span class="nv">msg</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// functions marked with `throws` must be called using `try`</span>
<span class="kd">func</span> <span class="nf">fakeFetch</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="mi">7</span> <span class="o">==</span> <span class="n">value</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="kt">MyError</span><span class="o">.</span><span class="nf">reallyBadValue</span><span class="p">(</span><span class="nv">msg</span><span class="p">:</span> <span class="s">"Some really bad value"</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="s">"test"</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">testTryStuff</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// assumes there will be no error thrown, otherwise a runtime exception is raised</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="k">try!</span> <span class="nf">fakeFetch</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">7</span><span class="p">)</span>

    <span class="c1">// if an error is thrown, then it proceeds, but if the value is nil</span>
    <span class="c1">// it also wraps every return value in an optional, even if its already optional</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="k">try</span><span class="p">?</span> <span class="nf">fakeFetch</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">7</span><span class="p">)</span>

    <span class="k">do</span> <span class="p">{</span>
        <span class="c1">// normal try operation that provides error handling via `catch` block</span>
        <span class="k">try</span> <span class="nf">fakeFetch</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="kt">MyError</span><span class="o">.</span><span class="nf">badValue</span><span class="p">(</span><span class="k">let</span> <span class="nv">msg</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Error message: </span><span class="se">\(</span><span class="n">msg</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
        <span class="c1">// must be exhaustive</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nf">testTryStuff</span><span class="p">()</span>
</code></pre></div>
    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/swift.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by Grant Timmerman, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/swift.html.markdown">32 contributor(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://github.com/grant">Grant Timmerman</a>,
        <a href="http://github.com/cbess">Christopher Bess</a>,
        <a href="http://github.com/kamidox">Joey Huang</a>,
        <a href="http://github.com/anthonyn60">Anthony Nguyen</a>,
        <a href="https://github.com/cwalk">Clayton Walker</a>,
        <a href="http://visualcosita.xyz">Fernando Valverde</a>,
        <a href="https://github.com/rogaven">Alexey Nazaroff</a>,
        <a href="https://github.com/Samasaur1">@Samasaur1</a>
    </p>

    <p>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
