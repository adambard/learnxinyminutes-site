<!DOCTYPE html lang="en-us" xml:lang="en-us" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="en-us">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Julia in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/julia/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fjulia%2F&text=Learn+X+in+Y+minutes%2C+where+X%3DJulia">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="/">Learn X in Y minutes</a></h1>
  <h2>Where X=Julia</h2>
    <p class="filelink">
    Get the code:
    <a href="/docs/files/learnjulia.jl">learnjulia.jl</a>
    </p>
  <div id="doc">
    <p>Julia is a new homoiconic functional language focused on technical computing.
While having the full power of homoiconic macros, first-class functions,
and low-level control, Julia is as easy to learn and use as Python.</p>

<p>This is based on Julia version 1.0.0.</p>
<div class="highlight"><pre class="highlight julia"><code><span class="c"># Single line comments start with a hash (pound) symbol.</span>
<span class="cm">#= Multiline comments can be written
   by putting '#=' before the text  and '=#'
   after the text. They can also be nested.
=#</span>

<span class="c">####################################################</span>
<span class="c">## 1. Primitive Datatypes and Operators</span>
<span class="c">####################################################</span>

<span class="c"># Everything in Julia is an expression.</span>

<span class="c"># There are several basic types of numbers.</span>
<span class="n">typeof</span><span class="x">(</span><span class="mi">3</span><span class="x">)</span>       <span class="c"># =&gt; Int64</span>
<span class="n">typeof</span><span class="x">(</span><span class="mf">3.2</span><span class="x">)</span>     <span class="c"># =&gt; Float64</span>
<span class="n">typeof</span><span class="x">(</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="nb">im</span><span class="x">)</span> <span class="c"># =&gt; Complex{Int64}</span>
<span class="n">typeof</span><span class="x">(</span><span class="mi">2</span> <span class="o">//</span> <span class="mi">3</span><span class="x">)</span>  <span class="c"># =&gt; Rational{Int64}</span>

<span class="c"># All of the normal infix operators are available.</span>
<span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>      <span class="c"># =&gt; 2</span>
<span class="mi">8</span> <span class="o">-</span> <span class="mi">1</span>      <span class="c"># =&gt; 7</span>
<span class="mi">10</span> <span class="o">*</span> <span class="mi">2</span>     <span class="c"># =&gt; 20</span>
<span class="mi">35</span> <span class="o">/</span> <span class="mi">5</span>     <span class="c"># =&gt; 7.0</span>
<span class="mi">10</span> <span class="o">/</span> <span class="mi">2</span>     <span class="c"># =&gt; 5.0  # dividing integers always results in a Float64</span>
<span class="n">div</span><span class="x">(</span><span class="mi">5</span><span class="x">,</span> <span class="mi">2</span><span class="x">)</span>  <span class="c"># =&gt; 2    # for a truncated result, use div</span>
<span class="mi">5</span> <span class="o">\</span> <span class="mi">35</span>     <span class="c"># =&gt; 7.0</span>
<span class="mi">2</span><span class="o">^</span><span class="mi">2</span>        <span class="c"># =&gt; 4    # power, not bitwise xor</span>
<span class="mi">12</span> <span class="o">%</span> <span class="mi">10</span>    <span class="c"># =&gt; 2</span>

<span class="c"># Enforce precedence with parentheses</span>
<span class="x">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span><span class="x">)</span> <span class="o">*</span> <span class="mi">2</span>  <span class="c"># =&gt; 8</span>

<span class="c"># Julia (unlike Python for instance) has integer under/overflow</span>
<span class="mi">10</span><span class="o">^</span><span class="mi">19</span>      <span class="c"># =&gt; -8446744073709551616</span>
<span class="c"># use bigint or floating point to avoid this</span>
<span class="n">big</span><span class="x">(</span><span class="mi">10</span><span class="x">)</span><span class="o">^</span><span class="mi">19</span> <span class="c"># =&gt; 10000000000000000000</span>
<span class="mf">1e19</span>       <span class="c"># =&gt; 1.0e19</span>
<span class="mf">10.0</span><span class="o">^</span><span class="mi">19</span>    <span class="c"># =&gt; 1.0e19</span>

<span class="c"># Bitwise Operators</span>
<span class="o">~</span><span class="mi">2</span>         <span class="c"># =&gt; -3 # bitwise not</span>
<span class="mi">3</span> <span class="o">&amp;</span> <span class="mi">5</span>      <span class="c"># =&gt; 1  # bitwise and</span>
<span class="mi">2</span> <span class="o">|</span> <span class="mi">4</span>      <span class="c"># =&gt; 6  # bitwise or</span>
<span class="n">xor</span><span class="x">(</span><span class="mi">2</span><span class="x">,</span> <span class="mi">4</span><span class="x">)</span>  <span class="c"># =&gt; 6  # bitwise xor</span>
<span class="mi">2</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span>    <span class="c"># =&gt; 1  # logical shift right</span>
<span class="mi">2</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>     <span class="c"># =&gt; 1  # arithmetic shift right</span>
<span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>     <span class="c"># =&gt; 4  # logical/arithmetic shift left</span>

<span class="c"># Use the bitstring function to see the binary representation of a number.</span>
<span class="n">bitstring</span><span class="x">(</span><span class="mi">12345</span><span class="x">)</span>
<span class="c"># =&gt; "0000000000000000000000000000000000000000000000000011000000111001"</span>
<span class="n">bitstring</span><span class="x">(</span><span class="mf">12345.0</span><span class="x">)</span>
<span class="c"># =&gt; "0100000011001000000111001000000000000000000000000000000000000000"</span>

<span class="c"># Boolean values are primitives</span>
<span class="nb">true</span>
<span class="nb">false</span>

<span class="c"># Boolean operators</span>
<span class="o">!</span><span class="nb">true</span>   <span class="c"># =&gt; false</span>
<span class="o">!</span><span class="nb">false</span>  <span class="c"># =&gt; true</span>
<span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c"># =&gt; true</span>
<span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c"># =&gt; false</span>
<span class="mi">1</span> <span class="o">!=</span> <span class="mi">1</span>  <span class="c"># =&gt; false</span>
<span class="mi">2</span> <span class="o">!=</span> <span class="mi">1</span>  <span class="c"># =&gt; true</span>
<span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">10</span>  <span class="c"># =&gt; true</span>
<span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">10</span>  <span class="c"># =&gt; false</span>
<span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">2</span>  <span class="c"># =&gt; true</span>
<span class="mi">2</span> <span class="o">&gt;=</span> <span class="mi">2</span>  <span class="c"># =&gt; true</span>
<span class="c"># Comparisons can be chained, like in Python but unlike many other languages</span>
<span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="mi">3</span>  <span class="c"># =&gt; true</span>
<span class="mi">2</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">&lt;</span> <span class="mi">2</span>  <span class="c"># =&gt; false</span>

<span class="c"># Strings are created with "</span>
<span class="s">"This is a string."</span>

<span class="c"># Character literals are written with '</span>
<span class="sc">'a'</span>

<span class="c"># Strings are UTF8 encoded, so strings like "π" or "☃" are not directly equivalent</span>
<span class="c"># to an array of single characters.</span>
<span class="c"># Only if they contain only ASCII characters can they be safely indexed.</span>
<span class="n">ascii</span><span class="x">(</span><span class="s">"This is a string"</span><span class="x">)[</span><span class="mi">1</span><span class="x">]</span>    <span class="c"># =&gt; 'T'</span>
<span class="c"># =&gt; 'T': ASCII/Unicode U+0054 (category Lu: Letter, uppercase)</span>
<span class="c"># Beware, Julia indexes everything from 1 (like MATLAB), not 0 (like most languages).</span>
<span class="c"># Otherwise, iterating over strings is recommended (map, for loops, etc).</span>

<span class="c"># String can be compared lexicographically, in dictionnary order:</span>
<span class="s">"good"</span> <span class="o">&gt;</span> <span class="s">"bye"</span>   <span class="c"># =&gt; true</span>
<span class="s">"good"</span> <span class="o">==</span> <span class="s">"good"</span> <span class="c"># =&gt; true</span>
<span class="s">"1 + 2 = 3"</span> <span class="o">==</span> <span class="s">"1 + 2 = </span><span class="si">$</span><span class="s">(1 + 2)"</span> <span class="c"># =&gt; true</span>

<span class="c"># $(..) can be used for string interpolation:</span>
<span class="s">"2 + 2 = </span><span class="si">$</span><span class="s">(2 + 2)"</span> <span class="c"># =&gt; "2 + 2 = 4"</span>
<span class="c"># You can put any Julia expression inside the parentheses.</span>

<span class="c"># Printing is easy</span>
<span class="n">println</span><span class="x">(</span><span class="s">"I'm Julia. Nice to meet you!"</span><span class="x">)</span>  <span class="c"># =&gt; I'm Julia. Nice to meet you!</span>

<span class="c"># Another way to format strings is the printf macro from the stdlib Printf.</span>
<span class="k">using</span> <span class="n">Printf</span>   <span class="c"># this is how you load (or import) a module</span>
<span class="nd">@printf</span> <span class="s">"%d is less than %f</span><span class="se">\n</span><span class="s">"</span> <span class="mf">4.5</span> <span class="mf">5.3</span>   <span class="c"># =&gt; 5 is less than 5.300000</span>


<span class="c">####################################################</span>
<span class="c">## 2. Variables and Collections</span>
<span class="c">####################################################</span>

<span class="c"># You don't declare variables before assigning to them.</span>
<span class="n">someVar</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c"># =&gt; 5</span>
<span class="n">someVar</span>      <span class="c"># =&gt; 5</span>

<span class="c"># Accessing a previously unassigned variable is an error</span>
<span class="k">try</span>
    <span class="n">someOtherVar</span>  <span class="c"># =&gt; ERROR: UndefVarError: someOtherVar not defined</span>
<span class="k">catch</span> <span class="n">e</span>
    <span class="n">println</span><span class="x">(</span><span class="n">e</span><span class="x">)</span>
<span class="k">end</span>

<span class="c"># Variable names start with a letter or underscore.</span>
<span class="c"># After that, you can use letters, digits, underscores, and exclamation points.</span>
<span class="n">SomeOtherVar123!</span> <span class="o">=</span> <span class="mi">6</span>  <span class="c"># =&gt; 6</span>

<span class="c"># You can also use certain unicode characters</span>
<span class="c"># here ☃ is a Unicode 'snowman' characters, see http://emojipedia.org/%E2%98%83%EF%B8%8F if it displays wrongly here</span>
<span class="n">☃</span> <span class="o">=</span> <span class="mi">8</span>  <span class="c"># =&gt; 8</span>
<span class="c"># These are especially handy for mathematical notation, like the constant π</span>
<span class="mi">2</span> <span class="o">*</span> <span class="nb">π</span>  <span class="c"># =&gt; 6.283185307179586</span>

<span class="c"># A note on naming conventions in Julia:</span>
<span class="c">#</span>
<span class="c"># * Word separation can be indicated by underscores ('_'), but use of</span>
<span class="c">#   underscores is discouraged unless the name would be hard to read</span>
<span class="c">#   otherwise.</span>
<span class="c">#</span>
<span class="c"># * Names of Types begin with a capital letter and word separation is shown</span>
<span class="c">#   with CamelCase instead of underscores.</span>
<span class="c">#</span>
<span class="c"># * Names of functions and macros are in lower case, without underscores.</span>
<span class="c">#</span>
<span class="c"># * Functions that modify their inputs have names that end in !. These</span>
<span class="c">#   functions are sometimes called mutating functions or in-place functions.</span>

<span class="c"># Arrays store a sequence of values indexed by integers 1 through n:</span>
<span class="n">a</span> <span class="o">=</span> <span class="kt">Int64</span><span class="x">[]</span> <span class="c"># =&gt; 0-element Array{Int64,1}</span>

<span class="c"># 1-dimensional array literals can be written with comma-separated values.</span>
<span class="n">b</span> <span class="o">=</span> <span class="x">[</span><span class="mi">4</span><span class="x">,</span> <span class="mi">5</span><span class="x">,</span> <span class="mi">6</span><span class="x">]</span> <span class="c"># =&gt; 3-element Array{Int64,1}: [4, 5, 6]</span>
<span class="n">b</span> <span class="o">=</span> <span class="x">[</span><span class="mi">4</span><span class="x">;</span> <span class="mi">5</span><span class="x">;</span> <span class="mi">6</span><span class="x">]</span> <span class="c"># =&gt; 3-element Array{Int64,1}: [4, 5, 6]</span>
<span class="n">b</span><span class="x">[</span><span class="mi">1</span><span class="x">]</span>    <span class="c"># =&gt; 4</span>
<span class="n">b</span><span class="x">[</span><span class="k">end</span><span class="x">]</span>  <span class="c"># =&gt; 6</span>

<span class="c"># 2-dimensional arrays use space-separated values and semicolon-separated rows.</span>
<span class="n">matrix</span> <span class="o">=</span> <span class="x">[</span><span class="mi">1</span> <span class="mi">2</span><span class="x">;</span> <span class="mi">3</span> <span class="mi">4</span><span class="x">]</span> <span class="c"># =&gt; 2×2 Array{Int64,2}: [1 2; 3 4]</span>

<span class="c"># Arrays of a particular type</span>
<span class="n">b</span> <span class="o">=</span> <span class="kt">Int8</span><span class="x">[</span><span class="mi">4</span><span class="x">,</span> <span class="mi">5</span><span class="x">,</span> <span class="mi">6</span><span class="x">]</span> <span class="c"># =&gt; 3-element Array{Int8,1}: [4, 5, 6]</span>

<span class="c"># Add stuff to the end of a list with push! and append!</span>
<span class="c"># By convention, the exclamation mark '!' is appended to names of functions</span>
<span class="c"># that modify their arguments</span>
<span class="n">push!</span><span class="x">(</span><span class="n">a</span><span class="x">,</span> <span class="mi">1</span><span class="x">)</span>    <span class="c"># =&gt; [1]</span>
<span class="n">push!</span><span class="x">(</span><span class="n">a</span><span class="x">,</span> <span class="mi">2</span><span class="x">)</span>    <span class="c"># =&gt; [1,2]</span>
<span class="n">push!</span><span class="x">(</span><span class="n">a</span><span class="x">,</span> <span class="mi">4</span><span class="x">)</span>    <span class="c"># =&gt; [1,2,4]</span>
<span class="n">push!</span><span class="x">(</span><span class="n">a</span><span class="x">,</span> <span class="mi">3</span><span class="x">)</span>    <span class="c"># =&gt; [1,2,4,3]</span>
<span class="n">append!</span><span class="x">(</span><span class="n">a</span><span class="x">,</span> <span class="n">b</span><span class="x">)</span>  <span class="c"># =&gt; [1,2,4,3,4,5,6]</span>

<span class="c"># Remove from the end with pop</span>
<span class="n">pop!</span><span class="x">(</span><span class="n">b</span><span class="x">)</span>  <span class="c"># =&gt; 6</span>
<span class="n">b</span> <span class="c"># =&gt; [4,5]</span>

<span class="c"># Let's put it back</span>
<span class="n">push!</span><span class="x">(</span><span class="n">b</span><span class="x">,</span> <span class="mi">6</span><span class="x">)</span>  <span class="c"># =&gt; [4,5,6]</span>
<span class="n">b</span> <span class="c"># =&gt; [4,5,6]</span>

<span class="n">a</span><span class="x">[</span><span class="mi">1</span><span class="x">]</span>  <span class="c"># =&gt; 1  # remember that Julia indexes from 1, not 0!</span>

<span class="c"># end is a shorthand for the last index. It can be used in any</span>
<span class="c"># indexing expression</span>
<span class="n">a</span><span class="x">[</span><span class="k">end</span><span class="x">]</span>  <span class="c"># =&gt; 6</span>

<span class="c"># we also have popfirst! and pushfirst!</span>
<span class="n">popfirst!</span><span class="x">(</span><span class="n">a</span><span class="x">)</span>  <span class="c"># =&gt; 1 </span>
<span class="n">a</span> <span class="c"># =&gt; [2,4,3,4,5,6]</span>
<span class="n">pushfirst!</span><span class="x">(</span><span class="n">a</span><span class="x">,</span> <span class="mi">7</span><span class="x">)</span>  <span class="c"># =&gt; [7,2,4,3,4,5,6]</span>
<span class="n">a</span> <span class="c"># =&gt; [7,2,4,3,4,5,6]</span>

<span class="c"># Function names that end in exclamations points indicate that they modify</span>
<span class="c"># their argument.</span>
<span class="n">arr</span> <span class="o">=</span> <span class="x">[</span><span class="mi">5</span><span class="x">,</span><span class="mi">4</span><span class="x">,</span><span class="mi">6</span><span class="x">]</span>  <span class="c"># =&gt; 3-element Array{Int64,1}: [5,4,6]</span>
<span class="n">sort</span><span class="x">(</span><span class="n">arr</span><span class="x">)</span>      <span class="c"># =&gt; [4,5,6]</span>
<span class="n">arr</span>            <span class="c"># =&gt; [5,4,6]</span>
<span class="n">sort!</span><span class="x">(</span><span class="n">arr</span><span class="x">)</span>     <span class="c"># =&gt; [4,5,6]</span>
<span class="n">arr</span>            <span class="c"># =&gt; [4,5,6]</span>

<span class="c"># Looking out of bounds is a BoundsError</span>
<span class="k">try</span>
    <span class="n">a</span><span class="x">[</span><span class="mi">0</span><span class="x">]</span> 
    <span class="c"># =&gt; ERROR: BoundsError: attempt to access 7-element Array{Int64,1} at </span>
    <span class="c"># index [0]</span>
    <span class="c"># =&gt; Stacktrace:</span>
    <span class="c"># =&gt;  [1] getindex(::Array{Int64,1}, ::Int64) at .\array.jl:731</span>
    <span class="c"># =&gt;  [2] top-level scope at none:0</span>
    <span class="c"># =&gt;  [3] ...</span>
    <span class="c"># =&gt; in expression starting at ...\LearnJulia.jl:180</span>
    <span class="n">a</span><span class="x">[</span><span class="k">end</span> <span class="o">+</span> <span class="mi">1</span><span class="x">]</span> 
    <span class="c"># =&gt; ERROR: BoundsError: attempt to access 7-element Array{Int64,1} at </span>
    <span class="c"># index [8]</span>
    <span class="c"># =&gt; Stacktrace:</span>
    <span class="c"># =&gt;  [1] getindex(::Array{Int64,1}, ::Int64) at .\array.jl:731</span>
    <span class="c"># =&gt;  [2] top-level scope at none:0</span>
    <span class="c"># =&gt;  [3] ...</span>
    <span class="c"># =&gt; in expression starting at ...\LearnJulia.jl:188</span>
<span class="k">catch</span> <span class="n">e</span>
    <span class="n">println</span><span class="x">(</span><span class="n">e</span><span class="x">)</span>
<span class="k">end</span>

<span class="c"># Errors list the line and file they came from, even if it's in the standard</span>
<span class="c"># library. You can look in the folder share/julia inside the julia folder to</span>
<span class="c"># find these files.</span>

<span class="c"># You can initialize arrays from ranges</span>
<span class="n">a</span> <span class="o">=</span> <span class="x">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">5</span><span class="x">;]</span>  <span class="c"># =&gt; 5-element Array{Int64,1}: [1,2,3,4,5]</span>
<span class="n">a2</span> <span class="o">=</span> <span class="x">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">5</span><span class="x">]</span>  <span class="c"># =&gt; 1-element Array{UnitRange{Int64},1}: [1:5]</span>

<span class="c"># You can look at ranges with slice syntax.</span>
<span class="n">a</span><span class="x">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">3</span><span class="x">]</span>    <span class="c"># =&gt; [1, 2, 3]</span>
<span class="n">a</span><span class="x">[</span><span class="mi">2</span><span class="o">:</span><span class="k">end</span><span class="x">]</span>  <span class="c"># =&gt; [2, 3, 4, 5]</span>

<span class="c"># Remove elements from an array by index with splice!</span>
<span class="n">arr</span> <span class="o">=</span> <span class="x">[</span><span class="mi">3</span><span class="x">,</span><span class="mi">4</span><span class="x">,</span><span class="mi">5</span><span class="x">]</span>
<span class="n">splice!</span><span class="x">(</span><span class="n">arr</span><span class="x">,</span> <span class="mi">2</span><span class="x">)</span> <span class="c"># =&gt; 4 </span>
<span class="n">arr</span> <span class="c"># =&gt; [3,5]</span>

<span class="c"># Concatenate lists with append!</span>
<span class="n">b</span> <span class="o">=</span> <span class="x">[</span><span class="mi">1</span><span class="x">,</span><span class="mi">2</span><span class="x">,</span><span class="mi">3</span><span class="x">]</span>
<span class="n">append!</span><span class="x">(</span><span class="n">a</span><span class="x">,</span> <span class="n">b</span><span class="x">)</span> <span class="c"># =&gt; [1, 2, 3, 4, 5, 1, 2, 3]</span>
<span class="n">a</span> <span class="c"># =&gt; [1, 2, 3, 4, 5, 1, 2, 3]</span>

<span class="c"># Check for existence in a list with in</span>
<span class="k">in</span><span class="x">(</span><span class="mi">1</span><span class="x">,</span> <span class="n">a</span><span class="x">)</span>  <span class="c"># =&gt; true</span>

<span class="c"># Examine the length with length</span>
<span class="n">length</span><span class="x">(</span><span class="n">a</span><span class="x">)</span>  <span class="c"># =&gt; 8</span>

<span class="c"># Tuples are immutable.</span>
<span class="n">tup</span> <span class="o">=</span> <span class="x">(</span><span class="mi">1</span><span class="x">,</span> <span class="mi">2</span><span class="x">,</span> <span class="mi">3</span><span class="x">)</span>  <span class="c"># =&gt; (1,2,3)</span>
<span class="n">typeof</span><span class="x">(</span><span class="n">tup</span><span class="x">)</span> <span class="c"># =&gt; Tuple{Int64,Int64,Int64}</span>
<span class="n">tup</span><span class="x">[</span><span class="mi">1</span><span class="x">]</span> <span class="c"># =&gt; 1</span>
<span class="k">try</span>
    <span class="n">tup</span><span class="x">[</span><span class="mi">1</span><span class="x">]</span> <span class="o">=</span> <span class="mi">3</span>  
    <span class="c"># =&gt; ERROR: MethodError: no method matching </span>
    <span class="c"># setindex!(::Tuple{Int64,Int64,Int64}, ::Int64, ::Int64)</span>
<span class="k">catch</span> <span class="n">e</span>
    <span class="n">println</span><span class="x">(</span><span class="n">e</span><span class="x">)</span>
<span class="k">end</span>

<span class="c"># Many array functions also work on tuples</span>
<span class="n">length</span><span class="x">(</span><span class="n">tup</span><span class="x">)</span> <span class="c"># =&gt; 3</span>
<span class="n">tup</span><span class="x">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">2</span><span class="x">]</span>    <span class="c"># =&gt; (1,2)</span>
<span class="k">in</span><span class="x">(</span><span class="mi">2</span><span class="x">,</span> <span class="n">tup</span><span class="x">)</span>  <span class="c"># =&gt; true</span>

<span class="c"># You can unpack tuples into variables</span>
<span class="n">a</span><span class="x">,</span> <span class="n">b</span><span class="x">,</span> <span class="n">c</span> <span class="o">=</span> <span class="x">(</span><span class="mi">1</span><span class="x">,</span> <span class="mi">2</span><span class="x">,</span> <span class="mi">3</span><span class="x">)</span>  <span class="c"># =&gt; (1,2,3)  </span>
<span class="n">a</span>  <span class="c"># =&gt; 1</span>
<span class="n">b</span>  <span class="c"># =&gt; 2</span>
<span class="n">c</span>  <span class="c"># =&gt; 3</span>

<span class="c"># Tuples are created even if you leave out the parentheses</span>
<span class="n">d</span><span class="x">,</span> <span class="n">e</span><span class="x">,</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">4</span><span class="x">,</span> <span class="mi">5</span><span class="x">,</span> <span class="mi">6</span>  <span class="c"># =&gt; (4,5,6)</span>
<span class="n">d</span>  <span class="c"># =&gt; 4</span>
<span class="n">e</span>  <span class="c"># =&gt; 5</span>
<span class="n">f</span>  <span class="c"># =&gt; 6</span>

<span class="c"># A 1-element tuple is distinct from the value it contains</span>
<span class="x">(</span><span class="mi">1</span><span class="x">,)</span> <span class="o">==</span> <span class="mi">1</span> <span class="c"># =&gt; false</span>
<span class="x">(</span><span class="mi">1</span><span class="x">)</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c"># =&gt; true</span>

<span class="c"># Look how easy it is to swap two values</span>
<span class="n">e</span><span class="x">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="x">,</span> <span class="n">e</span>  <span class="c"># =&gt; (5,4) </span>
<span class="n">d</span>  <span class="c"># =&gt; 5</span>
<span class="n">e</span>  <span class="c"># =&gt; 4</span>

<span class="c"># Dictionaries store mappings</span>
<span class="n">emptyDict</span> <span class="o">=</span> <span class="kt">Dict</span><span class="x">()</span>  <span class="c"># =&gt; Dict{Any,Any} with 0 entries</span>

<span class="c"># You can create a dictionary using a literal</span>
<span class="n">filledDict</span> <span class="o">=</span> <span class="kt">Dict</span><span class="x">(</span><span class="s">"one"</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="x">,</span> <span class="s">"two"</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="x">,</span> <span class="s">"three"</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="x">)</span>
<span class="c"># =&gt; Dict{String,Int64} with 3 entries:</span>
<span class="c"># =&gt;  "two" =&gt; 2, "one" =&gt; 1, "three" =&gt; 3</span>

<span class="c"># Look up values with []</span>
<span class="n">filledDict</span><span class="x">[</span><span class="s">"one"</span><span class="x">]</span>  <span class="c"># =&gt; 1</span>

<span class="c"># Get all keys</span>
<span class="n">keys</span><span class="x">(</span><span class="n">filledDict</span><span class="x">)</span>
<span class="c"># =&gt; Base.KeySet for a Dict{String,Int64} with 3 entries. Keys:</span>
<span class="c"># =&gt;  "two", "one", "three"</span>
<span class="c"># Note - dictionary keys are not sorted or in the order you inserted them.</span>

<span class="c"># Get all values</span>
<span class="n">values</span><span class="x">(</span><span class="n">filledDict</span><span class="x">)</span>
<span class="c"># =&gt; Base.ValueIterator for a Dict{String,Int64} with 3 entries. Values: </span>
<span class="c"># =&gt;  2, 1, 3</span>
<span class="c"># Note - Same as above regarding key ordering.</span>

<span class="c"># Check for existence of keys in a dictionary with in, haskey</span>
<span class="k">in</span><span class="x">((</span><span class="s">"one"</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="x">),</span> <span class="n">filledDict</span><span class="x">)</span>  <span class="c"># =&gt; true</span>
<span class="k">in</span><span class="x">((</span><span class="s">"two"</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="x">),</span> <span class="n">filledDict</span><span class="x">)</span>  <span class="c"># =&gt; false</span>
<span class="n">haskey</span><span class="x">(</span><span class="n">filledDict</span><span class="x">,</span> <span class="s">"one"</span><span class="x">)</span>     <span class="c"># =&gt; true</span>
<span class="n">haskey</span><span class="x">(</span><span class="n">filledDict</span><span class="x">,</span> <span class="mi">1</span><span class="x">)</span>         <span class="c"># =&gt; false</span>

<span class="c"># Trying to look up a non-existent key will raise an error</span>
<span class="k">try</span>
    <span class="n">filledDict</span><span class="x">[</span><span class="s">"four"</span><span class="x">]</span>  <span class="c"># =&gt; ERROR: KeyError: key "four" not found</span>
<span class="k">catch</span> <span class="n">e</span>
    <span class="n">println</span><span class="x">(</span><span class="n">e</span><span class="x">)</span>
<span class="k">end</span>

<span class="c"># Use the get method to avoid that error by providing a default value</span>
<span class="c"># get(dictionary, key, defaultValue)</span>
<span class="n">get</span><span class="x">(</span><span class="n">filledDict</span><span class="x">,</span> <span class="s">"one"</span><span class="x">,</span> <span class="mi">4</span><span class="x">)</span>   <span class="c"># =&gt; 1</span>
<span class="n">get</span><span class="x">(</span><span class="n">filledDict</span><span class="x">,</span> <span class="s">"four"</span><span class="x">,</span> <span class="mi">4</span><span class="x">)</span>  <span class="c"># =&gt; 4</span>

<span class="c"># Use Sets to represent collections of unordered, unique values</span>
<span class="n">emptySet</span> <span class="o">=</span> <span class="kt">Set</span><span class="x">()</span>  <span class="c"># =&gt; Set(Any[])</span>
<span class="c"># Initialize a set with values</span>
<span class="n">filledSet</span> <span class="o">=</span> <span class="kt">Set</span><span class="x">([</span><span class="mi">1</span><span class="x">,</span> <span class="mi">2</span><span class="x">,</span> <span class="mi">2</span><span class="x">,</span> <span class="mi">3</span><span class="x">,</span> <span class="mi">4</span><span class="x">])</span>  <span class="c"># =&gt; Set([4, 2, 3, 1])</span>

<span class="c"># Add more values to a set</span>
<span class="n">push!</span><span class="x">(</span><span class="n">filledSet</span><span class="x">,</span> <span class="mi">5</span><span class="x">)</span>  <span class="c"># =&gt; Set([4, 2, 3, 5, 1])</span>

<span class="c"># Check if the values are in the set</span>
<span class="k">in</span><span class="x">(</span><span class="mi">2</span><span class="x">,</span> <span class="n">filledSet</span><span class="x">)</span>   <span class="c"># =&gt; true</span>
<span class="k">in</span><span class="x">(</span><span class="mi">10</span><span class="x">,</span> <span class="n">filledSet</span><span class="x">)</span>  <span class="c"># =&gt; false</span>

<span class="c"># There are functions for set intersection, union, and difference.</span>
<span class="n">otherSet</span> <span class="o">=</span> <span class="kt">Set</span><span class="x">([</span><span class="mi">3</span><span class="x">,</span> <span class="mi">4</span><span class="x">,</span> <span class="mi">5</span><span class="x">,</span> <span class="mi">6</span><span class="x">])</span>         <span class="c"># =&gt; Set([4, 3, 5, 6])</span>
<span class="n">intersect</span><span class="x">(</span><span class="n">filledSet</span><span class="x">,</span> <span class="n">otherSet</span><span class="x">)</span>      <span class="c"># =&gt; Set([4, 3, 5])</span>
<span class="n">union</span><span class="x">(</span><span class="n">filledSet</span><span class="x">,</span> <span class="n">otherSet</span><span class="x">)</span>          <span class="c"># =&gt; Set([4, 2, 3, 5, 6, 1])</span>
<span class="n">setdiff</span><span class="x">(</span><span class="kt">Set</span><span class="x">([</span><span class="mi">1</span><span class="x">,</span><span class="mi">2</span><span class="x">,</span><span class="mi">3</span><span class="x">,</span><span class="mi">4</span><span class="x">]),</span> <span class="kt">Set</span><span class="x">([</span><span class="mi">2</span><span class="x">,</span><span class="mi">3</span><span class="x">,</span><span class="mi">5</span><span class="x">]))</span> <span class="c"># =&gt; Set([4, 1])</span>

<span class="c"># Assignment with `=` attaches a new label to the same value without copying</span>
<span class="n">a</span> <span class="o">=</span> <span class="x">[</span><span class="mi">1</span><span class="x">,</span> <span class="mi">2</span><span class="x">,</span> <span class="mi">3</span><span class="x">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
<span class="c"># Now `b` and `a` point to the same value, so changing one affects the other:</span>
<span class="n">a</span><span class="x">[</span><span class="mi">3</span><span class="x">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">b</span><span class="x">[</span><span class="mi">3</span><span class="x">]</span>  <span class="c"># =&gt; 5</span>

<span class="c"># The `copy()` function can create a shallow copy of an array, dictionary,</span>
<span class="c"># or other container</span>
<span class="n">a</span> <span class="o">=</span> <span class="x">[</span><span class="mi">1</span><span class="x">,</span> <span class="mi">2</span><span class="x">,</span> <span class="mi">3</span><span class="x">]</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">copy</span><span class="x">(</span><span class="n">a</span><span class="x">)</span>
<span class="n">a</span><span class="x">[</span><span class="mi">3</span><span class="x">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">c</span><span class="x">[</span><span class="mi">3</span><span class="x">]</span> <span class="c"># =&gt; 3</span>

<span class="c">####################################################</span>
<span class="c">## 3. Control Flow</span>
<span class="c">####################################################</span>

<span class="c"># Let's make a variable</span>
<span class="n">someVar</span> <span class="o">=</span> <span class="mi">5</span>

<span class="c"># Here is an if statement. Indentation is not meaningful in Julia.</span>
<span class="k">if</span> <span class="n">someVar</span> <span class="o">&gt;</span> <span class="mi">10</span>
    <span class="n">println</span><span class="x">(</span><span class="s">"someVar is totally bigger than 10."</span><span class="x">)</span>
<span class="k">elseif</span> <span class="n">someVar</span> <span class="o">&lt;</span> <span class="mi">10</span>    <span class="c"># This elseif clause is optional.</span>
    <span class="n">println</span><span class="x">(</span><span class="s">"someVar is smaller than 10."</span><span class="x">)</span>
<span class="k">else</span>                    <span class="c"># The else clause is optional too.</span>
    <span class="n">println</span><span class="x">(</span><span class="s">"someVar is indeed 10."</span><span class="x">)</span>
<span class="k">end</span>
<span class="c"># =&gt; prints "some var is smaller than 10"</span>

<span class="c"># For loops iterate over iterables.</span>
<span class="c"># Iterable types include Range, Array, Set, Dict, and AbstractString.</span>
<span class="k">for</span> <span class="n">animal</span> <span class="o">=</span> <span class="x">[</span><span class="s">"dog"</span><span class="x">,</span> <span class="s">"cat"</span><span class="x">,</span> <span class="s">"mouse"</span><span class="x">]</span>
    <span class="n">println</span><span class="x">(</span><span class="s">"</span><span class="si">$</span><span class="s">animal is a mammal"</span><span class="x">)</span>
    <span class="c"># You can use $ to interpolate variables or expression into strings.</span>
    <span class="c"># In this special case, no need for parenthesis: $animal and $(animal) give the same</span>
<span class="k">end</span>
<span class="c"># =&gt; dog is a mammal</span>
<span class="c"># =&gt; cat is a mammal</span>
<span class="c"># =&gt; mouse is a mammal</span>

<span class="c"># You can use 'in' instead of '='.</span>
<span class="k">for</span> <span class="n">animal</span> <span class="k">in</span> <span class="x">[</span><span class="s">"dog"</span><span class="x">,</span> <span class="s">"cat"</span><span class="x">,</span> <span class="s">"mouse"</span><span class="x">]</span>
    <span class="n">println</span><span class="x">(</span><span class="s">"</span><span class="si">$</span><span class="s">animal is a mammal"</span><span class="x">)</span>
<span class="k">end</span>
<span class="c"># =&gt; dog is a mammal</span>
<span class="c"># =&gt; cat is a mammal</span>
<span class="c"># =&gt; mouse is a mammal</span>

<span class="k">for</span> <span class="n">pair</span> <span class="k">in</span> <span class="kt">Dict</span><span class="x">(</span><span class="s">"dog"</span> <span class="o">=&gt;</span> <span class="s">"mammal"</span><span class="x">,</span> <span class="s">"cat"</span> <span class="o">=&gt;</span> <span class="s">"mammal"</span><span class="x">,</span> <span class="s">"mouse"</span> <span class="o">=&gt;</span> <span class="s">"mammal"</span><span class="x">)</span>
    <span class="n">from</span><span class="x">,</span> <span class="n">to</span> <span class="o">=</span> <span class="n">pair</span>
    <span class="n">println</span><span class="x">(</span><span class="s">"</span><span class="si">$</span><span class="s">from is a </span><span class="si">$</span><span class="s">to"</span><span class="x">)</span>
<span class="k">end</span>
<span class="c"># =&gt; mouse is a mammal</span>
<span class="c"># =&gt; cat is a mammal</span>
<span class="c"># =&gt; dog is a mammal</span>

<span class="k">for</span> <span class="x">(</span><span class="n">k</span><span class="x">,</span> <span class="n">v</span><span class="x">)</span> <span class="k">in</span> <span class="kt">Dict</span><span class="x">(</span><span class="s">"dog"</span> <span class="o">=&gt;</span> <span class="s">"mammal"</span><span class="x">,</span> <span class="s">"cat"</span> <span class="o">=&gt;</span> <span class="s">"mammal"</span><span class="x">,</span> <span class="s">"mouse"</span> <span class="o">=&gt;</span> <span class="s">"mammal"</span><span class="x">)</span>
    <span class="n">println</span><span class="x">(</span><span class="s">"</span><span class="si">$</span><span class="s">k is a </span><span class="si">$</span><span class="s">v"</span><span class="x">)</span>
<span class="k">end</span>
<span class="c"># =&gt; mouse is a mammal</span>
<span class="c"># =&gt; cat is a mammal</span>
<span class="c"># =&gt; dog is a mammal</span>

<span class="c"># While loops loop while a condition is true</span>
<span class="n">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">4</span>
        <span class="n">println</span><span class="x">(</span><span class="n">x</span><span class="x">)</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c"># Shorthand for in place increment: x = x + 1</span>
    <span class="k">end</span>
<span class="k">end</span>
<span class="c"># =&gt; 0</span>
<span class="c"># =&gt; 1</span>
<span class="c"># =&gt; 2</span>
<span class="c"># =&gt; 3</span>

<span class="c"># Handle exceptions with a try/catch block</span>
<span class="k">try</span>
    <span class="n">error</span><span class="x">(</span><span class="s">"help"</span><span class="x">)</span>
<span class="k">catch</span> <span class="n">e</span>
    <span class="n">println</span><span class="x">(</span><span class="s">"caught it </span><span class="si">$</span><span class="s">e"</span><span class="x">)</span>
<span class="k">end</span>
<span class="c"># =&gt; caught it ErrorException("help")</span>

<span class="c">####################################################</span>
<span class="c">## 4. Functions</span>
<span class="c">####################################################</span>

<span class="c"># The keyword 'function' creates new functions</span>
<span class="c"># function name(arglist)</span>
<span class="c">#   body...</span>
<span class="c"># end</span>
<span class="k">function</span><span class="nf"> add</span><span class="x">(</span><span class="n">x</span><span class="x">,</span> <span class="n">y</span><span class="x">)</span>
    <span class="n">println</span><span class="x">(</span><span class="s">"x is </span><span class="si">$</span><span class="s">x and y is </span><span class="si">$</span><span class="s">y"</span><span class="x">)</span>

    <span class="c"># Functions return the value of their last statement</span>
    <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="k">end</span>

<span class="n">add</span><span class="x">(</span><span class="mi">5</span><span class="x">,</span> <span class="mi">6</span><span class="x">)</span>
<span class="c"># =&gt; x is 5 and y is 6</span>
<span class="c"># =&gt; 11</span>

<span class="c"># Compact assignment of functions</span>
<span class="n">f_add</span><span class="x">(</span><span class="n">x</span><span class="x">,</span> <span class="n">y</span><span class="x">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>  <span class="c"># =&gt; f_add (generic function with 1 method)</span>
<span class="n">f_add</span><span class="x">(</span><span class="mi">3</span><span class="x">,</span> <span class="mi">4</span><span class="x">)</span>  <span class="c"># =&gt; 7</span>

<span class="c"># Function can also return multiple values as tuple</span>
<span class="n">fn</span><span class="x">(</span><span class="n">x</span><span class="x">,</span> <span class="n">y</span><span class="x">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="x">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="c"># =&gt; fn (generic function with 1 method)</span>
<span class="n">fn</span><span class="x">(</span><span class="mi">3</span><span class="x">,</span> <span class="mi">4</span><span class="x">)</span>  <span class="c"># =&gt; (7, -1)</span>

<span class="c"># You can define functions that take a variable number of</span>
<span class="c"># positional arguments</span>
<span class="k">function</span><span class="nf"> varargs</span><span class="x">(</span><span class="n">args</span><span class="o">...</span><span class="x">)</span>
    <span class="k">return</span> <span class="n">args</span>
    <span class="c"># use the keyword return to return anywhere in the function</span>
<span class="k">end</span>
<span class="c"># =&gt; varargs (generic function with 1 method)</span>

<span class="n">varargs</span><span class="x">(</span><span class="mi">1</span><span class="x">,</span> <span class="mi">2</span><span class="x">,</span> <span class="mi">3</span><span class="x">)</span>  <span class="c"># =&gt; (1,2,3)</span>

<span class="c"># The ... is called a splat.</span>
<span class="c"># We just used it in a function definition.</span>
<span class="c"># It can also be used in a function call,</span>
<span class="c"># where it will splat an Array or Tuple's contents into the argument list.</span>
<span class="n">add</span><span class="x">([</span><span class="mi">5</span><span class="x">,</span><span class="mi">6</span><span class="x">]</span><span class="o">...</span><span class="x">)</span>  <span class="c"># this is equivalent to add(5,6)</span>

<span class="n">x</span> <span class="o">=</span> <span class="x">(</span><span class="mi">5</span><span class="x">,</span> <span class="mi">6</span><span class="x">)</span>  <span class="c"># =&gt; (5,6)</span>
<span class="n">add</span><span class="x">(</span><span class="n">x</span><span class="o">...</span><span class="x">)</span>  <span class="c"># this is equivalent to add(5,6)</span>


<span class="c"># You can define functions with optional positional arguments</span>
<span class="k">function</span><span class="nf"> defaults</span><span class="x">(</span><span class="n">a</span><span class="x">,</span> <span class="n">b</span><span class="x">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">5</span><span class="x">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">6</span><span class="x">)</span>
    <span class="k">return</span> <span class="s">"</span><span class="si">$</span><span class="s">a </span><span class="si">$</span><span class="s">b and </span><span class="si">$</span><span class="s">x </span><span class="si">$</span><span class="s">y"</span>
<span class="k">end</span>
<span class="c"># =&gt; defaults (generic function with 3 methods)</span>

<span class="n">defaults</span><span class="x">(</span><span class="sc">'h'</span><span class="x">,</span> <span class="sc">'g'</span><span class="x">)</span>  <span class="c"># =&gt; "h g and 5 6"</span>
<span class="n">defaults</span><span class="x">(</span><span class="sc">'h'</span><span class="x">,</span> <span class="sc">'g'</span><span class="x">,</span> <span class="sc">'j'</span><span class="x">)</span>  <span class="c"># =&gt; "h g and j 6"</span>
<span class="n">defaults</span><span class="x">(</span><span class="sc">'h'</span><span class="x">,</span> <span class="sc">'g'</span><span class="x">,</span> <span class="sc">'j'</span><span class="x">,</span> <span class="sc">'k'</span><span class="x">)</span>  <span class="c"># =&gt; "h g and j k"</span>
<span class="k">try</span>
    <span class="n">defaults</span><span class="x">(</span><span class="sc">'h'</span><span class="x">)</span>  <span class="c"># =&gt; ERROR: MethodError: no method matching defaults(::Char)</span>
    <span class="n">defaults</span><span class="x">()</span>  <span class="c"># =&gt; ERROR: MethodError: no method matching defaults()</span>
<span class="k">catch</span> <span class="n">e</span>
    <span class="n">println</span><span class="x">(</span><span class="n">e</span><span class="x">)</span>
<span class="k">end</span>

<span class="c"># You can define functions that take keyword arguments</span>
<span class="k">function</span><span class="nf"> keyword_args</span><span class="x">(;</span><span class="n">k1</span><span class="o">=</span><span class="mi">4</span><span class="x">,</span> <span class="n">name2</span><span class="o">=</span><span class="s">"hello"</span><span class="x">)</span>  <span class="c"># note the ;</span>
    <span class="k">return</span> <span class="kt">Dict</span><span class="x">(</span><span class="s">"k1"</span> <span class="o">=&gt;</span> <span class="n">k1</span><span class="x">,</span> <span class="s">"name2"</span> <span class="o">=&gt;</span> <span class="n">name2</span><span class="x">)</span>
<span class="k">end</span>
<span class="c"># =&gt; keyword_args (generic function with 1 method)</span>

<span class="n">keyword_args</span><span class="x">(</span><span class="n">name2</span><span class="o">=</span><span class="s">"ness"</span><span class="x">)</span>  <span class="c"># =&gt; ["name2"=&gt;"ness", "k1"=&gt;4]</span>
<span class="n">keyword_args</span><span class="x">(</span><span class="n">k1</span><span class="o">=</span><span class="s">"mine"</span><span class="x">)</span>     <span class="c"># =&gt; ["name2"=&gt;"hello", "k1"=&gt;"mine"]</span>
<span class="n">keyword_args</span><span class="x">()</span>              <span class="c"># =&gt; ["name2"=&gt;"hello", "k1"=&gt;4]</span>

<span class="c"># You can combine all kinds of arguments in the same function</span>
<span class="k">function</span><span class="nf"> all_the_args</span><span class="x">(</span><span class="n">normalArg</span><span class="x">,</span> <span class="n">optionalPositionalArg</span><span class="o">=</span><span class="mi">2</span><span class="x">;</span> <span class="n">keywordArg</span><span class="o">=</span><span class="s">"foo"</span><span class="x">)</span>
    <span class="n">println</span><span class="x">(</span><span class="s">"normal arg: </span><span class="si">$</span><span class="s">normalArg"</span><span class="x">)</span>
    <span class="n">println</span><span class="x">(</span><span class="s">"optional arg: </span><span class="si">$</span><span class="s">optionalPositionalArg"</span><span class="x">)</span>
    <span class="n">println</span><span class="x">(</span><span class="s">"keyword arg: </span><span class="si">$</span><span class="s">keywordArg"</span><span class="x">)</span>
<span class="k">end</span>
<span class="c"># =&gt; all_the_args (generic function with 2 methods)</span>

<span class="n">all_the_args</span><span class="x">(</span><span class="mi">1</span><span class="x">,</span> <span class="mi">3</span><span class="x">,</span> <span class="n">keywordArg</span><span class="o">=</span><span class="mi">4</span><span class="x">)</span>
<span class="c"># =&gt; normal arg: 1</span>
<span class="c"># =&gt; optional arg: 3</span>
<span class="c"># =&gt; keyword arg: 4</span>

<span class="c"># Julia has first class functions</span>
<span class="k">function</span><span class="nf"> create_adder</span><span class="x">(</span><span class="n">x</span><span class="x">)</span>
    <span class="n">adder</span> <span class="o">=</span> <span class="k">function</span><span class="nf"> </span><span class="o">(</span><span class="n">y</span><span class="x">)</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
    <span class="k">end</span>
    <span class="k">return</span> <span class="n">adder</span>
<span class="k">end</span>
<span class="c"># =&gt; create_adder (generic function with 1 method)</span>

<span class="c"># This is "stabby lambda syntax" for creating anonymous functions</span>
<span class="x">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="x">)(</span><span class="mi">3</span><span class="x">)</span>  <span class="c"># =&gt; true</span>

<span class="c"># This function is identical to create_adder implementation above.</span>
<span class="k">function</span><span class="nf"> create_adder</span><span class="x">(</span><span class="n">x</span><span class="x">)</span>
    <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="k">end</span>
<span class="c"># =&gt; create_adder (generic function with 1 method)</span>

<span class="c"># You can also name the internal function, if you want</span>
<span class="k">function</span><span class="nf"> create_adder</span><span class="x">(</span><span class="n">x</span><span class="x">)</span>
    <span class="k">function</span><span class="nf"> adder</span><span class="x">(</span><span class="n">y</span><span class="x">)</span>
        <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
    <span class="k">end</span>
    <span class="n">adder</span>
<span class="k">end</span>
<span class="c"># =&gt; create_adder (generic function with 1 method)</span>

<span class="n">add_10</span> <span class="o">=</span> <span class="n">create_adder</span><span class="x">(</span><span class="mi">10</span><span class="x">)</span> <span class="c"># =&gt; (::getfield(Main, Symbol("#adder#11")){Int64}) </span>
                          <span class="c"># (generic function with 1 method)</span>
<span class="n">add_10</span><span class="x">(</span><span class="mi">3</span><span class="x">)</span> <span class="c"># =&gt; 13</span>


<span class="c"># There are built-in higher order functions</span>
<span class="n">map</span><span class="x">(</span><span class="n">add_10</span><span class="x">,</span> <span class="x">[</span><span class="mi">1</span><span class="x">,</span><span class="mi">2</span><span class="x">,</span><span class="mi">3</span><span class="x">])</span>  <span class="c"># =&gt; [11, 12, 13]</span>
<span class="n">filter</span><span class="x">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="x">,</span> <span class="x">[</span><span class="mi">3</span><span class="x">,</span> <span class="mi">4</span><span class="x">,</span> <span class="mi">5</span><span class="x">,</span> <span class="mi">6</span><span class="x">,</span> <span class="mi">7</span><span class="x">])</span>  <span class="c"># =&gt; [6, 7]</span>

<span class="c"># We can use list comprehensions</span>
<span class="x">[</span><span class="n">add_10</span><span class="x">(</span><span class="n">i</span><span class="x">)</span> <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="x">[</span><span class="mi">1</span><span class="x">,</span> <span class="mi">2</span><span class="x">,</span> <span class="mi">3</span><span class="x">]]</span>   <span class="c"># =&gt; [11, 12, 13]</span>
<span class="x">[</span><span class="n">add_10</span><span class="x">(</span><span class="n">i</span><span class="x">)</span> <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="x">[</span><span class="mi">1</span><span class="x">,</span> <span class="mi">2</span><span class="x">,</span> <span class="mi">3</span><span class="x">]]</span>  <span class="c"># =&gt; [11, 12, 13]</span>
<span class="x">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="x">[</span><span class="mi">3</span><span class="x">,</span> <span class="mi">4</span><span class="x">,</span> <span class="mi">5</span><span class="x">,</span> <span class="mi">6</span><span class="x">,</span> <span class="mi">7</span><span class="x">]</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="x">]</span> <span class="c"># =&gt; [6, 7]</span>

<span class="c">####################################################</span>
<span class="c">## 5. Types</span>
<span class="c">####################################################</span>

<span class="c"># Julia has a type system.</span>
<span class="c"># Every value has a type; variables do not have types themselves.</span>
<span class="c"># You can use the `typeof` function to get the type of a value.</span>
<span class="n">typeof</span><span class="x">(</span><span class="mi">5</span><span class="x">)</span>  <span class="c"># =&gt; Int64</span>

<span class="c"># Types are first-class values</span>
<span class="n">typeof</span><span class="x">(</span><span class="kt">Int64</span><span class="x">)</span>     <span class="c"># =&gt; DataType</span>
<span class="n">typeof</span><span class="x">(</span><span class="kt">DataType</span><span class="x">)</span>  <span class="c"># =&gt; DataType</span>
<span class="c"># DataType is the type that represents types, including itself.</span>

<span class="c"># Types are used for documentation, optimizations, and dispatch.</span>
<span class="c"># They are not statically checked.</span>

<span class="c"># Users can define types</span>
<span class="c"># They are like records or structs in other languages.</span>
<span class="c"># New types are defined using the `struct` keyword.</span>

<span class="c"># struct Name</span>
<span class="c">#   field::OptionalType</span>
<span class="c">#   ...</span>
<span class="c"># end</span>
<span class="k">struct</span><span class="nc"> Tiger</span>
    <span class="n">taillength</span><span class="o">::</span><span class="kt">Float64</span>
    <span class="n">coatcolor</span>  <span class="c"># not including a type annotation is the same as `::Any`</span>
<span class="k">end</span>

<span class="c"># The default constructor's arguments are the properties</span>
<span class="c"># of the type, in the order they are listed in the definition</span>
<span class="n">tigger</span> <span class="o">=</span> <span class="n">Tiger</span><span class="x">(</span><span class="mf">3.5</span><span class="x">,</span> <span class="s">"orange"</span><span class="x">)</span>  <span class="c"># =&gt; Tiger(3.5,"orange")</span>

<span class="c"># The type doubles as the constructor function for values of that type</span>
<span class="n">sherekhan</span> <span class="o">=</span> <span class="n">typeof</span><span class="x">(</span><span class="n">tigger</span><span class="x">)(</span><span class="mf">5.6</span><span class="x">,</span> <span class="s">"fire"</span><span class="x">)</span>  <span class="c"># =&gt; Tiger(5.6,"fire")</span>

<span class="c"># These struct-style types are called concrete types</span>
<span class="c"># They can be instantiated, but cannot have subtypes.</span>
<span class="c"># The other kind of types is abstract types.</span>

<span class="c"># abstract Name</span>
<span class="k">abstract type</span><span class="nc"> Cat</span> <span class="k">end</span>  <span class="c"># just a name and point in the type hierarchy</span>

<span class="c"># Abstract types cannot be instantiated, but can have subtypes.</span>
<span class="c"># For example, Number is an abstract type</span>
<span class="n">subtypes</span><span class="x">(</span><span class="kt">Number</span><span class="x">)</span>  <span class="c"># =&gt; 2-element Array{Any,1}:</span>
                  <span class="c"># =&gt;  Complex</span>
                  <span class="c"># =&gt;  Real</span>
<span class="n">subtypes</span><span class="x">(</span><span class="n">Cat</span><span class="x">)</span>  <span class="c"># =&gt; 0-element Array{Any,1}</span>

<span class="c"># AbstractString, as the name implies, is also an abstract type</span>
<span class="n">subtypes</span><span class="x">(</span><span class="kt">AbstractString</span><span class="x">)</span>  <span class="c"># =&gt; 4-element Array{Any,1}:</span>
                          <span class="c"># =&gt;  String</span>
                          <span class="c"># =&gt;  SubString</span>
                          <span class="c"># =&gt;  SubstitutionString</span>
                          <span class="c"># =&gt;  Test.GenericString</span>

<span class="c"># Every type has a super type; use the `supertype` function to get it.</span>
<span class="n">typeof</span><span class="x">(</span><span class="mi">5</span><span class="x">)</span> <span class="c"># =&gt; Int64</span>
<span class="n">supertype</span><span class="x">(</span><span class="kt">Int64</span><span class="x">)</span>    <span class="c"># =&gt; Signed</span>
<span class="n">supertype</span><span class="x">(</span><span class="kt">Signed</span><span class="x">)</span>   <span class="c"># =&gt; Integer</span>
<span class="n">supertype</span><span class="x">(</span><span class="kt">Integer</span><span class="x">)</span>  <span class="c"># =&gt; Real</span>
<span class="n">supertype</span><span class="x">(</span><span class="kt">Real</span><span class="x">)</span>     <span class="c"># =&gt; Number</span>
<span class="n">supertype</span><span class="x">(</span><span class="kt">Number</span><span class="x">)</span>   <span class="c"># =&gt; Any</span>
<span class="n">supertype</span><span class="x">(</span><span class="n">supertype</span><span class="x">(</span><span class="kt">Signed</span><span class="x">))</span>  <span class="c"># =&gt; Real</span>
<span class="n">supertype</span><span class="x">(</span><span class="kt">Any</span><span class="x">)</span>      <span class="c"># =&gt; Any</span>
<span class="c"># All of these type, except for Int64, are abstract.</span>
<span class="n">typeof</span><span class="x">(</span><span class="s">"fire"</span><span class="x">)</span>      <span class="c"># =&gt; String</span>
<span class="n">supertype</span><span class="x">(</span><span class="kt">String</span><span class="x">)</span>   <span class="c"># =&gt; AbstractString</span>
<span class="c"># Likewise here with String</span>
<span class="n">supertype</span><span class="x">(</span><span class="kt">SubString</span><span class="x">)</span>  <span class="c"># =&gt; AbstractString</span>

<span class="c"># &lt;: is the subtyping operator</span>
<span class="k">struct</span><span class="nc"> Lion</span> <span class="o">&lt;:</span> <span class="n">Cat</span>  <span class="c"># Lion is a subtype of Cat</span>
    <span class="n">maneColor</span>
    <span class="n">roar</span><span class="o">::</span><span class="kt">AbstractString</span>
<span class="k">end</span>

<span class="c"># You can define more constructors for your type</span>
<span class="c"># Just define a function of the same name as the type</span>
<span class="c"># and call an existing constructor to get a value of the correct type</span>
<span class="n">Lion</span><span class="x">(</span><span class="n">roar</span><span class="o">::</span><span class="kt">AbstractString</span><span class="x">)</span> <span class="o">=</span> <span class="n">Lion</span><span class="x">(</span><span class="s">"green"</span><span class="x">,</span> <span class="n">roar</span><span class="x">)</span>
<span class="c"># This is an outer constructor because it's outside the type definition</span>

<span class="k">struct</span><span class="nc"> Panther</span> <span class="o">&lt;:</span> <span class="n">Cat</span>  <span class="c"># Panther is also a subtype of Cat</span>
    <span class="n">eyeColor</span>
    <span class="n">Panther</span><span class="x">()</span> <span class="o">=</span> <span class="n">new</span><span class="x">(</span><span class="s">"green"</span><span class="x">)</span>
    <span class="c"># Panthers will only have this constructor, and no default constructor.</span>
<span class="k">end</span>
<span class="c"># Using inner constructors, like Panther does, gives you control</span>
<span class="c"># over how values of the type can be created.</span>
<span class="c"># When possible, you should use outer constructors rather than inner ones.</span>

<span class="c">####################################################</span>
<span class="c">## 6. Multiple-Dispatch</span>
<span class="c">####################################################</span>

<span class="c"># In Julia, all named functions are generic functions</span>
<span class="c"># This means that they are built up from many small methods</span>
<span class="c"># Each constructor for Lion is a method of the generic function Lion.</span>

<span class="c"># For a non-constructor example, let's make a function meow:</span>

<span class="c"># Definitions for Lion, Panther, Tiger</span>
<span class="k">function</span><span class="nf"> meow</span><span class="x">(</span><span class="n">animal</span><span class="o">::</span><span class="n">Lion</span><span class="x">)</span>
    <span class="n">animal</span><span class="o">.</span><span class="n">roar</span>  <span class="c"># access type properties using dot notation</span>
<span class="k">end</span>

<span class="k">function</span><span class="nf"> meow</span><span class="x">(</span><span class="n">animal</span><span class="o">::</span><span class="n">Panther</span><span class="x">)</span>
    <span class="s">"grrr"</span>
<span class="k">end</span>

<span class="k">function</span><span class="nf"> meow</span><span class="x">(</span><span class="n">animal</span><span class="o">::</span><span class="n">Tiger</span><span class="x">)</span>
    <span class="s">"rawwwr"</span>
<span class="k">end</span>

<span class="c"># Testing the meow function</span>
<span class="n">meow</span><span class="x">(</span><span class="n">tigger</span><span class="x">)</span>  <span class="c"># =&gt; "rawwwr"</span>
<span class="n">meow</span><span class="x">(</span><span class="n">Lion</span><span class="x">(</span><span class="s">"brown"</span><span class="x">,</span> <span class="s">"ROAAR"</span><span class="x">))</span>  <span class="c"># =&gt; "ROAAR"</span>
<span class="n">meow</span><span class="x">(</span><span class="n">Panther</span><span class="x">())</span> <span class="c"># =&gt; "grrr"</span>

<span class="c"># Review the local type hierarchy</span>
<span class="n">Tiger</span>   <span class="o">&lt;:</span> <span class="n">Cat</span>  <span class="c"># =&gt; false</span>
<span class="n">Lion</span>    <span class="o">&lt;:</span> <span class="n">Cat</span>  <span class="c"># =&gt; true</span>
<span class="n">Panther</span> <span class="o">&lt;:</span> <span class="n">Cat</span>  <span class="c"># =&gt; true</span>

<span class="c"># Defining a function that takes Cats</span>
<span class="k">function</span><span class="nf"> pet_cat</span><span class="x">(</span><span class="n">cat</span><span class="o">::</span><span class="n">Cat</span><span class="x">)</span>
    <span class="n">println</span><span class="x">(</span><span class="s">"The cat says </span><span class="si">$</span><span class="s">(meow(cat))"</span><span class="x">)</span>
<span class="k">end</span>
<span class="c"># =&gt; pet_cat (generic function with 1 method)</span>

<span class="n">pet_cat</span><span class="x">(</span><span class="n">Lion</span><span class="x">(</span><span class="s">"42"</span><span class="x">))</span> <span class="c"># =&gt; The cat says 42</span>
<span class="k">try</span>
    <span class="n">pet_cat</span><span class="x">(</span><span class="n">tigger</span><span class="x">)</span> <span class="c"># =&gt; ERROR: MethodError: no method matching pet_cat(::Tiger)</span>
<span class="k">catch</span> <span class="n">e</span>
    <span class="n">println</span><span class="x">(</span><span class="n">e</span><span class="x">)</span>
<span class="k">end</span>

<span class="c"># In OO languages, single dispatch is common;</span>
<span class="c"># this means that the method is picked based on the type of the first argument.</span>
<span class="c"># In Julia, all of the argument types contribute to selecting the best method.</span>

<span class="c"># Let's define a function with more arguments, so we can see the difference</span>
<span class="k">function</span><span class="nf"> fight</span><span class="x">(</span><span class="n">t</span><span class="o">::</span><span class="n">Tiger</span><span class="x">,</span> <span class="n">c</span><span class="o">::</span><span class="n">Cat</span><span class="x">)</span>
    <span class="n">println</span><span class="x">(</span><span class="s">"The </span><span class="si">$</span><span class="s">(t.coatcolor) tiger wins!"</span><span class="x">)</span>
<span class="k">end</span>
<span class="c"># =&gt; fight (generic function with 1 method)</span>

<span class="n">fight</span><span class="x">(</span><span class="n">tigger</span><span class="x">,</span> <span class="n">Panther</span><span class="x">())</span>  <span class="c"># =&gt; The orange tiger wins!</span>
<span class="n">fight</span><span class="x">(</span><span class="n">tigger</span><span class="x">,</span> <span class="n">Lion</span><span class="x">(</span><span class="s">"ROAR"</span><span class="x">))</span> <span class="c"># =&gt; The orange tiger wins!</span>

<span class="c"># Let's change the behavior when the Cat is specifically a Lion</span>
<span class="n">fight</span><span class="x">(</span><span class="n">t</span><span class="o">::</span><span class="n">Tiger</span><span class="x">,</span> <span class="n">l</span><span class="o">::</span><span class="n">Lion</span><span class="x">)</span> <span class="o">=</span> <span class="n">println</span><span class="x">(</span><span class="s">"The </span><span class="si">$</span><span class="s">(l.maneColor)-maned lion wins!"</span><span class="x">)</span>
<span class="c"># =&gt; fight (generic function with 2 methods)</span>

<span class="n">fight</span><span class="x">(</span><span class="n">tigger</span><span class="x">,</span> <span class="n">Panther</span><span class="x">())</span>  <span class="c"># =&gt; The orange tiger wins!</span>
<span class="n">fight</span><span class="x">(</span><span class="n">tigger</span><span class="x">,</span> <span class="n">Lion</span><span class="x">(</span><span class="s">"ROAR"</span><span class="x">))</span> <span class="c"># =&gt; The green-maned lion wins!</span>

<span class="c"># We don't need a Tiger in order to fight</span>
<span class="n">fight</span><span class="x">(</span><span class="n">l</span><span class="o">::</span><span class="n">Lion</span><span class="x">,</span> <span class="n">c</span><span class="o">::</span><span class="n">Cat</span><span class="x">)</span> <span class="o">=</span> <span class="n">println</span><span class="x">(</span><span class="s">"The victorious cat says </span><span class="si">$</span><span class="s">(meow(c))"</span><span class="x">)</span>
<span class="c"># =&gt; fight (generic function with 3 methods)</span>

<span class="n">fight</span><span class="x">(</span><span class="n">Lion</span><span class="x">(</span><span class="s">"balooga!"</span><span class="x">),</span> <span class="n">Panther</span><span class="x">())</span>  <span class="c"># =&gt; The victorious cat says grrr</span>
<span class="k">try</span>
    <span class="n">fight</span><span class="x">(</span><span class="n">Panther</span><span class="x">(),</span> <span class="n">Lion</span><span class="x">(</span><span class="s">"RAWR"</span><span class="x">))</span>  
    <span class="c"># =&gt; ERROR: MethodError: no method matching fight(::Panther, ::Lion)</span>
    <span class="c"># =&gt; Closest candidates are:</span>
    <span class="c"># =&gt;   fight(::Tiger, ::Lion) at ...</span>
    <span class="c"># =&gt;   fight(::Tiger, ::Cat) at ...</span>
    <span class="c"># =&gt;   fight(::Lion, ::Cat) at ...</span>
    <span class="c"># =&gt; ...</span>
<span class="k">catch</span> <span class="n">e</span>
    <span class="n">println</span><span class="x">(</span><span class="n">e</span><span class="x">)</span>
<span class="k">end</span>

<span class="c"># Also let the cat go first</span>
<span class="n">fight</span><span class="x">(</span><span class="n">c</span><span class="o">::</span><span class="n">Cat</span><span class="x">,</span> <span class="n">l</span><span class="o">::</span><span class="n">Lion</span><span class="x">)</span> <span class="o">=</span> <span class="n">println</span><span class="x">(</span><span class="s">"The cat beats the Lion"</span><span class="x">)</span>
<span class="c"># =&gt; fight (generic function with 4 methods)</span>

<span class="c"># This warning is because it's unclear which fight will be called in:</span>
<span class="k">try</span>
    <span class="n">fight</span><span class="x">(</span><span class="n">Lion</span><span class="x">(</span><span class="s">"RAR"</span><span class="x">),</span> <span class="n">Lion</span><span class="x">(</span><span class="s">"brown"</span><span class="x">,</span> <span class="s">"rarrr"</span><span class="x">))</span>
    <span class="c"># =&gt; ERROR: MethodError: fight(::Lion, ::Lion) is ambiguous. Candidates:</span>
    <span class="c"># =&gt;   fight(c::Cat, l::Lion) in Main at ...</span>
    <span class="c"># =&gt;   fight(l::Lion, c::Cat) in Main at ...</span>
    <span class="c"># =&gt; Possible fix, define</span>
    <span class="c"># =&gt;   fight(::Lion, ::Lion)</span>
    <span class="c"># =&gt; ...</span>
<span class="k">catch</span> <span class="n">e</span>
    <span class="n">println</span><span class="x">(</span><span class="n">e</span><span class="x">)</span>
<span class="k">end</span>
<span class="c"># The result may be different in other versions of Julia</span>

<span class="n">fight</span><span class="x">(</span><span class="n">l</span><span class="o">::</span><span class="n">Lion</span><span class="x">,</span> <span class="n">l2</span><span class="o">::</span><span class="n">Lion</span><span class="x">)</span> <span class="o">=</span> <span class="n">println</span><span class="x">(</span><span class="s">"The lions come to a tie"</span><span class="x">)</span> 
<span class="c"># =&gt; fight (generic function with 5 methods)</span>
<span class="n">fight</span><span class="x">(</span><span class="n">Lion</span><span class="x">(</span><span class="s">"RAR"</span><span class="x">),</span> <span class="n">Lion</span><span class="x">(</span><span class="s">"brown"</span><span class="x">,</span> <span class="s">"rarrr"</span><span class="x">))</span>  <span class="c"># =&gt; The lions come to a tie</span>


<span class="c"># Under the hood</span>
<span class="c"># You can take a look at the llvm  and the assembly code generated.</span>

<span class="n">square_area</span><span class="x">(</span><span class="n">l</span><span class="x">)</span> <span class="o">=</span> <span class="n">l</span> <span class="o">*</span> <span class="n">l</span>  <span class="c"># square_area (generic function with 1 method)</span>

<span class="n">square_area</span><span class="x">(</span><span class="mi">5</span><span class="x">)</span>  <span class="c"># =&gt; 25</span>

<span class="c"># What happens when we feed square_area an integer?</span>
<span class="n">code_native</span><span class="x">(</span><span class="n">square_area</span><span class="x">,</span> <span class="x">(</span><span class="kt">Int32</span><span class="x">,),</span> <span class="n">syntax</span> <span class="o">=</span> <span class="o">:</span><span class="n">intel</span><span class="x">)</span>
    <span class="c">#         .text</span>
    <span class="c"># ; Function square_area {</span>
    <span class="c"># ; Location: REPL[116]:1       # Prologue</span>
    <span class="c">#         push    rbp</span>
    <span class="c">#         mov     rbp, rsp</span>
    <span class="c"># ; Function *; {</span>
    <span class="c"># ; Location: int.jl:54</span>
    <span class="c">#         imul    ecx, ecx      # Square l and store the result in ECX</span>
    <span class="c"># ;}</span>
    <span class="c">#         mov     eax, ecx</span>
    <span class="c">#         pop     rbp           # Restore old base pointer</span>
    <span class="c">#         ret                   # Result will still be in EAX</span>
    <span class="c">#         nop     dword ptr [rax + rax]</span>
    <span class="c"># ;}</span>

<span class="n">code_native</span><span class="x">(</span><span class="n">square_area</span><span class="x">,</span> <span class="x">(</span><span class="kt">Float32</span><span class="x">,),</span> <span class="n">syntax</span> <span class="o">=</span> <span class="o">:</span><span class="n">intel</span><span class="x">)</span>
    <span class="c">#         .text</span>
    <span class="c"># ; Function square_area {</span>
    <span class="c"># ; Location: REPL[116]:1</span>
    <span class="c">#         push    rbp</span>
    <span class="c">#         mov     rbp, rsp</span>
    <span class="c"># ; Function *; {</span>
    <span class="c"># ; Location: float.jl:398</span>
    <span class="c">#         vmulss  xmm0, xmm0, xmm0  # Scalar single precision multiply (AVX)</span>
    <span class="c"># ;}</span>
    <span class="c">#         pop     rbp</span>
    <span class="c">#         ret</span>
    <span class="c">#         nop     word ptr [rax + rax]</span>
    <span class="c"># ;}</span>

<span class="n">code_native</span><span class="x">(</span><span class="n">square_area</span><span class="x">,</span> <span class="x">(</span><span class="kt">Float64</span><span class="x">,),</span> <span class="n">syntax</span> <span class="o">=</span> <span class="o">:</span><span class="n">intel</span><span class="x">)</span>
    <span class="c">#         .text</span>
    <span class="c"># ; Function square_area {</span>
    <span class="c"># ; Location: REPL[116]:1</span>
    <span class="c">#         push    rbp</span>
    <span class="c">#         mov     rbp, rsp</span>
    <span class="c"># ; Function *; {</span>
    <span class="c"># ; Location: float.jl:399</span>
    <span class="c">#         vmulsd  xmm0, xmm0, xmm0  # Scalar double precision multiply (AVX)</span>
    <span class="c"># ;}</span>
    <span class="c">#         pop     rbp</span>
    <span class="c">#         ret</span>
    <span class="c">#         nop     word ptr [rax + rax]</span>
    <span class="c"># ;}</span>

<span class="c"># Note that julia will use floating point instructions if any of the</span>
<span class="c"># arguments are floats.</span>
<span class="c"># Let's calculate the area of a circle</span>
<span class="n">circle_area</span><span class="x">(</span><span class="n">r</span><span class="x">)</span> <span class="o">=</span> <span class="nb">pi</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">r</span>     <span class="c"># circle_area (generic function with 1 method)</span>
<span class="n">circle_area</span><span class="x">(</span><span class="mi">5</span><span class="x">)</span>  <span class="c"># 78.53981633974483</span>

<span class="n">code_native</span><span class="x">(</span><span class="n">circle_area</span><span class="x">,</span> <span class="x">(</span><span class="kt">Int32</span><span class="x">,),</span> <span class="n">syntax</span> <span class="o">=</span> <span class="o">:</span><span class="n">intel</span><span class="x">)</span>
    <span class="c">#         .text</span>
    <span class="c"># ; Function circle_area {</span>
    <span class="c"># ; Location: REPL[121]:1</span>
    <span class="c">#         push    rbp</span>
    <span class="c">#         mov     rbp, rsp</span>
    <span class="c"># ; Function *; {</span>
    <span class="c"># ; Location: operators.jl:502</span>
    <span class="c"># ; Function *; {</span>
    <span class="c"># ; Location: promotion.jl:314</span>
    <span class="c"># ; Function promote; {</span>
    <span class="c"># ; Location: promotion.jl:284</span>
    <span class="c"># ; Function _promote; {</span>
    <span class="c"># ; Location: promotion.jl:261</span>
    <span class="c"># ; Function convert; {</span>
    <span class="c"># ; Location: number.jl:7</span>
    <span class="c"># ; Function Type; {</span>
    <span class="c"># ; Location: float.jl:60</span>
    <span class="c">#         vcvtsi2sd       xmm0, xmm0, ecx     # Load integer (r) from memory</span>
    <span class="c">#         movabs  rax, 497710928              # Load pi</span>
    <span class="c"># ;}}}}}</span>
    <span class="c"># ; Function *; {</span>
    <span class="c"># ; Location: float.jl:399</span>
    <span class="c">#         vmulsd  xmm1, xmm0, qword ptr [rax] # pi * r</span>
    <span class="c">#         vmulsd  xmm0, xmm1, xmm0            # (pi * r) * r</span>
    <span class="c"># ;}}</span>
    <span class="c">#         pop     rbp</span>
    <span class="c">#         ret</span>
    <span class="c">#         nop     dword ptr [rax]</span>
    <span class="c"># ;}</span>

<span class="n">code_native</span><span class="x">(</span><span class="n">circle_area</span><span class="x">,</span> <span class="x">(</span><span class="kt">Float64</span><span class="x">,),</span> <span class="n">syntax</span> <span class="o">=</span> <span class="o">:</span><span class="n">intel</span><span class="x">)</span>
    <span class="c">#         .text</span>
    <span class="c"># ; Function circle_area {</span>
    <span class="c"># ; Location: REPL[121]:1</span>
    <span class="c">#         push    rbp</span>
    <span class="c">#         mov     rbp, rsp</span>
    <span class="c">#         movabs  rax, 497711048</span>
    <span class="c"># ; Function *; {</span>
    <span class="c"># ; Location: operators.jl:502</span>
    <span class="c"># ; Function *; {</span>
    <span class="c"># ; Location: promotion.jl:314</span>
    <span class="c"># ; Function *; {</span>
    <span class="c"># ; Location: float.jl:399</span>
    <span class="c">#         vmulsd  xmm1, xmm0, qword ptr [rax]</span>
    <span class="c"># ;}}}</span>
    <span class="c"># ; Function *; {</span>
    <span class="c"># ; Location: float.jl:399</span>
    <span class="c">#         vmulsd  xmm0, xmm1, xmm0</span>
    <span class="c"># ;}</span>
    <span class="c">#         pop     rbp</span>
    <span class="c">#         ret</span>
    <span class="c">#         nop     dword ptr [rax + rax]</span>
    <span class="c"># ;}</span>
</code></pre></div>
<h2>Further Reading</h2>

<p>You can get a lot more detail from the <a href="https://docs.julialang.org/">Julia Documentation</a></p>

<p>The best place to get help with Julia is the (very friendly) <a href="https://discourse.julialang.org/">Discourse forum</a>.</p>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/julia.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by Leah Hanson, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/julia.html.markdown">29 contributor(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://leahhanson.us">Leah Hanson</a>,
        <a href="https://github.com/pranitbauva1997">Pranit Bauva</a>,
        <a href="https://github.com/dlintw">Daniel YC Lin</a>
    </p>

    <p>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
