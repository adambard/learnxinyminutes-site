<!DOCTYPE html lang="pl-pl" xml:lang="pl-pl" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="pl-pl">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Haskell in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/pl-pl/haskell-pl/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fpl-pl%2Fhaskell-pl%2F&text=Learn+X+in+Y+minutes%2C+where+X%3DHaskell">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="/">Learn X in Y minutes</a></h1>
  <h2>Where X=Haskell</h2>
    <p class="filelink">
    Get the code:
    <a href="/docs/files/haskell-pl.hs">haskell-pl.hs</a>
    </p>
  <div id="doc">
    <p>Haskell został zaprojektowany jako praktyczny, czysto funkcyjny język 
programowania. Jest znany przede wszystkim ze względu na jego monady oraz system
typów, ale ja lubię do niego wracać przez jego elegancję. Sprawił on, że 
programowanie jest prawdziwą przyjemnością.</p>
<div class="highlight"><pre class="highlight haskell"><code><span class="c1">-- Komentarze jednolinijkowe zaczynają się od dwóch myślników</span>
<span class="cm">{- Komentarze wielolinijkowe należy 
zamykać w bloki klamrami.
-}</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 1. Podstawowe typy danych oraz operatory</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Mamy liczby</span>
<span class="mi">3</span> <span class="c1">-- 3</span>

<span class="c1">-- Podstawowe działania działają tak, jak powinny</span>
<span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">-- 2</span>
<span class="mi">8</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">-- 7</span>
<span class="mi">10</span> <span class="o">*</span> <span class="mi">2</span> <span class="c1">-- 20</span>
<span class="mi">35</span> <span class="o">/</span> <span class="mi">5</span> <span class="c1">-- 7.0</span>

<span class="c1">-- dzielenie domyślnie zwraca ,,dokładny'' wynik</span>
<span class="mi">35</span> <span class="o">/</span> <span class="mi">4</span> <span class="c1">-- 8.75</span>

<span class="c1">-- dzielenie całkowitoliczbowe</span>
<span class="mi">35</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">4</span> <span class="c1">-- 8</span>

<span class="c1">-- wartości logiczne także są podstawowym typem danych:</span>
<span class="kt">True</span>
<span class="kt">False</span>

<span class="c1">-- operacje logiczne: negacja oraz porównania</span>
<span class="n">not</span> <span class="kt">True</span> <span class="c1">-- False</span>
<span class="n">not</span> <span class="kt">False</span> <span class="c1">-- True</span>
<span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="c1">-- True</span>
<span class="mi">1</span> <span class="o">/=</span> <span class="mi">1</span> <span class="c1">-- False</span>
<span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="c1">-- True</span>

<span class="c1">-- W powyższych przykładach, `not` jest funkcją przyjmującą jeden argument.</span>
<span class="c1">-- Haskell nie potrzebuje nawiasów, by wywołać funkcję: argumenty są po prostu</span>
<span class="c1">-- wypisywane jeden za drugim. Ogólnie wygląda to tak:</span>
<span class="c1">-- funkcja arg1 arg2 arg3...</span>
<span class="c1">-- Sekcja poświęcona funkcjom zawiera informacje, jak stworzyć własne.</span>

<span class="c1">-- Łańcuchy znaków (stringi) i pojedyncze znaki:</span>
<span class="s">"To jest lancuch."</span>
<span class="sc">'a'</span> <span class="c1">-- znak</span>
<span class="kt">'Nie</span> <span class="n">mozna</span> <span class="n">laczyc</span> <span class="n">apostrofow</span> <span class="n">z</span> <span class="n">lancuchami</span><span class="o">.</span><span class="n">'</span> <span class="c1">-- błąd!</span>

<span class="c1">-- Łańcuchy można sklejać</span>
<span class="s">"Hello "</span> <span class="o">++</span> <span class="s">"world!"</span> <span class="c1">-- "Hello world!"</span>

<span class="c1">-- Łańcuch jest listą własnych znaków</span>
<span class="p">[</span><span class="sc">'H'</span><span class="p">,</span> <span class="sc">'e'</span><span class="p">,</span> <span class="sc">'l'</span><span class="p">,</span> <span class="sc">'l'</span><span class="p">,</span> <span class="sc">'o'</span><span class="p">]</span> <span class="c1">-- "Hello"</span>
<span class="s">"To jest lancuch"</span> <span class="o">!!</span> <span class="mi">0</span> <span class="c1">-- 'T'</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 2. Listy oraz krotki</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Wszystkie elementy listy muszą być tego samego typu.</span>
<span class="c1">-- Poniższe dwie listy są identyczne:</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>

<span class="c1">-- Zakresy są uniwersalne.</span>
<span class="p">[</span><span class="sc">'A'</span><span class="o">..</span><span class="sc">'F'</span><span class="p">]</span> <span class="c1">-- "ABCDEF"</span>

<span class="c1">-- Przy tworzeniu zakresów można określić krok.</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="c1">-- [0, 2, 4, 6, 8, 10]</span>
<span class="p">[</span><span class="mi">5</span><span class="o">..</span><span class="mi">1</span><span class="p">]</span> <span class="c1">-- To nie zadziała, gdyż w Haskellu zakresy tworzone są domyślnie rosnąco</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="o">..</span><span class="mi">1</span><span class="p">]</span> <span class="c1">-- [5, 4, 3, 2, 1]</span>

<span class="c1">-- indeksowanie listy od zera</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="o">!!</span> <span class="mi">3</span> <span class="c1">-- 4</span>

<span class="c1">-- Można nawet tworzyć listy nieskończone!</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span> <span class="c1">-- lista wszystkich liczb naturalnych</span>

<span class="c1">-- Nieskończone listy mają prawo działać, ponieważ Haskell cechuje się leniwym </span>
<span class="c1">-- wartościowaniem. To oznacza, że obliczane są jedynie te elementy listy, </span>
<span class="c1">-- których istotnie potrzebujemy. Możemy poprosić o tysiączny element i </span>
<span class="c1">-- dostaniemy go:</span>

<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span> <span class="o">!!</span> <span class="mi">999</span> <span class="c1">-- 1000</span>

<span class="c1">-- Haskell wyznaczył pierwsze tysiąc elementów listy, ale cała jej reszta </span>
<span class="c1">-- jeszcze nie istnieje! Nie zostanie obliczona ich wartość, póki nie zajdzie</span>
<span class="c1">-- taka potrzeba.</span>

<span class="c1">-- łączenie dwóch list</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="mi">6</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>

<span class="c1">-- dodawanie pojedynczego elementu na początek listy</span>
<span class="mi">0</span><span class="o">:</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- [0, 1, 2, 3, 4, 5]</span>

<span class="c1">-- więcej operacji na listach</span>
<span class="n">head</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- 1</span>
<span class="n">tail</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- [2, 3, 4, 5]</span>
<span class="n">init</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- [1, 2, 3, 4]</span>
<span class="n">last</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- 5</span>

<span class="c1">-- list comprehensions</span>
<span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]]</span> <span class="c1">-- [2, 4, 6, 8, 10]</span>

<span class="c1">-- z dodatkowym warunkiem</span>
<span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">],</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">]</span> <span class="c1">-- [6, 8, 10]</span>

<span class="c1">-- każdy element krotki może być innego typu, jednak sama krotka musi być stałej </span>
<span class="c1">-- długości. Przykładowo:</span>
<span class="p">(</span><span class="s">"haskell"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1">-- dostęp do elementów pary (krotki długości 2):</span>
<span class="n">fst</span> <span class="p">(</span><span class="s">"haskell"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">-- "haskell"</span>
<span class="n">snd</span> <span class="p">(</span><span class="s">"haskell"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">-- 1</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 3. Funkcje</span>
<span class="c1">----------------------------------------------------</span>
<span class="c1">-- Prosta funkcja przyjmująca dwa argumenty</span>
<span class="n">add</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="c1">-- Pamiętaj, że podczas stosowania ghci, interpretera Haskella, wszelkie </span>
<span class="c1">-- definicje muszą zostać poprzedzone słowem `let`, na przykład:</span>
<span class="c1">-- let add a b = a + b</span>

<span class="c1">-- Używanie funkcji:</span>
<span class="n">add</span> <span class="mi">1</span> <span class="mi">2</span> <span class="c1">-- 3</span>

<span class="c1">-- Nazwę funkcji można podać między dwoma argumentami, ale wtedy musi zostać</span>
<span class="c1">-- otoczona grawisami:</span>
<span class="mi">1</span> <span class="p">`</span><span class="n">add</span><span class="p">`</span> <span class="mi">2</span> <span class="c1">-- 3</span>

<span class="c1">-- Nazwa funkcji nie musi zawierać żadnych liter, przykładem czego jest </span>
<span class="c1">-- operator dzielenia:</span>
<span class="p">(</span><span class="o">//</span><span class="p">)</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="n">b</span>
<span class="mi">35</span> <span class="o">//</span> <span class="mi">4</span> <span class="c1">-- 8</span>

<span class="c1">-- Strażnicy: prosty sposób na rozbijanie funkcji na przypadki</span>
<span class="n">fib</span> <span class="n">x</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="n">fib</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1">-- Dopasowanie wzorca jest podobne. Haskell sam automatycznie wybierze, która</span>
<span class="c1">-- z poniższych definicji fib powinna zostać użyta:</span>
<span class="n">fib</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">fib</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">fib</span> <span class="n">x</span> <span class="o">=</span> <span class="n">fib</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1">-- Dopasowanie z krotkami:</span>
<span class="n">foo</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1">-- Dopasowanie z listami. Tutaj `x` jest pierwszym elementem listy, </span>
<span class="c1">-- natomiast `xs` to jej reszta (ogon). Poniższa funkcja nakłada funkcję</span>
<span class="c1">-- na każdy z elementów listy:</span>
<span class="n">myMap</span> <span class="n">func</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">myMap</span> <span class="n">func</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">func</span> <span class="n">x</span><span class="o">:</span><span class="p">(</span><span class="n">myMap</span> <span class="n">func</span> <span class="n">xs</span><span class="p">)</span>

<span class="c1">-- Funkcje anonimowe tworzone są przy użyciu w-tył-ciachu, po którym następują</span>
<span class="c1">-- wszystkie argumenty:</span>
<span class="n">myMap</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- [3, 4, 5, 6, 7]</span>

<span class="c1">-- używanie zwijania z anonimowymi funkcjami: foldl1 zwija z lewej strony,</span>
<span class="c1">-- przyjmując jako wartość początkową zbieracza pierwszy element listy.</span>
<span class="n">foldl1</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- 15</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 4. Więcej funkcji</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- częściowe nakładanie: jeśli funkcja nie otrzyma wszystkich swoich argumentów, </span>
<span class="c1">-- zostaje cześciowo nałożona - zwraca funkcję, która przyjmuje pozostałe,</span>
<span class="c1">-- brakujące argumenty.</span>

<span class="n">add</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">add</span> <span class="mi">10</span> <span class="c1">-- foo jest teraz funkcją, która przyjmuje liczbę, zwiększa ją o 10</span>
<span class="n">foo</span> <span class="mi">5</span> <span class="c1">-- 15</span>

<span class="c1">-- Inny sposób na zapisanie tego samego:</span>
<span class="n">foo</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="o">+</span><span class="p">)</span>
<span class="n">foo</span> <span class="mi">5</span> <span class="c1">-- 15</span>

<span class="c1">-- składanie funkcji:</span>
<span class="c1">-- operator `.` składa wiele funkcji w jedną.</span>
<span class="c1">-- Dla przykładu, foo jest funkcją, która powiększa swój argument o 10, mnoży </span>
<span class="c1">-- tak uzyskaną liczbę przez 4 i zwraca wynik:</span>
<span class="n">foo</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="mi">10</span><span class="o">+</span><span class="p">)</span>

<span class="c1">-- 4*(10 + 5) = 60</span>
<span class="n">foo</span> <span class="mi">5</span> <span class="c1">-- 60</span>

<span class="c1">-- ustalanie kolejności</span>
<span class="c1">-- Haskell posiada inny operator, `$`, który nakłada funkcję do podanego</span>
<span class="c1">-- parametru. W przeciwieństwie do zwykłego lewostronnie łącznego nakładania </span>
<span class="c1">-- funkcji, którego priorytet jest najwyższy (10), operator `$` posiada</span>
<span class="c1">-- priorytet 0 i jest prawostronnie łączny. Tak niski priorytet oznacza, że</span>
<span class="c1">-- wyrażenie po prawej traktowane jest jako parametr funkcji po lewej</span>

<span class="c1">-- wcześniej</span>
<span class="n">even</span> <span class="p">(</span><span class="n">fib</span> <span class="mi">7</span><span class="p">)</span> <span class="c1">-- fałsz</span>

<span class="c1">-- równoważnie</span>
<span class="n">even</span> <span class="o">$</span> <span class="n">fib</span> <span class="mi">7</span> <span class="c1">-- fałsz</span>

<span class="c1">-- składanie funkcji</span>
<span class="n">even</span> <span class="o">.</span> <span class="n">fib</span> <span class="o">$</span> <span class="mi">7</span> <span class="c1">-- fałsz</span>


<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 5. Sygnatury typów</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Haskell posiada wyjątkowo silny system typów, w którym każde poprawne </span>
<span class="c1">-- wyrażenie ma swój typ.</span>

<span class="c1">-- Kilka podstawowych typów:</span>
<span class="mi">5</span> <span class="o">::</span> <span class="kt">Integer</span>
<span class="s">"hello"</span> <span class="o">::</span> <span class="kt">String</span>
<span class="kt">True</span> <span class="o">::</span> <span class="kt">Bool</span>

<span class="c1">-- Funkcje też są określonego typu.</span>
<span class="c1">-- `not` przyjmuje wartość logiczną i taką też zwraca:</span>
<span class="c1">-- not :: Bool -&gt; Bool</span>

<span class="c1">-- Przykład funkcji przyjmującej dwa argumenty</span>
<span class="c1">-- add :: Integer -&gt; Integer -&gt; Integer</span>

<span class="c1">-- Dobrą praktyką podczas definiowania wartości jest napisanie nad nią</span>
<span class="c1">-- także jej typu:</span>
<span class="n">double</span> <span class="o">::</span> <span class="kt">Integer</span> <span class="o">-&gt;</span> <span class="kt">Integer</span>
<span class="n">double</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 6. Wyrażenia warunkowe</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- wyrażenie warunkowe</span>
<span class="n">haskell</span> <span class="o">=</span> <span class="kr">if</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="kr">then</span> <span class="s">"wspaniale"</span> <span class="kr">else</span> <span class="s">"paskudnie"</span> <span class="c1">-- haskell = "wspaniale"</span>

<span class="c1">-- wyrażenie warunkowe można rozbić na wiele linii, </span>
<span class="c1">-- ale trzeba uważać na wcięcia w kodzie</span>
<span class="n">haskell</span> <span class="o">=</span> <span class="kr">if</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="kr">then</span> <span class="s">"wspaniale"</span>
            <span class="kr">else</span> <span class="s">"paskudnie"</span>

<span class="c1">-- rozpatrywanie przypadków: oto jak można parsować argumenty z linii poleceń:</span>
<span class="kr">case</span> <span class="n">args</span> <span class="kr">of</span>
  <span class="s">"help"</span> <span class="o">-&gt;</span> <span class="n">printHelp</span>
  <span class="s">"start"</span> <span class="o">-&gt;</span> <span class="n">startProgram</span>
  <span class="kr">_</span> <span class="o">-&gt;</span> <span class="n">putStrLn</span> <span class="s">"bad args"</span>

<span class="c1">-- Haskell zastępuje pętle (których nie ma) rekurencyjnymi wywołaniami funkcji.</span>
<span class="c1">-- map aplikuje funkcję do każdego elementu listy:</span>

<span class="n">map</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- [2, 4, 6, 8, 10]</span>

<span class="c1">-- możesz zdefiniować funkcję for przy użyciu map:</span>
<span class="n">for</span> <span class="n">array</span> <span class="n">func</span> <span class="o">=</span> <span class="n">map</span> <span class="n">func</span> <span class="n">array</span>

<span class="c1">-- a następnie użyć jej:</span>
<span class="n">for</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="o">$</span> <span class="nf">\</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">show</span> <span class="n">i</span>

<span class="c1">-- mogliśmy użyć krótszego zapisu bez zmiany działania funkcji for:</span>
<span class="n">for</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="n">show</span>

<span class="c1">-- Do redukcji listy służy polecenie foldl (foldr):</span>
<span class="c1">-- foldl &lt;fn&gt; &lt;initial value&gt; &lt;list&gt;</span>
<span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="mi">4</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="c1">-- 43</span>

<span class="c1">-- Jest to równoważne z:</span>
<span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>

<span class="c1">-- foldl składa od od lewej strony, foldr od prawej</span>
<span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="mi">4</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="c1">-- 16</span>

<span class="c1">-- To zaś równoważne jest:</span>
<span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)))</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 7. Typy danych</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Oto jak tworzy się nowe typy danych w Haskellu:</span>

<span class="kr">data</span> <span class="kt">Color</span> <span class="o">=</span> <span class="kt">Red</span> <span class="o">|</span> <span class="kt">Blue</span> <span class="o">|</span> <span class="kt">Green</span>

<span class="c1">-- Teraz można używać ich we własnych funkcjach:</span>

<span class="n">say</span> <span class="o">::</span> <span class="kt">Color</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">say</span> <span class="kt">Red</span> <span class="o">=</span> <span class="s">"You are Red!"</span>
<span class="n">say</span> <span class="kt">Blue</span> <span class="o">=</span> <span class="s">"You are Blue!"</span>
<span class="n">say</span> <span class="kt">Green</span> <span class="o">=</span>  <span class="s">"You are Green!"</span>

<span class="c1">-- Twoje typy danych mogą posiadać nawet parametry:</span>

<span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Nothing</span> <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>

<span class="c1">-- Wszystkie poniższe są typu Maybe</span>
<span class="kt">Just</span> <span class="s">"hello"</span>    <span class="c1">-- typu `Maybe String`</span>
<span class="kt">Just</span> <span class="mi">1</span>          <span class="c1">-- typu `Maybe Int`</span>
<span class="kt">Nothing</span>         <span class="c1">-- typu `Maybe a` for any `a`</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 8. Haskell IO</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Chociaż obsługa wejścia i wyjścia nie może zostać wyjaśniona przez poznaniem</span>
<span class="c1">-- monad, spróbujemy zrobić to częściowo</span>

<span class="c1">-- Wykonanie programu napisanego w Haskellu wywołuje funkcję `main` </span>
<span class="c1">-- Musi zwrócić wartość typu `IO a` dla pewnego `a`. Przykład:</span>

<span class="n">main</span> <span class="o">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">main</span> <span class="o">=</span> <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">"Hello, sky! "</span> <span class="o">++</span> <span class="p">(</span><span class="n">say</span> <span class="kt">Blue</span><span class="p">)</span>
<span class="c1">-- putStrLn has type String -&gt; IO ()</span>

<span class="c1">-- Najłatwiej obsłużyć wejście i wyjście, kiedy program zostanie </span>
<span class="c1">-- zaimplementowany jako funkcja String -&gt; String. Funkcja</span>
<span class="c1">--    interact :: (String -&gt; String) -&gt; IO ()</span>
<span class="c1">-- pobiera pewien tekst, wykonuje na nim operacje, po czym wypisuje wynik.</span>

<span class="n">countLines</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">countLines</span> <span class="o">=</span> <span class="n">show</span> <span class="o">.</span> <span class="n">length</span> <span class="o">.</span> <span class="n">lines</span>

<span class="n">main'</span> <span class="o">=</span> <span class="n">interact</span> <span class="n">countLines</span>

<span class="c1">-- Możesz myśleć o wartości typu `IO ()` jako reprezentującej ciąg czynności,</span>
<span class="c1">-- które komputer ma wykonać, zupełnie niczym program komputerowy w imperatywnym</span>
<span class="c1">-- języku programowania. Akcje można łączyć przy użyciu notacji `do`:</span>

<span class="n">sayHello</span> <span class="o">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">sayHello</span> <span class="o">=</span> <span class="kr">do</span>
   <span class="n">putStrLn</span> <span class="s">"What is your name?"</span>
   <span class="n">name</span> <span class="o">&lt;-</span> <span class="n">getLine</span> <span class="c1">-- this gets a line and gives it the name "name"</span>
   <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">"Hello, "</span> <span class="o">++</span> <span class="n">name</span>

<span class="c1">-- Ćwiczenie: napisz własną wersję `interact`, </span>
<span class="c1">-- która czyta tylko jedną linię wejścia.</span>

<span class="c1">-- Kod w `sayHello` nigdy się nie wykona. Jedyną akcją, która zostanie </span>
<span class="c1">-- uruchomiona, jest wartość `main`.</span>
<span class="c1">-- Aby uruchomić `sayHello`, należy zastąpić poprzednią definicję `main` przez</span>
<span class="c1">--   main = sayHello</span>

<span class="c1">-- Spróbujmy lepiej zrozumieć, jak działa funkcja `getLine`, której właśnie</span>
<span class="c1">-- użyliśmy. Jej typem jest</span>
<span class="c1">--    getLine :: IO String</span>
<span class="c1">-- Możesz myśleć o wartości typu `IO a` jako reprezentującej program, który</span>
<span class="c1">-- wygeneruje wartość typu `a`, poza wszystkim innym, co jeszcze zrobi.</span>
<span class="c1">-- Możemy także tworzyć własne akcje typu `IO String`:</span>

<span class="n">action</span> <span class="o">::</span> <span class="kt">IO</span> <span class="kt">String</span>
<span class="n">action</span> <span class="o">=</span> <span class="kr">do</span>
   <span class="n">putStrLn</span> <span class="s">"This is a line. Duh"</span>
   <span class="n">input1</span> <span class="o">&lt;-</span> <span class="n">getLine</span>
   <span class="n">input2</span> <span class="o">&lt;-</span> <span class="n">getLine</span>
   <span class="c1">-- The type of the `do` statement is that of its last line.</span>
   <span class="c1">-- `return` is not a keyword, but merely a function</span>
   <span class="n">return</span> <span class="p">(</span><span class="n">input1</span> <span class="o">++</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span> <span class="o">++</span> <span class="n">input2</span><span class="p">)</span> <span class="c1">-- return :: String -&gt; IO String</span>

<span class="c1">-- Możemy użyć tego tak jak używaliśmy `getLine`:</span>

<span class="n">main''</span> <span class="o">=</span> <span class="kr">do</span>
    <span class="n">putStrLn</span> <span class="s">"I will echo two lines!"</span>
    <span class="n">result</span> <span class="o">&lt;-</span> <span class="n">action</span>
    <span class="n">putStrLn</span> <span class="n">result</span>
    <span class="n">putStrLn</span> <span class="s">"This was all, folks!"</span>

<span class="c1">-- Typ `IO` jest przykładem monady. Sposób w jakim Haskell używa monad do </span>
<span class="c1">-- obsługi wejścia i wyjścia pozwala mu być czysto funkcyjnym językiem.</span>
<span class="c1">-- Każda funkcja, która wchodzi w interakcje ze światem zewnętrznym, oznaczana</span>
<span class="c1">-- jest jako `IO` w jej sygnaturze typu, co umożliwia odróżnianie funkcji</span>
<span class="c1">-- czystych od zależnych od świata lub modyfikujących stan.</span>

<span class="c1">-- To naprawdę użyteczna własność, dzięki której jesteśmy w stanie uruchamiać</span>
<span class="c1">-- czyste funkcje jednocześnie.</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 9. Interaktywne środowisko programowania</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Aby uruchomić repl (read-eval-print loop, interaktywne środowisko), należy</span>
<span class="c1">-- wpisać `ghci`. Można już programować. Do definiowania nowych wartości służy</span>
<span class="c1">-- słowo kluczowe `let`:</span>

<span class="kr">let</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">5</span>

<span class="c1">-- Do sprawdzania typów dowolnej wartości (wyrażenia) wykorzystuje się `:t`:</span>

<span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="n">foo</span>
<span class="n">foo</span> <span class="o">::</span> <span class="kt">Integer</span>

<span class="c1">-- Działania takie jak `+`, `:` czy `$`, są funkcjami.</span>
<span class="c1">-- Przed sprawdzeniem ich typu należy otoczyć je nawiasami:</span>

<span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="p">(</span><span class="o">:</span><span class="p">)</span>
<span class="p">(</span><span class="o">:</span><span class="p">)</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>

<span class="c1">-- Dodatkowych informacji dostarcza `:i`:</span>

<span class="o">&gt;</span> <span class="o">:</span><span class="n">i</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span>
<span class="kr">class</span> <span class="kt">Num</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
  <span class="o">...</span>
    <span class="c1">-- Defined in ‘GHC.Num’</span>
<span class="kr">infixl</span> <span class="mi">6</span> <span class="o">+</span>

<span class="c1">-- Można nawet wykonywać akcje typu `IO ()`!</span>

<span class="o">&gt;</span> <span class="n">sayHello</span>
<span class="kt">What</span> <span class="n">is</span> <span class="n">your</span> <span class="n">name</span><span class="o">?</span>
<span class="kt">Friend</span><span class="o">!</span>
<span class="kt">Hello</span><span class="p">,</span> <span class="kt">Friend</span><span class="o">!</span>
</code></pre></div>
<p>Pominęliśmy wiele aspektów Haskella, wliczając w to monady. To właśnie one 
sprawiają, że programowanie w Haskellu sprawia tyle frajdy. Na zakończenie
pokażę Tobie implementację algorytmu quicksort w Haskellu:</p>
<div class="highlight"><pre class="highlight haskell"><code><span class="n">qsort</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">qsort</span> <span class="p">(</span><span class="n">p</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">qsort</span> <span class="n">lesser</span> <span class="o">++</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">++</span> <span class="n">qsort</span> <span class="n">greater</span>
    <span class="kr">where</span> <span class="n">lesser</span>  <span class="o">=</span> <span class="n">filter</span> <span class="p">(</span><span class="o">&lt;</span> <span class="n">p</span><span class="p">)</span> <span class="n">xs</span>
          <span class="n">greater</span> <span class="o">=</span> <span class="n">filter</span> <span class="p">(</span><span class="o">&gt;=</span> <span class="n">p</span><span class="p">)</span> <span class="n">xs</span>
</code></pre></div>
<p>Haskell może zostać zainstalowany na co najmniej dwa sposoby:
 - tradycyjnie <a href="http://www.haskell.org/platform/">przy użyciu Cabala</a>,
 - nowocześnie <a href="https://www.stackage.org/install">z pomocą Stack</a>.</p>

<p>Godnymi poleceniami wprowadzeniami są wspaniałe
<a href="http://learnyouahaskell.com/">Learn you a Haskell</a> albo
<a href="http://book.realworldhaskell.org/">Real World Haskell</a>.</p>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/pl-pl/haskell-pl.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by Adit Bhargava, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/pl-pl/haskell-pl.html.markdown">3 contributor(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://adit.io">Adit Bhargava</a>
    </p>

    <p>
      Translated by:
        <a href="https://github.com/remigiusz-suwalski">Remigiusz Suwalski</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
