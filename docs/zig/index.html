<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="en-us" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="en-us" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="en-us" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="en-us" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="en-us">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn zig in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/zig/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fzig%2F&text=Learn+X+in+Y+minutes%2C+where+X%3Dzig">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="/">Learn X in Y minutes</a></h1>
  <h2>Where X=zig</h2>
    <p class="filelink">
    Get the code:
    <a href="/docs/files/learnzig.zig">learnzig.zig</a>
    </p>
  <div id="doc">
    <p><a href="https://ziglang.org">Zig</a> aims to be a replacement for the C programming language.</p>

<p><strong>WARNING</strong>: this document expects you to understand a few basic concepts in computer science, such as pointers, stack and heap memory, etc.</p>

<p><strong>WARNING</strong>: Zig isn&rsquo;t considered as ready for production. Bugs are expected.</p>

<p>Prior knowledge of C is recommended.</p>

<h2>Quick overview: Zig compared to C</h2>

<ul>
<li>Syntax is mostly the same, with some improvements (less ambiguity).</li>
<li>Zig introduces namespaces.</li>
<li><code>try</code> and <code>catch</code> mechanism, which is both convenient, efficient and optional.</li>
<li>Most of the C undefined behaviors (UBs) are fixed.</li>
<li>Compared to C, raw pointers are safer to use and less likely to be needed.

<ul>
<li>The type system distinguishes between a pointer to a single value, or multiple values, etc.</li>
<li>Slices are preferred, which is a structure with a pointer and a runtime known size, which characterizes most uses of pointers in the first place.</li>
</ul></li>
<li>Some arbitrary language limitations are removed. For example, enumerations, structures and unions can have functions.</li>
<li>Simple access to SIMD operations (basic maths on vectors).</li>
<li>Zig provides both low-level features of C and the one provided through compiler extensions.
For example: packed structures.</li>
<li>An extensive standard library, including data structures and algorithms.</li>
<li>Cross-compilation capability is provided by default, without any dependency.
Different libc are provided to ease the process.
Cross-compilation works from, and to, any operating system and architecture.</li>
</ul>

<h2>Zig language</h2>
<div class="highlight"><pre><span></span><span class="c1">//! Top-level documentation.</span>

<span class="c1">/// Documentation comment.</span>

<span class="c1">// Simple comment.</span>
</pre></div>
<h3>Hello world.</h3>
<div class="highlight"><pre><span></span><span class="c1">// Import standard library, reachable through the &quot;std&quot; constant.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">std</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@import</span><span class="p">(</span><span class="s">&quot;std&quot;</span><span class="p">);</span>

<span class="c1">// &quot;info&quot; now refers to the &quot;std.log.info&quot; function.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">;</span>

<span class="c1">// Usual hello world.</span>
<span class="c1">// syntax: [pub] fn &lt;function-name&gt;(&lt;arguments&gt;) &lt;return-type&gt; { &lt;body&gt; }</span>
<span class="kr">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Contrary to C functions, Zig functions have a fixed number of arguments.</span>
<span class="w">    </span><span class="c1">// In C: &quot;printf&quot; takes any number of arguments.</span>
<span class="w">    </span><span class="c1">// In Zig: std.log.info takes a format and a list of elements to print.</span>
<span class="w">    </span><span class="n">info</span><span class="p">(</span><span class="s">&quot;hello world&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{});</span><span class="w">  </span><span class="c1">// .{} is an empty anonymous tuple.</span>
<span class="p">}</span>
</pre></div>
<h3>Booleans, integers and float.</h3>
<div class="highlight"><pre><span></span><span class="c1">// Booleans.</span>
<span class="c1">// Keywords are preferred to operators for boolean operations.</span>
<span class="n">print</span><span class="p">(</span><span class="s">&quot;{}</span><span class="se">\n</span><span class="s">{}</span><span class="se">\n</span><span class="s">{}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span>
<span class="w">    </span><span class="kc">true</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">    </span><span class="kc">true</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">    </span><span class="o">!</span><span class="kc">true</span><span class="p">,</span>
<span class="p">});</span>

<span class="c1">// Integers.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">one_plus_one</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="s">&quot;1 + 1 = {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">one_plus_one</span><span class="p">});</span><span class="w"> </span><span class="c1">// 2</span>

<span class="c1">// Floats.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">seven_div_three</span><span class="o">:</span><span class="w"> </span><span class="kt">f32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">7.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">3.0</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="s">&quot;7.0 / 3.0 = {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">seven_div_three</span><span class="p">});</span><span class="w"> </span><span class="c1">// 2.33333325e+00</span>

<span class="c1">// Integers have arbitrary value lengths.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">myvar</span><span class="o">:</span><span class="w"> </span><span class="n">u10</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// 10-bit unsigned integer</span>
<span class="c1">// Useful for example to read network packets, or complex binary formats.</span>

<span class="c1">// Number representation is greatly improved compared to C.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">one_billion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="n">_000_000_000</span><span class="p">;</span><span class="w">         </span><span class="c1">// Decimal.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">binary_mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mb">0b1</span><span class="n">_1111_1111</span><span class="p">;</span><span class="w">         </span><span class="c1">// Binary. Ex: network mask.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">permissions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0o7</span><span class="n">_5_5</span><span class="p">;</span><span class="w">               </span><span class="c1">// Octal.  Ex: Unix permissions.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">big_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xFF80</span><span class="n">_0000_0000_0000</span><span class="p">;</span><span class="w"> </span><span class="c1">// Hexa.   Ex: IPv6 address.</span>


<span class="c1">// Overflow operators: tell the compiler when it&#39;s okay to overflow.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">i</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// &quot;i&quot; is an unsigned 8-bit integer</span>
<span class="n">i</span><span class="w">  </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">        </span><span class="c1">// runtime overflow error (unsigned value always are positive)</span>
<span class="n">i</span><span class="w"> </span><span class="o">-%=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">        </span><span class="c1">// okay (wrapping operator), i == 255</span>

<span class="c1">// Saturation operators: values will stick to their lower and upper bounds.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">i</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">200</span><span class="p">;</span><span class="w">   </span><span class="c1">// &quot;i&quot; is an unsigned 8-bit integer (values: from 0 to 255)</span>
<span class="n">i</span><span class="w">  </span><span class="o">+|</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">255</span><span class="w">   </span><span class="c1">// u8: won&#39;t go higher than 255</span>
<span class="n">i</span><span class="w">  </span><span class="o">-|</span><span class="w"> </span><span class="mi">300</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="c1">// unsigned, won&#39;t go lower than 0</span>
<span class="n">i</span><span class="w">  </span><span class="o">*|</span><span class="w"> </span><span class="mi">2</span><span class="w">   </span><span class="o">==</span><span class="w"> </span><span class="mi">255</span><span class="w">   </span><span class="c1">// u8: won&#39;t go higher than 255</span>
<span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;|</span><span class="w"> </span><span class="mi">8</span><span class="w">   </span><span class="o">==</span><span class="w"> </span><span class="mi">255</span><span class="w">   </span><span class="c1">// u8: won&#39;t go higher than 255</span>
</pre></div>
<h3>Arrays.</h3>
<div class="highlight"><pre><span></span><span class="c1">// An array is a well-defined structure with a length attribute (len).</span>

<span class="c1">// 5-byte array with undefined content (stack garbage).</span>
<span class="kr">var</span><span class="w"> </span><span class="n">array1</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">undefined</span><span class="p">;</span>

<span class="c1">// 5-byte array with defined content.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">array2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">};</span>
<span class="c1">// [_] means the compiler knows the length at compile-time.</span>

<span class="c1">// 1000-byte array with defined content (0).</span>
<span class="kr">var</span><span class="w"> </span><span class="n">array3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="mi">0</span><span class="p">}</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span>

<span class="c1">// Another 1000-byte array with defined content.</span>
<span class="c1">// The content is provided by the &quot;foo&quot; function, called at compile-time and</span>
<span class="c1">// allows complex initializations.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">array4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="n">foo</span><span class="p">()}</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span>

<span class="c1">// In any case, array.len gives the length of the array,</span>
<span class="c1">// array1.len and array2.len produce 5, array3.len and array4.len produce 1000.</span>


<span class="c1">// Modifying and accessing arrays content.</span>

<span class="c1">// Array of 10 32-bit undefined integers.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">some_integers</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">undefined</span><span class="p">;</span>

<span class="n">some_integers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">;</span><span class="w"> </span><span class="c1">// first element of the array is now 30</span>

<span class="kr">var</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_integers</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="c1">// &quot;x&quot; now equals to 30, its type is inferred.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_integers</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="c1">// Second element of the array isn&#39;t defined.</span>
<span class="w">                          </span><span class="c1">// &quot;y&quot; got a stack garbage value (no runtime error).</span>

<span class="c1">// Array of 10 32-bit undefined integers.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">some_integers</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">undefined</span><span class="p">;</span>

<span class="kr">var</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_integers</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span><span class="w"> </span><span class="c1">// index &gt; array size, compilation error.</span>

<span class="c1">// At runtime, we loop over the elements of &quot;some_integers&quot; with an index.</span>
<span class="c1">// Index i = 20, then we try:</span>
<span class="k">try</span><span class="w"> </span><span class="n">some_integers</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"> </span><span class="c1">// Runtime error &#39;index out of bounds&#39;.</span>
<span class="w">                      </span><span class="c1">// &quot;try&quot; keyword is necessary when accessing an array with</span>
<span class="w">                      </span><span class="c1">// an index, since there is a potential runtime error.</span>
<span class="w">                      </span><span class="c1">// More on that later.</span>
</pre></div>
<h3>Multidimensional arrays.</h3>
<div class="highlight"><pre><span></span><span class="kr">const</span><span class="w"> </span><span class="n">mat4x4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span><span class="kt">f32</span><span class="p">{</span>
<span class="w">    </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">f32</span><span class="p">{</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">f32</span><span class="p">{</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">f32</span><span class="p">{</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">f32</span><span class="p">{</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">},</span>
<span class="p">};</span>

<span class="c1">// Access the 2D array then the inner array through indexes.</span>
<span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">mat4x4</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>

<span class="c1">// Here we iterate with for loops.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">mat4x4</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">row_index</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">row</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">cell</span><span class="p">,</span><span class="w"> </span><span class="n">column_index</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h3>Strings.</h3>
<div class="highlight"><pre><span></span><span class="c1">// Simple string constant.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">greetings</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p">;</span>
<span class="c1">// ... which is equivalent to:</span>
<span class="kr">const</span><span class="w"> </span><span class="n">greetings</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="kr">const</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p">;</span>
<span class="c1">// In words: &quot;greetings&quot; is a constant value, a pointer on a constant array of 5</span>
<span class="c1">// elements (8-bit unsigned integers), with an extra &#39;0&#39; at the end.</span>
<span class="c1">// The extra &quot;0&quot; is called a &quot;sentinel value&quot;.</span>

<span class="n">print</span><span class="p">(</span><span class="s">&quot;string: {s}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">greetings</span><span class="p">});</span>

<span class="c1">// This represents rather faithfully C strings. Although, Zig strings are</span>
<span class="c1">// structures, no need for &quot;strlen&quot; to compute their size.</span>
<span class="c1">// greetings.len == 5</span>
</pre></div>
<h3>Slices.</h3>
<div class="highlight"><pre><span></span><span class="c1">// A slice is a pointer and a size, an array without compile-time known size.</span>
<span class="c1">// Slices have runtime out-of-band verifications.</span>

<span class="kr">const</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span><span class="w">     </span><span class="c1">// [_] = array with compile-time known size.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">..</span><span class="n">array</span><span class="p">.</span><span class="n">len</span><span class="p">];</span><span class="w">  </span><span class="c1">// &quot;slice&quot; represents the whole array.</span>
<span class="w">                                    </span><span class="c1">// slice[10] gives a runtime error.</span>
</pre></div>
<h3>Pointers.</h3>
<div class="highlight"><pre><span></span><span class="c1">// Pointer on a value can be created with &quot;&amp;&quot;.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="kr">const</span><span class="w"> </span><span class="n">pointer</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w">  </span><span class="c1">// &quot;pointer&quot; is a pointer on the i32 var &quot;x&quot;.</span>
<span class="n">print</span><span class="p">(</span><span class="s">&quot;1 = {}, {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">pointer</span><span class="p">});</span>

<span class="c1">// Pointer values are accessed and modified with &quot;.*&quot;.</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pointer</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;x value == {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">pointer</span><span class="p">.</span><span class="o">*</span><span class="p">});</span>
<span class="p">}</span>

<span class="c1">// &quot;.?&quot; is a shortcut for &quot;orelse unreachable&quot;.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pointer</span><span class="p">.</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// Get the pointed value, otherwise crash.</span>
</pre></div>
<h3>Optional values (?<type>).</h3>
<div class="highlight"><pre><span></span><span class="c1">// An optional is a value than can be of any type or null.</span>

<span class="c1">// Example: &quot;optional_value&quot; can either be &quot;null&quot; or an unsigned 32-bit integer.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">optional_value</span><span class="o">:</span><span class="w"> </span><span class="o">?</span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w"> </span><span class="c1">// optional_value == null</span>
<span class="n">optional_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w">             </span><span class="c1">// optional_value != null</span>

<span class="c1">// &quot;some_function&quot; returns ?u32</span>
<span class="kr">var</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_function</span><span class="p">();</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">value</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// In case &quot;some_function&quot; returned a value.</span>
<span class="w">    </span><span class="c1">// Do something with &#39;value&#39;.</span>
<span class="p">}</span>
</pre></div>
<h3>Errors.</h3>
<div class="highlight"><pre><span></span><span class="c1">// Zig provides an unified way to express errors.</span>

<span class="c1">// Errors are defined in error enumerations, example:</span>
<span class="kr">const</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">error</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">WatchingAnyNetflixTVShow</span><span class="p">,</span>
<span class="w">    </span><span class="n">BeOnTwitter</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// Normal enumerations are expressed the same way, but with &quot;enum&quot; keyword.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">SuccessStory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">DoingSport</span><span class="p">,</span>
<span class="w">    </span><span class="n">ReadABook</span><span class="p">,</span>
<span class="p">};</span>


<span class="c1">// Error union (!).</span>
<span class="c1">// Either the value &quot;mylife&quot; is an an error or a normal value.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">mylife</span><span class="o">:</span><span class="w"> </span><span class="n">Error</span><span class="o">!</span><span class="n">SuccessStory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Error</span><span class="p">.</span><span class="n">BeOnTwitter</span><span class="p">;</span>
<span class="c1">// mylife is an error. Sad.</span>

<span class="n">mylife</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SuccessStory</span><span class="p">.</span><span class="n">ReadABook</span><span class="p">;</span>
<span class="c1">// Now mylife is an enum.</span>


<span class="c1">// Zig ships with many pre-defined errors. Example:</span>
<span class="kr">const</span><span class="w"> </span><span class="n">value</span><span class="o">:</span><span class="w"> </span><span class="kt">anyerror</span><span class="o">!</span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">error</span><span class="p">.</span><span class="n">Broken</span><span class="p">;</span>


<span class="c1">// Handling errors.</span>

<span class="c1">// Some error examples.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">error</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UnExpected</span><span class="p">,</span>
<span class="w">    </span><span class="n">Authentication</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// &quot;some_function&quot; can either return an &quot;Error&quot; or an integer.</span>
<span class="k">fn</span><span class="w"> </span><span class="n">some_function</span><span class="p">()</span><span class="w"> </span><span class="n">Error</span><span class="o">!</span><span class="kt">u8</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Error</span><span class="p">.</span><span class="n">UnExpected</span><span class="p">;</span><span class="w"> </span><span class="c1">// It returns an error.</span>
<span class="p">}</span>

<span class="c1">// Errors can be &quot;catch&quot; without intermediate variable.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_function</span><span class="p">()</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="o">|</span><span class="n">err</span><span class="o">|</span><span class="w"> </span><span class="k">switch</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Error</span><span class="p">.</span><span class="n">UnExpected</span><span class="w">     </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">,</span><span class="w">   </span><span class="c1">// Returns the error.</span>
<span class="w">    </span><span class="n">Error</span><span class="p">.</span><span class="n">Authentication</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">unreachable</span><span class="p">,</span><span class="w">  </span><span class="c1">// Not expected. Crashes the program.</span>
<span class="w">    </span><span class="k">else</span><span class="w">                 </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">unreachable</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// An error can be &quot;catch&quot; without giving it a name.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">unwrapped</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_function</span><span class="p">()</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="mi">1234</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;unwrapped&quot; = 1234</span>

<span class="c1">// &quot;try&quot; is a very handy shortcut for &quot;catch |err| return err&quot;.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">some_function</span><span class="p">();</span>
<span class="c1">// If &quot;some_function&quot; fails, the current function stops and returns the error.</span>
<span class="c1">// &quot;value&quot; can only have a valid value, the error already is handled with &quot;try&quot;.</span>
</pre></div>
<h3>Control flow.</h3>
<div class="highlight"><pre><span></span><span class="c1">// Conditional branching.</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">condition</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
<span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>

<span class="c1">// Ternary.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">condition</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>

<span class="c1">// Shortcut for &quot;if (x) x else 0&quot;</span>
<span class="kr">var</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">orelse</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// If &quot;a&quot; is an optional, which may contain a value.</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">value</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;value: {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">value</span><span class="p">});</span>
<span class="p">}</span>
<span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;&#39;a&#39; is null</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{});</span>
<span class="p">}</span>

<span class="c1">// Get a pointer on the value (if it exists).</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">|*</span><span class="n">value</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>


<span class="c1">// Loops.</span>

<span class="c1">// Syntax examples:</span>
<span class="c1">//   while (condition) statement</span>
<span class="c1">//   while (condition) : (end-of-iteration-statement) statement</span>
<span class="c1">//</span>
<span class="c1">//   for (iterable) statement</span>
<span class="c1">//   for (iterable) |capture| statement</span>
<span class="c1">//   for (iterable) statement else statement</span>

<span class="c1">// Note: loops work the same way over arrays or slices.</span>

<span class="c1">// Simple &quot;while&quot; loop.</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="c1">// While loop with a &quot;continue expression&quot;</span>
<span class="c1">// (expression executed as the last expression of the loop).</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="c1">// Same, with a more complex continue expression (block of code).</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2000</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">({</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>

<span class="c1">// To iterate over a portion of a slice, reslice.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">..</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">|</span><span class="n">value</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="c1">// Loop over every item of an array (or slice).</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">items</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">value</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="c1">// Iterate and get pointers on values instead of copies.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">items</span><span class="p">)</span><span class="w"> </span><span class="o">|*</span><span class="n">value</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="c1">// Iterate with an index.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">items</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;val[{}] = {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">});</span><span class="w"> </span><span class="p">}</span>

<span class="c1">// Iterate with pointer and index.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">items</span><span class="p">)</span><span class="w"> </span><span class="o">|*</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;val[{}] = {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">});</span><span class="w"> </span><span class="n">value</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>


<span class="c1">// Break and continue are supported.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">items</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">value</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// For loops can also be used as expressions.</span>
<span class="c1">// Similar to while loops, when you break from a for loop,</span>
<span class="c1">// the else branch is not evaluated.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">sum</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="c1">// The &quot;for&quot; loop has to provide a value, which will be the &quot;else&quot; value.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">items</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">value</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">value</span><span class="p">.</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;result&quot; will be the last &quot;sum&quot; value.</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">                  </span><span class="c1">// Last value.</span>
</pre></div>
<h3>Labels.</h3>
<div class="highlight"><pre><span></span><span class="c1">// Labels are a way to name an instruction, a location in the code.</span>
<span class="c1">// Labels can be used to &quot;continue&quot; or &quot;break&quot; in a nested loop.</span>
<span class="n">outer</span><span class="o">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">([</span><span class="n">_</span><span class="p">]</span><span class="kt">i32</span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">([</span><span class="n">_</span><span class="p">]</span><span class="kt">i32</span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">count</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="k">continue</span><span class="w"> </span><span class="o">:</span><span class="n">outer</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;continue&quot; for the first loop.</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// count = 8</span>
<span class="n">outer</span><span class="o">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">([</span><span class="n">_</span><span class="p">]</span><span class="kt">i32</span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">([</span><span class="n">_</span><span class="p">]</span><span class="kt">i32</span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">count</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="k">break</span><span class="w"> </span><span class="o">:</span><span class="n">outer</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;break&quot; for the first loop.</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// count = 1</span>


<span class="c1">// Labels can also be used to return a value from a block.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="kr">const</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blk</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">break</span><span class="w"> </span><span class="o">:</span><span class="n">blk</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="c1">// Now &quot;x&quot; equals 6.</span>
<span class="p">};</span>
<span class="c1">// Relevant in cases like &quot;for else&quot; expression (explained in the following).</span>

<span class="c1">// For loops can be used as expressions.</span>
<span class="c1">// When you break from a for loop, the else branch is not evaluated.</span>
<span class="c1">// WARNING: counter-intuitive.</span>
<span class="c1">//      The &quot;for&quot; loop will run, then the &quot;else&quot; block will run.</span>
<span class="c1">//      The &quot;else&quot; keyword has to be followed by the value to give to &quot;result&quot;.</span>
<span class="c1">//      See later for another form.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">sum</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kr">const</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">items</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">value</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"> </span><span class="c1">// result = 8</span>

<span class="c1">// In this case, the &quot;else&quot; keyword is followed by a value, too.</span>
<span class="c1">// However, the syntax is different: it is labeled.</span>
<span class="c1">// Instead of a value, there is a label followed by a block of code, which</span>
<span class="c1">// allows to do stuff before returning the value (see the &quot;break&quot; invocation).</span>
<span class="kr">const</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">items</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">value</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// First: loop.</span>
<span class="w">    </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="n">blk</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w">                        </span><span class="c1">// Second: &quot;else&quot; block.</span>
<span class="w">    </span><span class="n">std</span><span class="p">.</span><span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;executed AFTER the loop!&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{});</span>
<span class="w">    </span><span class="k">break</span><span class="w"> </span><span class="o">:</span><span class="n">blk</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span><span class="w"> </span><span class="c1">// The &quot;sum&quot; value will replace the label &quot;blk&quot;.</span>
<span class="p">};</span>
</pre></div>
<h3>Switch.</h3>
<div class="highlight"><pre><span></span><span class="c1">// As a switch in C, but slightly more advanced.</span>
<span class="c1">// Syntax:</span>
<span class="c1">//   switch (value) {</span>
<span class="c1">//       pattern =&gt; expression,</span>
<span class="c1">//       pattern =&gt; expression,</span>
<span class="c1">//       else    =&gt; expression</span>
<span class="c1">//   };</span>

<span class="c1">// A switch only checking for simple values.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">switch</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Error</span><span class="p">.</span><span class="n">UnExpected</span><span class="w">     </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">,</span>
<span class="w">    </span><span class="n">Error</span><span class="p">.</span><span class="n">Authentication</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">unreachable</span><span class="p">,</span>
<span class="w">    </span><span class="k">else</span><span class="w">                 </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">unreachable</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// A slightly more advanced switch, accepting a range of values:</span>
<span class="kr">const</span><span class="w"> </span><span class="n">foo</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kr">const</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="mi">0</span><span class="w">                        </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&quot;zero&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="mi">1</span><span class="p">...</span><span class="n">std</span><span class="p">.</span><span class="n">math</span><span class="p">.</span><span class="n">maxInt</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&quot;positive&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="k">else</span><span class="w">                     </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&quot;negative&quot;</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
<h3>Structures.</h3>
<div class="highlight"><pre><span></span><span class="c1">// Structure containing a single value.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">Full</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">number</span><span class="o">:</span><span class="w"> </span><span class="kt">u16</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// Packed structure, with guaranteed in-memory layout.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">Divided</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kr">packed</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">half1</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span>
<span class="w">    </span><span class="n">quarter3</span><span class="o">:</span><span class="w"> </span><span class="n">u4</span><span class="p">,</span>
<span class="w">    </span><span class="n">quarter4</span><span class="o">:</span><span class="w"> </span><span class="n">u4</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// Point is a constant representing a structure containing two u32, &quot;x&quot; and &quot;y&quot;.</span>
<span class="c1">// &quot;x&quot; has a default value, which wasn&#39;t possible in C.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="c1">// default value</span>
<span class="w">    </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// Variable &quot;p&quot; is a new Point, with x = 1 (default value) and y = 2.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">};</span>

<span class="c1">// Fields are accessed as usual with the dot notation: variable.field.</span>
<span class="n">print</span><span class="p">(</span><span class="s">&quot;p.x: {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">});</span><span class="w"> </span><span class="c1">// 1</span>
<span class="n">print</span><span class="p">(</span><span class="s">&quot;p.y: {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">});</span><span class="w"> </span><span class="c1">// 2</span>


<span class="c1">// A structure can also contain public constants and functions.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">pub</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="n">some_constant</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">;</span>

<span class="w">    </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// This function &quot;init&quot; creates a Point and returns it.</span>
<span class="w">    </span><span class="kr">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">init</span><span class="p">()</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Point</span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>


<span class="c1">// How to access a structure public constant.</span>
<span class="c1">// The value isn&#39;t accessed from an &quot;instance&quot; of the structure, but from the</span>
<span class="c1">// constant representing the structure definition (Point).</span>
<span class="n">print</span><span class="p">(</span><span class="s">&quot;constant: {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">Point</span><span class="p">.</span><span class="n">some_constant</span><span class="p">});</span>

<span class="c1">// Having an &quot;init&quot; function is rather idiomatic in the standard library.</span>
<span class="c1">// More on that later.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">.</span><span class="n">init</span><span class="p">();</span>
<span class="n">print</span><span class="p">(</span><span class="s">&quot;p.x: {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">});</span><span class="w"> </span><span class="c1">// p.x = 0</span>
<span class="n">print</span><span class="p">(</span><span class="s">&quot;p.y: {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">});</span><span class="w"> </span><span class="c1">// p.y = 0</span>


<span class="c1">// Structures often have functions to modify their state, similar to</span>
<span class="c1">// object-oriented programming.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">Self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@This</span><span class="p">();</span><span class="w"> </span><span class="c1">// Refers to its own type (later called &quot;Point&quot;).</span>

<span class="w">    </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// Take a look at the signature. First argument is of type *Self: &quot;self&quot; is</span>
<span class="w">    </span><span class="c1">// a pointer on the instance of the structure.</span>
<span class="w">    </span><span class="c1">// This allows the same &quot;dot&quot; notation as in OOP, like &quot;instance.set(x,y)&quot;.</span>
<span class="w">    </span><span class="c1">// See the following example.</span>
<span class="w">    </span><span class="kr">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">set</span><span class="p">(</span><span class="n">self</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">        </span><span class="n">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Again, look at the signature. First argument is of type Self (not *Self),</span>
<span class="w">    </span><span class="c1">// this isn&#39;t a pointer. In this case, &quot;self&quot; refers to the instance of the</span>
<span class="w">    </span><span class="c1">// structure, but can&#39;t be modified.</span>
<span class="w">    </span><span class="kr">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">getx</span><span class="p">(</span><span class="n">self</span><span class="o">:</span><span class="w"> </span><span class="n">Self</span><span class="p">)</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// PS: two previous functions may be somewhat useless.</span>
<span class="w">    </span><span class="c1">//     Attributes can be changed directly, no need for accessor functions.</span>
<span class="w">    </span><span class="c1">//     It was just an example.</span>
<span class="p">};</span>

<span class="c1">// Let&#39;s use the previous structure.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// &quot;p&quot; variable is a Point.</span>

<span class="n">p</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">);</span><span class="w"> </span><span class="c1">// x and y attributes of &quot;p&quot; are modified via the &quot;set&quot; function.</span>
<span class="n">print</span><span class="p">(</span><span class="s">&quot;p.x: {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">});</span><span class="w"> </span><span class="c1">// 10</span>
<span class="n">print</span><span class="p">(</span><span class="s">&quot;p.y: {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">});</span><span class="w"> </span><span class="c1">// 30</span>

<span class="c1">// In C:</span>
<span class="c1">//   1. We would have written something like: point_set(p, 10, 30).</span>
<span class="c1">//   2. Since all functions are in the same namespace, it would have been</span>
<span class="c1">//      very cumbersome to create functions with different names for different</span>
<span class="c1">//      structures. Many long names, painful to read.</span>
<span class="c1">//</span>
<span class="c1">// In Zig, structures provide namespaces for their own functions.</span>
<span class="c1">// Different structures can have the same names for their functions,</span>
<span class="c1">// which brings clarity.</span>
</pre></div>
<h3>Tuples.</h3>
<div class="highlight"><pre><span></span><span class="c1">// A tuple is a list of elements, possibly of different types.</span>

<span class="kr">const</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="p">};</span>
<span class="c1">// foo.len == 3</span>
</pre></div>
<h3>Enumerations.</h3>
<div class="highlight"><pre><span></span><span class="kr">const</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ok</span><span class="p">,</span><span class="w"> </span><span class="n">not_ok</span><span class="w"> </span><span class="p">};</span>

<span class="kr">const</span><span class="w"> </span><span class="n">CardinalDirections</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">North</span><span class="p">,</span><span class="w"> </span><span class="n">South</span><span class="p">,</span><span class="w"> </span><span class="n">East</span><span class="p">,</span><span class="w"> </span><span class="n">West</span><span class="w"> </span><span class="p">};</span>
<span class="kr">const</span><span class="w"> </span><span class="n">direction</span><span class="o">:</span><span class="w"> </span><span class="n">CardinalDirections</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">North</span><span class="p">;</span>
<span class="kr">const</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">direction</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// shorthand for CardinalDirections.North</span>
<span class="w">    </span><span class="p">.</span><span class="n">North</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">false</span>
<span class="p">};</span>

<span class="c1">// Switch statements need exhaustiveness.</span>
<span class="c1">// WARNING: won&#39;t compile. East and West are missing.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">direction</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">North</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">South</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="p">};</span>


<span class="c1">// Switch statements need exhaustiveness.</span>
<span class="c1">// Won&#39;t compile: East and West are missing.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">direction</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">North</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">South</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">East</span><span class="p">,</span><span class="w">          </span><span class="c1">// Its value is the same as the following pattern: false.</span>
<span class="w">    </span><span class="p">.</span><span class="n">West</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="p">};</span>


<span class="c1">// Enumerations are like structures: they can have functions.</span>
</pre></div>
<h3>Unions.</h3>
<div class="highlight"><pre><span></span><span class="kr">const</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">boolean</span><span class="o">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span>
<span class="w">    </span><span class="n">int</span><span class="o">:</span><span class="w"> </span><span class="kt">i16</span><span class="p">,</span>
<span class="w">    </span><span class="n">float</span><span class="o">:</span><span class="w"> </span><span class="kt">f32</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// Both syntaxes are equivalent.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Bar</span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="p">};</span>
<span class="kr">const</span><span class="w"> </span><span class="n">foo</span><span class="o">:</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="p">.</span><span class="n">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="p">};</span>

<span class="c1">// Unions, like enumerations and structures, can have functions.</span>
</pre></div>
<h3>Tagged unions.</h3>
<div class="highlight"><pre><span></span><span class="c1">// Unions can be declared with an enum tag type, allowing them to be used in</span>
<span class="c1">// switch expressions.</span>

<span class="kr">const</span><span class="w"> </span><span class="n">MaybeEnum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">success</span><span class="p">,</span>
<span class="w">    </span><span class="n">failure</span><span class="p">,</span>
<span class="p">};</span>

<span class="kr">const</span><span class="w"> </span><span class="n">Maybe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">union</span><span class="p">(</span><span class="n">MaybeEnum</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">success</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span>
<span class="w">    </span><span class="n">failure</span><span class="o">:</span><span class="w"> </span><span class="p">[]</span><span class="kr">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// First value: success!</span>
<span class="kr">const</span><span class="w"> </span><span class="n">yay</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Maybe</span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">success</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="p">};</span>
<span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">yay</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">success</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">|</span><span class="n">value</span><span class="o">|</span><span class="w">     </span><span class="n">std</span><span class="p">.</span><span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;success: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">value</span><span class="p">}),</span>
<span class="w">    </span><span class="p">.</span><span class="n">failure</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">|</span><span class="n">err_msg</span><span class="o">|</span><span class="w">   </span><span class="n">std</span><span class="p">.</span><span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;failure: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">err_msg</span><span class="p">}),</span>
<span class="p">}</span>

<span class="c1">// Second value: failure! :(</span>
<span class="kr">const</span><span class="w"> </span><span class="n">nay</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Maybe</span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">failure</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;I was too lazy&quot;</span><span class="w"> </span><span class="p">};</span>
<span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">nay</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">success</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">|</span><span class="n">value</span><span class="o">|</span><span class="w">     </span><span class="n">std</span><span class="p">.</span><span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;success: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">value</span><span class="p">}),</span>
<span class="w">    </span><span class="p">.</span><span class="n">failure</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">|</span><span class="n">err_msg</span><span class="o">|</span><span class="w">   </span><span class="n">std</span><span class="p">.</span><span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;failure: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">err_msg</span><span class="p">}),</span>
<span class="p">}</span>
</pre></div>
<h3>Defer and errdefer.</h3>
<div class="highlight"><pre><span></span><span class="c1">// Make sure that an action (single instruction or block of code) is executed</span>
<span class="c1">// before the end of the scope (function, block of code).</span>
<span class="c1">// Even on error, that action will be executed.</span>
<span class="c1">// Useful for memory allocations, and resource management in general.</span>

<span class="kr">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Should be executed at the end of the function.</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;third!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{});</span>

<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Last element of its scope: will be executed right away.</span>
<span class="w">        </span><span class="k">defer</span><span class="w"> </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;first!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{});</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;second!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{});</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="n">hello_world</span><span class="p">()</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;end of function</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{});</span><span class="w"> </span><span class="c1">// after &quot;hello world!&quot;</span>

<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;hello world!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{});</span>
<span class="p">}</span>

<span class="c1">// errdefer executes the instruction (or block of code) only on error.</span>
<span class="k">fn</span><span class="w"> </span><span class="n">second_hello_world</span><span class="p">()</span><span class="w"> </span><span class="o">!</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">errdefer</span><span class="w"> </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;2. something went wrong!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{});</span><span class="w"> </span><span class="c1">// if &quot;foo&quot; fails.</span>
<span class="w">    </span><span class="k">defer</span><span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;1. second hello world</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{});</span><span class="w">    </span><span class="c1">// executed after &quot;foo&quot;</span>

<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">// Defer statements can be seen as stacked: first one is executed last.</span>
</pre></div>
<h3>Memory allocators.</h3>

<p>Memory isn&rsquo;t managed directly in the standard library, instead an &ldquo;allocator&rdquo; is asked every time an operation on memory is required.
Thus, the standard library lets developers handle memory as they need, through structures called &ldquo;allocators&rdquo;, handling all memory operations.</p>

<p><strong>NOTE</strong>: the choice of the allocator isn&rsquo;t in the scope of this document.
A whole book could be written about it.
However, here are some examples, to get an idea of what you can expect:
- <code>page_allocator</code>.
  Allocate a whole page of memory each time we ask for some memory.
  Very simple, very dumb, very wasteful.
- <code>GeneralPurposeAllocator</code>.
  Get some memory first and manage some buckets of memory in order to
  reduce the number of allocations.
  A bit complex. Can be combined with other allocators.
  Can detect leaks and provide useful information to find them.
- <code>FixedBufferAllocator</code>.
  Use a fixed buffer to get its memory, don&rsquo;t ask memory to the kernel.
  Very simple, limited and wasteful (can&rsquo;t deallocate), but very fast.
- <code>ArenaAllocator</code>.
  Allow to free all allocated memory at once.
  To use in combinations with another allocator.
  Very simple way of avoiding leaks.</p>

<p>A first example.</p>
<div class="highlight"><pre><span></span><span class="c1">// &quot;!void&quot; means the function doesn&#39;t return any value except for errors.</span>
<span class="c1">// In this case we try to allocate memory, and this may fail.</span>
<span class="k">fn</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="o">!</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// In this example we use a page allocator.</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">allocator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">heap</span><span class="p">.</span><span class="n">page_allocator</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// &quot;list&quot; is an ArrayList of 8-bit unsigned integers.</span>
<span class="w">    </span><span class="c1">// An ArrayList is a contiguous, growable list of elements in memory.</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">ArrayList</span><span class="p">(</span><span class="kt">u8</span><span class="p">).</span><span class="n">initAllocated</span><span class="p">(</span><span class="n">allocator</span><span class="p">);</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="n">list</span><span class="p">.</span><span class="n">deinit</span><span class="p">();</span><span class="w"> </span><span class="c1">// Free the memory at the end of the scope. Can&#39;t leak.</span>
<span class="w">    </span><span class="c1">// &quot;defer&quot; allows to express memory release right after its allocation,</span>
<span class="w">    </span><span class="c1">// regardless of the complexity of the function (loops, conditions, etc.).</span>

<span class="w">    </span><span class="n">list</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// Some memory is allocated here, with the provided allocator.</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">list</span><span class="p">.</span><span class="n">items</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">item</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="p">.</span><span class="n">debug</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">&quot;item: {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">item</span><span class="p">});</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h3>Memory allocation combined with error management and defer.</h3>
<div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="n">some_memory_allocation_example</span><span class="p">()</span><span class="w"> </span><span class="o">!</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Memory allocation may fail, so we &quot;try&quot; to allocate the memory and</span>
<span class="w">    </span><span class="c1">// in case there is an error, the current function returns it.</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">page_allocator</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Defer memory release right after the allocation.</span>
<span class="w">    </span><span class="c1">// Will happen even if an error occurs.</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="n">page_allocator</span><span class="p">.</span><span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Second allocation.</span>
<span class="w">    </span><span class="c1">// In case of a failure, the first allocation is correctly released.</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">buf2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">page_allocator</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="n">page_allocator</span><span class="p">.</span><span class="n">free</span><span class="p">(</span><span class="n">buf2</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// In case of failure, both previous allocations are correctly deallocated.</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">foo</span><span class="p">();</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">bar</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
<h3>Memory allocators: a taste of the standard library.</h3>
<div class="highlight"><pre><span></span><span class="c1">// Allocators: 4 main functions to know</span>
<span class="c1">//   single_value = create (type)</span>
<span class="c1">//   destroy (single_value)</span>
<span class="c1">//   slice = alloc (type, size)</span>
<span class="c1">//   free (slice)</span>

<span class="c1">// Page Allocator</span>
<span class="k">fn</span><span class="w"> </span><span class="n">page_allocator_fn</span><span class="p">()</span><span class="w"> </span><span class="o">!</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">heap</span><span class="p">.</span><span class="n">page_allocator</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">heap</span><span class="p">.</span><span class="n">page_allocator</span><span class="p">.</span><span class="n">free</span><span class="p">(</span><span class="n">slice</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// playing_with_a_slice(slice);</span>
<span class="p">}</span>

<span class="c1">// GeneralPurposeAllocator</span>
<span class="k">fn</span><span class="w"> </span><span class="n">general_purpose_allocator_fn</span><span class="p">()</span><span class="w"> </span><span class="o">!</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// GeneralPurposeAllocator has to be configured.</span>
<span class="w">    </span><span class="c1">// In this case, we want to track down memory leaks.</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.{.</span><span class="n">safety</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">};</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">gpa</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">heap</span><span class="p">.</span><span class="n">GeneralPurposeAllocator</span><span class="p">(</span><span class="n">config</span><span class="p">){};</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gpa</span><span class="p">.</span><span class="n">deinit</span><span class="p">();</span>

<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">allocator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gpa</span><span class="p">.</span><span class="n">allocator</span><span class="p">();</span>

<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">allocator</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="n">allocator</span><span class="p">.</span><span class="n">free</span><span class="p">(</span><span class="n">slice</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// playing_with_a_slice(slice);</span>
<span class="p">}</span>

<span class="c1">// FixedBufferAllocator</span>
<span class="k">fn</span><span class="w"> </span><span class="n">fixed_buffer_allocator_fn</span><span class="p">()</span><span class="w"> </span><span class="o">!</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="mi">0</span><span class="p">}</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="c1">// array of 1000 u8, all initialized at zero.</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">fba</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">heap</span><span class="p">.</span><span class="n">FixedBufferAllocator</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">..]);</span>
<span class="w">    </span><span class="c1">// Side note: buffer[0..] is a way to create a slice from an array.</span>
<span class="w">    </span><span class="c1">//            Since the function takes a slice and not an array, this makes</span>
<span class="w">    </span><span class="c1">//            the type system happy.</span>

<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">allocator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fba</span><span class="p">.</span><span class="n">allocator</span><span class="p">();</span>

<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">allocator</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// No need for &quot;free&quot;, memory cannot be freed with a fixed buffer allocator.</span>
<span class="w">    </span><span class="c1">// defer allocator.free(slice);</span>

<span class="w">    </span><span class="c1">// playing_with_a_slice(slice);</span>
<span class="p">}</span>

<span class="c1">// ArenaAllocator</span>
<span class="k">fn</span><span class="w"> </span><span class="n">arena_allocator_fn</span><span class="p">()</span><span class="w"> </span><span class="o">!</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Reminder: arena doesn&#39;t allocate memory, it uses an inner allocator.</span>
<span class="w">    </span><span class="c1">// In this case, we combine the arena allocator with the page allocator.</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">arena</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">heap</span><span class="p">.</span><span class="n">arena_allocator</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">std</span><span class="p">.</span><span class="n">heap</span><span class="p">.</span><span class="n">page_allocator</span><span class="p">);</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="n">arena</span><span class="p">.</span><span class="n">deinit</span><span class="p">();</span><span class="w"> </span><span class="c1">// end of function = all allocations are freed.</span>

<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">allocator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arena</span><span class="p">.</span><span class="n">allocator</span><span class="p">();</span>

<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">allocator</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// No need for &quot;free&quot;, memory will be freed anyway.</span>

<span class="w">    </span><span class="c1">// playing_with_a_slice(slice);</span>
<span class="p">}</span>


<span class="c1">// Combining the general purpose and arena allocators. Both are very useful,</span>
<span class="c1">// and their combinations should be in everyone&#39;s favorite cookbook.</span>
<span class="k">fn</span><span class="w"> </span><span class="n">gpa_arena_allocator_fn</span><span class="p">()</span><span class="w"> </span><span class="o">!</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.{.</span><span class="n">safety</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">};</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">gpa</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">heap</span><span class="p">.</span><span class="n">GeneralPurposeAllocator</span><span class="p">(</span><span class="n">config</span><span class="p">){};</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gpa</span><span class="p">.</span><span class="n">deinit</span><span class="p">();</span>

<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">gpa_allocator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gpa</span><span class="p">.</span><span class="n">allocator</span><span class="p">();</span>

<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">arena</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arena_allocator</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">gpa_allocator</span><span class="p">);</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="n">arena</span><span class="p">.</span><span class="n">deinit</span><span class="p">();</span>

<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">allocator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arena</span><span class="p">.</span><span class="n">allocator</span><span class="p">();</span>

<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">allocator</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="n">allocator</span><span class="p">.</span><span class="n">free</span><span class="p">(</span><span class="n">slice</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// playing_with_a_slice(slice);</span>
<span class="p">}</span>
</pre></div>
<h3>Comptime.</h3>
<div class="highlight"><pre><span></span><span class="c1">// Comptime is a way to avoid the pre-processor.</span>
<span class="c1">// The idea is simple: run code at compilation.</span>

<span class="kr">inline</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="kr">comptime</span><span class="w"> </span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="kt">type</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">var</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="kr">var</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="kt">f32</span><span class="p">,</span><span class="w"> </span><span class="mf">10.50</span><span class="p">,</span><span class="w"> </span><span class="mf">32.19</span><span class="p">);</span>


<span class="c1">// Comptime: creating generic structures.</span>

<span class="k">fn</span><span class="w"> </span><span class="n">List</span><span class="p">(</span><span class="kr">comptime</span><span class="w"> </span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="kt">type</span><span class="p">)</span><span class="w"> </span><span class="kt">type</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">items</span><span class="o">:</span><span class="w"> </span><span class="p">[]</span><span class="n">T</span><span class="p">,</span>

<span class="w">        </span><span class="k">fn</span><span class="w"> </span><span class="n">init</span><span class="p">()</span><span class="w">   </span><span class="p">...</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="w">        </span><span class="k">fn</span><span class="w"> </span><span class="n">deinit</span><span class="p">()</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="w">        </span><span class="k">fn</span><span class="w"> </span><span class="n">do</span><span class="p">()</span><span class="w">     </span><span class="p">...</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">};</span>
<span class="p">}</span>

<span class="kr">const</span><span class="w"> </span><span class="n">MyList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">List</span><span class="p">(</span><span class="kt">u8</span><span class="p">);</span>


<span class="c1">// use</span>
<span class="kr">var</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyList</span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">items</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="c1">// memory allocation</span>
<span class="p">};</span>

<span class="n">list</span><span class="p">.</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
</pre></div>
<h3>Conditional compilation.</h3>
<div class="highlight"><pre><span></span><span class="kr">const</span><span class="w"> </span><span class="n">available_os</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">OpenBSD</span><span class="p">,</span><span class="w"> </span><span class="n">Linux</span><span class="w"> </span><span class="p">};</span>
<span class="kr">const</span><span class="w"> </span><span class="n">myos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">available_os</span><span class="p">.</span><span class="n">OpenBSD</span><span class="p">;</span>


<span class="c1">// The following switch is based on a constant value.</span>
<span class="c1">// This means that the only possible outcome is known at compile-time.</span>
<span class="c1">// Thus, there is no need to build the rest of the possibilities.</span>
<span class="c1">// Similar to the &quot;#ifdef&quot; in C, but without requiring a pre-processor.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">myos</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="p">.</span><span class="n">OpenBSD</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&quot;OpenBSD is awesome!&quot;</span><span class="p">,</span>
<span class="w">   </span><span class="p">.</span><span class="n">Linux</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&quot;Linux rocks!&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// Also works in this case.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">myprint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">switch</span><span class="p">(</span><span class="n">myos</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">OpenBSD</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">debug</span><span class="p">.</span><span class="n">print</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">Linux</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
<h3>Testing our functions.</h3>
<div class="highlight"><pre><span></span><span class="kr">const</span><span class="w"> </span><span class="n">std</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@import</span><span class="p">(</span><span class="s">&quot;std&quot;</span><span class="p">);</span>
<span class="kr">const</span><span class="w"> </span><span class="n">expect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">testing</span><span class="p">.</span><span class="n">expect</span><span class="p">;</span>

<span class="c1">// Function to test.</span>
<span class="kr">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">some_function</span><span class="p">()</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// This &quot;test&quot; block can be run with &quot;zig test&quot;.</span>
<span class="c1">// It will test the function at compile-time.</span>
<span class="k">test</span><span class="w"> </span><span class="s">&quot;returns true&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">expect</span><span class="p">(</span><span class="kc">false</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">some_function</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
<h3>Compiler built-ins.</h3>

<p>The compiler has special functions called &ldquo;built-ins&rdquo;, starting with an &ldquo;@&rdquo;.
There are more than a hundred built-ins, allowing very low-level stuff:
- compile-time errors, logging, verifications
- type coercion and conversion, even in an unsafe way
- alignment management
- memory tricks (such as getting the byte offset of a field in a struct)
- calling functions at compile-time
- including C headers to transparently call C functions
- atomic operations
- embed files into the executable (@embedFile)
- frame manipulations (for async functions, for example)
- etc.</p>

<p>Example: enums aren&rsquo;t integers, they have to be converted with a built-in.</p>
<div class="highlight"><pre><span></span><span class="kr">const</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">zero</span><span class="p">,</span><span class="w"> </span><span class="n">stuff</span><span class="p">,</span><span class="w"> </span><span class="n">blah</span><span class="w"> </span><span class="p">};</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">@enumToInt</span><span class="p">(</span><span class="n">Value</span><span class="p">.</span><span class="n">zero</span><span class="p">)</span><span class="w">  </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">@enumToInt</span><span class="p">(</span><span class="n">Value</span><span class="p">.</span><span class="n">stuff</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">@enumToInt</span><span class="p">(</span><span class="n">Value</span><span class="p">.</span><span class="n">blah</span><span class="p">)</span><span class="w">  </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
</pre></div>
<h3>A few &ldquo;not yourself in the foot&rdquo; measures in the Zig language.</h3>

<ul>
<li>Namespaces: name conflicts are easily avoided.
In practice, that means a unified API between different structures (data types).</li>
<li>Enumerations aren&rsquo;t integers. Comparing an enumeration to an integer requires a conversion.</li>
<li>Explicit casts, coercion exists but is limited.
Types are slightly more enforced than in C, just a taste:
Pointers aren&rsquo;t integers, explicit conversion is necessary.
You won&rsquo;t lose precision by accident, implicit coercions are only authorized in cases where no precision can be lost.
Unions cannot be reinterpreted (in a union with an integer and a float, one cannot take a value for another by accident).
Etc.</li>
<li>Removing most of the C undefined behaviors (UBs), and when the compiler encounters one, it stops.</li>
<li>Slice and Array structures are preferred to pointers.
Types enforced by the compiler are less prone to errors than pointer manipulations.</li>
<li>Numerical overflows produce an error, unless explicitly accepted using wrapping operators.</li>
<li><code>try</code> and <code>catch</code> mechanism.
It&rsquo;s both handy, trivially implemented (simple error enumeration), and it takes almost no space nor computation time.</li>
<li>Unused variables are considered to be errors by the compiler.</li>
<li>Many pointer types exist in order to represent what is pointed to.
Example: is this a single value or an array, is the length known, etc.</li>
<li>Structures need a value for their attributes, and it is still possible to give an undefined value (stack garbage), but at least it is explicitly undefined.</li>
</ul>

<h2>Further Reading</h2>

<p>For a start, some concepts are presented on <a href="https://zig.guide/">zig.guide</a>.</p>

<p>The <a href="https://ziglang.org/documentation/">official website</a> provides the reference documentation of the language. The standard library <a href="https://ziglang.org/documentation/master/std/">has its own documentation</a>.</p>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/zig.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by Philippe Pittoli, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/zig.html.markdown">3 contributors</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="https://karchnu.fr/">Philippe Pittoli</a>
    </p>

    <p>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
