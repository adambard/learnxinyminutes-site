<!DOCTYPE html lang="en-us" xml:lang="en-us" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="en-us">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn zig in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/zig/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fzig%2F&text=Learn+X+in+Y+minutes%2C+where+X%3Dzig">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="/">Learn X in Y minutes</a></h1>
  <h2>Where X=zig</h2>
    <p class="filelink">
    Get the code:
    <a href="/docs/files/learnzig.zig">learnzig.zig</a>
    </p>
  <div id="doc">
    <p><a href="https://ziglang.org">Zig</a> aims to be a replacement for the C programming language.</p>

<p><strong>WARNING</strong>: this document expects you to understand a few basic concepts in computer science, such as pointers, stack and heap memory, etc.</p>

<p><strong>WARNING</strong>: Zig isn&rsquo;t considered as ready for production. Bugs are expected.</p>

<p>Prior knowledge of C is recommended.</p>

<h2>Quick overview: Zig compared to C</h2>

<ul>
<li>Syntax is mostly the same, with some improvements (less ambiguity).</li>
<li>Zig introduces namespaces.</li>
<li><code>try</code> and <code>catch</code> mechanism, which is both convenient, efficient and optional.</li>
<li>Most of the C undefined behaviors (UBs) are fixed.</li>
<li>Compared to C, raw pointers are safer to use and less likely to be needed.

<ul>
<li>The type system distinguishes between a pointer to a single value, or multiple values, etc.</li>
<li>Slices are preferred, which is a structure with a pointer and a runtime known size, which characterizes most uses of pointers in the first place.</li>
</ul></li>
<li>Some arbitrary language limitations are removed. For example, enumerations, structures and unions can have functions.</li>
<li>Simple access to SIMD operations (basic maths on vectors).</li>
<li>Zig provides both low-level features of C and the one provided through compiler extensions.
For example: packed structures.</li>
<li>An extensive standard library, including data structures and algorithms.</li>
<li>Cross-compilation capability is provided by default, without any dependency.
Different libc are provided to ease the process.
Cross-compilation works from, and to, any operating system and architecture.</li>
</ul>

<h2>Zig language</h2>
<div class="highlight"><pre class="highlight zig"><code><span class="c">//! Top-level documentation.</span>

<span class="c">/// Documentation comment.</span>

<span class="c">// Simple comment.</span>
</code></pre></div>
<h3>Hello world.</h3>
<div class="highlight"><pre class="highlight zig"><code><span class="c">// Import standard library, reachable through the "std" constant.</span>
<span class="k">const</span> <span class="n">std</span> <span class="o">=</span> <span class="nb">@import</span><span class="p">(</span><span class="s">"std"</span><span class="p">);</span>

<span class="c">// "info" now refers to the "std.log.info" function.</span>
<span class="k">const</span> <span class="n">info</span> <span class="o">=</span> <span class="n">std</span><span class="p">.</span><span class="py">log</span><span class="p">.</span><span class="py">info</span><span class="p">;</span>

<span class="c">// Usual hello world.</span>
<span class="c">// syntax: [pub] fn &lt;function-name&gt;(&lt;arguments&gt;) &lt;return-type&gt; { &lt;body&gt; }</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="k">void</span> <span class="p">{</span>
    <span class="c">// Contrary to C functions, Zig functions have a fixed number of arguments.</span>
    <span class="c">// In C: "printf" takes any number of arguments.</span>
    <span class="c">// In Zig: std.log.info takes a format and a list of elements to print.</span>
    <span class="n">info</span><span class="p">(</span><span class="s">"hello world"</span><span class="p">,</span> <span class="o">.</span><span class="p">{});</span>  <span class="c">// .{} is an empty anonymous tuple.</span>
<span class="p">}</span>
</code></pre></div>
<h3>Booleans, integers and float.</h3>
<div class="highlight"><pre class="highlight zig"><code><span class="c">// Booleans.</span>
<span class="c">// Keywords are preferred to operators for boolean operations.</span>
<span class="n">print</span><span class="p">(</span><span class="s">"{}</span><span class="se">\n</span><span class="s">{}</span><span class="se">\n</span><span class="s">{}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">.</span><span class="p">{</span>
    <span class="kc">true</span> <span class="k">and</span> <span class="kc">false</span><span class="p">,</span>
    <span class="kc">true</span> <span class="k">or</span> <span class="kc">false</span><span class="p">,</span>
    <span class="o">!</span><span class="kc">true</span><span class="p">,</span>
<span class="p">});</span>

<span class="c">// Integers.</span>
<span class="k">const</span> <span class="n">one_plus_one</span><span class="p">:</span> <span class="kt">i32</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="s">"1 + 1 = {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">.</span><span class="p">{</span><span class="n">one_plus_one</span><span class="p">});</span> <span class="c">// 2</span>

<span class="c">// Floats.</span>
<span class="k">const</span> <span class="n">seven_div_three</span><span class="p">:</span> <span class="kt">f32</span> <span class="o">=</span> <span class="mf">7.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="s">"7.0 / 3.0 = {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">.</span><span class="p">{</span><span class="n">seven_div_three</span><span class="p">});</span> <span class="c">// 2.33333325e+00</span>

<span class="c">// Integers have arbitrary value lengths.</span>
<span class="k">var</span> <span class="n">myvar</span><span class="p">:</span> <span class="kt">u10</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c">// 10-bit unsigned integer</span>
<span class="c">// Useful for example to read network packets, or complex binary formats.</span>

<span class="c">// Number representation is greatly improved compared to C.</span>
<span class="k">const</span> <span class="n">one_billion</span> <span class="o">=</span> <span class="mi">1_000_000_000</span><span class="p">;</span>         <span class="c">// Decimal.</span>
<span class="k">const</span> <span class="n">binary_mask</span> <span class="o">=</span> <span class="mi">0b1_1111_1111</span><span class="p">;</span>         <span class="c">// Binary. Ex: network mask.</span>
<span class="k">const</span> <span class="n">permissions</span> <span class="o">=</span> <span class="mi">0</span><span class="n">o7_5_5</span><span class="p">;</span>               <span class="c">// Octal.  Ex: Unix permissions.</span>
<span class="k">const</span> <span class="n">big_address</span> <span class="o">=</span> <span class="mi">0xFF80_0000_0000_0000</span><span class="p">;</span> <span class="c">// Hexa.   Ex: IPv6 address.</span>


<span class="c">// Overflow operators: tell the compiler when it's okay to overflow.</span>
<span class="k">var</span> <span class="n">i</span><span class="p">:</span> <span class="kt">u8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c">// "i" is an unsigned 8-bit integer</span>
<span class="n">i</span>  <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>        <span class="c">// runtime overflow error (unsigned value always are positive)</span>
<span class="n">i</span> <span class="o">-%=</span> <span class="mi">1</span><span class="p">;</span>        <span class="c">// okay (wrapping operator), i == 255</span>

<span class="c">// Saturation operators: values will stick to their lower and upper bounds.</span>
<span class="k">var</span> <span class="n">i</span><span class="p">:</span> <span class="kt">u8</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>   <span class="c">// "i" is an unsigned 8-bit integer (values: from 0 to 255)</span>
<span class="n">i</span>  <span class="o">+</span><span class="p">|</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">255</span>   <span class="c">// u8: won't go higher than 255</span>
<span class="n">i</span>  <span class="o">-</span><span class="p">|</span> <span class="mi">300</span> <span class="o">==</span> <span class="mi">0</span>     <span class="c">// unsigned, won't go lower than 0</span>
<span class="n">i</span>  <span class="o">*</span><span class="p">|</span> <span class="mi">2</span>   <span class="o">==</span> <span class="mi">255</span>   <span class="c">// u8: won't go higher than 255</span>
<span class="n">i</span> <span class="o">&lt;&lt;</span><span class="p">|</span> <span class="mi">8</span>   <span class="o">==</span> <span class="mi">255</span>   <span class="c">// u8: won't go higher than 255</span>
</code></pre></div>
<h3>Arrays.</h3>
<div class="highlight"><pre class="highlight zig"><code><span class="c">// An array is a well-defined structure with a length attribute (len).</span>

<span class="c">// 5-byte array with undefined content (stack garbage).</span>
<span class="k">var</span> <span class="n">array1</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="kt">u8</span> <span class="o">=</span> <span class="k">undefined</span><span class="p">;</span>

<span class="c">// 5-byte array with defined content.</span>
<span class="k">var</span> <span class="n">array2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">_</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">};</span>
<span class="c">// [_] means the compiler knows the length at compile-time.</span>

<span class="c">// 1000-byte array with defined content (0).</span>
<span class="k">var</span> <span class="n">array3</span> <span class="o">=</span> <span class="p">[</span><span class="mi">_</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="mi">0</span><span class="p">}</span> <span class="o">**</span> <span class="mi">1000</span><span class="p">;</span>

<span class="c">// Another 1000-byte array with defined content.</span>
<span class="c">// The content is provided by the "foo" function, called at compile-time and</span>
<span class="c">// allows complex initializations.</span>
<span class="k">var</span> <span class="n">array4</span> <span class="o">=</span> <span class="p">[</span><span class="mi">_</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="n">foo</span><span class="p">()}</span> <span class="o">**</span> <span class="mi">1000</span><span class="p">;</span>

<span class="c">// In any case, array.len gives the length of the array,</span>
<span class="c">// array1.len and array2.len produce 5, array3.len and array4.len produce 1000.</span>


<span class="c">// Modifying and accessing arrays content.</span>

<span class="c">// Array of 10 32-bit undefined integers.</span>
<span class="k">var</span> <span class="n">some_integers</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="kt">i32</span> <span class="o">=</span> <span class="k">undefined</span><span class="p">;</span>

<span class="n">some_integers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span> <span class="c">// first element of the array is now 30</span>

<span class="k">var</span> <span class="n">x</span> <span class="o">=</span> <span class="n">some_integers</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c">// "x" now equals to 30, its type is inferred.</span>
<span class="k">var</span> <span class="n">y</span> <span class="o">=</span> <span class="n">some_integers</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c">// Second element of the array isn't defined.</span>
                          <span class="c">// "y" got a stack garbage value (no runtime error).</span>

<span class="c">// Array of 10 32-bit undefined integers.</span>
<span class="k">var</span> <span class="n">some_integers</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="kt">i32</span> <span class="o">=</span> <span class="k">undefined</span><span class="p">;</span>

<span class="k">var</span> <span class="n">z</span> <span class="o">=</span> <span class="n">some_integers</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span> <span class="c">// index &gt; array size, compilation error.</span>

<span class="c">// At runtime, we loop over the elements of "some_integers" with an index.</span>
<span class="c">// Index i = 20, then we try:</span>
<span class="k">try</span> <span class="n">some_integers</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c">// Runtime error 'index out of bounds'.</span>
                      <span class="c">// "try" keyword is necessary when accessing an array with</span>
                      <span class="c">// an index, since there is a potential runtime error.</span>
                      <span class="c">// More on that later.</span>
</code></pre></div>
<h3>Multidimensional arrays.</h3>
<div class="highlight"><pre class="highlight zig"><code><span class="k">const</span> <span class="n">mat4x4</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span><span class="kt">f32</span><span class="p">{</span>
    <span class="p">[</span><span class="mi">_</span><span class="p">]</span><span class="kt">f32</span><span class="p">{</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">},</span>
    <span class="p">[</span><span class="mi">_</span><span class="p">]</span><span class="kt">f32</span><span class="p">{</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">},</span>
    <span class="p">[</span><span class="mi">_</span><span class="p">]</span><span class="kt">f32</span><span class="p">{</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">},</span>
    <span class="p">[</span><span class="mi">_</span><span class="p">]</span><span class="kt">f32</span><span class="p">{</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">},</span>
<span class="p">};</span>

<span class="c">// Access the 2D array then the inner array through indexes.</span>
<span class="k">try</span> <span class="n">expect</span><span class="p">(</span><span class="n">mat4x4</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">);</span>

<span class="c">// Here we iterate with for loops.</span>
<span class="k">for</span> <span class="p">(</span><span class="n">mat4x4</span><span class="p">)</span> <span class="p">|</span><span class="n">row</span><span class="p">,</span> <span class="n">row_index</span><span class="p">|</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="p">|</span><span class="n">cell</span><span class="p">,</span> <span class="n">column_index</span><span class="p">|</span> <span class="p">{</span>
        <span class="c">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3>Strings.</h3>
<div class="highlight"><pre class="highlight zig"><code><span class="c">// Simple string constant.</span>
<span class="k">const</span> <span class="n">greetings</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span>
<span class="c">// ... which is equivalent to:</span>
<span class="k">const</span> <span class="n">greetings</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span><span class="kt">u8</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span>
<span class="c">// In words: "greetings" is a constant value, a pointer on a constant array of 5</span>
<span class="c">// elements (8-bit unsigned integers), with an extra '0' at the end.</span>
<span class="c">// The extra "0" is called a "sentinel value".</span>

<span class="n">print</span><span class="p">(</span><span class="s">"string: {s}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">.</span><span class="p">{</span><span class="n">greetings</span><span class="p">});</span>

<span class="c">// This represents rather faithfully C strings. Although, Zig strings are</span>
<span class="c">// structures, no need for "strlen" to compute their size.</span>
<span class="c">// greetings.len == 5</span>
</code></pre></div>
<h3>Slices.</h3>
<div class="highlight"><pre class="highlight zig"><code><span class="c">// A slice is a pointer and a size, an array without compile-time known size.</span>
<span class="c">// Slices have runtime out-of-band verifications.</span>

<span class="k">const</span> <span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">_</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>     <span class="c">// [_] = array with compile-time known size.</span>
<span class="k">const</span> <span class="n">slice</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">array</span><span class="p">.</span><span class="py">len</span><span class="p">];</span>  <span class="c">// "slice" represents the whole array.</span>
                                    <span class="c">// slice[10] gives a runtime error.</span>
</code></pre></div>
<h3>Pointers.</h3>
<div class="highlight"><pre class="highlight zig"><code><span class="c">// Pointer on a value can be created with "&amp;".</span>
<span class="k">const</span> <span class="n">x</span><span class="p">:</span> <span class="kt">i32</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">const</span> <span class="n">pointer</span><span class="p">:</span> <span class="o">*</span><span class="kt">i32</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>  <span class="c">// "pointer" is a pointer on the i32 var "x".</span>
<span class="n">print</span><span class="p">(</span><span class="s">"1 = {}, {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">.</span><span class="p">{</span><span class="n">x</span><span class="p">,</span> <span class="n">pointer</span><span class="p">});</span>

<span class="c">// Pointer values are accessed and modified with ".*".</span>
<span class="k">if</span> <span class="p">(</span><span class="n">pointer</span><span class="o">.*</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s">"x value == {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">.</span><span class="p">{</span><span class="n">pointer</span><span class="o">.*</span><span class="p">});</span>
<span class="p">}</span>

<span class="c">// ".?" is a shortcut for "orelse unreachable".</span>
<span class="k">const</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">pointer</span><span class="o">.?</span><span class="p">;</span> <span class="c">// Get the pointed value, otherwise crash.</span>
</code></pre></div>
<h3>Optional values (?<type>).</h3>
<div class="highlight"><pre class="highlight zig"><code><span class="c">// An optional is a value than can be of any type or null.</span>

<span class="c">// Example: "optional_value" can either be "null" or an unsigned 32-bit integer.</span>
<span class="k">var</span> <span class="n">optional_value</span><span class="p">:</span> <span class="o">?</span><span class="kt">u32</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c">// optional_value == null</span>
<span class="n">optional_value</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>             <span class="c">// optional_value != null</span>

<span class="c">// "some_function" returns ?u32</span>
<span class="k">var</span> <span class="n">x</span> <span class="o">=</span> <span class="n">some_function</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">|</span><span class="n">value</span><span class="p">|</span> <span class="p">{</span>
    <span class="c">// In case "some_function" returned a value.</span>
    <span class="c">// Do something with 'value'.</span>
<span class="p">}</span>
</code></pre></div>
<h3>Errors.</h3>
<div class="highlight"><pre class="highlight zig"><code><span class="c">// Zig provides an unified way to express errors.</span>

<span class="c">// Errors are defined in error enumerations, example:</span>
<span class="k">const</span> <span class="n">Error</span> <span class="o">=</span> <span class="k">error</span> <span class="p">{</span>
    <span class="n">WatchingAnyNetflixTVShow</span><span class="p">,</span>
    <span class="n">BeOnTwitter</span><span class="p">,</span>
<span class="p">};</span>

<span class="c">// Normal enumerations are expressed the same way, but with "enum" keyword.</span>
<span class="k">const</span> <span class="n">SuccessStory</span> <span class="o">=</span> <span class="k">enum</span> <span class="p">{</span>
    <span class="n">DoingSport</span><span class="p">,</span>
    <span class="n">ReadABook</span><span class="p">,</span>
<span class="p">};</span>


<span class="c">// Error union (!).</span>
<span class="c">// Either the value "mylife" is an an error or a normal value.</span>
<span class="k">var</span> <span class="n">mylife</span><span class="p">:</span> <span class="n">Error</span><span class="o">!</span><span class="n">SuccessStory</span> <span class="o">=</span> <span class="n">Error</span><span class="p">.</span><span class="py">BeOnTwitter</span><span class="p">;</span>
<span class="c">// mylife is an error. Sad.</span>

<span class="n">mylife</span> <span class="o">=</span> <span class="n">SuccessStory</span><span class="p">.</span><span class="py">ReadABook</span><span class="p">;</span>
<span class="c">// Now mylife is an enum.</span>


<span class="c">// Zig ships with many pre-defined errors. Example:</span>
<span class="k">const</span> <span class="n">value</span><span class="p">:</span> <span class="k">anyerror</span><span class="o">!</span><span class="kt">u32</span> <span class="o">=</span> <span class="k">error</span><span class="p">.</span><span class="py">Broken</span><span class="p">;</span>


<span class="c">// Handling errors.</span>

<span class="c">// Some error examples.</span>
<span class="k">const</span> <span class="n">Error</span> <span class="o">=</span> <span class="k">error</span> <span class="p">{</span>
    <span class="n">UnExpected</span><span class="p">,</span>
    <span class="n">Authentication</span><span class="p">,</span>
<span class="p">};</span>

<span class="c">// "some_function" can either return an "Error" or an integer.</span>
<span class="k">fn</span> <span class="n">some_function</span><span class="p">()</span> <span class="n">Error</span><span class="o">!</span><span class="kt">u8</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Error</span><span class="p">.</span><span class="py">UnExpected</span><span class="p">;</span> <span class="c">// It returns an error.</span>
<span class="p">}</span>

<span class="c">// Errors can be "catch" without intermediate variable.</span>
<span class="k">var</span> <span class="n">value</span> <span class="o">=</span> <span class="n">some_function</span><span class="p">()</span> <span class="k">catch</span> <span class="p">|</span><span class="n">err</span><span class="p">|</span> <span class="k">switch</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Error</span><span class="p">.</span><span class="py">UnExpected</span>     <span class="o">=&gt;</span> <span class="k">return</span> <span class="n">err</span><span class="p">,</span>   <span class="c">// Returns the error.</span>
    <span class="n">Error</span><span class="p">.</span><span class="py">Authentication</span> <span class="o">=&gt;</span> <span class="k">unreachable</span><span class="p">,</span>  <span class="c">// Not expected. Crashes the program.</span>
    <span class="k">else</span>                 <span class="o">=&gt;</span> <span class="k">unreachable</span><span class="p">,</span>
<span class="p">};</span>

<span class="c">// An error can be "catch" without giving it a name.</span>
<span class="k">const</span> <span class="n">unwrapped</span> <span class="o">=</span> <span class="n">some_function</span><span class="p">()</span> <span class="k">catch</span> <span class="mi">1234</span><span class="p">;</span> <span class="c">// "unwrapped" = 1234</span>

<span class="c">// "try" is a very handy shortcut for "catch |err| return err".</span>
<span class="k">var</span> <span class="n">value</span> <span class="o">=</span> <span class="k">try</span> <span class="n">some_function</span><span class="p">();</span>
<span class="c">// If "some_function" fails, the current function stops and returns the error.</span>
<span class="c">// "value" can only have a valid value, the error already is handled with "try".</span>
</code></pre></div>
<h3>Control flow.</h3>
<div class="highlight"><pre class="highlight zig"><code><span class="c">// Conditional branching.</span>

<span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>

<span class="c">// Ternary.</span>
<span class="k">var</span> <span class="n">value</span> <span class="o">=</span> <span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="n">x</span> <span class="k">else</span> <span class="n">y</span><span class="p">;</span>

<span class="c">// Shortcut for "if (x) x else 0"</span>
<span class="k">var</span> <span class="n">value</span> <span class="o">=</span> <span class="n">x</span> <span class="k">orelse</span> <span class="mi">0</span><span class="p">;</span>

<span class="c">// If "a" is an optional, which may contain a value.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">|</span><span class="n">value</span><span class="p">|</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s">"value: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">.</span><span class="p">{</span><span class="n">value</span><span class="p">});</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s">"'a' is null</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">.</span><span class="p">{});</span>
<span class="p">}</span>

<span class="c">// Get a pointer on the value (if it exists).</span>
<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">|</span><span class="o">*</span><span class="n">value</span><span class="p">|</span> <span class="p">{</span> <span class="n">value</span><span class="o">.*</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>


<span class="c">// Loops.</span>

<span class="c">// Syntax examples:</span>
<span class="c">//   while (condition) statement</span>
<span class="c">//   while (condition) : (end-of-iteration-statement) statement</span>
<span class="c">//</span>
<span class="c">//   for (iterable) statement</span>
<span class="c">//   for (iterable) |capture| statement</span>
<span class="c">//   for (iterable) statement else statement</span>

<span class="c">// Note: loops work the same way over arrays or slices.</span>

<span class="c">// Simple "while" loop.</span>
<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>

<span class="c">// While loop with a "continue expression"</span>
<span class="c">// (expression executed as the last expression of the loop).</span>
<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="c">// Same, with a more complex continue expression (block of code).</span>
<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">2000</span><span class="p">)</span> <span class="p">:</span> <span class="p">({</span> <span class="n">i</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">j</span> <span class="o">*=</span> <span class="mi">3</span><span class="p">;</span> <span class="p">})</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="c">// To iterate over a portion of a slice, reslice.</span>
<span class="k">for</span> <span class="p">(</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">1</span><span class="p">])</span> <span class="p">|</span><span class="n">value</span><span class="p">|</span> <span class="p">{</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">value</span><span class="p">;</span> <span class="p">}</span>

<span class="c">// Loop over every item of an array (or slice).</span>
<span class="k">for</span> <span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="p">|</span><span class="n">value</span><span class="p">|</span> <span class="p">{</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">value</span><span class="p">;</span> <span class="p">}</span>

<span class="c">// Iterate and get pointers on values instead of copies.</span>
<span class="k">for</span> <span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="p">|</span><span class="o">*</span><span class="n">value</span><span class="p">|</span> <span class="p">{</span> <span class="n">value</span><span class="o">.*</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>

<span class="c">// Iterate with an index.</span>
<span class="k">for</span> <span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="p">|</span><span class="n">value</span><span class="p">,</span> <span class="n">i</span><span class="p">|</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="s">"val[{}] = {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">.</span><span class="p">{</span><span class="n">i</span><span class="p">,</span> <span class="n">value</span><span class="p">});</span> <span class="p">}</span>

<span class="c">// Iterate with pointer and index.</span>
<span class="k">for</span> <span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="p">|</span><span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="n">i</span><span class="p">|</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="s">"val[{}] = {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">.</span><span class="p">{</span><span class="n">i</span><span class="p">,</span> <span class="n">value</span><span class="p">});</span> <span class="n">value</span><span class="o">.*</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>


<span class="c">// Break and continue are supported.</span>
<span class="k">for</span> <span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="p">|</span><span class="n">value</span><span class="p">|</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>  <span class="p">{</span> <span class="k">continue</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span> <span class="k">break</span><span class="p">;</span>    <span class="p">}</span>
    <span class="c">// ...</span>
<span class="p">}</span>

<span class="c">// For loops can also be used as expressions.</span>
<span class="c">// Similar to while loops, when you break from a for loop,</span>
<span class="c">// the else branch is not evaluated.</span>
<span class="k">var</span> <span class="n">sum</span><span class="p">:</span> <span class="kt">i32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c">// The "for" loop has to provide a value, which will be the "else" value.</span>
<span class="k">const</span> <span class="n">result</span> <span class="o">=</span> <span class="k">for</span> <span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="p">|</span><span class="n">value</span><span class="p">|</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">value</span><span class="o">.?</span><span class="p">;</span> <span class="c">// "result" will be the last "sum" value.</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="k">else</span> <span class="mi">0</span><span class="p">;</span>                  <span class="c">// Last value.</span>
</code></pre></div>
<h3>Labels.</h3>
<div class="highlight"><pre class="highlight zig"><code><span class="c">// Labels are a way to name an instruction, a location in the code.</span>
<span class="c">// Labels can be used to "continue" or "break" in a nested loop.</span>
<span class="n">outer</span><span class="p">:</span> <span class="k">for</span> <span class="p">([</span><span class="mi">_</span><span class="p">]</span><span class="kt">i32</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span> <span class="p">})</span> <span class="p">|</span><span class="mi">_</span><span class="p">|</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">([</span><span class="mi">_</span><span class="p">]</span><span class="kt">i32</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">})</span> <span class="p">|</span><span class="mi">_</span><span class="p">|</span> <span class="p">{</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">continue</span> <span class="p">:</span><span class="n">outer</span><span class="p">;</span> <span class="c">// "continue" for the first loop.</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="c">// count = 8</span>
<span class="n">outer</span><span class="p">:</span> <span class="k">for</span> <span class="p">([</span><span class="mi">_</span><span class="p">]</span><span class="kt">i32</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span> <span class="p">})</span> <span class="p">|</span><span class="mi">_</span><span class="p">|</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">([</span><span class="mi">_</span><span class="p">]</span><span class="kt">i32</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">})</span> <span class="p">|</span><span class="mi">_</span><span class="p">|</span> <span class="p">{</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">break</span> <span class="p">:</span><span class="n">outer</span><span class="p">;</span> <span class="c">// "break" for the first loop.</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="c">// count = 1</span>


<span class="c">// Labels can also be used to return a value from a block.</span>
<span class="k">var</span> <span class="n">y</span><span class="p">:</span> <span class="kt">i32</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">const</span> <span class="n">x</span> <span class="o">=</span> <span class="n">blk</span><span class="p">:</span> <span class="p">{</span>
    <span class="n">y</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">break</span> <span class="p">:</span><span class="n">blk</span> <span class="n">y</span><span class="p">;</span> <span class="c">// Now "x" equals 6.</span>
<span class="p">};</span>
<span class="c">// Relevant in cases like "for else" expression (explained in the following).</span>

<span class="c">// For loops can be used as expressions.</span>
<span class="c">// When you break from a for loop, the else branch is not evaluated.</span>
<span class="c">// WARNING: counter-intuitive.</span>
<span class="c">//      The "for" loop will run, then the "else" block will run.</span>
<span class="c">//      The "else" keyword has to be followed by the value to give to "result".</span>
<span class="c">//      See later for another form.</span>
<span class="k">var</span> <span class="n">sum</span><span class="p">:</span> <span class="kt">u8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="n">result</span> <span class="o">=</span> <span class="k">for</span> <span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="p">|</span><span class="n">value</span><span class="p">|</span> <span class="p">{</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="mi">8</span><span class="p">;</span> <span class="c">// result = 8</span>

<span class="c">// In this case, the "else" keyword is followed by a value, too.</span>
<span class="c">// However, the syntax is different: it is labeled.</span>
<span class="c">// Instead of a value, there is a label followed by a block of code, which</span>
<span class="c">// allows to do stuff before returning the value (see the "break" invocation).</span>
<span class="k">const</span> <span class="n">result</span> <span class="o">=</span> <span class="k">for</span> <span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="p">|</span><span class="n">value</span><span class="p">|</span> <span class="p">{</span> <span class="c">// First: loop.</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="n">blk</span><span class="p">:</span> <span class="p">{</span>                        <span class="c">// Second: "else" block.</span>
    <span class="n">std</span><span class="p">.</span><span class="py">log</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s">"executed AFTER the loop!"</span><span class="p">,</span> <span class="o">.</span><span class="p">{});</span>
    <span class="k">break</span> <span class="p">:</span><span class="n">blk</span> <span class="n">sum</span><span class="p">;</span> <span class="c">// The "sum" value will replace the label "blk".</span>
<span class="p">};</span>
</code></pre></div>
<h3>Switch.</h3>
<div class="highlight"><pre class="highlight zig"><code><span class="c">// As a switch in C, but slightly more advanced.</span>
<span class="c">// Syntax:</span>
<span class="c">//   switch (value) {</span>
<span class="c">//       pattern =&gt; expression,</span>
<span class="c">//       pattern =&gt; expression,</span>
<span class="c">//       else    =&gt; expression</span>
<span class="c">//   };</span>

<span class="c">// A switch only checking for simple values.</span>
<span class="k">var</span> <span class="n">x</span> <span class="o">=</span> <span class="k">switch</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Error</span><span class="p">.</span><span class="py">UnExpected</span>     <span class="o">=&gt;</span> <span class="k">return</span> <span class="n">err</span><span class="p">,</span>
    <span class="n">Error</span><span class="p">.</span><span class="py">Authentication</span> <span class="o">=&gt;</span> <span class="k">unreachable</span><span class="p">,</span>
    <span class="k">else</span>                 <span class="o">=&gt;</span> <span class="k">unreachable</span><span class="p">,</span>
<span class="p">};</span>

<span class="c">// A slightly more advanced switch, accepting a range of values:</span>
<span class="k">const</span> <span class="n">foo</span><span class="p">:</span> <span class="kt">i32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="n">bar</span> <span class="o">=</span> <span class="k">switch</span> <span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">0</span>                        <span class="o">=&gt;</span> <span class="s">"zero"</span><span class="p">,</span>
    <span class="mi">1</span><span class="o">...</span><span class="n">std</span><span class="p">.</span><span class="py">math</span><span class="p">.</span><span class="nf">maxInt</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s">"positive"</span><span class="p">,</span>
    <span class="k">else</span>                     <span class="o">=&gt;</span> <span class="s">"negative"</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div>
<h3>Structures.</h3>
<div class="highlight"><pre class="highlight zig"><code><span class="c">// Structure containing a single value.</span>
<span class="k">const</span> <span class="n">Full</span> <span class="o">=</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">number</span><span class="p">:</span> <span class="kt">u16</span><span class="p">,</span>
<span class="p">};</span>

<span class="c">// Packed structure, with guaranteed in-memory layout.</span>
<span class="k">const</span> <span class="n">Divided</span> <span class="o">=</span> <span class="k">packed</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">half1</span><span class="p">:</span> <span class="kt">u8</span><span class="p">,</span>
    <span class="n">quarter3</span><span class="p">:</span> <span class="kt">u4</span><span class="p">,</span>
    <span class="n">quarter4</span><span class="p">:</span> <span class="kt">u4</span><span class="p">,</span>
<span class="p">};</span>

<span class="c">// Point is a constant representing a structure containing two u32, "x" and "y".</span>
<span class="c">// "x" has a default value, which wasn't possible in C.</span>
<span class="k">const</span> <span class="n">Point</span> <span class="o">=</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="kt">u32</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c">// default value</span>
    <span class="n">y</span><span class="p">:</span> <span class="kt">u32</span><span class="p">,</span>
<span class="p">};</span>

<span class="c">// Variable "p" is a new Point, with x = 1 (default value) and y = 2.</span>
<span class="k">var</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">{</span> <span class="p">.</span><span class="py">y</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">};</span>

<span class="c">// Fields are accessed as usual with the dot notation: variable.field.</span>
<span class="n">print</span><span class="p">(</span><span class="s">"p.x: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">.</span><span class="p">{</span><span class="n">p</span><span class="p">.</span><span class="py">x</span><span class="p">});</span> <span class="c">// 1</span>
<span class="n">print</span><span class="p">(</span><span class="s">"p.y: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">.</span><span class="p">{</span><span class="n">p</span><span class="p">.</span><span class="py">y</span><span class="p">});</span> <span class="c">// 2</span>


<span class="c">// A structure can also contain public constants and functions.</span>
<span class="k">const</span> <span class="n">Point</span> <span class="o">=</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">const</span> <span class="n">some_constant</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>

    <span class="n">x</span><span class="p">:</span> <span class="kt">u32</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="kt">u32</span><span class="p">,</span>

    <span class="c">// This function "init" creates a Point and returns it.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">init</span><span class="p">()</span> <span class="n">Point</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Point</span><span class="p">{</span> <span class="p">.</span><span class="py">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="py">y</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="p">}</span>
<span class="p">};</span>


<span class="c">// How to access a structure public constant.</span>
<span class="c">// The value isn't accessed from an "instance" of the structure, but from the</span>
<span class="c">// constant representing the structure definition (Point).</span>
<span class="n">print</span><span class="p">(</span><span class="s">"constant: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">.</span><span class="p">{</span><span class="n">Point</span><span class="p">.</span><span class="py">some_constant</span><span class="p">});</span>

<span class="c">// Having an "init" function is rather idiomatic in the standard library.</span>
<span class="c">// More on that later.</span>
<span class="k">var</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">.</span><span class="nf">init</span><span class="p">();</span>
<span class="n">print</span><span class="p">(</span><span class="s">"p.x: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">.</span><span class="p">{</span><span class="n">p</span><span class="p">.</span><span class="py">x</span><span class="p">});</span> <span class="c">// p.x = 0</span>
<span class="n">print</span><span class="p">(</span><span class="s">"p.y: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">.</span><span class="p">{</span><span class="n">p</span><span class="p">.</span><span class="py">y</span><span class="p">});</span> <span class="c">// p.y = 0</span>


<span class="c">// Structures often have functions to modify their state, similar to</span>
<span class="c">// object-oriented programming.</span>
<span class="k">const</span> <span class="n">Point</span> <span class="o">=</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">Self</span> <span class="o">=</span> <span class="nb">@This</span><span class="p">();</span> <span class="c">// Refers to its own type (later called "Point").</span>

    <span class="n">x</span><span class="p">:</span> <span class="kt">u32</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="kt">u32</span><span class="p">,</span>

    <span class="c">// Take a look at the signature. First argument is of type *Self: "self" is</span>
    <span class="c">// a pointer on the instance of the structure.</span>
    <span class="c">// This allows the same "dot" notation as in OOP, like "instance.set(x,y)".</span>
    <span class="c">// See the following example.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">set</span><span class="p">(</span><span class="n">self</span><span class="p">:</span> <span class="o">*</span><span class="n">Self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="kt">u32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="kt">u32</span><span class="p">)</span> <span class="k">void</span> <span class="p">{</span>
        <span class="n">self</span><span class="p">.</span><span class="py">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">self</span><span class="p">.</span><span class="py">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c">// Again, look at the signature. First argument is of type Self (not *Self),</span>
    <span class="c">// this isn't a pointer. In this case, "self" refers to the instance of the</span>
    <span class="c">// structure, but can't be modified.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">getx</span><span class="p">(</span><span class="n">self</span><span class="p">:</span> <span class="n">Self</span><span class="p">)</span> <span class="kt">u32</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="py">x</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c">// PS: two previous functions may be somewhat useless.</span>
    <span class="c">//     Attributes can be changed directly, no need for accessor functions.</span>
    <span class="c">//     It was just an example.</span>
<span class="p">};</span>

<span class="c">// Let's use the previous structure.</span>
<span class="k">var</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">{</span> <span class="p">.</span><span class="py">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="py">y</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">};</span> <span class="c">// "p" variable is a Point.</span>

<span class="n">p</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span> <span class="c">// x and y attributes of "p" are modified via the "set" function.</span>
<span class="n">print</span><span class="p">(</span><span class="s">"p.x: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">.</span><span class="p">{</span><span class="n">p</span><span class="p">.</span><span class="py">x</span><span class="p">});</span> <span class="c">// 10</span>
<span class="n">print</span><span class="p">(</span><span class="s">"p.y: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">.</span><span class="p">{</span><span class="n">p</span><span class="p">.</span><span class="py">y</span><span class="p">});</span> <span class="c">// 30</span>

<span class="c">// In C:</span>
<span class="c">//   1. We would have written something like: point_set(p, 10, 30).</span>
<span class="c">//   2. Since all functions are in the same namespace, it would have been</span>
<span class="c">//      very cumbersome to create functions with different names for different</span>
<span class="c">//      structures. Many long names, painful to read.</span>
<span class="c">//</span>
<span class="c">// In Zig, structures provide namespaces for their own functions.</span>
<span class="c">// Different structures can have the same names for their functions,</span>
<span class="c">// which brings clarity.</span>
</code></pre></div>
<h3>Tuples.</h3>
<div class="highlight"><pre class="highlight zig"><code><span class="c">// A tuple is a list of elements, possibly of different types.</span>

<span class="k">const</span> <span class="n">foo</span> <span class="o">=</span> <span class="o">.</span><span class="p">{</span> <span class="s">"hello"</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">42</span> <span class="p">};</span>
<span class="c">// foo.len == 3</span>
</code></pre></div>
<h3>Enumerations.</h3>
<div class="highlight"><pre class="highlight zig"><code><span class="k">const</span> <span class="n">Type</span> <span class="o">=</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">ok</span><span class="p">,</span> <span class="n">not_ok</span> <span class="p">};</span>

<span class="k">const</span> <span class="n">CardinalDirections</span> <span class="o">=</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">North</span><span class="p">,</span> <span class="n">South</span><span class="p">,</span> <span class="n">East</span><span class="p">,</span> <span class="n">West</span> <span class="p">};</span>
<span class="k">const</span> <span class="n">direction</span><span class="p">:</span> <span class="n">CardinalDirections</span> <span class="o">=</span> <span class="p">.</span><span class="py">North</span><span class="p">;</span>
<span class="k">const</span> <span class="n">x</span> <span class="o">=</span> <span class="k">switch</span> <span class="p">(</span><span class="n">direction</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// shorthand for CardinalDirections.North</span>
    <span class="p">.</span><span class="py">North</span> <span class="o">=&gt;</span> <span class="kc">true</span><span class="p">,</span>
    <span class="k">else</span> <span class="o">=&gt;</span> <span class="kc">false</span>
<span class="p">};</span>

<span class="c">// Switch statements need exhaustiveness.</span>
<span class="c">// WARNING: won't compile. East and West are missing.</span>
<span class="k">const</span> <span class="n">x</span> <span class="o">=</span> <span class="k">switch</span> <span class="p">(</span><span class="n">direction</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">.</span><span class="py">North</span> <span class="o">=&gt;</span> <span class="kc">true</span><span class="p">,</span>
    <span class="p">.</span><span class="py">South</span> <span class="o">=&gt;</span> <span class="kc">true</span><span class="p">,</span>
<span class="p">};</span>


<span class="c">// Switch statements need exhaustiveness.</span>
<span class="c">// Won't compile: East and West are missing.</span>
<span class="k">const</span> <span class="n">x</span> <span class="o">=</span> <span class="k">switch</span> <span class="p">(</span><span class="n">direction</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">.</span><span class="py">North</span> <span class="o">=&gt;</span> <span class="kc">true</span><span class="p">,</span>
    <span class="p">.</span><span class="py">South</span> <span class="o">=&gt;</span> <span class="kc">true</span><span class="p">,</span>
    <span class="p">.</span><span class="py">East</span><span class="p">,</span>          <span class="c">// Its value is the same as the following pattern: false.</span>
    <span class="p">.</span><span class="py">West</span> <span class="o">=&gt;</span> <span class="kc">false</span><span class="p">,</span>
<span class="p">};</span>


<span class="c">// Enumerations are like structures: they can have functions.</span>
</code></pre></div>
<h3>Unions.</h3>
<div class="highlight"><pre class="highlight zig"><code><span class="k">const</span> <span class="n">Bar</span> <span class="o">=</span> <span class="k">union</span> <span class="p">{</span>
    <span class="n">boolean</span><span class="p">:</span> <span class="k">bool</span><span class="p">,</span>
    <span class="n">int</span><span class="p">:</span> <span class="kt">i16</span><span class="p">,</span>
    <span class="n">float</span><span class="p">:</span> <span class="kt">f32</span><span class="p">,</span>
<span class="p">};</span>

<span class="c">// Both syntaxes are equivalent.</span>
<span class="k">const</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">{</span> <span class="p">.</span><span class="py">int</span> <span class="o">=</span> <span class="mi">42</span> <span class="p">};</span>
<span class="k">const</span> <span class="n">foo</span><span class="p">:</span> <span class="n">Bar</span> <span class="o">=</span> <span class="o">.</span><span class="p">{</span> <span class="p">.</span><span class="py">int</span> <span class="o">=</span> <span class="mi">42</span> <span class="p">};</span>

<span class="c">// Unions, like enumerations and structures, can have functions.</span>
</code></pre></div>
<h3>Tagged unions.</h3>
<div class="highlight"><pre class="highlight zig"><code><span class="c">// Unions can be declared with an enum tag type, allowing them to be used in</span>
<span class="c">// switch expressions.</span>

<span class="k">const</span> <span class="n">MaybeEnum</span> <span class="o">=</span> <span class="k">enum</span> <span class="p">{</span>
    <span class="n">success</span><span class="p">,</span>
    <span class="n">failure</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="n">Maybe</span> <span class="o">=</span> <span class="k">union</span><span class="p">(</span><span class="n">MaybeEnum</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">success</span><span class="p">:</span> <span class="kt">u8</span><span class="p">,</span>
    <span class="n">failure</span><span class="p">:</span> <span class="p">[]</span><span class="k">const</span> <span class="kt">u8</span><span class="p">,</span>
<span class="p">};</span>

<span class="c">// First value: success!</span>
<span class="k">const</span> <span class="n">yay</span> <span class="o">=</span> <span class="n">Maybe</span><span class="p">{</span> <span class="p">.</span><span class="py">success</span> <span class="o">=</span> <span class="mi">42</span> <span class="p">};</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">yay</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">.</span><span class="py">success</span> <span class="o">=&gt;</span> <span class="p">|</span><span class="n">value</span><span class="p">|</span>     <span class="n">std</span><span class="p">.</span><span class="py">log</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s">"success: {}"</span><span class="p">,</span> <span class="o">.</span><span class="p">{</span><span class="n">value</span><span class="p">}),</span>
    <span class="p">.</span><span class="py">failure</span> <span class="o">=&gt;</span> <span class="p">|</span><span class="n">err_msg</span><span class="p">|</span>   <span class="n">std</span><span class="p">.</span><span class="py">log</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s">"failure: {}"</span><span class="p">,</span> <span class="o">.</span><span class="p">{</span><span class="n">err_msg</span><span class="p">}),</span>
<span class="p">}</span>

<span class="c">// Second value: failure! :(</span>
<span class="k">const</span> <span class="n">nay</span> <span class="o">=</span> <span class="n">Maybe</span><span class="p">{</span> <span class="p">.</span><span class="py">failure</span> <span class="o">=</span> <span class="s">"I was too lazy"</span> <span class="p">};</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">nay</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">.</span><span class="py">success</span> <span class="o">=&gt;</span> <span class="p">|</span><span class="n">value</span><span class="p">|</span>     <span class="n">std</span><span class="p">.</span><span class="py">log</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s">"success: {}"</span><span class="p">,</span> <span class="o">.</span><span class="p">{</span><span class="n">value</span><span class="p">}),</span>
    <span class="p">.</span><span class="py">failure</span> <span class="o">=&gt;</span> <span class="p">|</span><span class="n">err_msg</span><span class="p">|</span>   <span class="n">std</span><span class="p">.</span><span class="py">log</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s">"failure: {}"</span><span class="p">,</span> <span class="o">.</span><span class="p">{</span><span class="n">err_msg</span><span class="p">}),</span>
<span class="p">}</span>
</code></pre></div>
<h3>Defer and errdefer.</h3>
<div class="highlight"><pre class="highlight zig"><code><span class="c">// Make sure that an action (single instruction or block of code) is executed</span>
<span class="c">// before the end of the scope (function, block of code).</span>
<span class="c">// Even on error, that action will be executed.</span>
<span class="c">// Useful for memory allocations, and resource management in general.</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="k">void</span> <span class="p">{</span>
    <span class="c">// Should be executed at the end of the function.</span>
    <span class="k">defer</span> <span class="n">print</span><span class="p">(</span><span class="s">"third!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">.</span><span class="p">{});</span>

    <span class="p">{</span>
        <span class="c">// Last element of its scope: will be executed right away.</span>
        <span class="k">defer</span> <span class="n">print</span><span class="p">(</span><span class="s">"first!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">.</span><span class="p">{});</span>
    <span class="p">}</span>

    <span class="n">print</span><span class="p">(</span><span class="s">"second!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">.</span><span class="p">{});</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">hello_world</span><span class="p">()</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="n">print</span><span class="p">(</span><span class="s">"end of function</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">.</span><span class="p">{});</span> <span class="c">// after "hello world!"</span>

    <span class="n">print</span><span class="p">(</span><span class="s">"hello world!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">.</span><span class="p">{});</span>
<span class="p">}</span>

<span class="c">// errdefer executes the instruction (or block of code) only on error.</span>
<span class="k">fn</span> <span class="n">second_hello_world</span><span class="p">()</span> <span class="o">!</span><span class="k">void</span> <span class="p">{</span>
    <span class="k">errdefer</span> <span class="n">print</span><span class="p">(</span><span class="s">"2. something went wrong!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">.</span><span class="p">{});</span> <span class="c">// if "foo" fails.</span>
    <span class="k">defer</span>    <span class="n">print</span><span class="p">(</span><span class="s">"1. second hello world</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">.</span><span class="p">{});</span>    <span class="c">// executed after "foo"</span>

    <span class="k">try</span> <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
<span class="c">// Defer statements can be seen as stacked: first one is executed last.</span>
</code></pre></div>
<h3>Memory allocators.</h3>

<p>Memory isn&rsquo;t managed directly in the standard library, instead an &ldquo;allocator&rdquo; is asked every time an operation on memory is required.
Thus, the standard library lets developers handle memory as they need, through structures called &ldquo;allocators&rdquo;, handling all memory operations.</p>

<p><strong>NOTE</strong>: the choice of the allocator isn&rsquo;t in the scope of this document.
A whole book could be written about it.
However, here are some examples, to get an idea of what you can expect:
- <code>page_allocator</code>.
  Allocate a whole page of memory each time we ask for some memory.
  Very simple, very dumb, very wasteful.
- <code>GeneralPurposeAllocator</code>.
  Get some memory first and manage some buckets of memory in order to
  reduce the number of allocations.
  A bit complex. Can be combined with other allocators.
  Can detect leaks and provide useful information to find them.
- <code>FixedBufferAllocator</code>.
  Use a fixed buffer to get its memory, don&rsquo;t ask memory to the kernel.
  Very simple, limited and wasteful (can&rsquo;t deallocate), but very fast.
- <code>ArenaAllocator</code>.
  Allow to free all allocated memory at once.
  To use in combinations with another allocator.
  Very simple way of avoiding leaks.</p>

<p>A first example.</p>
<div class="highlight"><pre class="highlight zig"><code><span class="c">// "!void" means the function doesn't return any value except for errors.</span>
<span class="c">// In this case we try to allocate memory, and this may fail.</span>
<span class="k">fn</span> <span class="n">foo</span><span class="p">()</span> <span class="o">!</span><span class="k">void</span> <span class="p">{</span>
    <span class="c">// In this example we use a page allocator.</span>
    <span class="k">var</span> <span class="n">allocator</span> <span class="o">=</span> <span class="n">std</span><span class="p">.</span><span class="py">heap</span><span class="p">.</span><span class="py">page_allocator</span><span class="p">;</span>

    <span class="c">// "list" is an ArrayList of 8-bit unsigned integers.</span>
    <span class="c">// An ArrayList is a contiguous, growable list of elements in memory.</span>
    <span class="k">var</span> <span class="n">list</span> <span class="o">=</span> <span class="k">try</span> <span class="n">ArrayList</span><span class="p">(</span><span class="kt">u8</span><span class="p">).</span><span class="nf">initAllocated</span><span class="p">(</span><span class="n">allocator</span><span class="p">);</span>
    <span class="k">defer</span> <span class="n">list</span><span class="p">.</span><span class="nf">deinit</span><span class="p">();</span> <span class="c">// Free the memory at the end of the scope. Can't leak.</span>
    <span class="c">// "defer" allows to express memory release right after its allocation,</span>
    <span class="c">// regardless of the complexity of the function (loops, conditions, etc.).</span>

    <span class="n">list</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c">// Some memory is allocated here, with the provided allocator.</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">list</span><span class="p">.</span><span class="py">items</span><span class="p">)</span> <span class="p">|</span><span class="n">item</span><span class="p">|</span> <span class="p">{</span>
        <span class="n">std</span><span class="p">.</span><span class="py">debug</span><span class="p">.</span><span class="nf">print</span><span class="p">(</span><span class="s">"item: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">.</span><span class="p">{</span><span class="n">item</span><span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3>Memory allocation combined with error management and defer.</h3>
<div class="highlight"><pre class="highlight zig"><code><span class="k">fn</span> <span class="n">some_memory_allocation_example</span><span class="p">()</span> <span class="o">!</span><span class="k">void</span> <span class="p">{</span>
    <span class="c">// Memory allocation may fail, so we "try" to allocate the memory and</span>
    <span class="c">// in case there is an error, the current function returns it.</span>
    <span class="k">var</span> <span class="n">buf</span> <span class="o">=</span> <span class="k">try</span> <span class="n">page_allocator</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
    <span class="c">// Defer memory release right after the allocation.</span>
    <span class="c">// Will happen even if an error occurs.</span>
    <span class="k">defer</span> <span class="n">page_allocator</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

    <span class="c">// Second allocation.</span>
    <span class="c">// In case of a failure, the first allocation is correctly released.</span>
    <span class="k">var</span> <span class="n">buf2</span> <span class="o">=</span> <span class="k">try</span> <span class="n">page_allocator</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
    <span class="k">defer</span> <span class="n">page_allocator</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span><span class="n">buf2</span><span class="p">);</span>

    <span class="c">// In case of failure, both previous allocations are correctly deallocated.</span>
    <span class="k">try</span> <span class="n">foo</span><span class="p">();</span>
    <span class="k">try</span> <span class="n">bar</span><span class="p">();</span>

    <span class="c">// ...</span>
<span class="p">}</span>
</code></pre></div>
<h3>Memory allocators: a taste of the standard library.</h3>
<div class="highlight"><pre class="highlight zig"><code><span class="c">// Allocators: 4 main functions to know</span>
<span class="c">//   single_value = create (type)</span>
<span class="c">//   destroy (single_value)</span>
<span class="c">//   slice = alloc (type, size)</span>
<span class="c">//   free (slice)</span>

<span class="c">// Page Allocator</span>
<span class="k">fn</span> <span class="n">page_allocator_fn</span><span class="p">()</span> <span class="o">!</span><span class="k">void</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">slice</span> <span class="o">=</span> <span class="k">try</span> <span class="n">std</span><span class="p">.</span><span class="py">heap</span><span class="p">.</span><span class="py">page_allocator</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="k">defer</span> <span class="n">std</span><span class="p">.</span><span class="py">heap</span><span class="p">.</span><span class="py">page_allocator</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span><span class="n">slice</span><span class="p">);</span>

    <span class="c">// playing_with_a_slice(slice);</span>
<span class="p">}</span>

<span class="c">// GeneralPurposeAllocator</span>
<span class="k">fn</span> <span class="n">general_purpose_allocator_fn</span><span class="p">()</span> <span class="o">!</span><span class="k">void</span> <span class="p">{</span>
    <span class="c">// GeneralPurposeAllocator has to be configured.</span>
    <span class="c">// In this case, we want to track down memory leaks.</span>
    <span class="k">const</span> <span class="n">config</span> <span class="o">=</span> <span class="o">.</span><span class="p">{.</span><span class="py">safety</span> <span class="o">=</span> <span class="kc">true</span><span class="p">};</span>
    <span class="k">var</span> <span class="n">gpa</span> <span class="o">=</span> <span class="n">std</span><span class="p">.</span><span class="py">heap</span><span class="p">.</span><span class="nf">GeneralPurposeAllocator</span><span class="p">(</span><span class="n">config</span><span class="p">){};</span>
    <span class="k">defer</span> <span class="mi">_</span> <span class="o">=</span> <span class="n">gpa</span><span class="p">.</span><span class="nf">deinit</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">allocator</span> <span class="o">=</span> <span class="n">gpa</span><span class="p">.</span><span class="nf">allocator</span><span class="p">();</span>

    <span class="k">var</span> <span class="n">slice</span> <span class="o">=</span> <span class="k">try</span> <span class="n">allocator</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="k">defer</span> <span class="n">allocator</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span><span class="n">slice</span><span class="p">);</span>

    <span class="c">// playing_with_a_slice(slice);</span>
<span class="p">}</span>

<span class="c">// FixedBufferAllocator</span>
<span class="k">fn</span> <span class="n">fixed_buffer_allocator_fn</span><span class="p">()</span> <span class="o">!</span><span class="k">void</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">buffer</span> <span class="o">=</span> <span class="p">[</span><span class="mi">_</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="mi">0</span><span class="p">}</span> <span class="o">**</span> <span class="mi">1000</span><span class="p">;</span> <span class="c">// array of 1000 u8, all initialized at zero.</span>
    <span class="k">var</span> <span class="n">fba</span>  <span class="o">=</span> <span class="n">std</span><span class="p">.</span><span class="py">heap</span><span class="p">.</span><span class="py">FixedBufferAllocator</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">]);</span>
    <span class="c">// Side note: buffer[0..] is a way to create a slice from an array.</span>
    <span class="c">//            Since the function takes a slice and not an array, this makes</span>
    <span class="c">//            the type system happy.</span>

    <span class="k">var</span> <span class="n">allocator</span> <span class="o">=</span> <span class="n">fba</span><span class="p">.</span><span class="nf">allocator</span><span class="p">();</span>

    <span class="k">var</span> <span class="n">slice</span> <span class="o">=</span> <span class="k">try</span> <span class="n">allocator</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="c">// No need for "free", memory cannot be freed with a fixed buffer allocator.</span>
    <span class="c">// defer allocator.free(slice);</span>

    <span class="c">// playing_with_a_slice(slice);</span>
<span class="p">}</span>

<span class="c">// ArenaAllocator</span>
<span class="k">fn</span> <span class="n">arena_allocator_fn</span><span class="p">()</span> <span class="o">!</span><span class="k">void</span> <span class="p">{</span>
    <span class="c">// Reminder: arena doesn't allocate memory, it uses an inner allocator.</span>
    <span class="c">// In this case, we combine the arena allocator with the page allocator.</span>
    <span class="k">var</span> <span class="n">arena</span> <span class="o">=</span> <span class="n">std</span><span class="p">.</span><span class="py">heap</span><span class="p">.</span><span class="py">arena_allocator</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="n">std</span><span class="p">.</span><span class="py">heap</span><span class="p">.</span><span class="py">page_allocator</span><span class="p">);</span>
    <span class="k">defer</span> <span class="n">arena</span><span class="p">.</span><span class="nf">deinit</span><span class="p">();</span> <span class="c">// end of function = all allocations are freed.</span>

    <span class="k">var</span> <span class="n">allocator</span> <span class="o">=</span> <span class="n">arena</span><span class="p">.</span><span class="nf">allocator</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">slice</span> <span class="o">=</span> <span class="k">try</span> <span class="n">allocator</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="c">// No need for "free", memory will be freed anyway.</span>

    <span class="c">// playing_with_a_slice(slice);</span>
<span class="p">}</span>


<span class="c">// Combining the general purpose and arena allocators. Both are very useful,</span>
<span class="c">// and their combinations should be in everyone's favorite cookbook.</span>
<span class="k">fn</span> <span class="n">gpa_arena_allocator_fn</span><span class="p">()</span> <span class="o">!</span><span class="k">void</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">config</span> <span class="o">=</span> <span class="o">.</span><span class="p">{.</span><span class="py">safety</span> <span class="o">=</span> <span class="kc">true</span><span class="p">};</span>
    <span class="k">var</span> <span class="n">gpa</span> <span class="o">=</span> <span class="n">std</span><span class="p">.</span><span class="py">heap</span><span class="p">.</span><span class="nf">GeneralPurposeAllocator</span><span class="p">(</span><span class="n">config</span><span class="p">){};</span>
    <span class="k">defer</span> <span class="mi">_</span> <span class="o">=</span> <span class="n">gpa</span><span class="p">.</span><span class="nf">deinit</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">gpa_allocator</span> <span class="o">=</span> <span class="n">gpa</span><span class="p">.</span><span class="nf">allocator</span><span class="p">();</span>

    <span class="k">var</span> <span class="n">arena</span> <span class="o">=</span> <span class="n">arena_allocator</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="n">gpa_allocator</span><span class="p">);</span>
    <span class="k">defer</span> <span class="n">arena</span><span class="p">.</span><span class="nf">deinit</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">allocator</span> <span class="o">=</span> <span class="n">arena</span><span class="p">.</span><span class="nf">allocator</span><span class="p">();</span>

    <span class="k">var</span> <span class="n">slice</span> <span class="o">=</span> <span class="k">try</span> <span class="n">allocator</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="k">defer</span> <span class="n">allocator</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span><span class="n">slice</span><span class="p">);</span>

    <span class="c">// playing_with_a_slice(slice);</span>
<span class="p">}</span>
</code></pre></div>
<h3>Comptime.</h3>
<div class="highlight"><pre class="highlight zig"><code><span class="c">// Comptime is a way to avoid the pre-processor.</span>
<span class="c">// The idea is simple: run code at compilation.</span>

<span class="k">inline</span> <span class="k">fn</span> <span class="n">max</span><span class="p">(</span><span class="k">comptime</span> <span class="n">T</span><span class="p">:</span> <span class="k">type</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="n">T</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">var</span> <span class="n">res</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="kt">u64</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="k">var</span> <span class="n">res</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="kt">f32</span><span class="p">,</span> <span class="mf">10.50</span><span class="p">,</span> <span class="mf">32.19</span><span class="p">);</span>


<span class="c">// Comptime: creating generic structures.</span>

<span class="k">fn</span> <span class="n">List</span><span class="p">(</span><span class="k">comptime</span> <span class="n">T</span><span class="p">:</span> <span class="k">type</span><span class="p">)</span> <span class="k">type</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="n">items</span><span class="p">:</span> <span class="p">[]</span><span class="n">T</span><span class="p">,</span>

        <span class="k">fn</span> <span class="n">init</span><span class="p">()</span>   <span class="o">...</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
        <span class="k">fn</span> <span class="n">deinit</span><span class="p">()</span> <span class="o">...</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
        <span class="k">fn</span> <span class="n">do</span><span class="p">()</span>     <span class="o">...</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">MyList</span> <span class="o">=</span> <span class="n">List</span><span class="p">(</span><span class="kt">u8</span><span class="p">);</span>


<span class="c">// use</span>
<span class="k">var</span> <span class="n">list</span> <span class="o">=</span> <span class="n">MyList</span><span class="p">{</span>
    <span class="p">.</span><span class="py">items</span> <span class="o">=</span> <span class="o">...</span> <span class="c">// memory allocation</span>
<span class="p">};</span>

<span class="n">list</span><span class="p">.</span><span class="py">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</code></pre></div>
<h3>Conditional compilation.</h3>
<div class="highlight"><pre class="highlight zig"><code><span class="k">const</span> <span class="n">available_os</span> <span class="o">=</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">OpenBSD</span><span class="p">,</span> <span class="n">Linux</span> <span class="p">};</span>
<span class="k">const</span> <span class="n">myos</span> <span class="o">=</span> <span class="n">available_os</span><span class="p">.</span><span class="py">OpenBSD</span><span class="p">;</span>


<span class="c">// The following switch is based on a constant value.</span>
<span class="c">// This means that the only possible outcome is known at compile-time.</span>
<span class="c">// Thus, there is no need to build the rest of the possibilities.</span>
<span class="c">// Similar to the "#ifdef" in C, but without requiring a pre-processor.</span>
<span class="k">const</span> <span class="n">string</span> <span class="o">=</span> <span class="k">switch</span> <span class="p">(</span><span class="n">myos</span><span class="p">)</span> <span class="p">{</span>
   <span class="p">.</span><span class="py">OpenBSD</span> <span class="o">=&gt;</span> <span class="s">"OpenBSD is awesome!"</span><span class="p">,</span>
   <span class="p">.</span><span class="py">Linux</span> <span class="o">=&gt;</span> <span class="s">"Linux rocks!"</span><span class="p">,</span>
<span class="p">};</span>

<span class="c">// Also works in this case.</span>
<span class="k">const</span> <span class="n">myprint</span> <span class="o">=</span> <span class="k">switch</span><span class="p">(</span><span class="n">myos</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">.</span><span class="py">OpenBSD</span> <span class="o">=&gt;</span> <span class="n">std</span><span class="p">.</span><span class="py">debug</span><span class="p">.</span><span class="py">print</span><span class="p">,</span>
    <span class="p">.</span><span class="py">Linux</span> <span class="o">=&gt;</span> <span class="n">std</span><span class="p">.</span><span class="py">log</span><span class="p">.</span><span class="py">info</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>
<h3>Testing our functions.</h3>
<div class="highlight"><pre class="highlight zig"><code><span class="k">const</span> <span class="n">std</span> <span class="o">=</span> <span class="nb">@import</span><span class="p">(</span><span class="s">"std"</span><span class="p">);</span>
<span class="k">const</span> <span class="n">expect</span> <span class="o">=</span> <span class="n">std</span><span class="p">.</span><span class="py">testing</span><span class="p">.</span><span class="py">expect</span><span class="p">;</span>

<span class="c">// Function to test.</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="n">some_function</span><span class="p">()</span> <span class="k">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">// This "test" block can be run with "zig test".</span>
<span class="c">// It will test the function at compile-time.</span>
<span class="k">test</span> <span class="s">"returns true"</span> <span class="p">{</span>
    <span class="n">expect</span><span class="p">(</span><span class="kc">false</span> <span class="o">==</span> <span class="n">some_function</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div>
<h3>Compiler built-ins.</h3>

<p>The compiler has special functions called &ldquo;built-ins&rdquo;, starting with an &ldquo;@&rdquo;.
There are more than a hundred built-ins, allowing very low-level stuff:
- compile-time errors, logging, verifications
- type coercion and conversion, even in an unsafe way
- alignment management
- memory tricks (such as getting the byte offset of a field in a struct)
- calling functions at compile-time
- including C headers to transparently call C functions
- atomic operations
- embed files into the executable (@embedFile)
- frame manipulations (for async functions, for example)
- etc.</p>

<p>Example: enums aren&rsquo;t integers, they have to be converted with a built-in.</p>
<div class="highlight"><pre class="highlight zig"><code><span class="k">const</span> <span class="n">Value</span> <span class="o">=</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">zero</span><span class="p">,</span> <span class="n">stuff</span><span class="p">,</span> <span class="n">blah</span> <span class="p">};</span>
<span class="k">if</span> <span class="p">(</span><span class="nb">@enumToInt</span><span class="p">(</span><span class="n">Value</span><span class="p">.</span><span class="py">zero</span><span class="p">)</span>  <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="nb">@enumToInt</span><span class="p">(</span><span class="n">Value</span><span class="p">.</span><span class="py">stuff</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="nb">@enumToInt</span><span class="p">(</span><span class="n">Value</span><span class="p">.</span><span class="py">blah</span><span class="p">)</span>  <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div>
<h3>A few &ldquo;not yourself in the foot&rdquo; measures in the Zig language.</h3>

<ul>
<li>Namespaces: name conflicts are easily avoided.
In practice, that means a unified API between different structures (data types).</li>
<li>Enumerations aren&rsquo;t integers. Comparing an enumeration to an integer requires a conversion.</li>
<li>Explicit casts, coercion exists but is limited.
Types are slightly more enforced than in C, just a taste:
Pointers aren&rsquo;t integers, explicit conversion is necessary.
You won&rsquo;t lose precision by accident, implicit coercions are only authorized in cases where no precision can be lost.
Unions cannot be reinterpreted (in a union with an integer and a float, one cannot take a value for another by accident).
Etc.</li>
<li>Removing most of the C undefined behaviors (UBs), and when the compiler encounters one, it stops.</li>
<li>Slice and Array structures are preferred to pointers.
Types enforced by the compiler are less prone to errors than pointer manipulations.</li>
<li>Numerical overflows produce an error, unless explicitly accepted using wrapping operators.</li>
<li><code>try</code> and <code>catch</code> mechanism.
It&rsquo;s both handy, trivially implemented (simple error enumeration), and it takes almost no space nor computation time.</li>
<li>Unused variables are considered to be errors by the compiler.</li>
<li>Many pointer types exist in order to represent what is pointed to.
Example: is this a single value or an array, is the length known, etc.</li>
<li>Structures need a value for their attributes, and it is still possible to give an undefined value (stack garbage), but at least it is explicitly undefined.</li>
</ul>

<h2>Further Reading</h2>

<p>For a start, some concepts are presented on <a href="https://zig.guide/">zig.guide</a>.</p>

<p>The <a href="https://ziglang.org/documentation/">official website</a> provides the reference documentation of the language. The standard library <a href="https://ziglang.org/documentation/master/std/">has its own documentation</a>.</p>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/zig.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by Philippe Pittoli, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/zig.html.markdown">3 contributor(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="https://karchnu.fr/">Philippe Pittoli</a>
    </p>

    <p>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
