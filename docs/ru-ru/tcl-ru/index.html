<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="ru-ru" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="ru-ru" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="ru-ru" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="ru-ru" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="ru-ru">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Tcl in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/ru-ru/tcl-ru/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fru-ru%2Ftcl-ru%2F&text=%D0%98%D0%B7%D1%83%D1%87%D0%B8%D1%82%D0%B5+X+%D0%B7%D0%B0+Y+%D0%BC%D0%B8%D0%BD%D1%83%D1%82%2C+%D0%B3%D0%B4%D0%B5+X%3DTcl">
        Поделиться страницей
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Выберите тему:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">светлая</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">тёмная</button>
  </div>
  <h1><a href="/">Изучите X за Y минут</a></h1>
  <h2>Где X=Tcl</h2>
    <p class="filelink">
    Получить исходный код:
    <a href="/docs/files/learntcl-ru.tcl">learntcl-ru.tcl</a>
    </p>
  <div id="doc">
    <p>Tcl был создан <a href="https://ru.wikipedia.org/wiki/Оустерхаут,_Джон">Джоном Оустерхаутом</a>
в качестве скриптового языка в своих инструментах проектирования электрических цепей.
В 1997 году за разработку языка Tcl автор получил <a href="https://ru.wikipedia.org/wiki/ACM">ACM</a>
 Software System Award. Tcl может использоваться и как встраиваемый скриптовый язык,
и как язык программирования общего назначения. Кроме того, он может быть использован как
библиотека в программах на C, даже в случаях когда не требуется написание скриптов,
поскольку Tcl может предоставить программе на C различные типы данных, такие как
динамические строки, списки и хэш-таблицы. Также с помощью этой библиотеки возможно
использовать форматирование строк, операции с файловой системой, работу с кодировками и
динамически загружаемые библиотеки. К другим особенностям Tcl относятся:</p>

<ul>
<li><p>Удобный кроссплатформенный API для работы с сетью</p></li>
<li><p>Поддержка виртуальной файловой системы (VFS)</p></li>
<li><p>Стекируемые каналы ввода-вывода</p></li>
<li><p>Асинхронность в ядре языка</p></li>
<li><p>Поддержка корутин</p></li>
<li><p>Простая и надёжная модель потоков выполнения</p></li>
</ul>

<p>Tcl имеет много общего с Lisp, но в отличие от списков, в Tcl &ldquo;валютой&rdquo; языка
являются строки. Все значения являются строками. Список в Tcl это просто строка в
определённом формате, а тело процедуры (скрипт) это ещё одна строка, а не блок.
С целью увеличения производительности, интерпретатор Tcl использует кэшированные
внутренние представления различных типов данных. Например, рутины (routines), работающие
со списками, фактически используют внутреннее представление списков, а интерпретатор
Tcl обновляет строковое представление в том случае если оно используется в скрипте.
В Tcl используется подход copy-on-write, позволяющий оперировать большими объёмами
данных без дополнительного оверхеда. Процедуры в Tcl автоматически компилируются
в байткод, кроме случаев когда в процедуре используются динамические рутины, такие
как <code>uplevel</code>, <code>upvar</code> и <code>trace</code>.</p>

<p>Программировать на Tcl приятно. Его находят привлекательным хакеры, которым интересны
Lisp, Forth или Smalltalk, а также инженеры и учёные, которым просто необходим
гибкий инструмент для выполнения их задач. В Tcl языковые конструкции, включая
циклы и математические операторы, представлены в виде изменяемых рутин, в отличие
от других языков программирования, где они закреплены в синтаксисе, что позволяет
синтаксису Tcl не мешать работать с предметной областью проекта. Синтаксис Tcl в этом
смысле даже более минималистичен чем у Lisp.</p>
<div class="highlight"><pre><span></span><span class="c">#! /bin/env tclsh</span>

<span class="c">###############################################################################</span>
<span class="c">## 1. Рекомендации</span>
<span class="c">###############################################################################</span>

<span class="c"># Tcl это не shell или C! Этот момент требует уточнения, поскольку привычки</span>
<span class="c"># написания shell-скриптов почти работают в Tcl и часто люди начинают</span>
<span class="c"># изучать Tcl со знанием синтаксиса других языков. Поначалу это работает, но</span>
<span class="c"># когда скрипты становятся сложнее, наступает фрустрация.</span>

<span class="c"># Фигурные скобки {} в Tcl используются не для построения блоков кода или</span>
<span class="c"># списков, а как механизм экранирования (quoting) для кода. Фактически в Tcl</span>
<span class="c"># нет ни списков, ни блоков кода. Фигурные скобки использутся для</span>
<span class="c"># экранирования специальных символов и потому подходят для представления</span>
<span class="c"># тела процедур и строк, которые должны интерпретироваться как списки.</span>


<span class="c">###############################################################################</span>
<span class="c">## 2. Синтаксис</span>
<span class="c">###############################################################################</span>

<span class="c"># Скрипт состоит из команд, разделённых символами перевода строки или символами</span>
<span class="c"># точки с запятой. Каждая команда представляет собой вызов рутины. Первое слово</span>
<span class="c"># это имя вызываемой рутины, а последующие слова это аргументы. Слова разделены</span>
<span class="c"># пробелами. Так как каждый аргумент это слово в команде, он является строкой и</span>
<span class="c"># может быть неэкранирован:</span>
<span class="k">set</span><span class="w"> </span>part1<span class="w"> </span>Sal
<span class="k">set</span><span class="w"> </span>part2<span class="w"> </span>ut<span class="k">;</span><span class="w"> </span><span class="k">set</span><span class="w"> </span>part3<span class="w"> </span>ations


<span class="c"># символ доллара используется для подставления значения переменных:</span>
<span class="k">set</span><span class="w"> </span>greeting<span class="w"> </span><span class="nv">$part1$part2$part3</span>


<span class="c"># Когда &quot;set&quot; получает только имя переменной, возвращается значение переменной:</span>
<span class="k">set</span><span class="w"> </span>part3<span class="w"> </span><span class="k">;</span><span class="c"># Возвращает значение переменной</span>


<span class="c"># Содержимое квадратных скобок заменяется на результат выполнения:</span>
<span class="k">set</span><span class="w"> </span>greeting<span class="w"> </span><span class="nv">$part1$part2</span><span class="k">[set</span><span class="w"> </span>part3<span class="k">]</span>


<span class="c"># Встроенный таким образов скрипт может состоять из нескольких команд, но</span>
<span class="c"># результат подстановки определяется последней командой:</span>
<span class="k">set</span><span class="w"> </span>greeting<span class="w"> </span><span class="nv">$greeting</span><span class="k">[</span>
<span class="w">    </span><span class="nb">incr</span><span class="w"> </span>i
<span class="w">    </span><span class="nb">incr</span><span class="w"> </span>i
<span class="w">    </span><span class="nb">incr</span><span class="w"> </span>i
<span class="k">]</span>
<span class="nb">puts</span><span class="w"> </span><span class="nv">$greeting</span><span class="w"> </span><span class="k">;</span><span class="c"># Выведет &quot;Salutations3&quot;</span>

<span class="c"># Каждое слово в команде является строкой, включая имя рутины, поэтому</span>
<span class="c"># подстановки могут быть использованы и таким образом:</span>
<span class="k">set</span><span class="w"> </span>action<span class="w"> </span>pu

<span class="c"># следующие команды эквивалентны:</span>
<span class="nb">puts</span><span class="w"> </span><span class="nv">$greeting</span>
<span class="nv">${action}ts</span><span class="w"> </span><span class="nv">$greeting</span>
<span class="k">[set</span><span class="w"> </span>action<span class="k">]</span><span class="nv">ts</span><span class="w"> </span><span class="nv">$greeting</span>


<span class="c"># Обратный слэш экранирует специальные символы:</span>
<span class="k">set</span><span class="w"> </span>amount<span class="w"> </span><span class="err">\</span><span class="nv">$16.42</span>


<span class="c"># и он же используется для ввода специальных символов:</span>
<span class="nb">puts</span><span class="w"> </span>lots<span class="err">\</span>nof<span class="err">\</span>n<span class="err">\</span>n<span class="err">\</span>n<span class="err">\</span>n<span class="err">\</span>n<span class="err">\</span>nnewlines


<span class="c"># Слово в фигурных скобках никак не интерпретируется и в нём не работают</span>
<span class="c"># никакие подстановки, за исключением экранирования закрывающей скобки:</span>
<span class="k">set</span><span class="w"> </span>somevar<span class="w"> </span><span class="k">{</span>
<span class="w">    </span><span class="nv">Это</span><span class="w"> </span>литерал<span class="w"> </span>знака<span class="w"> </span><span class="err">$</span>,<span class="w"> </span>а<span class="w"> </span>это<span class="w"> </span><span class="err">\</span><span class="k">}</span><span class="w"> </span>экранированная<span class="w"> </span>закрывающая<span class="w"> </span>скобка
<span class="k">}</span>


<span class="c"># В слове внутри двойных кавычек, пробельные символы теряют своё</span>
<span class="c"># специальное значение:</span>
<span class="k">set</span><span class="w"> </span>name<span class="w"> </span>Neo
<span class="k">set</span><span class="w"> </span>greeting<span class="w"> </span><span class="s2">&quot;Hello, $name&quot;</span>


<span class="c"># Имя переменной может быть любой строкой:</span>
<span class="k">set</span><span class="w"> </span><span class="k">{</span><span class="nv">first</span><span class="w"> </span>name<span class="k">}</span><span class="w"> </span>New


<span class="c"># Фигурные скобки используются для доступа к переменным с составными именами:</span>
<span class="k">set</span><span class="w"> </span>greeting<span class="w"> </span><span class="s2">&quot;Hello, ${first name}&quot;</span>


<span class="c"># &quot;set&quot; всегда можно использовать вместо подстановки переменной:</span>
<span class="k">set</span><span class="w"> </span>greeting<span class="w"> </span><span class="s2">&quot;Hello, [set {first name}]&quot;</span>


<span class="c"># Чтобы &quot;распаковать&quot; список в команду используется оператор расширения &quot;{*}&quot;</span>
<span class="c"># Эти две команды эквивалентны:</span>
<span class="k">set</span><span class="w"> </span>name<span class="w"> </span>Neo
<span class="k">set</span><span class="w"> </span><span class="k">{</span><span class="o">*</span><span class="k">}{</span><span class="nv">name</span><span class="w"> </span>Neo<span class="k">}</span>


<span class="c"># Массив это особая переменная, являющаяся контейнером для других переменных.</span>
<span class="k">set</span><span class="w"> </span>person<span class="k">(</span><span class="nv">name</span><span class="k">)</span><span class="w"> </span>Neo
<span class="k">set</span><span class="w"> </span>person<span class="k">(</span><span class="nv">destiny</span><span class="k">)</span><span class="w"> </span><span class="k">{</span><span class="nv">The</span><span class="w"> </span>One<span class="k">}</span>
<span class="k">set</span><span class="w"> </span>greeting<span class="w"> </span><span class="s2">&quot;Hello, $person(name)&quot;</span>


<span class="c"># &quot;variable&quot; может быть использована для объявления или установки переменных.</span>
<span class="c"># В отличие от &quot;set&quot;, которая использует глобальное и локальное пространство</span>
<span class="c"># имён, &quot;variable&quot; работает только с локальным пространством:</span>
<span class="k">variable</span><span class="w"> </span>name<span class="w"> </span>New


<span class="c"># &quot;namespace eval&quot; создаёт новое пространство имён, если его не существует.</span>
<span class="c"># Пространство имён может содержать рутины и переменные:</span>
<span class="k">namespace</span><span class="w"> </span>eval<span class="w"> </span>people<span class="w"> </span><span class="k">{</span>
<span class="w">    </span><span class="k">namespace</span><span class="w"> </span>eval<span class="w"> </span>person1<span class="w"> </span><span class="k">{</span>
<span class="w">        </span><span class="k">variable</span><span class="w"> </span>name<span class="w"> </span>Neo
<span class="w">    </span><span class="k">}</span>
<span class="k">}</span>


<span class="c"># Двумя или более двоеточиями в именах переменных отделяется название</span>
<span class="c"># пространства имён:</span>
<span class="k">namespace</span><span class="w"> </span>eval<span class="w"> </span>people<span class="w"> </span><span class="k">{</span>
<span class="w">    </span><span class="k">set</span><span class="w"> </span>greeting<span class="w"> </span><span class="s2">&quot;Hello $person1::name&quot;</span>
<span class="k">}</span>

<span class="c"># Два или более двоеточия также отделяют название пространства имён</span>
<span class="c"># в имени рутины:</span>
<span class="k">proc</span><span class="w"> </span>people::person1::speak<span class="w"> </span><span class="k">{}</span><span class="w"> </span><span class="k">{</span>
<span class="w">    </span><span class="nb">puts</span><span class="w"> </span><span class="k">{</span><span class="nv">I</span><span class="w"> </span>am<span class="w"> </span>The<span class="w"> </span>One.<span class="k">}</span>
<span class="k">}</span>

<span class="c"># Полные(fully-qualified) имена начинаются с двух двоеточий:</span>
<span class="k">set</span><span class="w"> </span>greeting<span class="w"> </span><span class="s2">&quot;Hello $::people::person1::name&quot;</span>



<span class="c">###############################################################################</span>
<span class="c">## 3. Больше никакого синтаксиса</span>
<span class="c">###############################################################################</span>

<span class="c"># Все остальные функции реализованы посредством рутин. С этого момента и далее</span>
<span class="c"># больше нет нового синтаксиса. Всё остальное что можно изучить о Tcl это</span>
<span class="c"># поведение отдельных рутин и какие значения они присваивают своим аргументам.</span>



<span class="c">###############################################################################</span>
<span class="c">## 4. Переменные и пространства имён</span>
<span class="c">###############################################################################</span>

<span class="c"># Каждая переменная и рутина связана с пространством имён.</span>

<span class="c"># Чтобы получить интерпретатор, который не может сделать ничего, достаточно</span>
<span class="c"># удалить глобальное пространство имён. Особой пользы в этом нет, но это хорошо</span>
<span class="c"># иллюстрирует природу Tcl. Фактически имя глобального пространства имён это</span>
<span class="c"># пустая строка, но единственный способ представить её -- в виде полного имени:</span>
<span class="k">proc</span><span class="w"> </span>delete_global_namespace<span class="w"> </span><span class="k">{}</span><span class="w"> </span><span class="k">{</span>
<span class="w">    </span><span class="k">namespace</span><span class="w"> </span>delete<span class="w"> </span><span class="o">::</span>
<span class="k">}</span>

<span class="c"># Поскольку &quot;set&quot; всегда учитывает и глобальное, и текущее пространства имён,</span>
<span class="c"># более безопасно использовать &quot;variable&quot; чтобы объявить новую переменную или</span>
<span class="c"># задать значение переменной. Если переменная с именем &quot;name&quot; уже существует</span>
<span class="c"># в глобальном пространстве имён, использование &quot;set&quot; задаст значение</span>
<span class="c"># глобальной переменной, тогда как &quot;variable&quot; работает только с текущим</span>
<span class="c"># пространством имён.</span>

<span class="k">namespace</span><span class="w"> </span>eval<span class="w"> </span>people<span class="w"> </span><span class="k">{</span>
<span class="w">    </span><span class="k">namespace</span><span class="w"> </span>eval<span class="w"> </span>person1<span class="w"> </span><span class="k">{</span>
<span class="w">        </span><span class="k">variable</span><span class="w"> </span>name<span class="w"> </span>Neo
<span class="w">    </span><span class="k">}</span>
<span class="k">}</span>

<span class="c"># После объявления переменной в пространстве имён, [set] видит её, а не</span>
<span class="c"># одноимённую переменную в глобальном пространстве имён:</span>

<span class="k">namespace</span><span class="w"> </span>eval<span class="w"> </span>people<span class="w"> </span><span class="k">{</span>
<span class="w">    </span><span class="k">namespace</span><span class="w"> </span>eval<span class="w"> </span>person1<span class="w"> </span><span class="k">{</span>
<span class="w">        </span><span class="k">variable</span><span class="w"> </span>name
<span class="w">        </span><span class="k">set</span><span class="w"> </span>name<span class="w"> </span>Neo
<span class="w">    </span><span class="k">}</span>
<span class="k">}</span>

<span class="c"># Но если &quot;set&quot; приходится создать новую переменную, он всегда делает это</span>
<span class="c"># с учётом текущего пространства имён:</span>
<span class="k">unset</span><span class="w"> </span>name
<span class="k">namespace</span><span class="w"> </span>eval<span class="w"> </span>people<span class="w"> </span><span class="k">{</span>
<span class="w">    </span><span class="k">namespace</span><span class="w"> </span>eval<span class="w"> </span>person1<span class="w"> </span><span class="k">{</span>
<span class="w">        </span><span class="k">set</span><span class="w"> </span>name<span class="w"> </span>neo
<span class="w">    </span><span class="k">}</span>

<span class="k">}</span>
<span class="k">set</span><span class="w"> </span>people::person1::name


<span class="c"># Абсолютное имя всегда начинается с имени глобального пространства имён, то</span>
<span class="c"># есть с пустой строки, за которой следует два двоеточия:</span>
<span class="k">set</span><span class="w"> </span><span class="o">::</span>people::person1::name<span class="w"> </span>Neo


<span class="c"># В пределах процедуры &quot;variable&quot; связывает перменную в текущем пространстве</span>
<span class="c"># имён с локальной областью видимости:</span>
<span class="k">namespace</span><span class="w"> </span>eval<span class="w"> </span>people::person1<span class="w"> </span><span class="k">{</span>
<span class="w">    </span><span class="k">proc</span><span class="w"> </span>fly<span class="w"> </span><span class="k">{}</span><span class="w"> </span><span class="k">{</span>
<span class="w">        </span><span class="k">variable</span><span class="w"> </span>name
<span class="w">        </span><span class="nb">puts</span><span class="w"> </span><span class="s2">&quot;$name is flying!&quot;</span>
<span class="w">    </span><span class="k">}</span>
<span class="k">}</span>




<span class="c">###############################################################################</span>
<span class="c">## 5. Встроенные рутины</span>
<span class="c">###############################################################################</span>

<span class="c"># Математические операции можно выполнять при помощи &quot;expr&quot;:</span>
<span class="k">set</span><span class="w"> </span>a<span class="w"> </span><span class="mi">3</span>
<span class="k">set</span><span class="w"> </span>b<span class="w"> </span><span class="mi">4</span>
<span class="k">set</span><span class="w"> </span>c<span class="w"> </span><span class="k">[expr</span><span class="w"> </span><span class="k">{</span><span class="nv">$a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">$b</span><span class="k">}]</span>

<span class="c"># Поскольку &quot;expr&quot; самостоятельно занимается подстановкой значений переменных,</span>
<span class="c"># математическое выражение нужно оборачивать в фигурные скобки чтобы отключить</span>
<span class="c"># подстановку значений переменных интерпретатором Tcl.</span>
<span class="c"># Подробнее об этом можно прочесть здесь:</span>
<span class="c"># &quot;https://wiki.tcl-lang.org/page/Brace+your+expr-essions&quot;</span>


<span class="c"># &quot;expr&quot; выполняет подстановку переменных и результатов команд:</span>
<span class="k">set</span><span class="w"> </span>c<span class="w"> </span><span class="k">[expr</span><span class="w"> </span><span class="k">{</span><span class="nv">$a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">[set</span><span class="w"> </span>b<span class="k">]}]</span>


<span class="c"># &quot;expr&quot; предоставляет разные математические функции:</span>
<span class="k">set</span><span class="w"> </span>c<span class="w"> </span><span class="k">[expr</span><span class="w"> </span><span class="k">{</span><span class="nv">pow</span><span class="k">(</span><span class="nv">$a</span>,<span class="nv">$b</span><span class="k">)}]</span>


<span class="c"># Математические операторы сами по себе доступны в виде рутин в</span>
<span class="c"># пространстве имён ::tcl::mathop</span>
<span class="o">::</span><span class="nv">tcl</span><span class="o">::</span>mathop::<span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">3</span>

<span class="c"># Рутины могут быть импортированы из других пространств имён:</span>
<span class="k">namespace</span><span class="w"> </span>import<span class="w"> </span><span class="o">::</span>tcl::mathop::<span class="o">+</span>
<span class="k">set</span><span class="w"> </span>result<span class="w"> </span><span class="k">[</span><span class="o">+</span><span class="w"> </span><span class="nv">5</span><span class="w"> </span><span class="mi">3</span><span class="k">]</span>


<span class="c"># Не числовые значения должны быть квотированы. Такие операторы как &quot;eq&quot;</span>
<span class="c"># Могут быть использованы чтобы провести строковое сравнение:</span>
<span class="k">set</span><span class="w"> </span>name<span class="w"> </span>Neo
<span class="k">expr</span><span class="w"> </span><span class="k">{{</span><span class="nv">Bob</span><span class="k">}</span><span class="w"> </span><span class="nv">eq</span><span class="w"> </span><span class="nv">$name</span><span class="k">}</span>

<span class="c"># Общие операторы сравнения тоже работают со строками если числовое значение</span>
<span class="c"># операнда недоступно:</span>
<span class="k">expr</span><span class="w"> </span><span class="k">{{</span><span class="nv">Bob</span><span class="k">}</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nv">$name</span><span class="k">}</span>


<span class="c"># &quot;proc&quot; создаёт новые рутины:</span>
<span class="k">proc</span><span class="w"> </span>greet<span class="w"> </span>name<span class="w"> </span><span class="k">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="s2">&quot;Hello, $name!&quot;</span>
<span class="k">}</span>

<span class="c"># можно указать несколько параметров:</span>
<span class="k">proc</span><span class="w"> </span>greet<span class="w"> </span><span class="k">{</span><span class="nv">greeting</span><span class="w"> </span>name<span class="k">}</span><span class="w"> </span><span class="k">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="s2">&quot;$greeting, $name!&quot;</span>
<span class="k">}</span>


<span class="c"># Как было отмечено ранее, фигурные скобки не обозначают блок кода.</span>
<span class="c"># Любое значение, даже третий аргумент &quot;proc&quot;, является строкой.</span>
<span class="c"># Предыдущая команда может быть переписана без использования фигурных скобок:</span>
<span class="k">proc</span><span class="w"> </span>greet<span class="w"> </span>greeting<span class="err">\</span><span class="w"> </span>name<span class="w"> </span>return<span class="err">\</span><span class="w"> </span><span class="err">\</span><span class="s2">&quot;\$greeting,\ \$name!\&quot;</span>



<span class="s2"># Если последний параметр называется &quot;</span>args<span class="s2">&quot;, все дополнительные аргументы,</span>
<span class="s2"># переданные рутине, собираются в список и передаются как &quot;</span>args<span class="s2">&quot;:</span>
<span class="s2">proc fold {cmd first args} {</span>
<span class="s2">    foreach arg $args {</span>
<span class="s2">        set first [$cmd $first $arg]</span>
<span class="s2">    }</span>
<span class="s2">    return $first</span>
<span class="s2">}</span>
<span class="s2">fold ::tcl::mathop::* 5 3 3 ;# -&gt;  45</span>


<span class="s2"># Условное выполнение тоже реализовано как рутина:</span>
<span class="s2">if {3 &gt; 4} {</span>
<span class="s2">    puts {This will never happen}</span>
<span class="s2">} elseif {4 &gt; 4} {</span>
<span class="s2">    puts {This will also never happen}</span>
<span class="s2">} else {</span>
<span class="s2">    puts {This will always happen}</span>
<span class="s2">}</span>


<span class="s2"># Циклы реализованы как рутины. Первый и третий аргумент для &quot;</span>for<span class="s2">&quot;</span>
<span class="s2"># обрабатываются как скрипты, а второй аргумент как выражение:</span>
<span class="s2">set res 0</span>
<span class="s2">for {set i 0} {$i &lt; 10} {incr i} {</span>
<span class="s2">    set res [expr {$res + $i}]</span>
<span class="s2">}</span>
<span class="s2">unset res</span>


<span class="s2"># Первый аргумент для &quot;</span>while<span class="s2">&quot; тоже обрабатывается как выражение:</span>
<span class="s2">set i 0</span>
<span class="s2">while {$i &lt; 10} {</span>
<span class="s2">    incr i 2</span>
<span class="s2">}</span>


<span class="s2"># Список это строка, а элементы списка разделены пробелами:</span>
<span class="s2">set amounts 10\ 33\ 18</span>
<span class="s2">set amount [lindex $amounts 1]</span>

<span class="s2"># Если элемент списка содержит пробел, его надо экранировать:</span>
<span class="s2">set inventory {&quot;</span>item<span class="w"> </span><span class="mi">1</span><span class="s2">&quot; item\ 2 {item 3}}</span>


<span class="s2"># Хорошая практика использовать списковые рутины для обработки списков:</span>
<span class="s2">lappend inventory {item 1} {item 2} {item 3}</span>


<span class="s2"># Фигурные скобки и бэкслеш могут быть использованы чтобы хранить более</span>
<span class="s2"># комплексные структуры внутри списков. Список выглядит как скрипт, за</span>
<span class="s2"># исключением того, что перевод строки и точка с запятой теряют своё</span>
<span class="s2"># специальное значение, а также не производится подстановка значений.</span>
<span class="s2"># Эта особенность Tcl называется гомоиконичность</span>
<span class="s2"># https://ru.wikipedia.org/wiki/Гомоиконичность</span>
<span class="s2"># В приведённом списке есть три элемента:</span>
<span class="s2">set values {</span>

<span class="s2">    one\ two</span>

<span class="s2">    {three four}</span>

<span class="s2">    five\{six</span>

<span class="s2">}</span>


<span class="s2"># Поскольку как и все значения, список является строкой, строковые</span>
<span class="s2"># операции могут выполняться и над списком, с риском повреждения:</span>
<span class="s2">set values {one two three four}</span>
<span class="s2">set values [string map {two \{} $values] ;# $values больше не \</span>
<span class="s2">    правильно отформатированный список</span>


<span class="s2"># Безопасный способ работать со списками — использовать &quot;</span>list<span class="s2">&quot; рутины:</span>
<span class="s2">set values [list one \{ three four]</span>
<span class="s2">lappend values { } ;# добавить символ пробела как элемент в список</span>


<span class="s2"># Использование &quot;</span>eval<span class="s2">&quot; для вычисления значения скрипта:</span>
<span class="s2">eval {</span>
<span class="s2">    set name Neo</span>
<span class="s2">    set greeting &quot;</span>Hello,<span class="w"> </span><span class="nv">$name</span><span class="s2">&quot;</span>
<span class="s2">}</span>


<span class="s2"># Список всегда можно передать в &quot;</span>eval<span class="s2">&quot; как скрипт, содержащий одну команду:</span>
<span class="s2">eval {set name Neo}</span>
<span class="s2">eval [list set greeting &quot;Hello, $name&quot;]</span>


<span class="s2"># Следовательно, когда используется &quot;</span>eval<span class="s2">&quot;, используйте &quot;</span>list<span class="s2">&quot; чтобы собрать</span>
<span class="s2"># необходимую команду:</span>
<span class="s2">set command {set name}</span>
<span class="s2">lappend command {Archibald Sorbisol}</span>
<span class="s2">eval $command</span>


<span class="s2"># Частая ошибка: не использовать списковые функции для построения команды:</span>
<span class="s2">set command {set name}</span>
<span class="s2">append command { Archibald Sorbisol}</span>
<span class="s2">try {</span>
<span class="s2">    eval $command ;# Здесь будет ошибка, превышено количество аргументов \</span>
<span class="s2">        к &quot;</span>set<span class="s2">&quot; в {set name Archibald Sorbisol}</span>
<span class="s2">} on error {result eoptions} {</span>
<span class="s2">    puts [list {received an error} $result]</span>
<span class="s2">}</span>

<span class="s2"># Эта ошибка запросто может произойти с &quot;</span>subst<span class="s2">&quot;:</span>

<span class="s2">set replacement {Archibald Sorbisol}</span>
<span class="s2">set command {set name $replacement}</span>
<span class="s2">set command [subst $command]</span>
<span class="s2">try {</span>
<span class="s2">    eval $command ;# Та же ошибка, лишние аргументы к \</span>
<span class="s2">        {set name Archibald Sorbisol}</span>
<span class="s2">} trap {TCL WRONGARGS} {result options} {</span>
<span class="s2">    puts [list {received another error} $result]</span>
<span class="s2">}</span>


<span class="s2"># &quot;</span>list<span class="s2">&quot; корректно форматирует значение для подстановки:</span>
<span class="s2">set replacement [list {Archibald Sorbisol}]</span>
<span class="s2">set command {set name $replacement}</span>
<span class="s2">set command [subst $command]</span>
<span class="s2">eval $command</span>


<span class="s2"># &quot;</span>list<span class="s2">&quot; обычно используется для форматирования значений для подстановки в</span>
<span class="s2"># скрипты, вот несколько примеров:</span>


<span class="s2"># &quot;</span>apply<span class="s2">&quot; вычисляет список из двух элементов как рутину:</span>
<span class="s2">set cmd {{greeting name} {</span>
<span class="s2">    return &quot;</span><span class="nv">$greeting</span>,<span class="w"> </span><span class="nv">$name</span><span class="o">!</span><span class="s2">&quot;</span>
<span class="s2">}}</span>
<span class="s2">apply $cmd Whaddup Neo</span>

<span class="s2"># Третий элемент может быть использован для указания пространства имён рутины:</span>
<span class="s2">set cmd [list {greeting name} {</span>
<span class="s2">    return &quot;$greeting, $name!&quot;</span>
<span class="s2">} [namespace current]]</span>
<span class="s2">apply $cmd Whaddup Neo</span>


<span class="s2"># &quot;</span>uplevel<span class="s2">&quot; вычисляет скрипт на уровень выше в списке вызовов:</span>
<span class="s2">proc greet {} {</span>
<span class="s2">    uplevel {puts &quot;</span><span class="nv">$greeting</span>,<span class="w"> </span><span class="nv">$name</span><span class="s2">&quot;}</span>
<span class="s2">}</span>

<span class="s2">proc set_double {varname value} {</span>
<span class="s2">    if {[string is double $value]} {</span>
<span class="s2">        uplevel [list variable $varname $value]</span>
<span class="s2">    } else {</span>
<span class="s2">        error [list {not a double} $value]</span>
<span class="s2">    }</span>
<span class="s2">}</span>


<span class="s2"># &quot;</span>upvar<span class="s2">&quot; связывает переменную на текущем уровне вызовов с переменной на</span>
<span class="s2"># более высоком уровне:</span>
<span class="s2">proc set_double {varname value} {</span>
<span class="s2">    if {[string is double $value]} {</span>
<span class="s2">        upvar 1 $varname var</span>
<span class="s2">        set var $value</span>
<span class="s2">    } else {</span>
<span class="s2">        error [list {not a double} $value]</span>
<span class="s2">    }</span>
<span class="s2">}</span>


<span class="s2"># Избавляемся от встроенной рутины &quot;</span>while<span class="s2">&quot; и используем &quot;</span>proc<span class="s2">&quot; чтобы написать</span>
<span class="s2"># свою версию:</span>
<span class="s2">rename ::while {}</span>
<span class="s2"># обработка оставлена как упражнение:</span>
<span class="s2">proc while {condition script} {</span>
<span class="s2">    if {[uplevel 1 [list expr $condition]]} {</span>
<span class="s2">        uplevel 1 $script</span>
<span class="s2">        tailcall [namespace which while] $condition $script</span>
<span class="s2">    }</span>
<span class="s2">}</span>


<span class="s2"># &quot;</span>coroutine<span class="s2">&quot; создаёт новый стек вызовов, новую рутину для входа в этот стек</span>
<span class="s2"># и вызывает эту рутину. &quot;</span>yield<span class="s2">&quot; приостанавливает вычисления в этом стеке и</span>
<span class="s2"># возвращает управление вызывавшему стеку:</span>
<span class="s2">proc countdown count {</span>
<span class="s2">    # отправить что-нибудь обратно создателю корутины, фактически</span>
<span class="s2">    # останавливая стек вызовов на время.</span>
<span class="s2">    yield [info coroutine]</span>

<span class="s2">    while {$count &gt; 1} {</span>
<span class="s2">        yield [incr count -1]</span>
<span class="s2">    }</span>
<span class="s2">    return 0</span>
<span class="s2">}</span>
<span class="s2">coroutine countdown1 countdown 3</span>
<span class="s2">coroutine countdown2 countdown 5</span>
<span class="s2">puts [countdown1] ;# -&gt; 2</span>
<span class="s2">puts [countdown2] ;# -&gt; 4</span>
<span class="s2">puts [countdown1] ;# -&gt; 1</span>
<span class="s2">puts [countdown1] ;# -&gt; 0</span>
<span class="s2">catch {</span>
<span class="s2">    puts [coundown1] ;# -&gt; invalid command name &quot;</span>countdown1<span class="s2">&quot;</span>
<span class="s2">} cres copts</span>
<span class="s2">puts $cres</span>
<span class="s2">puts [countdown2] ;# -&gt; 3</span>


<span class="s2"># Стеки корутин могут передавать контроль друг другу:</span>

<span class="s2">proc pass {whom args} {</span>
<span class="s2">    return [yieldto $whom {*}$args]</span>
<span class="s2">}</span>

<span class="s2">coroutine a apply {{} {</span>
<span class="s2">        yield</span>
<span class="s2">        set result [pass b {please pass the salt}]</span>
<span class="s2">        puts [list got the $result]</span>
<span class="s2">        set result [pass b {please pass the pepper}]</span>
<span class="s2">        puts [list got the $result]</span>
<span class="s2">}}</span>

<span class="s2">coroutine b apply {{} {</span>
<span class="s2">    set request [yield]</span>
<span class="s2">    while 1 {</span>
<span class="s2">        set response [pass c $request]</span>
<span class="s2">        puts [list [info coroutine] is now yielding]</span>
<span class="s2">        set request [pass a $response]</span>
<span class="s2">    }</span>
<span class="s2">}}</span>

<span class="s2">coroutine c apply {{} {</span>
<span class="s2">    set request [yield]</span>
<span class="s2">    while 1 {</span>
<span class="s2">        if {[string match *salt* $request]} {</span>
<span class="s2">            set request [pass b salt]</span>
<span class="s2">        } else {</span>
<span class="s2">            set request [pass b huh?]</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">}}</span>
</pre></div>
<h2>Ссылки</h2>

<p><a href="https://www.tcl-lang.org">Официальная документация Tcl</a></p>

<p><a href="https://wiki.tcl-lang.org">Tcl Wiki</a></p>

<p><a href="http://www.reddit.com/r/Tcl">Tcl на Reddit</a></p>

    <hr>
    <p>Хотите предложить свой перевод? Может быть, улучшение перевода? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Откройте Issue</a> в репозитории Github или сделайте <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/ru-ru/tcl-ru.html.markdown">pull request</a> сами!
    </p>
    <p class="contributed">
    Первоначально предоставлено автором Poor Yorick, и обновлено <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/ru-ru/tcl-ru.html.markdown">1 автором</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="https://pooryorick.com/">Poor Yorick</a>
    </p>

    <p>
      Переводчик:
        <a href="https://github.com/weirdvic">Viktor Sokhranov</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
