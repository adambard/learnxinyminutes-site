<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="ru-ru" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="ru-ru" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="ru-ru" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="ru-ru" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="ru-ru">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Lua in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/ru-ru/lua-ru/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fru-ru%2Flua-ru%2F&text=%D0%98%D0%B7%D1%83%D1%87%D0%B8%D1%82%D0%B5+X+%D0%B7%D0%B0+Y+%D0%BC%D0%B8%D0%BD%D1%83%D1%82%2C+%D0%B3%D0%B4%D0%B5+X%3DLua">
        Поделиться страницей
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Выберите тему:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">светлая</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">тёмная</button>
  </div>
  <h1><a href="/">Изучите X за Y минут</a></h1>
  <h2>Где X=Lua</h2>
    <p class="filelink">
    Получить исходный код:
    <a href="/docs/files/learnlua-ru.lua">learnlua-ru.lua</a>
    </p>
  <div id="doc">
    <div class="highlight"><pre><span></span><span class="c1">-- Два дефиса начинают однострочный комментарий.</span>

<span class="cm">--[[</span>
<span class="cm">    Добавление двух квадратных скобок</span>
<span class="cm">    делает комментарий многострочным.</span>
<span class="cm">--]]</span>
<span class="c1">--------------------------------------------------------------------------------</span>
<span class="c1">-- 1. Переменные, циклы и условия.</span>
<span class="c1">--------------------------------------------------------------------------------</span>

<span class="n">num</span> <span class="o">=</span> <span class="mi">42</span>  <span class="c1">-- Все числа имеют тип double.</span>
<span class="c1">-- Не волнуйтесь, в 64-битных double 52 бита</span>
<span class="c1">-- отведено под хранение целой части числа;</span>
<span class="c1">-- точность не является проблемой для</span>
<span class="c1">-- целочисленных значений, занимающих меньше 52 бит.</span>

<span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;walternate&#39;</span>  <span class="c1">-- Неизменные строки, как в Python.</span>
<span class="n">t</span> <span class="o">=</span> <span class="s2">&quot;Двойные кавычки также приветствуются&quot;</span>
<span class="n">u</span> <span class="o">=</span> <span class="s">[[ Двойные квадратные скобки</span>
<span class="s">       начинают и заканчивают</span>
<span class="s">       многострочные значения.]]</span>
<span class="n">t</span> <span class="o">=</span> <span class="kc">nil</span>  <span class="c1">-- Удаляет определение переменной t; в Lua есть сборка мусора.</span>

<span class="c1">-- Блоки обозначаются ключевыми словами, такими как do/end:</span>
<span class="kr">while</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">50</span> <span class="kr">do</span>
  <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1">-- Операторов ++ и += нет.</span>
<span class="kr">end</span>

<span class="c1">-- Ветвление &quot;если&quot;:</span>
<span class="kr">if</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="mi">40</span> <span class="kr">then</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;больше 40&#39;</span><span class="p">)</span>
<span class="kr">elseif</span> <span class="n">s</span> <span class="o">~=</span> <span class="s1">&#39;walternate&#39;</span> <span class="kr">then</span>  <span class="c1">-- ~= обозначает &quot;не равно&quot;.</span>
  <span class="c1">-- Проверка равенства это ==, как в Python; работает для строк.</span>
  <span class="nb">io.write</span><span class="p">(</span><span class="s1">&#39;не больше 40</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>  <span class="c1">-- По умолчанию вывод в stdout.</span>
<span class="kr">else</span>
  <span class="c1">-- По умолчанию переменные являются глобальными.</span>
  <span class="n">thisIsGlobal</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1">-- Стиль CamelСase является общим.</span>

  <span class="c1">-- Как сделать переменную локальной:</span>
  <span class="kd">local</span> <span class="n">line</span> <span class="o">=</span> <span class="nb">io.read</span><span class="p">()</span>  <span class="c1">-- Считывает введённую строку.</span>

  <span class="c1">-- Для конкатенации строк используется оператор .. :</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Зима пришла, &#39;</span> <span class="o">..</span> <span class="n">line</span><span class="p">)</span>
<span class="kr">end</span>

<span class="c1">-- Неопределённые переменные возвращают nil.</span>
<span class="c1">-- Этот пример не является ошибочным:</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">anUnknownVariable</span>  <span class="c1">-- Теперь foo = nil.</span>

<span class="n">aBoolValue</span> <span class="o">=</span> <span class="kc">false</span>

<span class="c1">-- Только значения nil и false являются ложными; 0 и &#39;&#39; являются истинными!</span>
<span class="kr">if</span> <span class="ow">not</span> <span class="n">aBoolValue</span> <span class="kr">then</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;это значение ложно&#39;</span><span class="p">)</span> <span class="kr">end</span>

<span class="c1">-- Для &#39;or&#39; и &#39;and&#39; действует принцип &quot;какой оператор дальше,</span>
<span class="c1">-- тот и применяется&quot;. Это действует аналогично оператору a?b:c в C/js:</span>
<span class="n">ans</span> <span class="o">=</span> <span class="n">aBoolValue</span> <span class="ow">and</span> <span class="s1">&#39;yes&#39;</span> <span class="ow">or</span> <span class="s1">&#39;no&#39;</span>  <span class="c1">--&gt; &#39;no&#39;</span>

<span class="n">karlSum</span> <span class="o">=</span> <span class="mi">0</span>
<span class="kr">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span> <span class="kr">do</span>  <span class="c1">-- Здесь указан диапазон, ограниченный с двух сторон.</span>
  <span class="n">karlSum</span> <span class="o">=</span> <span class="n">karlSum</span> <span class="o">+</span> <span class="n">i</span>
<span class="kr">end</span>

<span class="c1">-- Используйте &quot;100, 1, -1&quot; как нисходящий диапазон:</span>
<span class="n">fredSum</span> <span class="o">=</span> <span class="mi">0</span>
<span class="kr">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="kr">do</span> <span class="n">fredSum</span> <span class="o">=</span> <span class="n">fredSum</span> <span class="o">+</span> <span class="n">j</span> <span class="kr">end</span>

<span class="c1">-- В основном, диапазон устроен так: начало, конец[, шаг].</span>

<span class="c1">-- Другая конструкция цикла:</span>
<span class="kr">repeat</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;путь будущего&#39;</span><span class="p">)</span>
  <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">-</span> <span class="mi">1</span>
<span class="kr">until</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">0</span>

<span class="c1">--------------------------------------------------------------------------------</span>
<span class="c1">-- 2. Функции.</span>
<span class="c1">--------------------------------------------------------------------------------</span>

<span class="kr">function</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="kr">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="kr">then</span> <span class="kr">return</span> <span class="n">n</span> <span class="kr">end</span>
  <span class="kr">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="kr">end</span>

<span class="c1">-- Вложенные и анонимные функции являются нормой:</span>
<span class="kr">function</span> <span class="nf">adder</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="c1">-- Возвращаемая функция создаётся, когда вызывается функция adder,</span>
  <span class="c1">-- и запоминает значение переменной x:</span>
  <span class="kr">return</span> <span class="kr">function</span> <span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="kr">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="kr">end</span>
<span class="kr">end</span>
<span class="n">a1</span> <span class="o">=</span> <span class="n">adder</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="n">a2</span> <span class="o">=</span> <span class="n">adder</span><span class="p">(</span><span class="mi">36</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a1</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>  <span class="c1">--&gt; 25</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a2</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span>  <span class="c1">--&gt; 100</span>

<span class="c1">-- Возвраты, вызовы функций и присвоения работают со списками,</span>
<span class="c1">-- которые могут иметь разную длину.</span>
<span class="c1">-- Лишние получатели принимают значение nil, а лишние значения игнорируются.</span>

<span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span>
<span class="c1">-- Теперь x = 1, y = 2, z = 3, а 4 просто отбрасывается.</span>

<span class="kr">function</span> <span class="nf">bar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
  <span class="kr">return</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">42</span>
<span class="kr">end</span>

<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">bar</span><span class="p">(</span><span class="s1">&#39;zaphod&#39;</span><span class="p">)</span>  <span class="c1">--&gt; выводит &quot;zaphod  nil nil&quot;</span>
<span class="c1">-- Теперь x = 4, y = 8, а значения 15..42 отбрасываются.</span>

<span class="c1">-- Функции могут быть локальными и глобальными. Эти строки делают одно и то же:</span>
<span class="kr">function</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="kr">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="kr">end</span>
<span class="n">f</span> <span class="o">=</span> <span class="kr">function</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="kr">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="kr">end</span>

<span class="c1">-- Эти тоже:</span>
<span class="kd">local</span> <span class="kr">function</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="kr">return</span> <span class="nb">math.sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="kr">end</span>
<span class="kd">local</span> <span class="n">g</span> <span class="o">=</span> <span class="kr">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="kr">return</span> <span class="nb">math.sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="kr">end</span>
<span class="c1">-- Эквивалентно для local function g(x)..., однако ссылки на g</span>
<span class="c1">-- в теле функции не будут работать, как ожидалось.</span>
<span class="kd">local</span> <span class="n">g</span><span class="p">;</span> <span class="n">g</span>  <span class="o">=</span> <span class="kr">function</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="kr">return</span> <span class="nb">math.sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="kr">end</span>
<span class="c1">-- &#39;local g&#39; будет прототипом функции.</span>

<span class="c1">-- Кстати, тригонометрические функции работают с радианами.</span>

<span class="c1">-- Вызов функции с одним строковым параметром не требует круглых скобок:</span>
<span class="nb">print</span> <span class="s1">&#39;hello&#39;</span>  <span class="c1">-- Работает без ошибок.</span>

<span class="c1">-- Вызов функции с одним табличным параметром также</span>
<span class="c1">-- не требует круглых скобок (про таблицы в след. части):</span>
<span class="nb">print</span> <span class="p">{}</span> <span class="c1">-- Тоже сработает.</span>

<span class="c1">--------------------------------------------------------------------------------</span>
<span class="c1">-- 3. Таблицы.</span>
<span class="c1">--------------------------------------------------------------------------------</span>

<span class="c1">-- Таблица = единственная составная структура данных в Lua;</span>
<span class="c1">-- представляет собой ассоциативный массив.</span>
<span class="c1">-- Подобно массивам в PHP или объектам в JS, они представляют собой</span>
<span class="c1">-- хеш-таблицы, которые также можно использовать в качестве списков.</span>


<span class="c1">-- Использование словарей:</span>

<span class="c1">-- Литералы имеют ключ по умолчанию:</span>
<span class="n">t</span> <span class="o">=</span> <span class="p">{</span><span class="n">key1</span> <span class="o">=</span> <span class="s1">&#39;value1&#39;</span><span class="p">,</span> <span class="n">key2</span> <span class="o">=</span> <span class="kc">false</span><span class="p">}</span>

<span class="c1">-- Строковые ключи используются, как в точечной нотации в JS:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">key1</span><span class="p">)</span>  <span class="c1">-- Печатает &#39;value1&#39;.</span>
<span class="n">t</span><span class="p">.</span><span class="n">newKey</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1">-- Добавляет новую пару ключ/значение.</span>
<span class="n">t</span><span class="p">.</span><span class="n">key2</span> <span class="o">=</span> <span class="kc">nil</span>   <span class="c1">-- Удаляет key2 из таблицы.</span>

<span class="c1">-- Литеральная нотация для любого значения ключа (кроме nil):</span>
<span class="n">u</span> <span class="o">=</span> <span class="p">{[</span><span class="s1">&#39;@!#&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;qbert&#39;</span><span class="p">,</span> <span class="p">[{}]</span> <span class="o">=</span> <span class="mi">1729</span><span class="p">,</span> <span class="p">[</span><span class="mf">6.28</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;tau&#39;</span><span class="p">}</span>
<span class="nb">print</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mf">6.28</span><span class="p">])</span>  <span class="c1">-- пишет &quot;tau&quot;</span>

<span class="c1">-- Ключ соответствует значению для чисел и строк, но при</span>
<span class="c1">-- использовании таблицы в качестве ключа берётся её экземпляр.</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="s1">&#39;@!#&#39;</span><span class="p">]</span>  <span class="c1">-- Теперь a = &#39;qbert&#39;.</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">u</span><span class="p">[{}]</span>     <span class="c1">-- Вы могли ожидать 1729, но получится nil:</span>
<span class="c1">-- b = nil, т.к. ключ не будет найден.</span>
<span class="c1">-- Это произойдёт потому, что за ключ мы использовали не тот же самый объект,</span>
<span class="c1">-- который был использован для сохранения оригинального значения.</span>
<span class="c1">-- Поэтому строки и числа удобнее использовать в качестве ключей.</span>

<span class="c1">-- Вызов функции с одной таблицей в качестве аргумента</span>
<span class="c1">-- не требует круглых скобок:</span>
<span class="kr">function</span> <span class="nf">h</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">key1</span><span class="p">)</span> <span class="kr">end</span>
<span class="n">h</span><span class="p">{</span><span class="n">key1</span> <span class="o">=</span> <span class="s1">&#39;Sonmi~451&#39;</span><span class="p">}</span>  <span class="c1">-- Печатает &#39;Sonmi~451&#39;.</span>

<span class="kr">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="kr">in</span> <span class="nb">pairs</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="kr">do</span>  <span class="c1">-- Цикл по таблице.</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
<span class="kr">end</span>

<span class="c1">-- _G - это таблица со всеми глобалями.</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">_G</span><span class="p">[</span><span class="s1">&#39;_G&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="nb">_G</span><span class="p">)</span>  <span class="c1">-- Печатает &#39;true&#39;.</span>

<span class="c1">-- Использование таблиц, как списков / массивов:</span>

<span class="c1">-- Список значений с неявно заданными целочисленными ключами:</span>
<span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;value1&#39;</span><span class="p">,</span> <span class="s1">&#39;value2&#39;</span><span class="p">,</span> <span class="mf">1.21</span><span class="p">,</span> <span class="s1">&#39;gigawatts&#39;</span><span class="p">}</span>
<span class="kr">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">#</span><span class="n">v</span> <span class="kr">do</span>  <span class="c1">-- #v - размер списка v.</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>  <span class="c1">-- Нумерация начинается с 1 !!</span>
<span class="kr">end</span>

<span class="c1">-- Список не является отдельным типом. v - всего лишь таблица</span>
<span class="c1">-- с последовательными целочисленными ключами, воспринимаемая как список.</span>

<span class="c1">--------------------------------------------------------------------------------</span>
<span class="c1">-- 3.1 Метатаблицы и метаметоды.</span>
<span class="c1">--------------------------------------------------------------------------------</span>

<span class="c1">-- Таблицу можно связать с метатаблицей, задав ей поведение, как при</span>
<span class="c1">-- перегрузке операторов. Позже мы увидим, что метатаблицы поддерживают</span>
<span class="c1">-- поведение, как в js-прототипах.</span>
<span class="n">f1</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">}</span>  <span class="c1">-- Представляет дробь a/b.</span>
<span class="n">f2</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">}</span>

<span class="c1">-- Это не сработает:</span>
<span class="c1">-- s = f1 + f2</span>

<span class="n">metafraction</span> <span class="o">=</span> <span class="p">{}</span>
<span class="kr">function</span> <span class="nc">metafraction</span><span class="p">.</span><span class="nf">__add</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">)</span>
  <span class="kd">local</span> <span class="n">sum</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="n">sum</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">f1</span><span class="p">.</span><span class="n">b</span> <span class="o">*</span> <span class="n">f2</span><span class="p">.</span><span class="n">b</span>
  <span class="n">sum</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">f1</span><span class="p">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">f2</span><span class="p">.</span><span class="n">b</span> <span class="o">+</span> <span class="n">f2</span><span class="p">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">f1</span><span class="p">.</span><span class="n">b</span>
  <span class="kr">return</span> <span class="n">sum</span>
<span class="kr">end</span>

<span class="nb">setmetatable</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">metafraction</span><span class="p">)</span>
<span class="nb">setmetatable</span><span class="p">(</span><span class="n">f2</span><span class="p">,</span> <span class="n">metafraction</span><span class="p">)</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">f1</span> <span class="o">+</span> <span class="n">f2</span>  <span class="c1">-- вызвать __add(f1, f2) на метатаблице от f1</span>

<span class="c1">-- f1, f2 не имеют ключа для своих метатаблиц в отличии от прототипов в js,</span>
<span class="c1">-- нужно получить его через getmetatable(f1). Метатаблица - обычная таблица</span>
<span class="c1">-- поэтому с ключами, известными для Lua (например, __add).</span>

<span class="c1">-- Но следущая строка будет ошибочной т.к в s нет метатаблицы:</span>
<span class="c1">-- t = s + s</span>
<span class="c1">-- Похожий на классы подход, приведенный ниже, поможет это исправить.</span>

<span class="c1">-- __index перегружает в метатаблице просмотр через точку:</span>
<span class="n">defaultFavs</span> <span class="o">=</span> <span class="p">{</span><span class="n">animal</span> <span class="o">=</span> <span class="s1">&#39;gru&#39;</span><span class="p">,</span> <span class="n">food</span> <span class="o">=</span> <span class="s1">&#39;donuts&#39;</span><span class="p">}</span>
<span class="n">myFavs</span> <span class="o">=</span> <span class="p">{</span><span class="n">food</span> <span class="o">=</span> <span class="s1">&#39;pizza&#39;</span><span class="p">}</span>
<span class="nb">setmetatable</span><span class="p">(</span><span class="n">myFavs</span><span class="p">,</span> <span class="p">{</span><span class="n">__index</span> <span class="o">=</span> <span class="n">defaultFavs</span><span class="p">})</span>
<span class="n">eatenBy</span> <span class="o">=</span> <span class="n">myFavs</span><span class="p">.</span><span class="n">animal</span>  <span class="c1">-- работает! спасибо, мета-таблица.</span>

<span class="c1">--------------------------------------------------------------------------------</span>
<span class="c1">-- При неудаче прямой табличный поиск попытается использовать</span>
<span class="c1">-- значение __index в метатаблице, причём это рекурсивно.</span>

<span class="c1">-- Значение __index также может быть функцией</span>
<span class="c1">-- function(tbl, key) для настраиваемого поиска.</span>

<span class="c1">-- Значения типа __index, __add, ... называются метаметодами.</span>
<span class="c1">-- Ниже приведён полный список метаметодов.</span>

<span class="c1">-- __add(a, b)                          для a + b</span>
<span class="c1">-- __sub(a, b)                          для a - b</span>
<span class="c1">-- __mul(a, b)                          для a * b</span>
<span class="c1">-- __div(a, b)                          для a / b</span>
<span class="c1">-- __mod(a, b)                          для a % b</span>
<span class="c1">-- __pow(a, b)                          для a ^ b</span>
<span class="c1">-- __unm(a)                             для -a</span>
<span class="c1">-- __concat(a, b)                       для a .. b</span>
<span class="c1">-- __len(a)                             для #a</span>
<span class="c1">-- __eq(a, b)                           для a == b</span>
<span class="c1">-- __lt(a, b)                           для a &lt; b</span>
<span class="c1">-- __le(a, b)                           для a &lt;= b</span>
<span class="c1">-- __index(a, b) &lt;функция или таблица&gt;  для a.b</span>
<span class="c1">-- __newindex(a, b, c)                  для a.b = c</span>
<span class="c1">-- __call(a, ...)                       для a(...)</span>

<span class="c1">--------------------------------------------------------------------------------</span>
<span class="c1">-- 3.2 Классоподобные таблицы и наследование.</span>
<span class="c1">--------------------------------------------------------------------------------</span>

<span class="c1">-- В Lua нет поддержки классов на уровне языка,</span>
<span class="c1">-- однако существуют разные способы их создания с помощью</span>
<span class="c1">-- таблиц и метатаблиц.</span>

<span class="c1">-- Ниже приведён один из таких способов.</span>

<span class="n">Dog</span> <span class="o">=</span> <span class="p">{}</span>                                   <span class="c1">-- 1.</span>

<span class="kr">function</span> <span class="nc">Dog</span><span class="p">:</span><span class="nf">new</span><span class="p">()</span>                         <span class="c1">-- 2.</span>
  <span class="kd">local</span> <span class="n">newObj</span> <span class="o">=</span> <span class="p">{</span><span class="n">sound</span> <span class="o">=</span> <span class="s1">&#39;woof&#39;</span><span class="p">}</span>          <span class="c1">-- 3.</span>
  <span class="n">self</span><span class="p">.</span><span class="n">__index</span> <span class="o">=</span> <span class="n">self</span>                      <span class="c1">-- 4.</span>
  <span class="kr">return</span> <span class="nb">setmetatable</span><span class="p">(</span><span class="n">newObj</span><span class="p">,</span> <span class="n">self</span><span class="p">)</span>        <span class="c1">-- 5.</span>
<span class="kr">end</span>

<span class="kr">function</span> <span class="nc">Dog</span><span class="p">:</span><span class="nf">makeSound</span><span class="p">()</span>                   <span class="c1">-- 6.</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;I say &#39;</span> <span class="o">..</span> <span class="n">self</span><span class="p">.</span><span class="n">sound</span><span class="p">)</span>
<span class="kr">end</span>

<span class="n">mrDog</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">:</span><span class="n">new</span><span class="p">()</span>                          <span class="c1">-- 7.</span>
<span class="n">mrDog</span><span class="p">:</span><span class="n">makeSound</span><span class="p">()</span>  <span class="c1">-- &#39;I say woof&#39;         -- 8.</span>

<span class="c1">-- 1. Dog похоже на класс, но на самом деле это таблица.</span>
<span class="c1">-- 2. &quot;function tablename:fn(...)&quot; - то же самое, что и</span>
<span class="c1">--    &quot;function tablename.fn(self, ...)&quot;, просто : добавляет первый аргумент</span>
<span class="c1">--    перед собой. См. пункты 7 и 8, чтобы понять, как self получает значение.</span>
<span class="c1">-- 3. newObj - это экземпляр класса Dog.</span>
<span class="c1">-- 4. &quot;self&quot; - экземпляр класса. Зачастую self = Dog, но с помощью наследования</span>
<span class="c1">--    это можно изменить. newObj получит свои функции, когда мы установим</span>
<span class="c1">--    метатаблицу для newObj и __index для self на саму себя.</span>
<span class="c1">-- 5. Напоминание: setmetatable возвращает первый аргумент.</span>
<span class="c1">-- 6. : работает, как в пункте 2, но в этот раз мы ожидаем,</span>
<span class="c1">--    что self будет экземпляром, а не классом.</span>
<span class="c1">-- 7. То же самое, что и Dog.new(Dog), поэтому self = Dog в new().</span>
<span class="c1">-- 8. То же самое, что mrDog.makeSound(mrDog); self = mrDog.</span>
<span class="c1">--------------------------------------------------------------------------------</span>

<span class="c1">-- Пример наследования:</span>

<span class="n">LoudDog</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">:</span><span class="n">new</span><span class="p">()</span>                           <span class="c1">-- 1.</span>

<span class="kr">function</span> <span class="nc">LoudDog</span><span class="p">:</span><span class="nf">makeSound</span><span class="p">()</span>
  <span class="kd">local</span> <span class="n">s</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">sound</span> <span class="o">..</span> <span class="s1">&#39; &#39;</span>                 <span class="c1">-- 2.</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">s</span> <span class="o">..</span> <span class="n">s</span> <span class="o">..</span> <span class="n">s</span><span class="p">)</span>
<span class="kr">end</span>

<span class="n">seymour</span> <span class="o">=</span> <span class="n">LoudDog</span><span class="p">:</span><span class="n">new</span><span class="p">()</span>                       <span class="c1">-- 3.</span>
<span class="n">seymour</span><span class="p">:</span><span class="n">makeSound</span><span class="p">()</span>  <span class="c1">-- &#39;woof woof woof&#39;      -- 4.</span>

<span class="c1">--------------------------------------------------------------------------------</span>
<span class="c1">-- 1. LoudDog получит методы и переменные класса Dog.</span>
<span class="c1">-- 2. В self будет ключ &#39;sound&#39; из new(), см. пункт 3.</span>
<span class="c1">-- 3. То же самое, что и &quot;LoudDog.new(LoudDog)&quot;, конвертированное</span>
<span class="c1">--    в &quot;Dog.new(LoudDog)&quot;, поскольку в LoudDog нет ключа &#39;new&#39;,</span>
<span class="c1">--    но в его метатаблице есть &quot;__index = Dog&quot;.</span>
<span class="c1">--    Результат: Метатаблицей для seymour стала LoudDog,</span>
<span class="c1">--    а &quot;LoudDog.__index = Dog&quot;. Поэтому seymour.key будет равно</span>
<span class="c1">--    seymour.key, LoudDog.key, Dog.key, в зависимости от того,</span>
<span class="c1">--    какая таблица будет первой с заданным ключом.</span>
<span class="c1">-- 4. Ключ &#39;makeSound&#39; находится в LoudDog;</span>
<span class="c1">--    то же самое, что и &quot;LoudDog.makeSound(seymour)&quot;.</span>

<span class="c1">-- При необходимости функция new() в подклассе</span>
<span class="c1">-- может быть похожа на аналог в базовом классе.</span>
<span class="kr">function</span> <span class="nc">LoudDog</span><span class="p">:</span><span class="nf">new</span><span class="p">()</span>
  <span class="kd">local</span> <span class="n">newObj</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="c1">-- установить newObj</span>
  <span class="n">self</span><span class="p">.</span><span class="n">__index</span> <span class="o">=</span> <span class="n">self</span>
  <span class="kr">return</span> <span class="nb">setmetatable</span><span class="p">(</span><span class="n">newObj</span><span class="p">,</span> <span class="n">self</span><span class="p">)</span>
<span class="kr">end</span>

<span class="c1">--------------------------------------------------------------------------------</span>
<span class="c1">-- 4. Модули.</span>
<span class="c1">--------------------------------------------------------------------------------</span>


<span class="c1">--[[ Я закомментировал этот раздел, чтобы остальная часть скрипта осталась</span>
<span class="c1">--   работоспособной.</span>
</pre></div><div class="highlight"><pre><span></span><span class="c1">-- Предположим, файл mod.lua будет выглядеть так:</span>
<span class="kd">local</span> <span class="n">M</span> <span class="o">=</span> <span class="p">{}</span>

<span class="kd">local</span> <span class="kr">function</span> <span class="nf">sayMyName</span><span class="p">()</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Hrunkner&#39;</span><span class="p">)</span>
<span class="kr">end</span>

<span class="kr">function</span> <span class="nc">M</span><span class="p">.</span><span class="nf">sayHello</span><span class="p">()</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Привет, &#39;</span><span class="p">)</span>
  <span class="n">sayMyName</span><span class="p">()</span>
<span class="kr">end</span>

<span class="kr">return</span> <span class="n">M</span>

<span class="c1">-- Другой файл может использовать функциональность mod.lua:</span>
<span class="kd">local</span> <span class="n">mod</span> <span class="o">=</span> <span class="nb">require</span><span class="p">(</span><span class="s1">&#39;mod&#39;</span><span class="p">)</span>  <span class="c1">-- Запустим файл mod.lua.</span>

<span class="c1">-- require - стандартный способ подключения модулей.</span>
<span class="c1">-- require ведёт себя так:     (если не кэшировано, см. ниже)</span>
<span class="kd">local</span> <span class="n">mod</span> <span class="o">=</span> <span class="p">(</span><span class="kr">function</span> <span class="p">()</span>
  <span class="o">&lt;</span><span class="err">содержимое</span> <span class="n">mod</span><span class="p">.</span><span class="n">lua</span><span class="o">&gt;</span>
<span class="kr">end</span><span class="p">)()</span>
<span class="c1">-- Файл mod.lua воспринимается, как тело функции, поэтому</span>
<span class="c1">-- все локальные переменные и функции внутри него не видны за его пределами.</span>

<span class="c1">-- Это работает, так как здесь mod = M в mod.lua:</span>
<span class="n">mod</span><span class="p">.</span><span class="n">sayHello</span><span class="p">()</span>  <span class="c1">-- Выведет &quot;Привет, Hrunkner&quot;.</span>

<span class="c1">-- Это будет ошибочным; sayMyName доступна только в mod.lua:</span>
<span class="n">mod</span><span class="p">.</span><span class="n">sayMyName</span><span class="p">()</span>  <span class="c1">-- ошибка</span>

<span class="c1">-- Значения, возвращаемые require, кэшируются,</span>
<span class="c1">-- поэтому содержимое файла выполняется только 1 раз,</span>
<span class="c1">-- даже если он подключается с помощью require много раз.</span>

<span class="c1">-- Предположим, mod2.lua содержит &quot;print(&#39;Hi!&#39;)&quot;.</span>
<span class="kd">local</span> <span class="n">a</span> <span class="o">=</span> <span class="nb">require</span><span class="p">(</span><span class="s1">&#39;mod2&#39;</span><span class="p">)</span>  <span class="c1">-- Выведет &quot;Hi!&quot;</span>
<span class="kd">local</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">require</span><span class="p">(</span><span class="s1">&#39;mod2&#39;</span><span class="p">)</span>  <span class="c1">-- Ничего не выведет; a=b.</span>

<span class="c1">-- dofile, в отличии от require, работает без кэширования:</span>
<span class="nb">dofile</span><span class="p">(</span><span class="s1">&#39;mod2&#39;</span><span class="p">)</span>  <span class="c1">--&gt; Hi!</span>
<span class="nb">dofile</span><span class="p">(</span><span class="s1">&#39;mod2&#39;</span><span class="p">)</span>  <span class="c1">--&gt; Hi! (запустится снова)</span>

<span class="c1">-- loadfile загружает файл, но не запускает его.</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">loadfile</span><span class="p">(</span><span class="s1">&#39;mod2&#39;</span><span class="p">)</span>  <span class="c1">-- Вызов f() запустит содержимое mod2.lua.</span>

<span class="c1">-- loadstring - это loadfile для строк.</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">loadstring</span><span class="p">(</span><span class="s1">&#39;print(343)&#39;</span><span class="p">)</span>  <span class="c1">-- Вернет функцию.</span>
<span class="n">g</span><span class="p">()</span>  <span class="c1">-- Напишет 343.</span>

<span class="c1">--]]</span>
</pre></div>
<h2>Примечание (от автора)</h2>

<p>Мне было интересно изучить Lua, чтобы делать игры при помощи <a href="http://love2d.org/">игрового движка LÖVE</a>.</p>

<p>Я начинал с <a href="http://nova-fusion.com/2012/08/27/lua-for-programmers-part-1/">BlackBulletIV&rsquo;s Lua for programmers</a>.
Затем я прочитал официальную <a href="http://www.lua.org/pil/contents.html">Документацию по Lua</a>.</p>

<p>Также может быть полезной <a href="http://lua-users.org/files/wiki_insecure/users/thomasl/luarefv51.pdf">Краткая справка по Lua</a> на lua-users.org.</p>

<p>Ещё из основных тем не охвачены стандартные библиотеки:</p>

<ul>
<li><a href="http://lua-users.org/wiki/StringLibraryTutorial">библиотека string</a></li>
<li><a href="http://lua-users.org/wiki/TableLibraryTutorial">библиотека table</a></li>
<li><a href="http://lua-users.org/wiki/MathLibraryTutorial">библиотека math</a></li>
<li><a href="http://lua-users.org/wiki/IoLibraryTutorial">библиотека io</a></li>
<li><a href="http://lua-users.org/wiki/OsLibraryTutorial">библиотека os</a></li>
</ul>

<p>Кстати, весь файл написан на Lua; сохраните его как learn.lua и запустите при помощи &ldquo;lua learn.lua&rdquo; !</p>

<p>Изначально эта статья была написана для tylerneylon.com.
Также она доступна как <a href="https://gist.github.com/tylerneylon/5853042">github gist</a>. Удачи с Lua!</p>

    <hr>
    <p>Хотите предложить свой перевод? Может быть, улучшение перевода? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Откройте Issue</a> в репозитории Github или сделайте <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/ru-ru/lua-ru.html.markdown">pull request</a> сами!
    </p>
    <p class="contributed">
    Первоначально предоставлено автором Tyler Neylon, и обновлено <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/ru-ru/lua-ru.html.markdown">7 авторами</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://tylerneylon.com/">Tyler Neylon</a>
    </p>

    <p>
      Переводчики:
        <a href="https://vk.com/solomonovmaksim">Max Solomonov</a>
        <a href="https://vk.com/maximmax42">Max Truhonin</a>
        <a href="https://vk.com/id0x1765d79">Konstantin Gromyko</a>
        <a href="https://vk.com/id156354391">Stanislav Gromov</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
