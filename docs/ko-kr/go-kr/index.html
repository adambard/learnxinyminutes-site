<!DOCTYPE html lang="ko-kr" xml:lang="ko-kr" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="ko-kr">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Go in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/ko-kr/go-kr/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fko-kr%2Fgo-kr%2F&text=Y%EB%B6%84%EC%97%90+X%EB%A5%BC+%EB%B0%B0%EC%9A%B0%EB%8B%A4%2C+%EC%97%AC%EA%B8%B0%EC%84%9C+X%3DGo">
        페이지 공유
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">테마 선택 :</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">밝은</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">어두운</button>
  </div>
  <h1><a href="/">Y분에 X를 배우다</a></h1>
  <h2>여기서 X=Go</h2>
    <p class="filelink">
    코드를 다운받다:
    <a href="/docs/files/learngo-kr.go">learngo-kr.go</a>
    </p>
  <div id="doc">
    <p>Go는 어떤 일을 잘 끝낼 수 있도록 하기위해 만들어졌다. Go가 잘 알려진 최신의
트렌드는 아니지만, 실세계의 문제들을 해결하기 위해서는 가장
새롭고 빠른 방법이다.</p>

<p>Go는 정적 타이핑(static typing)의 명령형 언어들(imperative languages)이
갖고 있는 특징과 유사한 개념들을 가지고 있다. Go는 컴파일과 실행속도가
빠르며, 오늘날의 멀티코어 CPU를 위해 이해하기 쉬운 동시성(concurrency)
기능이 추가되었다. 그리고 큰 스케일의 프로그래밍에도 도움이 되는
기능들을 가지고 있다.</p>

<p>또한 Go에는 훌륭한 표준 라이브러리와 열정적인 커뮤니티가 있다.</p>
<div class="highlight"><pre class="highlight go"><code><span class="c">// 한 줄 주석</span>
<span class="c">/* 여러 줄
   주석 */</span>

<span class="c">// 모든 Go 소스 파일은 package로 시작한다.</span>
<span class="c">// 패키지 이름 중 main은 라이브러리가 아닌 실행파일을 선언하는 특별한 이름이다.</span>
<span class="k">package</span> <span class="n">main</span>

<span class="c">// import는 이 Go 소스 파일 내에서 참조하는 라이브러리 패키지들을 선언한다.</span>
<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>      <span class="c">// Go 표준 라이브러리에 있는 패키지</span>
    <span class="s">"net/http"</span> <span class="c">// 표준 라이브러리에는 웹 서버 패키지도 있다! (클라이언트도 있음)</span>
    <span class="s">"strconv"</span>  <span class="c">// 문자열 변환 패키지</span>
<span class="p">)</span>

<span class="c">// 함수 선언. main은 실행 프로그램에서 시작점이 되는 특별한 함수다.</span>
<span class="c">// 중괄호를 사용한다.</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// Println은 표준 출력으로 개행을 출력한다.</span>
    <span class="c">// fmt 패키지를 통해 이용할 수 있다.</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Hello world!"</span><span class="p">)</span>

    <span class="c">// 다른 함수를 호출한다.</span>
    <span class="n">beyondHello</span><span class="p">()</span>
<span class="p">}</span>

<span class="c">// 함수에 파라미터가 없더라도 빈 괄호는 있어야 한다.</span>
<span class="k">func</span> <span class="n">beyondHello</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">x</span> <span class="kt">int</span> <span class="c">// 변수 선언. 변수는 사용하기 전에 선언해야 한다.</span>
    <span class="n">x</span> <span class="o">=</span> <span class="m">3</span>     <span class="c">// 변수에 값 할당.</span>
    <span class="c">// 짧은 선언(short declaration)으로 := 를 사용하는데,</span>
    <span class="c">// 이렇게 값을 할당하면 값의 타입에 따라 변수의 타입이 결정된다.</span>
    <span class="n">y</span> <span class="o">:=</span> <span class="m">4</span>
    <span class="n">sum</span><span class="p">,</span> <span class="n">prod</span> <span class="o">:=</span> <span class="n">learnMultiple</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>        <span class="c">// 함수는 두 개 이상의 리턴 값을 줄 수 있다.</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"sum:"</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="s">"prod:"</span><span class="p">,</span> <span class="n">prod</span><span class="p">)</span> <span class="c">// 간단한 출력</span>
    <span class="n">learnTypes</span><span class="p">()</span>                            <span class="c">// 잠시 후에 좀더 자세히!</span>
<span class="p">}</span>

<span class="c">// 함수는 파라미터들을 가질 수 있고, 복수개의 값을 리턴할 수 있다.</span>
<span class="k">func</span> <span class="n">learnMultiple</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">sum</span><span class="p">,</span> <span class="n">prod</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="c">// 두 개의 값을 리턴.</span>
<span class="p">}</span>

<span class="c">// 내장 타입과 리터럴</span>
<span class="k">func</span> <span class="n">learnTypes</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// 짧은 선언은 유용하다.</span>
    <span class="n">s</span> <span class="o">:=</span> <span class="s">"Learn Go!"</span> <span class="c">// string 타입</span>

    <span class="n">s2</span> <span class="o">:=</span> <span class="s">`역따옴표 안의 string 리터럴은
개행을 포함할 수 있다.`</span> <span class="c">// 같은 string 타입</span>

    <span class="c">// non-ASCII 리터럴. Go 소스는 UTF-8로 작성해야 한다.</span>
    <span class="n">g</span> <span class="o">:=</span> <span class="sc">'Σ'</span> <span class="c">// 유니코드 코드 포인트를 담고 있고, int32 타입의 가칭(alias)인 rune 타입</span>

    <span class="n">f</span> <span class="o">:=</span> <span class="m">3.14159</span> <span class="c">// float64, an IEEE-754 64-bit 부동소수 타입</span>
    <span class="n">c</span> <span class="o">:=</span> <span class="m">3</span> <span class="o">+</span> <span class="m">4i</span>  <span class="c">// complex128, 내부적으로는 두 개의 float64 타입으로 표현됨</span>

    <span class="c">// 초기값과 함께 사용하는 var 키워드.</span>
    <span class="k">var</span> <span class="n">u</span> <span class="kt">uint</span> <span class="o">=</span> <span class="m">7</span> <span class="c">// unsigned, 하지만 int에 따른 구현의존적인 크기</span>
    <span class="k">var</span> <span class="n">pi</span> <span class="kt">float32</span> <span class="o">=</span> <span class="m">22.</span> <span class="o">/</span> <span class="m">7</span>

    <span class="c">// 짧은 선언으로 변환(conversion)하는 문법.</span>
    <span class="c">// Go에서는 type casting 이라고 하지않고 type conversion 이라고 함.</span>
    <span class="n">n</span> <span class="o">:=</span> <span class="kt">byte</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">)</span> <span class="c">// byte는 uint8의 가칭(alias)</span>

    <span class="c">// 배열은 컴파일 시에 크기가 정해진다.</span>
    <span class="k">var</span> <span class="n">a4</span> <span class="p">[</span><span class="m">4</span><span class="p">]</span><span class="kt">int</span>           <span class="c">// 모두 0으로 초기화되는 int 타입 4개짜리 배열</span>
    <span class="n">a3</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="m">3</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">5</span><span class="p">}</span> <span class="c">// 3, 1, 5로 초기화되는 int 타입 3개짜리 배열</span>

    <span class="c">// 슬라이스(slice)라고 하는 타입은 배열에 대한 가변 크기를 가진다.</span>
    <span class="c">// 배열, 슬라이스 각자 장점이 있지만, 슬라이스가 더 많이 사용된다.</span>
    <span class="n">s3</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">9</span><span class="p">}</span>    <span class="c">// 위의 a3와 비교해보면 생략부호(...)가 없다.</span>
    <span class="n">s4</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">4</span><span class="p">)</span>    <span class="c">// 모두 0으로 초기화되는 int 4개에 대한 슬라이스를 할당.</span>
    <span class="k">var</span> <span class="n">d2</span> <span class="p">[][]</span><span class="kt">float64</span>      <span class="c">// 여기에서는 선언만 있고 할당은 없다.</span>
    <span class="n">bs</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"a slice"</span><span class="p">)</span> <span class="c">// string 타입을 byte 슬라이스 타입으로 형변환(type conversion)</span>

    <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">learnMemory</span><span class="p">()</span> <span class="c">// int에 대한 포인터 타입인 p와 q를 선언</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>   <span class="c">// C에서처럼 *는 포인터를 따라가 값을 참조한다. 여기서는 두 개의 int를 출력.</span>

    <span class="c">// 맵(map)은 다른 언어의 해시(hash)나 딕셔너리(dictionary)처럼 가변의 연관배열 타입.</span>
    <span class="n">m</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">"three"</span><span class="o">:</span> <span class="m">3</span><span class="p">,</span> <span class="s">"four"</span><span class="o">:</span> <span class="m">4</span><span class="p">}</span>
    <span class="n">m</span><span class="p">[</span><span class="s">"one"</span><span class="p">]</span> <span class="o">=</span> <span class="m">1</span>

    <span class="c">// 선언만 하고 사용하지 않는 변수가 있다면 Go에서는 컴파일 시 에러가 난다.</span>
    <span class="c">// 언더바를 이용해서 변수를 사용한 것처럼 하고 그 값은 무시해버릴 수 있다.</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">s2</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">s4</span><span class="p">,</span> <span class="n">bs</span>
    <span class="c">// 물론 출력을 하면 변수로 취급한다.</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">a4</span><span class="p">,</span> <span class="n">s3</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="n">learnFlowControl</span><span class="p">()</span> <span class="c">// 잠시 후에 다시 나옴</span>
<span class="p">}</span>

<span class="c">// Go는 가비지 컬렉션 기능을 JVM 같은 곳이 아닌 실행파일 런타임에 포함하고 있다.</span>
<span class="c">// 그리고 포인터는 있지만, 포인터 연산(*p++ 같은)은 없다.</span>
<span class="c">// 그래서 nil 포인터 접근같은 것 때문에 실수를 할 수는 있지만</span>
<span class="c">// 포인터 연산으로 인한 실수는 없게 된다.</span>
<span class="k">func</span> <span class="n">learnMemory</span><span class="p">()</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">*</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// 지명된 리턴 값(named return value)인 p와 q는 int에 대한 포인터 타입이다.</span>
    <span class="n">p</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="c">// 내장함수인 new는 메모리를 할당해준다.</span>
    <span class="c">// 메모리 할당된 int는 0으로 초기화 되고, p는 이제 nil이 아니다.</span>
    <span class="n">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">20</span><span class="p">)</span> <span class="c">// 메모리의 단일 블록으로 20개의 int 공간을 할당한다.</span>
    <span class="n">s</span><span class="p">[</span><span class="m">3</span><span class="p">]</span> <span class="o">=</span> <span class="m">7</span>             <span class="c">// 그중 하나에 값을 준다.</span>
    <span class="n">r</span> <span class="o">:=</span> <span class="o">-</span><span class="m">2</span>              <span class="c">// 또다른 로컬 변수를 선언한다.</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="m">3</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">r</span>     <span class="c">// &amp;는 어떤 대상체의 메모리 주소를 가져오게 된다.</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">expensiveComputation</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="m">1e6</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">learnFlowControl</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// if문에 중괄호는 필요하지만, 조건이 들어갈 곳에 소괄호는 쓰지 않는다.</span>
    <span class="k">if</span> <span class="no">true</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"told ya"</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c">// 모든 Go 소스의 코드 포맷팅은 "go fmt" 커맨드라인 명령으로 소스코드의 포맷을 맞춘다.</span>
    <span class="k">if</span> <span class="no">false</span> <span class="p">{</span>
        <span class="c">// pout</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c">// gloat</span>
    <span class="p">}</span>
    <span class="c">// if-else 체인 형태보다 switch 사용이 권장된다.</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="m">1</span>
    <span class="k">switch</span> <span class="n">x</span> <span class="p">{</span>
    <span class="k">case</span> <span class="m">0</span><span class="o">:</span>
    <span class="k">case</span> <span class="m">1</span><span class="o">:</span>
        <span class="c">// case 안에서는 break가 없어도 자동으로 다음 case로 내려가지 않는다.</span>
        <span class="c">// 자동으로 내려가게 하려면 fallthrough 키워드를 사용한다.</span>
    <span class="k">case</span> <span class="m">2</span><span class="o">:</span>
        <span class="c">// x는 1이므로 여기는 실행되지 않음.</span>
    <span class="p">}</span>
    <span class="c">// if 에서처럼 for 에서도 양쪽에 소괄호를 쓰지 않는다.</span>
    <span class="k">for</span> <span class="n">x</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span> <span class="p">{</span> <span class="c">// ++ 은 실행을 제어하는 하나의 구문(statement)이다.</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"iteration"</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c">// 여기서 x는 1이다. 위 for에서 x는 for 안의 블록 범위에 있기 때문.</span>

    <span class="c">// For is the only loop statement in Go, but it has alternate forms.</span>
    <span class="c">// for 는 Go에서 유일한 루프 구문이지만 다양한 형태로 조건을 주거나 while </span>
    <span class="c">// 처럼 쓸 수도 있다.</span>
    <span class="k">for</span> <span class="p">{</span> <span class="c">// 무한루프</span>
        <span class="k">break</span>    <span class="c">// 여기서 곧바로 break를 한 건 단지</span>
        <span class="k">continue</span> <span class="c">// break, continue를 루프 안에서 쓸 수 있다는 것을 보여주기 위함.</span>
    <span class="p">}</span>
    <span class="c">// for 에서처럼 if 에서 := 를 사용하는것은 y에 먼저 값을 대입하고,</span>
    <span class="c">// 그리고 y &gt; x를 검사한다는 의미.</span>
    <span class="k">if</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">expensiveComputation</span><span class="p">();</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">y</span>
    <span class="p">}</span>
    <span class="c">// 함수 리터럴은 클로저다.</span>
    <span class="n">xBig</span> <span class="o">:=</span> <span class="k">func</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="m">100</span> <span class="c">// 위 switch 문 바로 위에 있는 x를 참조한다.</span>
    <span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"xBig:"</span><span class="p">,</span> <span class="n">xBig</span><span class="p">())</span> <span class="c">// true (x에 1e6를 대입했었다.)</span>
    <span class="n">x</span> <span class="o">/=</span> <span class="m">1e5</span> <span class="c">// x는 10이 된다.</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"xBig:"</span><span class="p">,</span> <span class="n">xBig</span><span class="p">())</span> <span class="c">// 이제 xBig()의 결과는 false가 된다.</span>

    <span class="c">// `goto`가 필요하다면, 좋아하게 될지도...</span>
    <span class="k">goto</span> <span class="n">love</span>
<span class="n">love</span><span class="o">:</span>

    <span class="n">learnDefer</span><span class="p">()</span>      <span class="c">// defer에 대해</span>
    <span class="n">learnInterfaces</span><span class="p">()</span> <span class="c">// 곧이어서 좋은 기능에 대한 설명이 나올 거다.</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">learnDefer</span><span class="p">()</span> <span class="p">(</span><span class="n">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// deferred statements are executed just before the function returns.</span>
    <span class="c">// 연기된(deferred) 구문은 함수가 리턴하기 직전에 실행된다.</span>
    <span class="k">defer</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"deferred statements execute in reverse (LIFO) order."</span><span class="p">)</span> <span class="c">// 연기된 구문은 LIFO순으로 실행된다.</span>
    <span class="k">defer</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">This line is being printed first because"</span><span class="p">)</span>           <span class="c">// 이 줄이 먼저 실행된다.</span>
    <span class="c">// defer는 주로 파일을 닫는데 사용된다. </span>
    <span class="c">// 파일을 닫는함수를 파일을 여는함수에 가까이 둘수 있다.</span>
    <span class="k">return</span> <span class="no">true</span>
<span class="p">}</span>

<span class="c">// String 이라는 메서드 하나를 가진 Stringer 라는 인터페이스 타입을 정의하자.</span>
<span class="k">type</span> <span class="n">Stringer</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c">// x와 y라는 이름의 int 타입 필드를 가진 pair라는 struct를 정의하자.</span>
<span class="k">type</span> <span class="n">pair</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="c">// pair 타입에 메서드 String을 정의하자.</span>
<span class="c">// 이제 pair는 Stringer 인터페이스를 구현(implement)한 것이 되었다.</span>
<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="n">pair</span><span class="p">)</span> <span class="n">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="c">// 여기서 p는 리시버(receiver)라고 부른다.</span>
    <span class="c">// Sprintf는 fmt 패키지 안에 있는 외부로 공개된(exported) 함수다.</span>
    <span class="c">// 점(.)으로 p의 필드들을 참조할 수 있다.</span>
    <span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"(%d, %d)"</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">learnInterfaces</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// 중괄호 문법은 "구조체 리터럴(struct literal)"인데, 초기화된 구조체로</span>
    <span class="c">// 취급하게 해준다. := 문법으로 p를 이 구조체로 선언하고 초기화한다.</span>
    <span class="n">p</span> <span class="o">:=</span> <span class="n">pair</span><span class="p">{</span><span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">String</span><span class="p">())</span> <span class="c">// 타입 pair인 p의 String 메서드를 호출.</span>
    <span class="k">var</span> <span class="n">i</span> <span class="n">Stringer</span>          <span class="c">// Stringer 인터페이스 타입 i를 선언.</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">p</span>                   <span class="c">// pair는 Stringer를 구현했기 때문에 이 대입은 유효하다.</span>
    <span class="c">// 타입 Stringer인 i의 String 메서드 호출. 결과는 위와 같다.</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">String</span><span class="p">())</span>

    <span class="c">// fmt 패키지의 함수들을 통해 어떤 객체를 출력해보려고 할 때,</span>
    <span class="c">// fmt 패키지 내에서는 그 객체가 가진 String 메서드를 호출하도록 되어 있다.</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="c">// 결과는 위와 같다. Println은 String 메서드를 호출한다.</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c">// 결과는 위와 같다.</span>

    <span class="n">learnVariadicParams</span><span class="p">(</span><span class="s">"great"</span><span class="p">,</span> <span class="s">"learning"</span><span class="p">,</span> <span class="s">"here!"</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// 함수는 가변 인수(variadic) 파라미터를 가질수 있다.</span>
<span class="k">func</span> <span class="n">learnVariadicParams</span><span class="p">(</span><span class="n">myStrings</span> <span class="o">...</span><span class="k">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="c">// 가변 인수를 차례로 반복한다.</span>
    <span class="c">// 여기서 언더바(언더스코어, `_`)는 배열의 인덱스 인수를 무시한다.</span>
    <span class="c">// The underbar here is ignoring the index argument of the array.</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">param</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">myStrings</span> <span class="p">{</span>
          <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"param:"</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c">// 가변 인수 값을 가변인수 파라미터로 보내기.</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"params:"</span><span class="p">,</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintln</span><span class="p">(</span><span class="n">myStrings</span><span class="o">...</span><span class="p">))</span>

    <span class="n">learnErrorHandling</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">learnErrorHandling</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// ", ok" (comma okay)표현은 무언가가 맞는 것인지 아닌지 확인하는데 사용된다.</span>
    <span class="n">m</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="m">3</span><span class="o">:</span> <span class="s">"three"</span><span class="p">,</span> <span class="m">4</span><span class="o">:</span> <span class="s">"four"</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">x</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">m</span><span class="p">[</span><span class="m">1</span><span class="p">];</span> <span class="o">!</span><span class="n">ok</span> <span class="p">{</span> <span class="c">// 이 map 안에 키가 1인 것은 없으므로 ok는 false가 된다.</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"no one there"</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c">// 만일 1이 map에 있었다면 x는 키 1의 값이 들어가게 된다.</span>
    <span class="p">}</span>

    <span class="c">// Go에서는 함수가 복수 개의 리턴 값을 줄 수 있다는 점을 활용해 함수의 두 번째 리턴</span>
    <span class="c">// 값으로 error를 리턴해주고 그 error가 nil 인지 아닌지 확인하는 관례가 있다.</span>
    <span class="c">// 이때 이 error 값은 단지 위에서처럼 함수의 결과가 성공했는지 실패했는지를 확인하는</span>
    <span class="c">// 것뿐만 아니라 실패 시 어떤 문제가 있었는지 확인할 수 있는 수단도 된다.</span>
    <span class="k">if</span> <span class="n">_</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">strconv</span><span class="o">.</span><span class="n">Atoi</span><span class="p">(</span><span class="s">"non-int"</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span> <span class="c">// _ 는 값을 안 쓰고 버린다는 의미.</span>
        <span class="c">// "strconv.ParseInt: parsing "non-int": invalid syntax" 이런 에러가 출력된다.</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c">// 인터페이스에 대해 잠시 후에 다시 잠깐 볼 것이다.</span>
    <span class="n">learnConcurrency</span><span class="p">()</span>
<span class="p">}</span>

<span class="c">// c는 goroutine 간의 통신을 위한 채널(channel)이다.</span>
<span class="k">func</span> <span class="n">inc</span><span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">,</span> <span class="n">c</span> <span class="k">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">c</span> <span class="o">&lt;-</span> <span class="n">i</span> <span class="o">+</span> <span class="m">1</span> <span class="c">// 채널이 &lt;- 이 연산자 왼쪽에 온다면 그 채널로 데이터를 보낸다는 의미다.</span>
<span class="p">}</span>

<span class="c">// 우리는 어떤 숫자들을 동시에 증가시키기 위해 inc 함수를 사용할 것이다.</span>
<span class="k">func</span> <span class="n">learnConcurrency</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// make는 slice, map, channel 타입들에 대해 메모리를 할당하고 초기화를 한다.</span>
    <span class="c">// Go에는 메모리 할당 방법으로 new와 make가 있다.</span>
    <span class="n">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
    <span class="c">// 3개의 동시에 실행되는 goroutine를 시작한다. 만약 실행하고 있는 머신이</span>
    <span class="c">// 멀티코어 CPU를 가지고 있고 올바르게 설정되어(GOMAXPROCS) 있다면</span>
    <span class="c">// 숫자가 정말로 병렬적으로 증가하게 될 것이다.</span>
    <span class="k">go</span> <span class="n">inc</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="c">// go는 새로운 goroutine을 시작하는 구문이다.</span>
    <span class="k">go</span> <span class="n">inc</span><span class="p">(</span><span class="m">10</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
    <span class="k">go</span> <span class="n">inc</span><span class="p">(</span><span class="o">-</span><span class="m">805</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
    <span class="c">// 채널로부터 3개의 결과를 읽어 출력한다.</span>
    <span class="c">// 결과가 어떤 순서로 오는지는 알 수 없다.</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="n">c</span><span class="p">,</span> <span class="o">&lt;-</span><span class="n">c</span><span class="p">,</span> <span class="o">&lt;-</span><span class="n">c</span><span class="p">)</span> <span class="c">// 채널이 &lt;- 연산자 오른쪽에 있는 건, 채널로부터 데이터를 받는 연산이다.</span>

    <span class="n">cs</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">string</span><span class="p">)</span>       <span class="c">// string을 다루는 또 다른 채널</span>
    <span class="n">cc</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">chan</span> <span class="kt">string</span><span class="p">)</span>  <span class="c">// string 채널의 채널</span>
    <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">c</span> <span class="o">&lt;-</span> <span class="m">84</span> <span class="p">}()</span>       <span class="c">// c 채널로 값을 보내는 goroutine 시작.</span>
    <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">cs</span> <span class="o">&lt;-</span> <span class="s">"wordy"</span> <span class="p">}()</span> <span class="c">// cs 채널로 값을 보내느 goroutine 시작.</span>
    <span class="c">// select 구문은 switch 문과 비슷하지만, case에서 채널 연산에 관한 일을 한다.</span>
    <span class="c">// select의 case들은 채널통신을 할 준비가 된 case 하나가 무작위로 선택되어 </span>
    <span class="c">// 그 부분이 실행된다.</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">i</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">c</span><span class="o">:</span> <span class="c">// 채널로부터 받아진 값은 변수에 대입할 수 있다.</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"it's a %T"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="n">cs</span><span class="o">:</span> <span class="c">// 또는 받은 값을 그냥 버릴 수도 있다.</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"it's a string"</span><span class="p">)</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="n">cc</span><span class="o">:</span> <span class="c">// 통신할 준비가 되어 있지 않은 비어있는 채널.</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"didn't happen."</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c">// 여기서는 c나 cs 채널로부터 값 하나를 받을 수 있다. 위에서 실행한 두 개의</span>
    <span class="c">// goroutine 중 하나가 완료되면 다른 하나는 블락된 상태로 있게 된다.</span>

    <span class="n">learnWebProgramming</span><span class="p">()</span> <span class="c">// Go에서는 웹 서버쪽 개발도 쉽게 할 수 있다.</span>
<span class="p">}</span>

<span class="c">// http 패키지의 함수 하나로 웹 서버를 실행시킨다.</span>
<span class="k">func</span> <span class="n">learnWebProgramming</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// ListenAndServe의 첫 번째 파라미터는 listen 하기 위한 TCP 주소고,</span>
    <span class="c">// 두 번째 파라미터는 http.Handler 인터페이스다.</span>
    <span class="n">err</span> <span class="o">:=</span> <span class="n">http</span><span class="o">.</span><span class="n">ListenAndServe</span><span class="p">(</span><span class="s">":8080"</span><span class="p">,</span> <span class="n">pair</span><span class="p">{})</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="c">// don't ignore errors</span>
<span class="p">}</span>

<span class="c">// http.Handler의 하나 뿐인 메서드, ServeHTTP를 pair에서 구현한다.</span>
<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="n">pair</span><span class="p">)</span> <span class="n">ServeHTTP</span><span class="p">(</span><span class="n">w</span> <span class="n">http</span><span class="o">.</span><span class="n">ResponseWriter</span><span class="p">,</span> <span class="n">r</span> <span class="o">*</span><span class="n">http</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// http.ResponseWriter의 메서드로 클라이언트에게 데이터를 보낸다.</span>
    <span class="n">w</span><span class="o">.</span><span class="n">Write</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"You learned Go in Y minutes!"</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>
<h2>더 읽어볼 것들</h2>

<p>Go에 대한 모든 것들은 <a href="https://go.dev/">Go 공식 웹 사이트</a>를 참고하자.
여기에는 따라해볼 튜토리얼, 웹 기반의 인터랙티브 실행환경과 많은 읽을거리들이 있다.</p>

<p>Go 언어 자체에 대한 스펙도 읽어보기를 적극 추천한다. 읽기 쉽게 되어있고
그리 길지는 않다.</p>

<p>Go 소스코드에 대해 좀더 알아보고 싶다면 <a href="https://go.dev/src/">Go 표준 라이브러리</a>를
분석해보기 바란다. 이해하기 쉽게 문서화되어 있고, Go 스타일 그리고 Go에서의
관례 배우기에 가장 좋은 방법일 것이다. 또는 <a href="https://go.dev/pkg/">문서</a> 안에서
함수 이름 하나를 클릭해보면 소스코드를 브라우저에서 살펴볼 수도 있다.</p>

<p>Go를 배울수 있는 또하나의 좋은 방법은 <a href="https://gobyexample.com/">Go by example</a>.</p>

    <hr>
    <p>제안이 있으세요? 아니면 실수를 찾으셨어요? Github에서 <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">issue</a> 또는 <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/ko-kr/go-kr.html.markdown">pull request</a>를 만드세요
    </p>
    <p class="contributed">
    원작자는 Sonia Keys, 그리고 <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/ko-kr/go-kr.html.markdown">8 기여자들</a> 수정했다
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="https://github.com/soniakeys">Sonia Keys</a>,
        <a href="https://github.com/cbess">Christopher Bess</a>,
        <a href="https://github.com/holocronweaver">Jesse Johnson</a>,
        <a href="https://github.com/qguv">Quint Guvernator</a>
    </p>

    <p>
      Translated by:
        <a href="http://github.com/atomaths">Jongmin Kim</a>
        <a href="http://github.com/ins429">Peter Lee</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
