<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="en-us" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="en-us" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="en-us" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="en-us" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="en-us">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Raku in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/raku/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }
                el.className = theme === "dark" ? "dark" : "light";
                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (!theme) {
                theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"
              }
              set_theme(theme)
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.onload = function(){
              load_theme();
            };

            // Listen for system preference change
            window
              .matchMedia("(prefers-color-scheme: dark)")
              .addEventListener("change", ({matches:isDark}) => {
                set_theme(isDark ? "dark" : "light")
              })
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fraku%2F&text=Learn+X+in+Y+minutes%2C+where+X%3DRaku">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="/">Learn X in Y minutes</a></h1>
  <h2>Where X=Raku</h2>
    <p class="filelink">
    Get the code:
    <a href="/docs/files/learnraku.raku">learnraku.raku</a>
    </p>
  <div id="doc">
    <p>Raku (formerly Perl 6) is a highly capable, feature-rich programming language
made for at least the next hundred years.</p>

<p>The primary Raku compiler is called <a href="http://rakudo.org">Rakudo</a>, which runs on
the JVM and the <a href="http://moarvm.com">MoarVM</a>.</p>

<p>Meta-note:</p>

<ul>
<li>Although the pound sign (<code>#</code>) is used for sentences and notes, Pod-styled
comments (more below about them) are used whenever it&rsquo;s convenient.</li>
<li><code># OUTPUT:</code> is used to represent the output of a command to any standard
stream. If the output has a newline, it&rsquo;s represented by the <code>␤</code> symbol.
The output is always enclosed by angle brackets (<code>«</code> and <code>»</code>).</li>
<li><code>#=&gt;</code> represents the value of an expression, return value of a sub, etc.
In some cases, the value is accompanied by a comment.</li>
<li>Backticks are used to distinguish and highlight the language constructs
from the text.</li>
</ul>
<div class="highlight"><pre><span></span><span class="c1">####################################################</span>
<span class="c1"># 0. Comments</span>
<span class="c1">####################################################</span>

<span class="c1"># Single line comments start with a pound sign.</span>

<span class="cm">#`( Multiline comments use #` and a quoting construct.</span>
<span class="cm">  (), [], {}, 「」, etc, will work.</span>
<span class="cm">)</span>

<span class="cm">=for comment</span>
<span class="cm">Use the same syntax for multiline comments to embed comments.</span>
<span class="cm">for #`(each element in) @array {</span>
<span class="cm">    put #`(or print element) $_ #`(with newline);</span>
<span class="cm">}</span>

<span class="c1"># You can also use Pod-styled comments. For example:</span>

<span class="cm">=comment This is a comment that extends until an empty</span>
<span class="cm">newline is found.</span>

<span class="cm">=comment</span>
<span class="cm">The comment doesn&#39;t need to start in the same line as the directive.</span>

<span class="cm">=begin comment</span>
<span class="cm">This comment is multiline.</span>

<span class="cm">Empty newlines can exist here too!</span>
<span class="cm">=end comment</span>

<span class="c1">####################################################</span>
<span class="c1"># 1. Variables</span>
<span class="c1">####################################################</span>

<span class="c1"># In Raku, you declare a lexical variable using the `my` keyword:</span>
<span class="k">my</span> <span class="nv">$variable</span>;

<span class="c1"># Raku has 3 basic types of variables: scalars, arrays, and hashes.</span>

<span class="c1">#</span>
<span class="c1"># 1.1 Scalars</span>
<span class="c1">#</span>

<span class="c1"># Scalars represent a single value. They start with the `$` sigil:</span>
<span class="k">my</span> <span class="nv">$str</span> = <span class="s">&#39;String&#39;</span>;

<span class="c1"># Double quotes allow for interpolation (which we&#39;ll see later):</span>
<span class="k">my</span> <span class="nv">$str2</span> = <span class="s">&quot;$str&quot;</span>;

<span class="c1"># Variable names can contain but not end with simple quotes and dashes,</span>
<span class="c1"># and can contain (and end with) underscores:</span>
<span class="k">my</span> <span class="nv">$person&#39;s-belongings</span> = <span class="s">&#39;towel&#39;</span>; <span class="c1"># this works!</span>

<span class="k">my</span> <span class="nv">$bool</span> = <span class="nb">True</span>;             <span class="c1"># `True` and `False` are Raku&#39;s boolean values.</span>
<span class="k">my</span> <span class="nv">$inverse</span> = !<span class="nv">$bool</span>;        <span class="c1"># Invert a bool with the prefix `!` operator.</span>
<span class="k">my</span> <span class="nv">$forced-bool</span> = <span class="nb">so</span> <span class="nv">$str</span>;   <span class="c1"># And you can use the prefix `so` operator</span>
<span class="nv">$forced-bool</span> = ?<span class="nv">$str</span>;        <span class="c1"># to turn its operand into a Bool. Or use `?`.</span>

<span class="c1">#</span>
<span class="c1"># 1.2 Arrays and Lists</span>
<span class="c1">#</span>

<span class="c1"># Arrays represent multiple values. An array variable starts with the `@`</span>
<span class="c1"># sigil. Unlike lists, from which arrays inherit, arrays are mutable.</span>

<span class="k">my</span> <span class="nv">@array</span> = <span class="s">&#39;a&#39;</span>, <span class="s">&#39;b&#39;</span>, <span class="s">&#39;c&#39;</span>;
<span class="c1"># equivalent to:</span>
<span class="k">my</span> <span class="nv">@letters</span> = <span class="s">&lt;a b c&gt;</span>;
<span class="c1"># In the previous statement, we use the quote-words (`&lt;&gt;`) term for array</span>
<span class="c1"># of words, delimited by space. Similar to perl&#39;s qw, or Ruby&#39;s %w.</span>

<span class="nv">@array</span> = <span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">4</span>;

<span class="c1"># Array indices start at 0. Here the third element is being accessed.</span>
<span class="nb">say</span> <span class="nv">@array</span>[<span class="mi">2</span>]; <span class="c1"># OUTPUT: «4␤»</span>

<span class="nb">say</span> <span class="s">&quot;Interpolate an array using []: @array[]&quot;</span>;
<span class="c1"># OUTPUT: «Interpolate an array using []: 1 2 3␤»</span>

<span class="nv">@array</span>[<span class="mi">0</span>]    = -<span class="mi">1</span>;     <span class="c1"># Assigning a new value to an array index</span>
<span class="nv">@array</span>[<span class="mi">0</span>, <span class="mi">1</span>] = <span class="mi">5</span>, <span class="mi">6</span>;   <span class="c1"># Assigning multiple values</span>

<span class="k">my</span> <span class="nv">@keys</span> = <span class="mi">0</span>, <span class="mi">2</span>;
<span class="nv">@array</span>[<span class="nv">@keys</span>] = <span class="nv">@letters</span>; <span class="c1"># Assignment using an array containing index values</span>
<span class="nb">say</span> <span class="nv">@array</span>;               <span class="c1"># OUTPUT: «a 6 b␤»</span>

<span class="c1">#</span>
<span class="c1"># 1.3 Hashes, or key-value Pairs.</span>
<span class="c1">#</span>

<span class="c1"># Hashes are pairs of keys and values. You can construct a `Pair` object</span>
<span class="c1"># using the syntax `key =&gt; value`. Hash tables are very fast for lookup,</span>
<span class="c1"># and are stored unordered. Keep in mind that keys get &quot;flattened&quot; in hash</span>
<span class="c1"># context, and any duplicated keys are deduplicated.</span>
<span class="k">my</span> <span class="nv">%hash</span> = <span class="s">&#39;a&#39;</span> =&gt; <span class="mi">1</span>, <span class="s">&#39;b&#39;</span> =&gt; <span class="mi">2</span>;

<span class="c1"># Keys get auto-quoted when the fat comma (`=&gt;`) is used. Trailing commas are</span>
<span class="c1"># okay.</span>
<span class="nv">%hash</span> = <span class="n">a</span> =&gt; <span class="mi">1</span>, <span class="n">b</span> =&gt; <span class="mi">2</span>, ;

<span class="c1"># Even though hashes are internally stored differently than arrays,</span>
<span class="c1"># Raku allows you to easily create a hash from an even numbered array:</span>
<span class="nv">%hash</span> = <span class="s">&lt;key1 value1 key2 value2&gt;</span>;          <span class="c1"># Or:</span>
<span class="nv">%hash</span> = <span class="s">&quot;key1&quot;</span>, <span class="s">&quot;value1&quot;</span>, <span class="s">&quot;key2&quot;</span>, <span class="s">&quot;value2&quot;</span>;

<span class="nv">%hash</span> = <span class="n">key1</span> =&gt; <span class="s">&#39;value1&#39;</span>, <span class="n">key2</span> =&gt; <span class="s">&#39;value2&#39;</span>; <span class="c1"># same result as above</span>

<span class="c1"># You can also use the &quot;colon pair&quot; syntax. This syntax is especially</span>
<span class="c1"># handy for named parameters that you&#39;ll see later.</span>
<span class="nv">%hash</span> = :<span class="n">n</span>(<span class="mi">2</span>),    <span class="c1"># equivalent to `n =&gt; 2`</span>
        :<span class="n">is-even</span>, <span class="c1"># equivalent to `:is-even(True)` or `is-even =&gt; True`</span>
        :!<span class="n">is-odd</span>, <span class="c1"># equivalent to `:is-odd(False)` or `is-odd =&gt; False`</span>
;
<span class="c1"># The `:` (as in `:is-even`) and `:!` (as `:!is-odd`) constructs are known</span>
<span class="c1"># as the `True` and `False` shortcuts respectively.</span>

<span class="c1"># As demonstrated in the example below, you can use {} to get the value from a key.</span>
<span class="c1"># If it&#39;s a string without spaces, you can actually use the quote-words operator</span>
<span class="c1"># (`&lt;&gt;`). Since Raku doesn&#39;t have barewords, as Perl does, `{key1}` doesn&#39;t work</span>
<span class="c1"># though.</span>
<span class="nb">say</span> <span class="nv">%hash</span>{<span class="s">&#39;n&#39;</span>};     <span class="c1"># OUTPUT: «2␤», gets value associated to key &#39;n&#39;</span>
<span class="nb">say</span> <span class="nv">%hash&lt;is-even&gt;</span>; <span class="c1"># OUTPUT: «True␤», gets value associated to key &#39;is-even&#39;</span>

<span class="c1">####################################################</span>
<span class="c1"># 2. Subroutines</span>
<span class="c1">####################################################</span>

<span class="c1"># Subroutines, or functions as most other languages call them, are</span>
<span class="c1"># created with the `sub` keyword.</span>
<span class="k">sub</span> <span class="n">say-hello</span> { <span class="nb">say</span> <span class="s">&quot;Hello, world&quot;</span> }

<span class="c1"># You can provide (typed) arguments. If specified, the type will be checked</span>
<span class="c1"># at compile-time if possible, otherwise at runtime.</span>
<span class="k">sub</span> <span class="n">say-hello-to</span>( <span class="nb">Str</span> <span class="nv">$name</span> ) {
    <span class="nb">say</span> <span class="s">&quot;Hello, $name !&quot;</span>;
}

<span class="c1"># A sub returns the last value of the block. Similarly, the semicolon in</span>
<span class="c1"># the last expression can be omitted.</span>
<span class="k">sub</span> <span class="n">return-value</span> { <span class="mi">5</span> }
<span class="nb">say</span> <span class="n">return-value</span>;      <span class="c1"># OUTPUT: «5␤»</span>

<span class="k">sub</span> <span class="n">return-empty</span> { }
<span class="nb">say</span> <span class="n">return-empty</span>;      <span class="c1"># OUTPUT: «Nil␤»</span>

<span class="c1"># Some control flow structures produce a value, for instance `if`:</span>
<span class="k">sub</span> <span class="n">return-if</span> {
    <span class="k">if</span> <span class="nb">True</span> { <span class="s">&quot;Truthy&quot;</span> }
}
<span class="nb">say</span> <span class="n">return-if</span>;         <span class="c1"># OUTPUT: «Truthy␤»</span>

<span class="c1"># Some don&#39;t, like `for`:</span>
<span class="k">sub</span> <span class="n">return-for</span> {
    <span class="k">for</span> <span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span> { <span class="s">&#39;Hi&#39;</span> }
}
<span class="nb">say</span> <span class="n">return-for</span>;        <span class="c1"># OUTPUT: «Nil␤»</span>

<span class="c1"># Positional arguments are required by default. To make them optional, use</span>
<span class="c1"># the `?` after the parameters&#39; names.</span>

<span class="c1"># In the following example, the sub `with-optional` returns `(Any)` (Perl&#39;s</span>
<span class="c1"># null-like value) if no argument is passed. Otherwise, it returns its argument.</span>
<span class="k">sub</span> <span class="n">with-optional</span>( <span class="nv">$arg</span>? ) {
    <span class="nv">$arg</span>;
}
<span class="n">with-optional</span>;     <span class="c1"># returns Any</span>
<span class="n">with-optional</span>();   <span class="c1"># returns Any</span>
<span class="n">with-optional</span>(<span class="mi">1</span>);  <span class="c1"># returns 1</span>

<span class="c1"># You can also give provide a default value when they&#39;re not passed. Doing</span>
<span class="c1"># this make said parameter optional. Required parameters must come before</span>
<span class="c1"># optional ones.</span>

<span class="c1"># In the sub `greeting`, the parameter `$type` is optional.</span>
<span class="k">sub</span> <span class="n">greeting</span>( <span class="nv">$name</span>, <span class="nv">$type</span> = <span class="s">&quot;Hello&quot;</span> ) {
  <span class="nb">say</span> <span class="s">&quot;$type, $name!&quot;</span>;
}

<span class="n">greeting</span>(<span class="s">&quot;Althea&quot;</span>);                 <span class="c1"># OUTPUT: «Hello, Althea!␤»</span>
<span class="n">greeting</span>(<span class="s">&quot;Arthur&quot;</span>, <span class="s">&quot;Good morning&quot;</span>); <span class="c1"># OUTPUT: «Good morning, Arthur!␤»</span>

<span class="c1"># You can also, by using a syntax akin to the one of hashes (yay unified syntax!),</span>
<span class="c1"># declared named parameters and thus pass named arguments to a subroutine.</span>
<span class="c1"># By default, named parameter are optional and will default to `Any`.</span>
<span class="k">sub</span> <span class="n">with-named</span>( <span class="nv">$normal-arg</span>, :<span class="nv">$named</span> ) {
    <span class="nb">say</span> <span class="nv">$normal-arg</span> + <span class="nv">$named</span>;
}
<span class="n">with-named</span>(<span class="mi">1</span>, <span class="nb">named</span> =&gt; <span class="mi">6</span>); <span class="c1"># OUTPUT: «7␤»</span>

<span class="c1"># There&#39;s one gotcha to be aware of, here: If you quote your key, Raku</span>
<span class="c1"># won&#39;t be able to see it at compile time, and you&#39;ll have a single `Pair`</span>
<span class="c1"># object as a positional parameter, which means the function subroutine</span>
<span class="c1"># `with-named(1, &#39;named&#39; =&gt; 6);` fails.</span>
<span class="n">with-named</span>(<span class="mi">2</span>, :<span class="n">named</span>(<span class="mi">5</span>));  <span class="c1"># OUTPUT: «7␤»</span>

<span class="c1"># Similar to positional parameters, you can provide your named arguments with</span>
<span class="c1"># default values.</span>
<span class="k">sub</span> <span class="n">named-def</span>( :<span class="nv">$def</span> = <span class="mi">5</span> ) {
    <span class="nb">say</span> <span class="nv">$def</span>;
}
<span class="n">named-def</span>;            <span class="c1"># OUTPUT: «5»</span>
<span class="n">named-def</span>(<span class="n">def</span> =&gt; <span class="mi">15</span>); <span class="c1"># OUTPUT: «15»</span>

<span class="c1"># In order to make a named parameter mandatory, you can append `!` to the</span>
<span class="c1"># parameter. This is the inverse of `?`, which makes a required parameter</span>
<span class="c1"># optional.</span>

<span class="k">sub</span> <span class="n">with-mandatory-named</span>( :<span class="nv">$str</span>! )  {
    <span class="nb">say</span> <span class="s">&quot;$str!&quot;</span>;
}
<span class="n">with-mandatory-named</span>(<span class="n">str</span> =&gt; <span class="s">&quot;My String&quot;</span>); <span class="c1"># OUTPUT: «My String!␤»</span>
<span class="c1"># with-mandatory-named;   # runtime error: &quot;Required named parameter not passed&quot;</span>
<span class="c1"># with-mandatory-named(3);# runtime error: &quot;Too many positional parameters passed&quot;</span>

<span class="c1"># If a sub takes a named boolean argument, you can use the same &quot;short boolean&quot;</span>
<span class="c1"># hash syntax we discussed earlier.</span>
<span class="k">sub</span> <span class="n">takes-a-bool</span>( <span class="nv">$name</span>, :<span class="nv">$bool</span> ) {
    <span class="nb">say</span> <span class="s">&quot;$name takes $bool&quot;</span>;
}
<span class="n">takes-a-bool</span>(<span class="s">&#39;config&#39;</span>, :<span class="n">bool</span>);  <span class="c1"># OUTPUT: «config takes True␤»</span>
<span class="n">takes-a-bool</span>(<span class="s">&#39;config&#39;</span>, :!<span class="n">bool</span>); <span class="c1"># OUTPUT: «config takes False␤»</span>

<span class="c1"># Since parenthesis can be omitted when calling a subroutine, you need to use</span>
<span class="c1"># `&amp;` in order to distinguish between a call to a sub with no arguments and</span>
<span class="c1"># the code object.</span>

<span class="c1"># For instance, in this example we must use `&amp;` to store the sub `say-hello`</span>
<span class="c1"># (i.e., the sub&#39;s code object) in a variable, not a subroutine call.</span>
<span class="k">my</span> <span class="nv">&amp;s</span> = <span class="nv">&amp;say-hello</span>;
<span class="k">my</span> <span class="nv">&amp;other-s</span> = <span class="k">sub</span> { <span class="nb">say</span> <span class="s">&quot;Anonymous function!&quot;</span> }

<span class="c1"># A sub can have a &quot;slurpy&quot; parameter, or what one&#39;d call a</span>
<span class="c1"># &quot;doesn&#39;t-matter-how-many&quot; parameter. This is Raku&#39;s way of supporting variadic</span>
<span class="c1"># functions. For this, you must use `*@` (slurpy) which will &quot;take everything</span>
<span class="c1"># else&quot;. You can have as many parameters *before* a slurpy one, but not *after*.</span>
<span class="k">sub</span> <span class="n">as-many</span>(<span class="nv">$head</span>, *<span class="nv">@rest</span>) {
    <span class="nv">@rest</span>.<span class="nb">join</span>(<span class="s">&#39; / &#39;</span>) ~ <span class="s">&quot; !&quot;</span>;
}
<span class="nb">say</span> <span class="n">as-many</span>(<span class="s">&#39;Happy&#39;</span>, <span class="s">&#39;Happy&#39;</span>, <span class="s">&#39;Birthday&#39;</span>);          <span class="c1"># OUTPUT: «Happy / Birthday !␤»</span>
<span class="nb">say</span> <span class="n">as-many</span>(<span class="s">&#39;Happy&#39;</span>, [<span class="s">&#39;Happy&#39;</span>, <span class="s">&#39;Birthday&#39;</span>], <span class="s">&#39;Day&#39;</span>); <span class="c1"># OUTPUT: «Happy / Birthday / Day !␤»</span>

<span class="c1"># Note that the splat (the *) did not consume the parameter before it.</span>

<span class="c1"># There are other two variations of slurpy parameters in Raku. The previous one</span>
<span class="c1"># (namely, `*@`), known as flattened slurpy, flattens passed arguments. The other</span>
<span class="c1"># two are `**@` and `+@` known as unflattened slurpy and &quot;single argument rule&quot;</span>
<span class="c1"># slurpy respectively. The unflattened slurpy doesn&#39;t flatten its listy</span>
<span class="c1"># arguments (or Iterable ones).</span>
<span class="k">sub</span> <span class="n">b</span>(**<span class="nv">@arr</span>) { <span class="nv">@arr</span>.<span class="nb">perl</span>.<span class="nb">say</span> };
<span class="n">b</span>([<span class="s">&#39;a&#39;</span>, <span class="s">&#39;b&#39;</span>, <span class="s">&#39;c&#39;</span>]);             <span class="c1"># OUTPUT: «[[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;],]»</span>
<span class="n">b</span>(<span class="mi">1</span>, $(<span class="s">&#39;d&#39;</span>, <span class="s">&#39;e&#39;</span>, <span class="s">&#39;f&#39;</span>), [<span class="mi">2</span>, <span class="mi">3</span>]); <span class="c1"># OUTPUT: «[1, (&quot;d&quot;, &quot;e&quot;, &quot;f&quot;), [2, 3]]»</span>
<span class="n">b</span>(<span class="mi">1</span>, [<span class="mi">1</span>, <span class="mi">2</span>], ([<span class="mi">3</span>, <span class="mi">4</span>], <span class="mi">5</span>));      <span class="c1"># OUTPUT: «[1, [1, 2], ([3, 4], 5)]␤»</span>

<span class="c1"># On the other hand, the &quot;single argument rule&quot; slurpy follows the &quot;single argument</span>
<span class="c1"># rule&quot; which dictates how to handle the slurpy argument based upon context and</span>
<span class="c1"># roughly states that if only a single argument is passed and that argument is</span>
<span class="c1"># Iterable, that argument is used to fill the slurpy parameter array. In any</span>
<span class="c1"># other case, `+@` works like `**@`.</span>
<span class="k">sub</span> <span class="n">c</span>(+<span class="nv">@arr</span>) { <span class="nv">@arr</span>.<span class="nb">perl</span>.<span class="nb">say</span> };
<span class="n">c</span>([<span class="s">&#39;a&#39;</span>, <span class="s">&#39;b&#39;</span>, <span class="s">&#39;c&#39;</span>]);             <span class="c1"># OUTPUT: «[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]␤»</span>
<span class="n">c</span>(<span class="mi">1</span>, $(<span class="s">&#39;d&#39;</span>, <span class="s">&#39;e&#39;</span>, <span class="s">&#39;f&#39;</span>), [<span class="mi">2</span>, <span class="mi">3</span>]); <span class="c1"># OUTPUT: «[1, (&quot;d&quot;, &quot;e&quot;, &quot;f&quot;), [2, 3]]␤»</span>
<span class="n">c</span>(<span class="mi">1</span>, [<span class="mi">1</span>, <span class="mi">2</span>], ([<span class="mi">3</span>, <span class="mi">4</span>], <span class="mi">5</span>));      <span class="c1"># OUTPUT: «[1, [1, 2], ([3, 4], 5)]␤»</span>

<span class="c1"># You can call a function with an array using the &quot;argument list flattening&quot;</span>
<span class="c1"># operator `|` (it&#39;s not actually the only role of this operator,</span>
<span class="c1"># but it&#39;s one of them).</span>
<span class="k">sub</span> <span class="n">concat3</span>(<span class="nv">$a</span>, <span class="nv">$b</span>, <span class="nv">$c</span>) {
    <span class="nb">say</span> <span class="s">&quot;$a, $b, $c&quot;</span>;
}
<span class="n">concat3</span>(|<span class="nv">@array</span>); <span class="c1"># OUTPUT: «a, b, c␤»</span>
                  <span class="c1"># `@array` got &quot;flattened&quot; as a part of the argument list</span>

<span class="c1">####################################################</span>
<span class="c1"># 3. Containers</span>
<span class="c1">####################################################</span>

<span class="c1"># In Raku, values are actually stored in &quot;containers&quot;. The assignment</span>
<span class="c1"># operator asks the container on the left to store the value on its right.</span>
<span class="c1"># When passed around, containers are marked as immutable which means that,</span>
<span class="c1"># in a function, you&#39;ll get an error if you try to mutate one of your</span>
<span class="c1"># arguments. If you really need to, you can ask for a mutable container by</span>
<span class="c1"># using the `is rw` trait.</span>
<span class="k">sub</span> <span class="n">mutate</span>( <span class="nv">$n</span> <span class="k">is</span> <span class="k">rw</span> ) {
    <span class="nv">$n</span>++; <span class="c1"># postfix ++ operator increments its argument but returns its old value</span>
}
<span class="k">my</span> <span class="nv">$m</span> = <span class="mi">42</span>;
<span class="n">mutate</span> <span class="nv">$m</span>; <span class="c1">#=&gt; 42, the value is incremented but the old value is returned</span>
<span class="nb">say</span> <span class="nv">$m</span>;    <span class="c1"># OUTPUT: «43␤»</span>

<span class="c1"># This works because we are passing the container $m to the `mutate` sub.</span>
<span class="c1"># If we try to just pass a number instead of passing a variable, it won&#39;t work</span>
<span class="c1"># because there is no container being passed and integers are immutable by</span>
<span class="c1"># themselves:</span>

<span class="c1"># mutate 42; # Parameter &#39;$n&#39; expected a writable container, but got Int value</span>

<span class="c1"># Similar error would be obtained, if a bound variable is passed to</span>
<span class="c1"># to the subroutine. In Raku, you bind a value to a variable using the binding</span>
<span class="c1"># operator `:=`.</span>
<span class="k">my</span> <span class="nv">$v</span> := <span class="mi">50</span>; <span class="c1"># binding 50 to the variable $v</span>
<span class="c1"># mutate $v;   # Parameter &#39;$n&#39; expected a writable container, but got Int value</span>

<span class="c1"># If what you want is a copy instead, use the `is copy` trait which will</span>
<span class="c1"># cause the argument to be copied and allow you to modify the argument</span>
<span class="c1"># inside the routine without modifying the passed argument.</span>

<span class="c1"># A sub itself returns a container, which means it can be marked as `rw`.</span>
<span class="c1"># Alternatively, you can explicitly mark the returned container as mutable</span>
<span class="c1"># by using `return-rw` instead of `return`.</span>
<span class="k">my</span> <span class="nv">$x</span> = <span class="mi">42</span>;
<span class="k">my</span> <span class="nv">$y</span> = <span class="mi">45</span>;
<span class="k">sub</span> <span class="o">x-</span><span class="n">store</span> <span class="k">is</span> <span class="k">rw</span> { <span class="nv">$x</span> }
<span class="k">sub</span> <span class="n">y-store</span>       { <span class="k">return-rw</span> <span class="nv">$y</span> }

<span class="c1"># In this case, the parentheses are mandatory or else Raku thinks that</span>
<span class="c1"># `x-store` and `y-store` are identifiers.</span>
<span class="o">x-</span><span class="n">store</span>() = <span class="mi">52</span>;
<span class="n">y-store</span>() *= <span class="mi">2</span>;

<span class="nb">say</span> <span class="nv">$x</span>; <span class="c1"># OUTPUT: «52␤»</span>
<span class="nb">say</span> <span class="nv">$y</span>; <span class="c1"># OUTPUT: «90␤»</span>

<span class="c1">####################################################</span>
<span class="c1"># 4.Control Flow Structures</span>
<span class="c1">####################################################</span>

<span class="c1">#</span>
<span class="c1"># 4.1 if/if-else/if-elsif-else/unless</span>
<span class="c1">#</span>

<span class="c1"># Before talking about `if`, we need to know which values are &quot;truthy&quot;</span>
<span class="c1"># (represent `True`), and which are &quot;falsey&quot; (represent `False`). Only these</span>
<span class="c1"># values are falsey: 0, (), {}, &quot;&quot;, Nil, a type (like `Str`, `Int`, etc.) and</span>
<span class="c1"># of course, `False` itself. Any other value is truthy.</span>
<span class="k">my</span> <span class="nv">$number</span> = <span class="mi">5</span>;
<span class="k">if</span> <span class="nv">$number</span> &lt; <span class="mi">5</span> {
    <span class="nb">say</span> <span class="s">&quot;Number is less than 5&quot;</span>
}
<span class="k">elsif</span> <span class="nv">$number</span> == <span class="mi">5</span> {
    <span class="nb">say</span> <span class="s">&quot;Number is equal to 5&quot;</span>
}
<span class="k">else</span> {
    <span class="nb">say</span> <span class="s">&quot;Number is greater than 5&quot;</span>
}

<span class="k">unless</span> <span class="nb">False</span> {
    <span class="nb">say</span> <span class="s">&quot;It&#39;s not false!&quot;</span>;
}

<span class="c1"># `unless` is the equivalent of `if not (X)` which inverts the sense of a</span>
<span class="c1"># conditional statement. However, you cannot use `else` or `elsif` with it.</span>

<span class="c1"># As you can see, you don&#39;t need parentheses around conditions. However, you</span>
<span class="c1"># do need the curly braces around the &quot;body&quot; block. For example,</span>
<span class="c1"># `if (True) say &#39;It&#39;s true&#39;;` doesn&#39;t work.</span>

<span class="c1"># You can also use their statement modifier (postfix) versions:</span>
<span class="nb">say</span> <span class="s">&quot;Quite truthy&quot;</span> <span class="k">if</span> <span class="nb">True</span>;      <span class="c1"># OUTPUT: «Quite truthy␤»</span>
<span class="nb">say</span> <span class="s">&quot;Quite falsey&quot;</span> <span class="k">unless</span> <span class="nb">False</span>; <span class="c1"># OUTPUT: «Quite falsey␤»</span>

<span class="c1"># The ternary operator (`??..!!`) is structured as follows `condition ??</span>
<span class="c1"># expression1 !! expression2` and it returns expression1 if the condition is</span>
<span class="c1"># true. Otherwise, it returns expression2.</span>
<span class="k">my</span> <span class="nv">$age</span> = <span class="mi">30</span>;
<span class="nb">say</span> <span class="nv">$age</span> &gt; <span class="mi">18</span> ?? <span class="s">&quot;You are an adult&quot;</span> !! <span class="s">&quot;You are under 18&quot;</span>;
<span class="c1"># OUTPUT: «You are an adult␤»</span>

<span class="c1">#</span>
<span class="c1"># 4.2 with/with-else/with-orwith-else/without</span>
<span class="c1">#</span>

<span class="c1"># The `with` statement is like `if`, but it tests for definedness rather than</span>
<span class="c1"># truth, and it topicalizes on the condition, much like `given` which will</span>
<span class="c1"># be discussed later.</span>
<span class="k">my</span> <span class="nv">$s</span> = <span class="s">&quot;raku&quot;</span>;
<span class="k">with</span>   <span class="nv">$s</span>.<span class="nb">index</span>(<span class="s">&quot;r&quot;</span>) { <span class="nb">say</span> <span class="s">&quot;Found a at $_&quot;</span>      }
<span class="k">orwith</span> <span class="nv">$s</span>.<span class="nb">index</span>(<span class="s">&quot;k&quot;</span>) { <span class="nb">say</span> <span class="s">&quot;Found c at $_&quot;</span>      }
<span class="k">else</span>                 { <span class="nb">say</span> <span class="s">&quot;Didn&#39;t find r or k&quot;</span> }

<span class="c1"># Similar to `unless` that checks un-truthiness, you can use `without` to</span>
<span class="c1"># check for undefined-ness.</span>
<span class="k">my</span> <span class="nv">$input01</span>;
<span class="k">without</span> <span class="nv">$input01</span> {
    <span class="nb">say</span> <span class="s">&quot;No input given.&quot;</span>
}
<span class="c1"># OUTPUT: «No input given.␤»</span>

<span class="c1"># There are also statement modifier versions for both `with` and `without`.</span>
<span class="k">my</span> <span class="nv">$input02</span> = <span class="s">&#39;Hello&#39;</span>;
<span class="nb">say</span> <span class="nv">$input02</span> <span class="k">with</span> <span class="nv">$input02</span>;               <span class="c1"># OUTPUT: «Hello␤»</span>
<span class="nb">say</span> <span class="s">&quot;No input given.&quot;</span> <span class="k">without</span> <span class="nv">$input02</span>;

<span class="c1">#</span>
<span class="c1"># 4.3 given/when, or Raku&#39;s switch construct</span>
<span class="c1">#</span>

<span class="cm">=begin comment</span>
<span class="cm">`given...when` looks like other languages&#39; `switch`, but is much more</span>
<span class="cm">powerful thanks to smart matching and Raku&#39;s &quot;topic variable&quot;, `$_`.</span>

<span class="cm">The topic variable `$_ `contains the default argument of a block, a loop&#39;s</span>
<span class="cm">current iteration (unless explicitly named), etc.</span>

<span class="cm">`given` simply puts its argument into `$_` (like a block would do),</span>
<span class="cm"> and `when` compares it using the &quot;smart matching&quot; (`~~`) operator.</span>

<span class="cm">Since other Raku constructs use this variable (as said before, like `for`,</span>
<span class="cm">blocks, `with` statement etc), this means the powerful `when` is not only</span>
<span class="cm">applicable along with a `given`, but instead anywhere a `$_` exists.</span>

<span class="cm">=end comment</span>

<span class="k">given</span> <span class="s">&quot;foo bar&quot;</span> {
    <span class="nb">say</span> <span class="nv">$_</span>;            <span class="c1"># OUTPUT: «foo bar␤»</span>

    <span class="c1"># Don&#39;t worry about smart matching yet. Just know `when` uses it. This is</span>
    <span class="c1"># equivalent to `if $_ ~~ /foo/`.</span>
    <span class="k">when</span> /<span class="n">foo</span>/ {
        <span class="nb">say</span> <span class="s">&quot;Yay !&quot;</span>;
    }

    <span class="c1"># smart matching anything with `True` is `True`, i.e. (`$a ~~ True`)</span>
    <span class="c1"># so you can also put &quot;normal&quot; conditionals. For example, this `when` is</span>
    <span class="c1"># equivalent to this `if`: `if $_ ~~ ($_.chars &gt; 50) {...}`</span>
    <span class="c1"># which means: `if $_.chars &gt; 50 {...}`</span>
    <span class="k">when</span> <span class="nv">$_</span>.<span class="nb">chars</span> &gt; <span class="mi">50</span> {
        <span class="nb">say</span> <span class="s">&quot;Quite a long string !&quot;</span>;
    }

    <span class="c1"># same as `when *` (using the Whatever Star)</span>
    <span class="k">default</span> {
        <span class="nb">say</span> <span class="s">&quot;Something else&quot;</span>
    }
}

<span class="c1">#</span>
<span class="c1"># 4.4 Looping constructs</span>
<span class="c1">#</span>

<span class="c1"># The `loop` construct is an infinite loop if you don&#39;t pass it arguments, but</span>
<span class="c1"># can also be a C-style `for` loop:</span>
<span class="k">loop</span> {
    <span class="nb">say</span> <span class="s">&quot;This is an infinite loop !&quot;</span>;
    <span class="nb">last</span>;
}
<span class="c1"># In the previous example, `last` breaks out of the loop very much</span>
<span class="c1"># like the `break` keyword in other languages.</span>

<span class="c1"># The `next` keyword skips to the next iteration, like `continue` in other</span>
<span class="c1"># languages. Note that you can also use postfix conditionals, loops, etc.</span>
<span class="k">loop</span> (<span class="k">my</span> <span class="nv">$i</span> = <span class="mi">0</span>; <span class="nv">$i</span> &lt; <span class="mi">5</span>; <span class="nv">$i</span>++) {
    <span class="nb">next</span> <span class="k">if</span> <span class="nv">$i</span> == <span class="mi">3</span>;
    <span class="nb">say</span> <span class="s">&quot;This is a C-style for loop!&quot;</span>;
}

<span class="c1"># The `for` constructs iterates over a list of elements.</span>
<span class="k">my</span> <span class="nv">@odd-array</span> = <span class="mi">1</span>, <span class="mi">3</span>, <span class="mi">5</span>, <span class="mi">7</span>, <span class="mi">9</span>;

<span class="c1"># Accessing the array&#39;s elements with the topic variable $_.</span>
<span class="k">for</span> <span class="nv">@odd-array</span> {
    <span class="nb">say</span> <span class="s">&quot;I&#39;ve got $_ !&quot;</span>;
}

<span class="c1"># Accessing the array&#39;s elements with a &quot;pointy block&quot;, `-&gt;`.</span>
<span class="c1"># Here each element is read-only.</span>
<span class="k">for</span> <span class="nv">@odd-array</span> -&gt; <span class="nv">$variable</span> {
    <span class="nb">say</span> <span class="s">&quot;I&#39;ve got $variable !&quot;</span>;
}

<span class="c1"># Accessing the array&#39;s elements with a &quot;doubly pointy block&quot;, `&lt;-&gt;`.</span>
<span class="c1"># Here each element is read-write so mutating `$variable` mutates</span>
<span class="c1"># that element in the array.</span>
<span class="k">for</span> <span class="nv">@odd-array</span> <span class="s">&lt;-&gt; $variable {</span>
<span class="s">    say &quot;I&#39;ve got $variable !&quot;;</span>
<span class="s">}</span>

<span class="s"># As we saw with `given`, a `for` loop&#39;s default &quot;current iteration&quot; variable</span>
<span class="s"># is `$_`. That means you can use `when` in a `for`loop just like you were</span>
<span class="s"># able to in a `given`.</span>
<span class="s">for @odd-array {</span>
<span class="s">    say &quot;I&#39;ve got $_&quot;;</span>

<span class="s">    # This is also allowed. A dot call with no &quot;topic&quot; (receiver) is sent to</span>
<span class="s">    # `$_` (topic variable) by default.</span>
<span class="s">    .say;</span>

<span class="s">    # This is equivalent to the above statement.</span>
<span class="s">    $_.say;</span>
<span class="s">}</span>

<span class="s">for @odd-array {</span>
<span class="s">    # You can...</span>
<span class="s">    next if $_ == 3; # Skip to the next iteration (`continue` in C-like lang.)</span>
<span class="s">    redo if $_ == 4; # Re-do iteration, keeping the same topic variable (`$_`)</span>
<span class="s">    last if $_ == 5; # Or break out of loop (like `break` in C-like lang.)</span>
<span class="s">}</span>

<span class="s"># The &quot;pointy block&quot; syntax isn&#39;t specific to the `for` loop. It&#39;s just a way</span>
<span class="s"># to express a block in Raku.</span>
<span class="s">sub long-computation { &quot;Finding factors of large primes&quot; }</span>
<span class="s">if long-computation() -&gt;</span> <span class="nv">$result</span> {
    <span class="nb">say</span> <span class="s">&quot;The result is $result.&quot;</span>;
}

<span class="c1">####################################################</span>
<span class="c1"># 5. Operators</span>
<span class="c1">####################################################</span>

<span class="cm">=begin comment</span>
<span class="cm">Since Perl languages are very much operator-based languages, Raku</span>
<span class="cm">operators are actually just funny-looking subroutines, in syntactic</span>
<span class="cm">categories, like infix:&lt;+&gt; (addition) or prefix:&lt;!&gt; (bool not).</span>

<span class="cm">The categories are:</span>
<span class="cm">    - &quot;prefix&quot;: before (like `!` in `!True`).</span>
<span class="cm">    - &quot;postfix&quot;: after (like `++` in `$a++`).</span>
<span class="cm">    - &quot;infix&quot;: in between (like `*` in `4 * 3`).</span>
<span class="cm">    - &quot;circumfix&quot;: around (like `[`-`]` in `[1, 2]`).</span>
<span class="cm">    - &quot;post-circumfix&quot;: around, after another term (like `{`-`}` in</span>
<span class="cm">                   `%hash{&#39;key&#39;}`)</span>

<span class="cm">The associativity and precedence list are explained below.</span>

<span class="cm">Alright, you&#39;re set to go!</span>

<span class="cm">=end comment</span>

<span class="c1">#</span>
<span class="c1"># 5.1 Equality Checking</span>
<span class="c1">#</span>

<span class="c1"># `==` is numeric comparison</span>
<span class="nb">say</span> <span class="mi">3</span> == <span class="mi">4</span>; <span class="c1"># OUTPUT: «False␤»</span>
<span class="nb">say</span> <span class="mi">3</span> != <span class="mi">4</span>; <span class="c1"># OUTPUT: «True␤»</span>

<span class="c1"># `eq` is string comparison</span>
<span class="nb">say</span> <span class="s">&#39;a&#39;</span> <span class="o">eq</span> <span class="s">&#39;b&#39;</span>;  <span class="c1"># OUTPUT: «False␤»</span>
<span class="nb">say</span> <span class="s">&#39;a&#39;</span> <span class="o">ne</span> <span class="s">&#39;b&#39;</span>;  <span class="c1"># OUTPUT: «True␤», not equal</span>
<span class="nb">say</span> <span class="s">&#39;a&#39;</span> !<span class="o">eq</span> <span class="s">&#39;b&#39;</span>; <span class="c1"># OUTPUT: «True␤», same as above</span>

<span class="c1"># `eqv` is canonical equivalence (or &quot;deep equality&quot;)</span>
<span class="nb">say</span> (<span class="mi">1</span>, <span class="mi">2</span>) <span class="o">eqv</span> (<span class="mi">1</span>, <span class="mi">3</span>); <span class="c1"># OUTPUT: «False␤»</span>
<span class="nb">say</span> (<span class="mi">1</span>, <span class="mi">2</span>) <span class="o">eqv</span> (<span class="mi">1</span>, <span class="mi">2</span>); <span class="c1"># OUTPUT: «True␤»</span>
<span class="nb">say</span> <span class="nb">Int</span> === <span class="nb">Int</span>;       <span class="c1"># OUTPUT: «True␤»</span>

<span class="c1"># `~~` is the smart match operator which aliases the left hand side to $_ and</span>
<span class="c1"># then evaluates the right hand side.</span>
<span class="c1"># Here are some common comparison semantics:</span>

<span class="c1"># String or numeric equality</span>
<span class="nb">say</span> <span class="s">&#39;Foo&#39;</span> ~~ <span class="s">&#39;Foo&#39;</span>; <span class="c1"># OUTPUT: «True␤», if strings are equal.</span>
<span class="nb">say</span> <span class="mf">12.5</span> ~~ <span class="mf">12.50</span>;  <span class="c1"># OUTPUT: «True␤», if numbers are equal.</span>

<span class="c1"># Regex - For matching a regular expression against the left side.</span>
<span class="c1"># Returns a `Match` object, which evaluates as True if regexp matches.</span>
<span class="k">my</span> <span class="nv">$obj</span> = <span class="s">&#39;abc&#39;</span> ~~<span class="sr"> /a/</span>;
<span class="nb">say</span> <span class="nv">$obj</span>;       <span class="c1"># OUTPUT: «｢a｣␤»</span>
<span class="nb">say</span> <span class="nv">$obj</span>.<span class="nb">WHAT</span>;  <span class="c1"># OUTPUT: «(Match)␤»</span>

<span class="c1"># Hashes</span>
<span class="nb">say</span> <span class="s">&#39;key&#39;</span> ~~ <span class="nv">%hash</span>; <span class="c1"># OUTPUT: «True␤», if key exists in hash.</span>

<span class="c1"># Type - Checks if left side &quot;is of type&quot; (can check superclasses and roles).</span>
<span class="nb">say</span> <span class="mi">1</span> ~~ <span class="nb">Int</span>;       <span class="c1"># OUTPUT: «True␤»</span>

<span class="c1"># Smart-matching against a boolean always returns that boolean (and will warn).</span>
<span class="nb">say</span> <span class="mi">1</span> ~~ <span class="nb">True</span>;        <span class="c1"># OUTPUT: «True␤», smartmatch against True always matches</span>
<span class="nb">say</span> <span class="nb">False</span>.<span class="nb">so</span> ~~ <span class="nb">True</span>; <span class="c1"># OUTPUT: «True␤», use .so for truthiness</span>

<span class="c1"># General syntax is `$arg ~~ &amp;bool-returning-function;`. For a complete list</span>
<span class="c1"># of combinations, refer to the table at:</span>
<span class="c1"># https://docs.raku.org/language/operators#index-entry-smartmatch_operator</span>

<span class="c1"># Of course, you also use `&lt;`, `&lt;=`, `&gt;`, `&gt;=` for numeric comparison.</span>
<span class="c1"># Their string equivalent are also available: `lt`, `le`, `gt`, `ge`.</span>
<span class="nb">say</span> <span class="mi">3</span> &gt; <span class="mi">4</span>;       <span class="c1"># OUTPUT: «False␤»</span>
<span class="nb">say</span> <span class="mi">3</span> &gt;= <span class="mi">4</span>;      <span class="c1"># OUTPUT: «False␤»</span>
<span class="nb">say</span> <span class="mi">3</span> &lt; <span class="mi">4</span>;       <span class="c1"># OUTPUT: «True␤»</span>
<span class="nb">say</span> <span class="mi">3</span> &lt;= <span class="mi">4</span>;      <span class="c1"># OUTPUT: «True␤»</span>
<span class="nb">say</span> <span class="s">&#39;a&#39;</span> <span class="o">gt</span> <span class="s">&#39;b&#39;</span>;  <span class="c1"># OUTPUT: «False␤»</span>
<span class="nb">say</span> <span class="s">&#39;a&#39;</span> <span class="o">ge</span> <span class="s">&#39;b&#39;</span>;  <span class="c1"># OUTPUT: «False␤»</span>
<span class="nb">say</span> <span class="s">&#39;a&#39;</span> <span class="o">lt</span> <span class="s">&#39;b&#39;</span>;  <span class="c1"># OUTPUT: «True␤»</span>
<span class="nb">say</span> <span class="s">&#39;a&#39;</span> <span class="o">le</span> <span class="s">&#39;b&#39;</span>;  <span class="c1"># OUTPUT: «True␤»</span>

<span class="c1">#</span>
<span class="c1"># 5.2 Range constructor</span>
<span class="c1">#</span>

<span class="nb">say</span> <span class="mi">3</span> .. <span class="mi">7</span>;          <span class="c1"># OUTPUT: «3..7␤»,   both included.</span>
<span class="nb">say</span> <span class="mi">3</span> ..^ <span class="mi">7</span>;         <span class="c1"># OUTPUT: «3..^7␤»,  exclude right endpoint.</span>
<span class="nb">say</span> <span class="mi">3</span> ^.. <span class="mi">7</span>;         <span class="c1"># OUTPUT: «3^..7␤»,  exclude left endpoint.</span>
<span class="nb">say</span> <span class="mi">3</span> ^..^ <span class="mi">7</span>;        <span class="c1"># OUTPUT: «3^..^7␤», exclude both endpoints.</span>

<span class="c1"># The range 3 ^.. 7 is similar like 4 .. 7 when we only consider integers.</span>
<span class="c1"># But when we consider decimals:</span>

<span class="nb">say</span> <span class="mf">3.5</span> ~~ <span class="mi">4</span> .. <span class="mi">7</span>;   <span class="c1"># OUTPUT: «False␤»</span>
<span class="nb">say</span> <span class="mf">3.5</span> ~~ <span class="mi">3</span> ^.. <span class="mi">7</span>;  <span class="c1"># OUTPUT: «True␤»,</span>

<span class="c1"># This is because the range `3 ^.. 7` only excludes anything strictly</span>
<span class="c1"># equal to 3. Hence, it contains decimals greater than 3. This could</span>
<span class="c1"># mathematically be described as 3.5 ∈ (3,7] or in set notation,</span>
<span class="c1"># 3.5 ∈ { x | 3 &lt; x ≤ 7 }.</span>

<span class="nb">say</span> <span class="mi">3</span> ^.. <span class="mi">7</span> ~~ <span class="mi">4</span> .. <span class="mi">7</span>; <span class="c1"># OUTPUT: «False␤»</span>

<span class="c1"># This also works as a shortcut for `0..^N`:</span>
<span class="nb">say</span> ^<span class="mi">10</span>;             <span class="c1"># OUTPUT: «^10␤», which means 0..^10</span>

<span class="c1"># This also allows us to demonstrate that Raku has lazy/infinite arrays,</span>
<span class="c1"># using the Whatever Star:</span>
<span class="k">my</span> <span class="nv">@natural</span> = <span class="mi">1</span>..*; <span class="c1"># 1 to Infinite! Equivalent to `1..Inf`.</span>

<span class="c1"># You can pass ranges as subscripts and it&#39;ll return an array of results.</span>
<span class="nb">say</span> <span class="nv">@natural</span>[^<span class="mi">10</span>]; <span class="c1"># OUTPUT: «1 2 3 4 5 6 7 8 9 10␤», doesn&#39;t run out of memory!</span>

<span class="c1"># NOTE: when reading an infinite list, Raku will &quot;reify&quot; the elements</span>
<span class="c1"># it needs, then keep them in memory. They won&#39;t be calculated more than once.</span>
<span class="c1"># It also will never calculate more elements than that are needed.</span>

<span class="c1"># An array subscript can also be a closure. It&#39;ll be called with the array&#39;s</span>
<span class="c1"># length as the argument. The following two examples are equivalent:</span>
<span class="nb">say</span> <span class="nb">join</span>(<span class="s">&#39; &#39;</span>, <span class="nv">@array</span>[<span class="mi">15</span>..*]);            <span class="c1"># OUTPUT: «15 16 17 18 19␤»</span>
<span class="nb">say</span> <span class="nb">join</span>(<span class="s">&#39; &#39;</span>, <span class="nv">@array</span>[-&gt; <span class="nv">$n</span> { <span class="mi">15</span>..<span class="nv">$n</span> }]); <span class="c1"># OUTPUT: «15 16 17 18 19␤»</span>

<span class="c1"># NOTE: if you try to do either of those with an infinite array, you&#39;ll</span>
<span class="c1"># trigger an infinite loop (your program won&#39;t finish).</span>

<span class="c1"># You can use that in most places you&#39;d expect, even when assigning to an array:</span>
<span class="k">my</span> <span class="nv">@numbers</span> = ^<span class="mi">20</span>;

<span class="c1"># Here the numbers increase by 6, like an arithmetic sequence; more on the</span>
<span class="c1"># sequence (`...`) operator later.</span>
<span class="k">my</span> <span class="nv">@seq</span> =  <span class="mi">3</span>, <span class="mi">9</span> ... * &gt; <span class="mi">95</span>;  <span class="c1"># 3 9 15 21 27 [...] 81 87 93 99;</span>

<span class="c1"># In this example, even though the sequence is infinite, only the 15</span>
<span class="c1"># needed values will be calculated.</span>
<span class="nv">@numbers</span>[<span class="mi">5</span>..*] = <span class="mi">3</span>, <span class="mi">9</span> ... *;
<span class="nb">say</span> <span class="nv">@numbers</span>; <span class="c1"># OUTPUT: «0 1 2 3 4 3 9 15 21 [...] 81 87␤», only 20 values</span>

<span class="c1">#</span>
<span class="c1"># 5.3 and (&amp;&amp;), or (||)</span>
<span class="c1">#</span>

<span class="c1"># Here `and` calls `.Bool` on both 3 and 4 and gets `True` so it returns</span>
<span class="c1"># 4 since both are `True`.</span>
<span class="nb">say</span> (<span class="mi">3</span> <span class="o">and</span> <span class="mi">4</span>);     <span class="c1"># OUTPUT: «4␤», which is truthy.</span>
<span class="nb">say</span> (<span class="mi">3</span> <span class="o">and</span> <span class="mi">0</span>);     <span class="c1"># OUTPUT: «0␤»</span>
<span class="nb">say</span> (<span class="mi">0</span> <span class="o">and</span> <span class="mi">4</span>);     <span class="c1"># OUTPUT: «0␤»</span>

<span class="c1"># Here `or` calls `.Bool` on `0` and `False` which are both `False`</span>
<span class="c1"># so it returns `False` since both are `False`.</span>
<span class="nb">say</span> (<span class="mi">0</span> <span class="o">or</span> <span class="nb">False</span>); <span class="c1"># OUTPUT: «False␤».</span>

<span class="c1"># Both `and` and `or` have tighter versions which also shortcut circuits.</span>
<span class="c1"># They&#39;re `&amp;&amp;` and `||` respectively.</span>

<span class="c1"># `&amp;&amp;` returns the first operand that evaluates to `False`. Otherwise,</span>
<span class="c1"># it returns the last operand.</span>
<span class="k">my</span> (<span class="nv">$a</span>, <span class="nv">$b</span>, <span class="nv">$c</span>, <span class="nv">$d</span>, <span class="nv">$e</span>) = <span class="mi">1</span>, <span class="mi">0</span>, <span class="nb">False</span>, <span class="nb">True</span>, <span class="s">&#39;pi&#39;</span>;
<span class="nb">say</span> <span class="nv">$a</span> &amp;&amp; <span class="nv">$b</span> &amp;&amp; <span class="nv">$c</span>; <span class="c1"># OUTPUT: «0␤», the first falsey value</span>
<span class="nb">say</span> <span class="nv">$a</span> &amp;&amp; <span class="nv">$b</span> &amp;&amp; <span class="nv">$c</span>; <span class="c1"># OUTPUT: «False␤», the first falsey value</span>
<span class="nb">say</span> <span class="nv">$a</span> &amp;&amp; <span class="nv">$d</span> &amp;&amp; <span class="nv">$e</span>; <span class="c1"># OUTPUT: «pi␤», last operand since everything before is truthy</span>

<span class="c1"># `||` returns the first argument that evaluates to `True`.</span>
<span class="nb">say</span> <span class="nv">$b</span> || <span class="nv">$a</span> || <span class="nv">$d</span>; <span class="c1"># OUTPUT: «1␤»</span>
<span class="nb">say</span> <span class="nv">$e</span> || <span class="nv">$d</span> || <span class="nv">$a</span>; <span class="c1"># OUTPUT: «pi␤»</span>

<span class="c1"># And because you&#39;re going to want them, you also have compound assignment</span>
<span class="c1"># operators:</span>
<span class="nv">$a</span> *= <span class="mi">2</span>;        <span class="c1"># multiply and assignment. Equivalent to $a = $a * 2;</span>
<span class="nv">$b</span> %%= <span class="mi">5</span>;       <span class="c1"># divisible by and assignment. Equivalent to $b = $b %% 2;</span>
<span class="nv">$c</span> <span class="o">div</span>= <span class="mi">3</span>;      <span class="c1"># return divisor and assignment. Equivalent to $c = $c div 3;</span>
<span class="nv">$d</span> <span class="o">mod</span>= <span class="mi">4</span>;      <span class="c1"># return remainder and assignment. Equivalent to $d = $d mod 4;</span>
<span class="nv">@array</span> .= <span class="nb">sort</span>; <span class="c1"># calls the `sort` method and assigns the result back</span>

<span class="c1">####################################################</span>
<span class="c1"># 6. More on subs!</span>
<span class="c1">####################################################</span>

<span class="c1"># As we said before, Raku has *really* powerful subs. We&#39;re going</span>
<span class="c1"># to see a few more key concepts that make them better than in any</span>
<span class="c1"># other language :-).</span>

<span class="c1">#</span>
<span class="c1"># 6.1 Unpacking!</span>
<span class="c1">#</span>

<span class="c1"># Unpacking is the ability to &quot;extract&quot; arrays and keys</span>
<span class="c1"># (AKA &quot;destructuring&quot;). It&#39;ll work in `my`s and in parameter lists.</span>
<span class="k">my</span> (<span class="nv">$f</span>, <span class="nv">$g</span>) = <span class="mi">1</span>, <span class="mi">2</span>;
<span class="nb">say</span> <span class="nv">$f</span>;                  <span class="c1"># OUTPUT: «1␤»</span>
<span class="k">my</span> ($, $, <span class="nv">$h</span>) = <span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>; <span class="c1"># keep the non-interesting values anonymous (`$`)</span>
<span class="nb">say</span> <span class="nv">$h</span>;                  <span class="c1"># OUTPUT: «3␤»</span>

<span class="k">my</span> (<span class="nv">$head</span>, *<span class="nv">@tail</span>) = <span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>; <span class="c1"># Yes, it&#39;s the same as with &quot;slurpy subs&quot;</span>
<span class="k">my</span> (*<span class="nv">@small</span>) = <span class="mi">1</span>;

<span class="k">sub</span> <span class="n">unpack_array</span>( <span class="nv">@array</span> [<span class="nv">$fst</span>, <span class="nv">$snd</span>] ) {
  <span class="nb">say</span> <span class="s">&quot;My first is $fst, my second is $snd! All in all, I&#39;m @array[].&quot;</span>;
  <span class="c1"># (^ remember the `[]` to interpolate the array)</span>
}
<span class="n">unpack_array</span>(<span class="nv">@tail</span>);
<span class="c1"># OUTPUT: «My first is 2, my second is 3! All in all, I&#39;m 2 3.␤»</span>

<span class="c1"># If you&#39;re not using the array itself, you can also keep it anonymous,</span>
<span class="c1"># much like a scalar:</span>
<span class="k">sub</span> <span class="n">first-of-array</span>( @ [<span class="nv">$fst</span>] ) { <span class="nv">$fst</span> }
<span class="n">first-of-array</span>(<span class="nv">@small</span>); <span class="c1">#=&gt; 1</span>

<span class="c1"># However calling `first-of-array(@tail);` will throw an error (&quot;Too many</span>
<span class="c1"># positional parameters passed&quot;), which means the `@tail` has too many</span>
<span class="c1"># elements.</span>

<span class="c1"># You can also use a slurpy parameter. You could keep `*@rest` anonymous</span>
<span class="c1"># Here, `@rest` is `(3,)`, since `$fst` holds the `2`. This results</span>
<span class="c1"># since the length (.elems) of `@rest` is 1.</span>
<span class="k">sub</span> <span class="n">slurp-in-array</span>(@ [<span class="nv">$fst</span>, *<span class="nv">@rest</span>]) {
    <span class="nb">say</span> <span class="nv">$fst</span> + <span class="nv">@rest</span>.<span class="nb">elems</span>;
}
<span class="n">slurp-in-array</span>(<span class="nv">@tail</span>); <span class="c1"># OUTPUT: «3␤»</span>

<span class="c1"># You could even extract on a slurpy (but it&#39;s pretty useless ;-).)</span>
<span class="k">sub</span> <span class="n">fst</span>(*@ [<span class="nv">$fst</span>]) { <span class="c1"># or simply: `sub fst($fst) { ... }`</span>
    <span class="nb">say</span> <span class="nv">$fst</span>;
}
<span class="n">fst</span>(<span class="mi">1</span>);    <span class="c1"># OUTPUT: «1␤»</span>

<span class="c1"># Calling `fst(1, 2);` will throw an error (&quot;Too many positional parameters</span>
<span class="c1"># passed&quot;) though. After all, the `fst` sub declares only a single positional</span>
<span class="c1"># parameter.</span>

<span class="c1"># You can also destructure hashes (and classes, which you&#39;ll learn about later).</span>
<span class="c1"># The syntax is basically the same as</span>
<span class="c1"># `%hash-name (:key($variable-to-store-value-in))`.</span>
<span class="c1"># The hash can stay anonymous if you only need the values you extracted.</span>

<span class="c1"># In order to call the function, you must supply a hash wither created with</span>
<span class="c1"># curly braces or with `%()` (recommended). Alternatively, you can pass</span>
<span class="c1"># a variable that contains a hash.</span>

<span class="k">sub</span> <span class="n">key-of</span>( % (:<span class="n">value</span>(<span class="nv">$val</span>), :<span class="n">qua</span>(<span class="nv">$qua</span>)) ) {
    <span class="nb">say</span> <span class="s">&quot;Got value $val, $qua time&quot;</span> ~~
        <span class="nv">$qua</span> == <span class="mi">1</span> ?? <span class="s">&#39;&#39;</span> !! <span class="s">&#39;s&#39;</span>;
}

<span class="k">my</span> <span class="nv">%foo-once</span> = %(<span class="nb">value</span> =&gt; <span class="s">&#39;foo&#39;</span>, <span class="n">qua</span> =&gt; <span class="mi">1</span>);
<span class="n">key-of</span>({<span class="nb">value</span> =&gt; <span class="s">&#39;foo&#39;</span>, <span class="n">qua</span> =&gt; <span class="mi">2</span>});  <span class="c1"># OUTPUT: «Got val foo, 2 times.␤»</span>
<span class="n">key-of</span>(%(<span class="nb">value</span> =&gt; <span class="s">&#39;foo&#39;</span>, <span class="n">qua</span> =&gt; <span class="mi">0</span>)); <span class="c1"># OUTPUT: «Got val foo, 0 times.␤»</span>
<span class="n">key-of</span>(<span class="nv">%foo-once</span>);                   <span class="c1"># OUTPUT: «Got val foo, 1 time.␤»</span>

<span class="c1"># The last expression of a sub is returned automatically (though you may</span>
<span class="c1"># indicate explicitly by using the `return` keyword, of course):</span>
<span class="k">sub</span> <span class="n">next-index</span>( <span class="nv">$n</span> ) {
    <span class="nv">$n</span> + <span class="mi">1</span>;
}
<span class="k">my</span> <span class="nv">$new-n</span> = <span class="n">next-index</span>(<span class="mi">3</span>); <span class="c1"># $new-n is now 4</span>

<span class="c1"># This is true for everything, except for the looping constructs (due to</span>
<span class="c1"># performance reasons): there&#39;s no reason to build a list if we&#39;re just going to</span>
<span class="c1"># discard all the results. If you still want to build one, you can use the</span>
<span class="c1"># `do` statement prefix or the `gather` prefix, which we&#39;ll see later:</span>

<span class="k">sub</span> <span class="n">list-of</span>( <span class="nv">$n</span> ) {
    <span class="nb">do</span> <span class="k">for</span> ^<span class="nv">$n</span> { <span class="nv">$_</span> }
}
<span class="k">my</span> <span class="nv">@list3</span> = <span class="n">list-of</span>(<span class="mi">3</span>); <span class="c1">#=&gt; (0, 1, 2)</span>

<span class="c1">#</span>
<span class="c1"># 6.2 Lambdas (or anonymous subroutines)</span>
<span class="c1">#</span>

<span class="c1"># You can create a lambda by using a pointy block (`-&gt; {}`), a</span>
<span class="c1"># block (`{}`) or creating a `sub` without a name.</span>

<span class="k">my</span> <span class="nv">&amp;lambda1</span> = -&gt; <span class="nv">$argument</span> {
    <span class="s">&quot;The argument passed to this lambda is $argument&quot;</span>
}

<span class="k">my</span> <span class="nv">&amp;lambda2</span> = {
    <span class="s">&quot;The argument passed to this lambda is $_&quot;</span>
}

<span class="k">my</span> <span class="nv">&amp;lambda3</span> = <span class="k">sub</span> (<span class="nv">$argument</span>) {
    <span class="s">&quot;The argument passed to this lambda is $argument&quot;</span>
}

<span class="c1"># Both pointy blocks and blocks are pretty much the same thing, except that</span>
<span class="c1"># the former can take arguments, and that the latter can be mistaken as</span>
<span class="c1"># a hash by the parser. That being said, blocks can declare what&#39;s known</span>
<span class="c1"># as placeholders parameters through the twigils `$^` (for positional</span>
<span class="c1"># parameters) and `$:` (for named parameters). More on them later on.</span>

<span class="k">my</span> <span class="nv">&amp;mult</span> = { <span class="nv">$^numbers</span> * <span class="nv">$:times</span> }
<span class="nb">say</span> <span class="n">mult</span> <span class="mi">4</span>, :<span class="n">times</span>(<span class="mi">6</span>); <span class="c1">#=&gt; «24␤»</span>

<span class="c1"># Both pointy blocks and blocks are quite versatile when working with functions</span>
<span class="c1"># that accepts other functions such as `map`, `grep`, etc. For example,</span>
<span class="c1"># we add 3 to each value of an array using the `map` function with a lambda:</span>
<span class="k">my</span> <span class="nv">@nums</span> = <span class="mi">1</span><span class="o">..</span><span class="mi">4</span>;
<span class="k">my</span> <span class="nv">@res1</span> = <span class="n">map</span> -&gt; <span class="nv">$v</span> { <span class="nv">$v</span> + <span class="mi">3</span> }, <span class="nv">@nums</span>; <span class="c1"># pointy block, explicit parameter</span>
<span class="k">my</span> <span class="nv">@res2</span> = <span class="n">map</span> { <span class="nv">$_</span> + <span class="mi">3</span> },       <span class="nv">@nums</span>; <span class="c1"># block using an implicit parameter</span>
<span class="k">my</span> <span class="nv">@res3</span> = <span class="n">map</span> { <span class="nv">$^val</span> + <span class="mi">3</span> },    <span class="nv">@nums</span>; <span class="c1"># block with placeholder parameter</span>

<span class="c1"># A sub (`sub {}`) has different semantics than a block (`{}` or `-&gt; {}`):</span>
<span class="c1"># A block doesn&#39;t have a &quot;function context&quot; (though it can have arguments),</span>
<span class="c1"># which means that if you return from it, you&#39;re going to return from the</span>
<span class="c1"># parent function.</span>

<span class="c1"># Compare:</span>
<span class="k">sub</span> <span class="n">is-in</span>( <span class="nv">@array</span>, <span class="nv">$elem</span> ) {
   <span class="nb">say</span> <span class="n">map</span>({ <span class="k">return</span> <span class="nb">True</span> <span class="k">if</span> <span class="nv">$_</span> == <span class="nv">$elem</span> }, <span class="nv">@array</span>);
   <span class="nb">say</span> <span class="s">&#39;Hi&#39;</span>;
}

<span class="c1"># with:</span>
<span class="k">sub</span> <span class="n">truthy-array</span>( <span class="nv">@array</span> ) {
    <span class="nb">say</span> <span class="n">map</span> <span class="k">sub</span> (<span class="nv">$i</span>) { <span class="nv">$i</span> ?? <span class="k">return</span> <span class="nb">True</span> !! <span class="k">return</span> <span class="nb">False</span> }, <span class="nv">@array</span>;
    <span class="nb">say</span> <span class="s">&#39;Hi&#39;</span>;
}

<span class="c1"># In the `is-in` sub, the block will `return` out of the `is-in` sub once the</span>
<span class="c1"># condition evaluates to `True`, the loop won&#39;t be run anymore and the</span>
<span class="c1"># following statement won&#39;t be executed. The last statement is only executed</span>
<span class="c1"># if the block never returns.</span>

<span class="c1"># On the contrary, the `truthy-array` sub will produce an array of `True` and</span>
<span class="c1"># `False`, which will printed, and always execute the last execute statement.</span>
<span class="c1"># Thus, the `return` only returns from the anonymous `sub`</span>

<span class="c1"># The `anon` declarator can be used to create an anonymous sub from a</span>
<span class="c1"># regular subroutine. The regular sub knows its name but its symbol is</span>
<span class="c1"># prevented from getting installed in the lexical scope, the method table</span>
<span class="c1"># and everywhere else.</span>
<span class="k">my</span> <span class="nv">$anon-sum</span> = <span class="k">anon</span> <span class="k">sub</span> <span class="n">summation</span>(*<span class="nv">@a</span>) { [+] <span class="nv">@a</span> }
<span class="nb">say</span> <span class="nv">$anon-sum</span>.<span class="nb">name</span>;     <span class="c1"># OUTPUT: «summation␤»</span>
<span class="nb">say</span> <span class="nv">$anon-sum</span>(<span class="mi">2</span>, <span class="mi">3</span>, <span class="mi">5</span>); <span class="c1"># OUTPUT: «10␤»</span>
<span class="c1">#say summation;         # Error: Undeclared routine: ...</span>

<span class="c1"># You can also use the Whatever Star to create an anonymous subroutine.</span>
<span class="c1"># (it&#39;ll stop at the furthest operator in the current expression).</span>
<span class="c1"># The following is the same as `{$_ + 3 }`, `-&gt; { $a + 3 }`,</span>
<span class="c1"># `sub ($a) { $a + 3 }`, or even `{$^a + 3}` (more on this later).</span>
<span class="k">my</span> <span class="nv">@arrayplus3v0</span> = <span class="n">map</span> * + <span class="mi">3</span>, <span class="nv">@nums</span>;

<span class="c1"># The following is the same as `-&gt; $a, $b { $a + $b + 3 }`,</span>
<span class="c1"># `sub ($a, $b) { $a + $b + 3 }`, or `{ $^a + $^b + 3 }` (more on this later).</span>
<span class="k">my</span> <span class="nv">@arrayplus3v1</span> = <span class="n">map</span> * + * + <span class="mi">3</span>, <span class="nv">@nums</span>;

<span class="nb">say</span> (*/<span class="mi">2</span>)(<span class="mi">4</span>); <span class="c1"># OUTPUT: «2␤», immediately execute the Whatever function created.</span>
<span class="nb">say</span> ((*+<span class="mi">3</span>)/<span class="mi">5</span>)(<span class="mi">5</span>); <span class="c1"># OUTPUT: «1.6␤», it works even in parens!</span>

<span class="c1"># But if you need to have more than one argument (`$_`) in a block (without</span>
<span class="c1"># wanting to resort to `-&gt; {}`), you can also either `$^` and `$:` which</span>
<span class="c1"># declared placeholder parameters or self-declared positional/named parameters.</span>
<span class="nb">say</span> <span class="n">map</span> { <span class="nv">$^a</span> + <span class="nv">$^b</span> + <span class="mi">3</span> }, <span class="nv">@nums</span>;

<span class="c1"># which is equivalent to the following which uses a `sub`:</span>
<span class="n">map</span> <span class="k">sub</span> (<span class="nv">$a</span>, <span class="nv">$b</span>) { <span class="nv">$a</span> + <span class="nv">$b</span> + <span class="mi">3</span> }, <span class="nv">@nums</span>;

<span class="c1"># Placeholder parameters are sorted lexicographically so the following two</span>
<span class="c1"># statements are equivalent:</span>
<span class="nb">say</span> <span class="nb">sort</span>           { <span class="nv">$^b</span> &lt;=&gt; <span class="nv">$^a</span> }, <span class="nv">@nums</span>;
<span class="nb">say</span> <span class="nb">sort</span> -&gt; <span class="nv">$a</span>, <span class="nv">$b</span> { <span class="nv">$b</span>  &lt;=&gt; <span class="nv">$a</span>  }, <span class="nv">@nums</span>;

<span class="c1">#</span>
<span class="c1"># 6.3 Multiple Dispatch</span>
<span class="c1">#</span>

<span class="c1"># Raku can decide which variant of a `sub` to call based on the type of the</span>
<span class="c1"># arguments, or on arbitrary preconditions, like with a type or `where`:</span>

<span class="c1"># with types:</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="n">sayit</span>( <span class="nb">Int</span> <span class="nv">$n</span> ) { <span class="c1"># note the `multi` keyword here</span>
    <span class="nb">say</span> <span class="s">&quot;Number: $n&quot;</span>;
}
<span class="k">multi</span> <span class="n">sayit</span>( <span class="nb">Str</span> <span class="nv">$s</span> ) {     <span class="c1"># a multi is a `sub` by default</span>
    <span class="nb">say</span> <span class="s">&quot;String: $s&quot;</span>;
}
<span class="n">sayit</span> <span class="s">&quot;foo&quot;</span>; <span class="c1"># OUTPUT: «String: foo␤»</span>
<span class="n">sayit</span> <span class="mi">25</span>;    <span class="c1"># OUTPUT: «Number: 25␤»</span>
<span class="n">sayit</span> <span class="nb">True</span>;  <span class="c1"># fails at *compile time* with &quot;calling &#39;sayit&#39; will never</span>
             <span class="c1"># work with arguments of types ...&quot;</span>

<span class="c1"># with arbitrary preconditions (remember subsets?):</span>
<span class="k">multi</span> <span class="n">is-big</span>(<span class="nb">Int</span> <span class="nv">$n</span> <span class="n">where</span> * &gt; <span class="mi">50</span>) { <span class="s">&quot;Yes!&quot;</span> }    <span class="c1"># using a closure</span>
<span class="k">multi</span> <span class="n">is-big</span>(<span class="nb">Int</span> <span class="nv">$n</span> <span class="n">where</span> {<span class="nv">$_</span> &gt; <span class="mi">50</span>}) { <span class="s">&quot;Yes!&quot;</span> } <span class="c1"># similar to above</span>
<span class="k">multi</span> <span class="n">is-big</span>(<span class="nb">Int</span> $ <span class="n">where</span> <span class="mi">10</span><span class="o">..</span><span class="mi">50</span>)  { <span class="s">&quot;Quite.&quot;</span> }  <span class="c1"># Using smart-matching</span>
<span class="k">multi</span> <span class="n">is-big</span>(<span class="nb">Int</span> $) { <span class="s">&quot;No&quot;</span> }

<span class="k">subset</span> <span class="n">Even</span> <span class="nb">of</span> <span class="nb">Int</span> <span class="n">where</span> * %% <span class="mi">2</span>;
<span class="k">multi</span> <span class="n">odd-or-even</span>(<span class="n">Even</span>) { <span class="s">&quot;Even&quot;</span> } <span class="c1"># Using the type. We don&#39;t name the argument.</span>
<span class="k">multi</span> <span class="n">odd-or-even</span>($) { <span class="s">&quot;Odd&quot;</span> }     <span class="c1"># &quot;everything else&quot; hence the $ variable</span>

<span class="c1"># You can even dispatch based on the presence of positional and named arguments:</span>
<span class="k">multi</span> <span class="n">with-or-without-you</span>(<span class="nv">$with</span>) {
    <span class="nb">say</span> <span class="s">&quot;I wish I could but I can&#39;t&quot;</span>;
}
<span class="k">multi</span> <span class="n">with-or-without-you</span>(:<span class="nv">$with</span>) {
    <span class="nb">say</span> <span class="s">&quot;I can live! Actually, I can&#39;t.&quot;</span>;
}
<span class="k">multi</span> <span class="n">with-or-without-you</span> {
    <span class="nb">say</span> <span class="s">&quot;Definitely can&#39;t live.&quot;</span>;
}

<span class="c1"># This is very, very useful for many purposes, like `MAIN` subs (covered</span>
<span class="c1"># later), and even the language itself uses it in several places.</span>

<span class="c1"># For example, the `is` trait is actually a `multi sub` named `trait_mod:&lt;is&gt;`,</span>
<span class="c1"># and it works off that. Thus, `is rw`, is simply a dispatch to a function with</span>
<span class="c1"># this signature `sub trait_mod:&lt;is&gt;(Routine $r, :$rw!) {}`</span>

<span class="c1">####################################################</span>
<span class="c1"># 7. About types...</span>
<span class="c1">####################################################</span>

<span class="c1"># Raku is gradually typed. This means you can specify the type of your</span>
<span class="c1"># variables/arguments/return types, or you can omit the type annotations in</span>
<span class="c1"># in which case they&#39;ll default to `Any`. Obviously you get access to a few</span>
<span class="c1"># base types, like `Int` and `Str`. The constructs for declaring types are</span>
<span class="c1"># `subset`, `class`, `role`, etc. which you&#39;ll see later.</span>

<span class="c1"># For now, let us examine `subset` which is a &quot;sub-type&quot; with additional</span>
<span class="c1"># checks. For example, &quot;a very big integer is an `Int` that&#39;s greater than 500&quot;.</span>
<span class="c1"># You can specify the type you&#39;re subtyping (by default, `Any`), and add</span>
<span class="c1"># additional checks with the `where` clause.</span>
<span class="k">subset</span> <span class="n">VeryBigInteger</span> <span class="nb">of</span> <span class="nb">Int</span> <span class="n">where</span> * &gt; <span class="mi">500</span>;

<span class="c1"># Or the set of the whole numbers:</span>
<span class="k">subset</span> <span class="n">WholeNumber</span> <span class="nb">of</span> <span class="nb">Int</span> <span class="n">where</span> * &gt;= <span class="mi">0</span>;
<span class="k">my</span> <span class="n">WholeNumber</span> <span class="nv">$whole-six</span>    = <span class="mi">6</span>;  <span class="c1"># OK</span>
<span class="c1">#my WholeNumber $nonwhole-one = -1; # Error: type check failed...</span>

<span class="c1"># Or the set of Positive Even Numbers whose Mod 5 is 1. Notice we&#39;re</span>
<span class="c1"># using the previously defined WholeNumber subset.</span>
<span class="k">subset</span> <span class="n">PENFO</span> <span class="nb">of</span> <span class="n">WholeNumber</span> <span class="n">where</span> { <span class="nv">$_</span> %% <span class="mi">2</span> <span class="o">and</span> <span class="nv">$_</span> <span class="o">mod</span> <span class="mi">5</span> == <span class="mi">1</span> };
<span class="k">my</span> <span class="n">PENFO</span> <span class="nv">$yes-penfo</span> = <span class="mi">36</span>;  <span class="c1"># OK</span>
<span class="c1">#my PENFO $no-penfo  = 2;  # Error: type check failed...</span>

<span class="c1">####################################################</span>
<span class="c1"># 8. Scoping</span>
<span class="c1">####################################################</span>

<span class="c1"># In Raku, unlike many scripting languages, (such as Python, Ruby, PHP),</span>
<span class="c1"># you must declare your variables before using them. The `my` declarator</span>
<span class="c1"># we&#39;ve used so far uses &quot;lexical scoping&quot;. There are a few other declarators,</span>
<span class="c1"># (`our`, `state`, ..., ) which we&#39;ll see later. This is called</span>
<span class="c1"># &quot;lexical scoping&quot;, where in inner blocks, you can access variables from</span>
<span class="c1"># outer blocks.</span>

<span class="k">my</span> <span class="nv">$file_scoped</span> = <span class="s">&#39;Foo&#39;</span>;
<span class="k">sub</span> <span class="n">outer</span> {
    <span class="k">my</span> <span class="nv">$outer_scoped</span> = <span class="s">&#39;Bar&#39;</span>;
    <span class="k">sub</span> <span class="n">inner</span> {
        <span class="nb">say</span> <span class="s">&quot;$file_scoped $outer_scoped&quot;</span>;
    }
    <span class="nv">&amp;inner</span>; <span class="c1"># return the function</span>
}
<span class="n">outer</span>()();  <span class="c1"># OUTPUT: «Foo Bar␤»</span>

<span class="c1"># As you can see, `$file_scoped` and `$outer_scoped` were captured.</span>
<span class="c1"># But if we were to try and use `$outer_scoped` outside the `outer` sub,</span>
<span class="c1"># the variable would be undefined (and you&#39;d get a compile time error).</span>

<span class="c1">####################################################</span>
<span class="c1"># 9. Twigils</span>
<span class="c1">####################################################</span>

<span class="c1"># There are many special `twigils` (composed sigils) in Raku. Twigils</span>
<span class="c1"># define a variable&#39;s scope.</span>
<span class="c1"># The `*` and `?` twigils work on standard variables:</span>
<span class="c1">#     * for dynamic variables</span>
<span class="c1">#     ? for compile-time variables</span>
<span class="c1">#</span>
<span class="c1"># The `!` and the `.` twigils are used with Raku&#39;s objects:</span>
<span class="c1">#     ! for attributes (instance attribute)</span>
<span class="c1">#     . for methods (not really a variable)</span>

<span class="c1">#</span>
<span class="c1"># `*` twigil: Dynamic Scope</span>
<span class="c1">#</span>

<span class="c1"># These variables use the `*` twigil to mark dynamically-scoped variables.</span>
<span class="c1"># Dynamically-scoped variables are looked up through the caller, not through</span>
<span class="c1"># the outer scope.</span>

<span class="k">my</span> <span class="vg">$*dyn_scoped_1</span> = <span class="mi">1</span>;
<span class="k">my</span> <span class="vg">$*dyn_scoped_2</span> = <span class="mi">10</span>;

<span class="k">sub</span> <span class="n">say_dyn</span> {
    <span class="nb">say</span> <span class="s">&quot;$*dyn_scoped_1 $*dyn_scoped_2&quot;</span>;
}

<span class="k">sub</span> <span class="n">call_say_dyn</span> {
    <span class="c1"># Defines $*dyn_scoped_1 only for this sub.</span>
    <span class="k">my</span> <span class="vg">$*dyn_scoped_1</span> = <span class="mi">25</span>;

    <span class="c1"># Will change the value of the file scoped variable.</span>
    <span class="vg">$*dyn_scoped_2</span> = <span class="mi">100</span>;

    <span class="c1"># $*dyn_scoped 1 and 2 will be looked for in the call.</span>
    <span class="n">say_dyn</span>();  <span class="c1"># OUTPUT: «25 100␤»</span>

    <span class="c1"># The call to `say_dyn` uses the value of $*dyn_scoped_1 from inside</span>
    <span class="c1"># this sub&#39;s lexical scope even though the blocks aren&#39;t nested (they&#39;re</span>
    <span class="c1"># call-nested).</span>
}
<span class="n">say_dyn</span>();      <span class="c1"># OUTPUT: «1 10␤»</span>

<span class="c1"># Uses $*dyn_scoped_1 as defined in `call_say_dyn` even though we are calling it</span>
<span class="c1"># from outside.</span>
<span class="n">call_say_dyn</span>(); <span class="c1"># OUTPUT: «25 100␤»</span>

<span class="c1"># We changed the value of $*dyn_scoped_2 in `call_say_dyn` so now its</span>
<span class="c1"># value has changed.</span>
<span class="n">say_dyn</span>();      <span class="c1"># OUTPUT: «1 100␤»</span>

<span class="c1"># TODO: Add information about remaining twigils</span>

<span class="c1">####################################################</span>
<span class="c1"># 10. Object Model</span>
<span class="c1">####################################################</span>

<span class="c1"># To call a method on an object, add a dot followed by the method name:</span>
<span class="c1"># `$object.method`</span>

<span class="c1"># Classes are declared with the `class` keyword. Attributes are declared</span>
<span class="c1"># with the `has` keyword, and methods declared with the `method` keyword.</span>

<span class="c1"># Every attribute that is private uses the `!` twigil. For example: `$!attr`.</span>
<span class="c1"># Immutable public attributes use the `.` twigil which creates a read-only</span>
<span class="c1"># method named after the attribute. In fact, declaring an attribute with `.`</span>
<span class="c1"># is equivalent to declaring the same attribute with `!` and then creating</span>
<span class="c1"># a read-only method with the attribute&#39;s name. However, this is done for us</span>
<span class="c1"># by Raku automatically. The easiest way to remember the `$.` twigil is</span>
<span class="c1"># by comparing it to how methods are called.</span>

<span class="c1"># Raku&#39;s object model (&quot;SixModel&quot;) is very flexible, and allows you to</span>
<span class="c1"># dynamically add methods, change semantics, etc... Unfortunately, these will</span>
<span class="c1"># not all be covered here, and you should refer to:</span>
<span class="c1"># https://docs.raku.org/language/objects.html.</span>

<span class="k">class</span> <span class="n">Human</span> {
    <span class="k">has</span> <span class="nb">Str</span> <span class="nv">$.name</span>;           <span class="c1"># `$.name` is immutable but with an accessor method.</span>
    <span class="k">has</span> <span class="nb">Str</span> <span class="nv">$.bcountry</span>;       <span class="c1"># Use `$!bcountry` to modify it inside the class.</span>
    <span class="k">has</span> <span class="nb">Str</span> <span class="nv">$.ccountry</span> <span class="k">is</span> <span class="k">rw</span>; <span class="c1"># This attribute can be modified from outside.</span>
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">$!age</span> = <span class="mi">0</span>;        <span class="c1"># A private attribute with default value.</span>

    <span class="k">method</span> <span class="n">birthday</span> {
        <span class="nv">$!age</span> += <span class="mi">1</span>; <span class="c1"># Add a year to human&#39;s age</span>
    }

    <span class="k">method</span> <span class="n">get-age</span> {
        <span class="k">return</span> <span class="nv">$!age</span>;
    }

    <span class="c1"># This method is private to the class. Note the `!` before the</span>
    <span class="c1"># method&#39;s name.</span>
    <span class="k">method</span> !<span class="n">do-decoration</span> {
        <span class="k">return</span> <span class="s">&quot;$!name born in $!bcountry and now lives in $!ccountry.&quot;</span>
    }

    <span class="c1"># This method is public, just like `birthday` and `get-age`.</span>
    <span class="k">method</span> <span class="n">get-info</span> {
        <span class="c1"># Invoking a method on `self` inside the class.</span>
        <span class="c1"># Use `self!priv-method` for private method.</span>
        <span class="nb">say</span> <span class="nb">self</span><span class="o">!</span><span class="n">do-decoration</span>;

        <span class="c1"># Use `self.public-method` for public method.</span>
        <span class="nb">say</span> <span class="s">&quot;Age: &quot;</span>, <span class="nb">self</span>.<span class="n">get-age</span>;
    }
};

<span class="c1"># Create a new instance of Human class.</span>
<span class="c1"># NOTE: Only attributes declared with the `.` twigil can be set via the</span>
<span class="c1"># default constructor (more later on). This constructor only accepts named</span>
<span class="c1"># arguments.</span>
<span class="k">my</span> <span class="nv">$person1</span> = <span class="n">Human</span>.<span class="nb">new</span>(
    <span class="nb">name</span>     =&gt; <span class="s">&quot;Jord&quot;</span>,
    <span class="n">bcountry</span> =&gt; <span class="s">&quot;Togo&quot;</span>,
    <span class="n">ccountry</span> =&gt; <span class="s">&quot;Togo&quot;</span>
);

<span class="c1"># Make human 10 years old.</span>
<span class="nv">$person1</span>.<span class="n">birthday</span> <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span>;

<span class="nb">say</span> <span class="nv">$person1</span>.<span class="nb">name</span>;     <span class="c1"># OUTPUT: «Jord␤»</span>
<span class="nb">say</span> <span class="nv">$person1</span>.<span class="n">bcountry</span>; <span class="c1"># OUTPUT: «Togo␤»</span>
<span class="nb">say</span> <span class="nv">$person1</span>.<span class="n">ccountry</span>; <span class="c1"># OUTPUT: «Togo␤»</span>
<span class="nb">say</span> <span class="nv">$person1</span>.<span class="n">get-age</span>;  <span class="c1"># OUTPUT: «10␤»</span>

<span class="c1"># This fails, because the `has $.bcountry`is immutable. Jord can&#39;t change</span>
<span class="c1"># his birthplace.</span>
<span class="c1"># $person1.bcountry = &quot;Mali&quot;;</span>

<span class="c1"># This works because the `$.ccountry` is mutable (`is rw`). Now Jord&#39;s</span>
<span class="c1"># current country is France.</span>
<span class="nv">$person1</span>.<span class="n">ccountry</span> = <span class="s">&quot;France&quot;</span>;

<span class="c1"># Calling methods on the instance objects.</span>
<span class="nv">$person1</span>.<span class="n">birthday</span>;      <span class="c1">#=&gt; 1</span>
<span class="nv">$person1</span>.<span class="n">get-info</span>;      <span class="c1">#=&gt; Jord born in Togo and now lives in France. Age: 10</span>
<span class="c1"># $person1.do-decoration; # This fails since the method `do-decoration` is private.</span>

<span class="c1">#</span>
<span class="c1"># 10.1 Object Inheritance</span>
<span class="c1">#</span>

<span class="c1"># Raku also has inheritance (along with multiple inheritance). While</span>
<span class="c1"># methods are inherited, submethods are not. Submethods are useful for</span>
<span class="c1"># object construction and destruction tasks, such as `BUILD`, or methods that</span>
<span class="c1"># must be overridden by subtypes. We will learn about `BUILD` later on.</span>

<span class="k">class</span> <span class="n">Parent</span> {
    <span class="k">has</span> <span class="nv">$.age</span>;
    <span class="k">has</span> <span class="nv">$.name</span>;

    <span class="c1"># This submethod won&#39;t be inherited by the Child class.</span>
    <span class="k">submethod</span> <span class="n">favorite-color</span> {
        <span class="nb">say</span> <span class="s">&quot;My favorite color is Blue&quot;</span>;
    }

    <span class="c1"># This method is inherited</span>
    <span class="k">method</span> <span class="n">talk</span> { <span class="nb">say</span> <span class="s">&quot;Hi, my name is $!name&quot;</span> }
}

<span class="c1"># Inheritance uses the `is` keyword</span>
<span class="k">class</span> <span class="n">Child</span> <span class="k">is</span> <span class="n">Parent</span> {
    <span class="k">method</span> <span class="n">talk</span> { <span class="nb">say</span> <span class="s">&quot;Goo goo ga ga&quot;</span> }
    <span class="c1"># This shadows Parent&#39;s `talk` method.</span>
    <span class="c1"># This child hasn&#39;t learned to speak yet!</span>
}

<span class="k">my</span> <span class="n">Parent</span> <span class="nv">$Richard</span> .= <span class="nb">new</span>(<span class="n">age</span> =&gt; <span class="mi">40</span>, <span class="nb">name</span> =&gt; <span class="s">&#39;Richard&#39;</span>);
<span class="nv">$Richard</span>.<span class="n">favorite-color</span>;  <span class="c1"># OUTPUT: «My favorite color is Blue␤»</span>
<span class="nv">$Richard</span>.<span class="n">talk</span>;            <span class="c1"># OUTPUT: «Hi, my name is Richard␤»</span>
<span class="c1"># $Richard is able to access the submethod and he knows how to say his name.</span>

<span class="k">my</span> <span class="n">Child</span> <span class="nv">$Madison</span> .= <span class="nb">new</span>(<span class="n">age</span> =&gt; <span class="mi">1</span>, <span class="nb">name</span> =&gt; <span class="s">&#39;Madison&#39;</span>);
<span class="nv">$Madison</span>.<span class="n">talk</span>;            <span class="c1"># OUTPUT: «Goo goo ga ga␤», due to the overridden method.</span>
<span class="c1"># $Madison.favorite-color # does not work since it is not inherited.</span>

<span class="c1"># When you use `my T $var`, `$var` starts off with `T` itself in it, so you can</span>
<span class="c1"># call `new` on it. (`.=` is just the dot-call and the assignment operator).</span>
<span class="c1"># Thus, `$a .= b` is the same as `$a = $a.b`. Also note that `BUILD` (the method</span>
<span class="c1"># called inside `new`) will set parent&#39;s properties too, so you can pass `val =&gt;</span>
<span class="c1"># 5`.</span>

<span class="c1">#</span>
<span class="c1"># 10.2 Roles, or Mixins</span>
<span class="c1">#</span>

<span class="c1"># Roles are supported too (which are called Mixins in other languages)</span>
<span class="k">role</span> <span class="n">PrintableVal</span> {
    <span class="k">has</span> <span class="nv">$!counter</span> = <span class="mi">0</span>;
    <span class="k">method</span> <span class="nb">print</span> {
        <span class="nb">say</span> <span class="nv">$.val</span>;
    }
}

<span class="c1"># you &quot;apply&quot; a role (or mixin) with the `does` keyword:</span>
<span class="k">class</span> <span class="n">Item</span> <span class="k">does</span> <span class="n">PrintableVal</span> {
    <span class="k">has</span> <span class="nv">$.val</span>;

<span class="cm">    =begin comment</span>
<span class="cm">    When `does`-ed, a `role` literally &quot;mixes in&quot; the class:</span>
<span class="cm">    the methods and attributes are put together, which means a class</span>
<span class="cm">    can access the private attributes/methods of its roles (but</span>
<span class="cm">    not the inverse!):</span>
<span class="cm">    =end comment</span>
    <span class="k">method</span> <span class="n">access</span> {
        <span class="nb">say</span> <span class="nv">$!counter</span>++;
    }

<span class="cm">    =begin comment</span>
<span class="cm">    However, this: method print {} is ONLY valid when `print` isn&#39;t a `multi`</span>
<span class="cm">    with the same dispatch. This means a parent class can shadow a child class&#39;s</span>
<span class="cm">    `multi print() {}`, but it&#39;s an error if a role does)</span>

<span class="cm">    NOTE: You can use a role as a class (with `is ROLE`). In this case,</span>
<span class="cm">    methods will be shadowed, since the compiler will consider `ROLE`</span>
<span class="cm">    to be a class.</span>
<span class="cm">    =end comment</span>
}

<span class="c1">####################################################</span>
<span class="c1"># 11. Exceptions</span>
<span class="c1">####################################################</span>

<span class="c1"># Exceptions are built on top of classes, in the package `X` (like `X::IO`).</span>
<span class="c1"># In Raku, exceptions are automatically &#39;thrown&#39;:</span>

<span class="c1"># open &#39;foo&#39;;   # OUTPUT: «Failed to open file foo: no such file or directory␤»</span>

<span class="c1"># It will also print out what line the error was thrown at</span>
<span class="c1"># and other error info.</span>

<span class="c1"># You can throw an exception using `die`. Here it&#39;s been commented out to</span>
<span class="c1"># avoid stopping the program&#39;s execution:</span>
<span class="c1"># die &#39;Error!&#39;; # OUTPUT: «Error!␤»</span>

<span class="c1"># Or more explicitly (commented out too):</span>
<span class="c1"># X::AdHoc.new(payload =&gt; &#39;Error!&#39;).throw; # OUTPUT: «Error!␤»</span>

<span class="c1"># In Raku, `orelse` is similar to the `or` operator, except it only matches</span>
<span class="c1"># undefined variables instead of anything evaluating as `False`.</span>
<span class="c1"># Undefined values include: `Nil`, `Mu` and `Failure` as well as `Int`, `Str`</span>
<span class="c1"># and other types that have not been initialized to any value yet.</span>
<span class="c1"># You can check if something is defined or not using the defined method:</span>
<span class="k">my</span> <span class="nv">$uninitialized</span>;
<span class="nb">say</span> <span class="nv">$uninitialized</span>.<span class="nb">defined</span>; <span class="c1"># OUTPUT: «False␤»</span>

<span class="c1"># When using `orelse` it will disarm the exception and alias $_ to that</span>
<span class="c1"># failure. This will prevent it to being automatically handled and printing</span>
<span class="c1"># lots of scary error messages to the screen. We can use the `exception`</span>
<span class="c1"># method on the `$_` variable to access the exception</span>
<span class="nb">open</span> <span class="s">&#39;foo&#39;</span> <span class="o">orelse</span> <span class="nb">say</span> <span class="s">&quot;Something happened {.exception}&quot;</span>;

<span class="c1"># This also works:</span>
<span class="nb">open</span> <span class="s">&#39;foo&#39;</span> <span class="o">orelse</span> <span class="nb">say</span> <span class="s">&quot;Something happened $_&quot;</span>;
<span class="c1"># OUTPUT: «Something happened Failed to open file foo: no such file or directory␤»</span>

<span class="c1"># Both of those above work but in case we get an object from the left side</span>
<span class="c1"># that is not a failure we will probably get a warning. We see below how we</span>
<span class="c1"># can use try` and `CATCH` to be more specific with the exceptions we catch.</span>

<span class="c1">#</span>
<span class="c1"># 11.1 Using `try` and `CATCH`</span>
<span class="c1">#</span>

<span class="c1"># By using `try` and `CATCH` you can contain and handle exceptions without</span>
<span class="c1"># disrupting the rest of the program. The `try` block will set the last</span>
<span class="c1"># exception to the special variable `$!` (known as the error variable).</span>
<span class="c1"># NOTE: This has no relation to $!variables seen inside class definitions.</span>

<span class="k">try</span> <span class="nb">open</span> <span class="s">&#39;foo&#39;</span>;
<span class="nb">say</span> <span class="s">&quot;Well, I tried! $!&quot;</span> <span class="k">if</span> <span class="nb">defined</span> <span class="vg">$!</span>;
<span class="c1"># OUTPUT: «Well, I tried! Failed to open file foo: no such file or directory␤»</span>

<span class="c1"># Now, what if we want more control over handling the exception?</span>
<span class="c1"># Unlike many other languages, in Raku, you put the `CATCH` block *within*</span>
<span class="c1"># the block to `try`. Similar to how the `$_` variable was set when we</span>
<span class="c1"># &#39;disarmed&#39; the exception with `orelse`, we also use `$_` in the CATCH block.</span>
<span class="c1"># NOTE: The `$!` variable is only set *after* the `try` block has caught an</span>
<span class="c1"># exception. By default, a `try` block has a `CATCH` block of its own that</span>
<span class="c1"># catches any exception (`CATCH { default {} }`).</span>

<span class="k">try</span> {
    <span class="k">my</span> <span class="nv">$a</span> = (<span class="mi">0</span> %% <span class="mi">0</span>);
    <span class="k">CATCH</span> {
        <span class="k">default</span> { <span class="nb">say</span> <span class="s">&quot;Something happened: $_&quot;</span> }
    }
}
<span class="c1"># OUTPUT: «Something happened: Attempt to divide by zero using infix:&lt;%%&gt;␤»</span>

<span class="c1"># You can redefine it using `when`s (and `default`) to handle the exceptions</span>
<span class="c1"># you want to catch explicitly:</span>

<span class="k">try</span> {
  <span class="nb">open</span> <span class="s">&#39;foo&#39;</span>;
    <span class="k">CATCH</span> {
        <span class="c1"># In the `CATCH` block, the exception is set to the $_ variable.</span>
        <span class="k">when</span> <span class="o">X</span>::<span class="n">AdHoc</span> {
            <span class="nb">say</span> <span class="s">&quot;Error: $_&quot;</span>
        }
        <span class="k">when</span> <span class="o">X</span>::<span class="n">Numeric::DivideByZero</span> {
            <span class="nb">say</span> <span class="s">&quot;Error: $_&quot;</span>;
        }

<span class="cm">        =begin comment</span>
<span class="cm">        Any other exceptions will be re-raised, since we don&#39;t have a `default`.</span>
<span class="cm">        Basically, if a `when` matches (or there&#39;s a `default`), the</span>
<span class="cm">        exception is marked as &quot;handled&quot; so as to prevent its re-throw</span>
<span class="cm">        from the `CATCH` block. You still can re-throw the exception</span>
<span class="cm">        (see below) by hand.</span>
<span class="cm">        =end comment</span>
        <span class="k">default</span> {
            <span class="nb">say</span> <span class="s">&quot;Any other error: $_&quot;</span>
        }
  }
}
<span class="c1"># OUTPUT: «Failed to open file /dir/foo: no such file or directory␤»</span>

<span class="c1"># There are also some subtleties to exceptions. Some Raku subs return a</span>
<span class="c1"># `Failure`, which is a wrapper around an `Exception` object which is</span>
<span class="c1"># &quot;unthrown&quot;. They&#39;re not thrown until you try to use the variables containing</span>
<span class="c1"># them unless you call `.Bool`/`.defined` on them - then they&#39;re handled.</span>
<span class="c1"># (the `.handled` method is `rw`, so you can mark it as `False` back yourself)</span>
<span class="c1"># You can throw a `Failure` using `fail`. Note that if the pragma `use fatal`</span>
<span class="c1"># is on, `fail` will throw an exception (like `die`).</span>

<span class="k">my</span> <span class="nv">$value</span> = <span class="mi">0</span><span class="o">/</span><span class="mi">0</span>; <span class="c1"># We&#39;re not trying to access the value, so no problem.</span>
<span class="k">try</span> {
    <span class="nb">say</span> <span class="s">&#39;Value: &#39;</span>, <span class="nv">$value</span>; <span class="c1"># Trying to use the value</span>
    <span class="k">CATCH</span> {
        <span class="k">default</span> {
            <span class="nb">say</span> <span class="s">&quot;It threw because we tried to get the fail&#39;s value!&quot;</span>
        }
  }
}

<span class="c1"># There is also another kind of exception: Control exceptions. Those are &quot;good&quot;</span>
<span class="c1"># exceptions, which happen when you change your program&#39;s flow, using operators</span>
<span class="c1"># like `return`, `next` or `last`. You can &quot;catch&quot; those with `CONTROL` (not 100%</span>
<span class="c1"># working in Rakudo yet).</span>

<span class="c1">####################################################</span>
<span class="c1"># 12. Packages</span>
<span class="c1">####################################################</span>

<span class="c1"># Packages are a way to reuse code. Packages are like &quot;namespaces&quot;, and any</span>
<span class="c1"># element of the six model (`module`, `role`, `class`, `grammar`, `subset` and</span>
<span class="c1"># `enum`) are actually packages. (Packages are the lowest common denominator)</span>
<span class="c1"># Packages are important - especially as Perl is well-known for CPAN,</span>
<span class="c1"># the Comprehensive Perl Archive Network.</span>

<span class="c1"># You can use a module (bring its declarations into scope) with `use`:</span>
<span class="k">use</span> <span class="n">JSON::Tiny</span>; <span class="c1"># if you installed Rakudo* or Panda, you&#39;ll have this module</span>
<span class="nb">say</span> <span class="n">from-json</span>(<span class="s">&#39;[1]&#39;</span>).<span class="nb">perl</span>; <span class="c1"># OUTPUT: «[1]␤»</span>

<span class="c1"># You should not declare packages using the `package` keyword (unlike Perl).</span>
<span class="c1"># Instead, use `class Package::Name::Here;` to declare a class, or if you only</span>
<span class="c1"># want to export variables/subs, you can use `module` instead.</span>

<span class="c1"># If `Hello` doesn&#39;t exist yet, it&#39;ll just be a &quot;stub&quot;, that can be redeclared</span>
<span class="c1"># as something else later.</span>
<span class="k">module</span> <span class="n">Hello::World</span> { <span class="c1"># bracketed form</span>
    <span class="c1"># declarations here</span>
}

<span class="c1"># The file-scoped form which extends until the end of the file. For</span>
<span class="c1"># instance, `unit module Parse::Text;` will extend until of the file.</span>

<span class="c1"># A grammar is a package, which you could `use`. You will learn more about</span>
<span class="c1"># grammars in the regex section.</span>
<span class="k">grammar</span> <span class="n">Parse::Text::Grammar</span> {
}

<span class="c1"># As said before, any part of the six model is also a package.</span>
<span class="c1"># Since `JSON::Tiny` uses its own `JSON::Tiny::Actions` class, you can use it:</span>
<span class="k">my</span> <span class="nv">$actions</span> = <span class="n">JSON::Tiny::Actions</span>.<span class="nb">new</span>;

<span class="c1"># We&#39;ll see how to export variables and subs in the next part.</span>

<span class="c1">####################################################</span>
<span class="c1"># 13. Declarators</span>
<span class="c1">####################################################</span>

<span class="c1"># In Raku, you get different behaviors based on how you declare a variable.</span>
<span class="c1"># You&#39;ve already seen `my` and `has`, we&#39;ll now explore the others.</span>

<span class="c1"># `our` - these declarations happen at `INIT` time -- (see &quot;Phasers&quot; below).</span>
<span class="c1"># It&#39;s like `my`, but it also creates a package variable. All packagish</span>
<span class="c1"># things such as `class`, `role`, etc. are `our` by default.</span>

<span class="k">module</span> <span class="n">Var::Increment</span> {
    <span class="c1"># NOTE: `our`-declared variables cannot be typed.</span>
    <span class="k">our</span> <span class="nv">$our-var</span> = <span class="mi">1</span>;
    <span class="k">my</span> <span class="nv">$my-var</span> = <span class="mi">22</span>;

    <span class="k">our</span> <span class="k">sub</span> <span class="n">Inc</span> {
        <span class="k">our</span> <span class="k">sub</span> <span class="n">available</span> { <span class="c1"># If you try to make inner `sub`s `our`...</span>
                            <span class="c1"># ... Better know what you&#39;re doing (Don&#39;t !).</span>
            <span class="nb">say</span> <span class="s">&quot;Don&#39;t do that. Seriously. You&#39;ll get burned.&quot;</span>;
        }

        <span class="k">my</span> <span class="k">sub</span> <span class="n">unavailable</span> { <span class="c1"># `sub`s are `my`-declared by default</span>
            <span class="nb">say</span> <span class="s">&quot;Can&#39;t access me from outside, I&#39;m &#39;my&#39;!&quot;</span>;
        }
        <span class="nb">say</span> ++<span class="nv">$our-var</span>; <span class="c1"># Increment the package variable and output its value</span>
  }

}

<span class="nb">say</span> <span class="nv">$Var::Increment::our-var</span>; <span class="c1"># OUTPUT: «1␤», this works!</span>
<span class="nb">say</span> <span class="nv">$Var::Increment::my-var</span>;  <span class="c1"># OUTPUT: «(Any)␤», this will not work!</span>

<span class="nb">say</span> <span class="n">Var::Increment::Inc</span>;  <span class="c1"># OUTPUT: «2␤»</span>
<span class="nb">say</span> <span class="n">Var::Increment::Inc</span>;  <span class="c1"># OUTPUT: «3␤», notice how the value of $our-var was retained.</span>

<span class="c1"># Var::Increment::unavailable;  # OUTPUT: «Could not find symbol &#39;&amp;unavailable&#39;␤»</span>

<span class="c1"># `constant` - these declarations happen at `BEGIN` time. You can use</span>
<span class="c1"># the `constant` keyword to declare a compile-time variable/symbol:</span>
<span class="k">constant</span> <span class="n">Pi</span> = <span class="mf">3.14</span>;
<span class="k">constant</span> <span class="nv">$var</span> = <span class="mi">1</span>;

<span class="c1"># And if you&#39;re wondering, yes, it can also contain infinite lists.</span>
<span class="k">constant</span> <span class="n">why-not</span> = <span class="mi">5</span>, <span class="mi">15</span> ... *;
<span class="nb">say</span> <span class="n">why-not</span>[^<span class="mi">5</span>]; <span class="c1"># OUTPUT: «5 15 25 35 45␤»</span>

<span class="c1"># `state` - these declarations happen at run time, but only once. State</span>
<span class="c1"># variables are only initialized one time. In other languages such as C</span>
<span class="c1"># they exist as `static` variables.</span>
<span class="k">sub</span> <span class="n">fixed-rand</span> {
    <span class="k">state</span> <span class="nv">$val</span> = <span class="nb">rand</span>;
    <span class="nb">say</span> <span class="nv">$val</span>;
}
<span class="n">fixed-rand</span> <span class="k">for</span> ^<span class="mi">10</span>; <span class="c1"># will print the same number 10 times</span>

<span class="c1"># Note, however, that they exist separately in different enclosing contexts.</span>
<span class="c1"># If you declare a function with a `state` within a loop, it&#39;ll re-create the</span>
<span class="c1"># variable for each iteration of the loop. See:</span>
<span class="k">for</span> ^<span class="mi">5</span> -&gt; <span class="nv">$a</span> {
    <span class="k">sub</span> <span class="n">foo</span> {
        <span class="c1"># This will be a different value for every value of `$a`</span>
        <span class="k">state</span> <span class="nv">$val</span> = <span class="nb">rand</span>;
    }
    <span class="k">for</span> ^<span class="mi">5</span> -&gt; <span class="nv">$b</span> {
        <span class="c1"># This will print the same value 5 times, but only 5. Next iteration</span>
        <span class="c1"># will re-run `rand`.</span>
        <span class="nb">say</span> <span class="n">foo</span>;
    }
}

<span class="c1">####################################################</span>
<span class="c1"># 14. Phasers</span>
<span class="c1">####################################################</span>

<span class="c1"># Phasers in Raku are blocks that happen at determined points of time in</span>
<span class="c1"># your program. They are called phasers because they mark a change in the</span>
<span class="c1"># phase of a program.  For example, when the program is compiled, a for loop</span>
<span class="c1"># runs, you leave a block, or an exception gets thrown (The `CATCH` block is</span>
<span class="c1"># actually a phaser!). Some of them can be used for their return values,</span>
<span class="c1"># some of them can&#39;t (those that can have a &quot;[*]&quot; in the beginning of their</span>
<span class="c1"># explanation text). Let&#39;s have a look!</span>

<span class="c1">#</span>
<span class="c1"># 14.1 Compile-time phasers</span>
<span class="c1">#</span>
<span class="k">BEGIN</span> { <span class="nb">say</span> <span class="s">&quot;[*] Runs at compile time, as soon as possible, only once&quot;</span> }
<span class="k">CHECK</span> { <span class="nb">say</span> <span class="s">&quot;[*] Runs at compile time, as late as possible, only once&quot;</span> }

<span class="c1">#</span>
<span class="c1"># 14.2 Run-time phasers</span>
<span class="c1">#</span>
<span class="k">INIT</span> { <span class="nb">say</span> <span class="s">&quot;[*] Runs at run time, as soon as possible, only once&quot;</span> }
<span class="k">END</span>  { <span class="nb">say</span> <span class="s">&quot;Runs at run time, as late as possible, only once&quot;</span> }

<span class="c1">#</span>
<span class="c1"># 14.3 Block phasers</span>
<span class="c1">#</span>
<span class="k">ENTER</span> { <span class="nb">say</span> <span class="s">&quot;[*] Runs every time you enter a block, repeats on loop blocks&quot;</span> }
<span class="k">LEAVE</span> {
    <span class="nb">say</span> <span class="s">&quot;Runs every time you leave a block, even when an exception</span>
<span class="s">    happened. Repeats on loop blocks.&quot;</span>
}

<span class="k">PRE</span> {
    <span class="nb">say</span> <span class="s">&quot;Asserts a precondition at every block entry,</span>
<span class="s">        before ENTER (especially useful for loops)&quot;</span>;
    <span class="nb">say</span> <span class="s">&quot;If this block doesn&#39;t return a truthy value,</span>
<span class="s">        an exception of type X::Phaser::PrePost is thrown.&quot;</span>;
}

<span class="c1"># Example (commented out):</span>
<span class="k">for</span> <span class="mi">0</span><span class="o">..</span><span class="mi">2</span> {
    <span class="c1"># PRE { $_ &gt; 1 } # OUTPUT: «Precondition &#39;{ $_ &gt; 1 }&#39; failed</span>
}

<span class="k">POST</span> {
    <span class="nb">say</span> <span class="s">&quot;Asserts a postcondition at every block exit,</span>
<span class="s">        after LEAVE (especially useful for loops)&quot;</span>;
    <span class="nb">say</span> <span class="s">&quot;If this block doesn&#39;t return a truthy value,</span>
<span class="s">        an exception of type X::Phaser::PrePost is thrown, like PRE.&quot;</span>;
}

<span class="c1"># Example (commented out):</span>
<span class="k">for</span> <span class="mi">0</span><span class="o">..</span><span class="mi">2</span> {
    <span class="c1"># POST { $_ &lt; 1 } # OUTPUT: «Postcondition &#39;{ $_ &lt; 1 }&#39; failed</span>
}

<span class="c1">#</span>
<span class="c1"># 14.4 Block/exceptions phasers</span>
<span class="c1">#</span>
{
    <span class="k">KEEP</span> { <span class="nb">say</span> <span class="s">&quot;Runs when you exit a block successfully</span>
<span class="s">                (without throwing an exception)&quot;</span> }
    <span class="k">UNDO</span> { <span class="nb">say</span> <span class="s">&quot;Runs when you exit a block unsuccessfully</span>
<span class="s">                (by throwing an exception)&quot;</span> }
}

<span class="c1">#</span>
<span class="c1"># 14.5 Loop phasers</span>
<span class="c1">#</span>
<span class="k">for</span> ^<span class="mi">5</span> {
  <span class="k">FIRST</span> { <span class="nb">say</span> <span class="s">&quot;[*] The first time the loop is run, before ENTER&quot;</span> }
  <span class="k">NEXT</span>  { <span class="nb">say</span> <span class="s">&quot;At loop continuation time, before LEAVE&quot;</span> }
  <span class="k">LAST</span>  { <span class="nb">say</span> <span class="s">&quot;At loop termination time, after LEAVE&quot;</span> }
}

<span class="c1">#</span>
<span class="c1"># 14.6 Role/class phasers</span>
<span class="c1">#</span>
<span class="n">COMPOSE</span> {
    <span class="nb">say</span> <span class="s">&quot;When a role is composed into a class. /!\ NOT YET IMPLEMENTED&quot;</span>
}

<span class="c1"># They allow for cute tricks or clever code...:</span>
<span class="nb">say</span> <span class="s">&quot;This code took &quot;</span> ~ (<span class="n">time</span> - <span class="k">CHECK</span> <span class="n">time</span>) ~ <span class="s">&quot;s to compile&quot;</span>;

<span class="c1"># ... or clever organization:</span>
<span class="k">class</span> <span class="n">DB</span> {
    <span class="k">method</span> <span class="n">start-transaction</span> { <span class="nb">say</span> <span class="s">&quot;Starting transaction!&quot;</span> }
    <span class="k">method</span> <span class="n">commit</span>            { <span class="nb">say</span> <span class="s">&quot;Committing transaction...&quot;</span> }
    <span class="k">method</span> <span class="n">rollback</span>          { <span class="nb">say</span> <span class="s">&quot;Something went wrong. Rolling back!&quot;</span> }
}

<span class="k">sub</span> <span class="n">do-db-stuff</span> {
    <span class="k">my</span> <span class="n">DB</span> <span class="nv">$db</span> .= <span class="nb">new</span>;
    <span class="nv">$db</span>.<span class="n">start-transaction</span>; <span class="c1"># start a new transaction</span>
    <span class="k">KEEP</span> <span class="nv">$db</span>.<span class="n">commit</span>;       <span class="c1"># commit the transaction if all went well</span>
    <span class="k">UNDO</span> <span class="nv">$db</span>.<span class="n">rollback</span>;     <span class="c1"># or rollback if all hell broke loose</span>
}

<span class="n">do-db-stuff</span>();

<span class="c1">####################################################</span>
<span class="c1"># 15. Statement prefixes</span>
<span class="c1">####################################################</span>

<span class="c1"># Those act a bit like phasers: they affect the behavior of the following</span>
<span class="c1"># code. Though, they run in-line with the executable code, so they&#39;re in</span>
<span class="c1"># lowercase. (`try` and `start` are theoretically in that list, but explained</span>
<span class="c1"># elsewhere) NOTE: all of these (except start) don&#39;t need explicit curly</span>
<span class="c1"># braces `{` and `}`.</span>

<span class="c1">#</span>
<span class="c1"># 15.1 `do` - It runs a block or a statement as a term.</span>
<span class="c1">#</span>

<span class="c1"># Normally you cannot use a statement as a value (or &quot;term&quot;). `do` helps</span>
<span class="c1"># us do it. With `do`, an `if`, for example, becomes a term returning a value.</span>
<span class="cm">=for comment :reason&lt;this fails since `if` is a statement&gt;</span>
<span class="cm">my $value = if True { 1 }</span>

<span class="c1"># this works!</span>
<span class="k">my</span> <span class="nv">$get-five</span> = <span class="nb">do</span> <span class="k">if</span> <span class="nb">True</span> { <span class="mi">5</span> }

<span class="c1">#</span>
<span class="c1"># 15.1 `once` - makes sure a piece of code only runs once.</span>
<span class="c1">#</span>
<span class="k">for</span> ^<span class="mi">5</span> {
    <span class="n">once</span> <span class="nb">say</span> <span class="mi">1</span>
};
<span class="c1"># OUTPUT: «1␤», only prints ... once</span>

<span class="c1"># Similar to `state`, they&#39;re cloned per-scope.</span>
<span class="k">for</span> ^<span class="mi">5</span> {
    <span class="k">sub</span> { <span class="n">once</span> <span class="nb">say</span> <span class="mi">1</span> }()
};
<span class="c1"># OUTPUT: «1 1 1 1 1␤», prints once per lexical scope.</span>

<span class="c1">#</span>
<span class="c1"># 15.2 `gather` - co-routine thread.</span>
<span class="c1">#</span>

<span class="c1"># The `gather` constructs allows us to `take` several values from an array/list,</span>
<span class="c1"># much like `do`.</span>
<span class="nb">say</span> <span class="k">gather</span> <span class="k">for</span> ^<span class="mi">5</span> {
    <span class="nb">take</span> <span class="nv">$_</span> * <span class="mi">3</span> - <span class="mi">1</span>;
    <span class="nb">take</span> <span class="nv">$_</span> * <span class="mi">3</span> + <span class="mi">1</span>;
}
<span class="c1"># OUTPUT: «-1 1 2 4 5 7 8 10 11 13␤»</span>

<span class="nb">say</span> <span class="nb">join</span> <span class="s">&#39;,&#39;</span>, <span class="k">gather</span> <span class="k">if</span> <span class="nb">False</span> {
    <span class="nb">take</span> <span class="mi">1</span>;
    <span class="nb">take</span> <span class="mi">2</span>;
    <span class="nb">take</span> <span class="mi">3</span>;
}
<span class="c1"># Doesn&#39;t print anything.</span>

<span class="c1">#</span>
<span class="c1"># 15.3 `eager` - evaluates a statement eagerly (forces eager context).</span>

<span class="c1"># Don&#39;t try this at home. This will probably hang for a while (and might crash)</span>
<span class="c1"># so commented out.</span>
<span class="c1"># eager 1..*;</span>

<span class="c1"># But consider, this version which doesn&#39;t print anything</span>
<span class="k">constant</span> <span class="n">thricev0</span> = <span class="k">gather</span> <span class="k">for</span> ^<span class="mi">3</span> { <span class="nb">say</span> <span class="nb">take</span> <span class="nv">$_</span> };
<span class="c1"># to:</span>
<span class="k">constant</span> <span class="n">thricev1</span> = <span class="nb">eager</span> <span class="k">gather</span> <span class="k">for</span> ^<span class="mi">3</span> { <span class="nb">say</span> <span class="nb">take</span> <span class="nv">$_</span> }; <span class="c1"># OUTPUT: «0 1 2␤»</span>

<span class="c1">####################################################</span>
<span class="c1"># 16. Iterables</span>
<span class="c1">####################################################</span>

<span class="c1"># Iterables are objects that can be iterated over for things such as</span>
<span class="c1"># the `for` construct.</span>

<span class="c1">#</span>
<span class="c1"># 16.1 `flat` - flattens iterables.</span>
<span class="c1">#</span>
<span class="nb">say</span> (<span class="mi">1</span>, <span class="mi">10</span>, (<span class="mi">20</span>, <span class="mi">10</span>) );      <span class="c1"># OUTPUT: «(1 10 (20 10))␤»,  notice how nested</span>
                             <span class="c1"># lists are preserved</span>
<span class="nb">say</span> (<span class="mi">1</span>, <span class="mi">10</span>, (<span class="mi">20</span>, <span class="mi">10</span>) ).<span class="nb">flat</span>; <span class="c1"># OUTPUT: «(1 10 20 10)␤», now the iterable is flat</span>

<span class="c1">#</span>
<span class="c1"># 16.2 `lazy` - defers actual evaluation until value is fetched by forcing lazy context.</span>
<span class="c1">#</span>
<span class="k">my</span> <span class="nv">@lazy-array</span> = (<span class="mi">1</span><span class="o">..</span><span class="mi">100</span>).<span class="nb">lazy</span>;
<span class="nb">say</span> <span class="nv">@lazy-array</span>.<span class="nb">is-lazy</span>; <span class="c1"># OUTPUT: «True␤», check for laziness with the `is-lazy` method.</span>

<span class="nb">say</span> <span class="nv">@lazy-array</span>;         <span class="c1"># OUTPUT: «[...]␤», List has not been iterated on!</span>

<span class="c1"># This works and will only do as much work as is needed.</span>
<span class="k">for</span> <span class="nv">@lazy-array</span> { .<span class="nb">print</span> };

<span class="c1"># (**TODO** explain that gather/take and map are all lazy)</span>

<span class="c1">#</span>
<span class="c1"># 16.3 `sink` - an `eager` that discards the results by forcing sink context.</span>
<span class="c1">#</span>
<span class="k">constant</span> <span class="n">nilthingie</span> = <span class="nb">sink</span> <span class="k">for</span> ^<span class="mi">3</span> { .<span class="nb">say</span> } <span class="c1">#=&gt; 0 1 2</span>
<span class="nb">say</span> <span class="n">nilthingie</span>.<span class="nb">perl</span>;                       <span class="c1"># OUTPUT: «Nil␤»</span>

<span class="c1">#</span>
<span class="c1"># 16.4 `quietly` - suppresses warnings in blocks.</span>
<span class="c1">#</span>
<span class="n">quietly</span> { <span class="nb">warn</span> <span class="s">&#39;This is a warning!&#39;</span> }; <span class="c1"># No output</span>

<span class="c1">####################################################</span>
<span class="c1"># 17. More operators thingies!</span>
<span class="c1">####################################################</span>

<span class="c1"># Everybody loves operators! Let&#39;s get more of them.</span>

<span class="c1"># The precedence list can be found here:</span>
<span class="c1"># https://docs.raku.org/language/operators#Operator_Precedence</span>
<span class="c1"># But first, we need a little explanation about associativity:</span>

<span class="c1">#</span>
<span class="c1"># 17.1 Binary operators</span>
<span class="c1">#</span>

<span class="k">my</span> (<span class="nv">$p</span>, <span class="nv">$q</span>, <span class="nv">$r</span>) = (<span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>);

<span class="c1"># Given some binary operator § (not a Raku-supported operator), then:</span>

<span class="c1"># $p § $q § $r; # with a left-associative  §, this is ($p § $q) § $r</span>
<span class="c1"># $p § $q § $r; # with a right-associative §, this is $p § ($q § $r)</span>
<span class="c1"># $p § $q § $r; # with a non-associative   §, this is illegal</span>
<span class="c1"># $p § $q § $r; # with a chain-associative §, this is ($p § $q) and ($q § $r)§</span>
<span class="c1"># $p § $q § $r; # with a list-associative  §, this is `infix:&lt;&gt;`</span>

<span class="c1">#</span>
<span class="c1"># 17.2 Unary operators</span>
<span class="c1">#</span>

<span class="c1"># Given some unary operator § (not a Raku-supported operator), then:</span>
<span class="c1"># §$p§ # with left-associative  §, this is (§$p)§</span>
<span class="c1"># §$p§ # with right-associative §, this is §($p§)</span>
<span class="c1"># §$p§ # with non-associative   §, this is illegal</span>

<span class="c1">#</span>
<span class="c1"># 17.3 Create your own operators!</span>
<span class="c1">#</span>

<span class="c1"># Okay, you&#39;ve been reading all of that, so you might want to try something</span>
<span class="c1"># more exciting?! I&#39;ll tell you a little secret (or not-so-secret):</span>
<span class="c1"># In Raku, all operators are actually just funny-looking subroutines.</span>

<span class="c1"># You can declare an operator just like you declare a sub. In the following</span>
<span class="c1"># example, `prefix` refers to the operator categories (prefix, infix, postfix,</span>
<span class="c1"># circumfix, and post-circumfix).</span>
<span class="k">sub</span> <span class="n">prefix:</span><span class="s">&lt;win&gt;</span>( <span class="nv">$winner</span> ) {
    <span class="nb">say</span> <span class="s">&quot;$winner Won!&quot;</span>;
}
<span class="n">win</span> <span class="s">&quot;The King&quot;</span>; <span class="c1"># OUTPUT: «The King Won!␤»</span>

<span class="c1"># you can still call the sub with its &quot;full name&quot;:</span>
<span class="nb">say</span> <span class="n">prefix:</span><span class="s">&lt;!&gt;(True);      # OUTPUT: «False␤»</span>
<span class="s">prefix:&lt;win&gt;</span>(<span class="s">&quot;The Queen&quot;</span>); <span class="c1"># OUTPUT: «The Queen Won!␤»</span>

<span class="k">sub</span> <span class="n">postfix:</span><span class="s">&lt;!&gt;( Int $n ) {</span>
<span class="s">    [*] 2..$n; # using the reduce meta-operator... See below ;-)!</span>
<span class="s">}</span>
<span class="s">say 5!; # OUTPUT: «120␤»</span>

<span class="s"># Postfix operators (&#39;after&#39;) have to come *directly* after the term.</span>
<span class="s"># No whitespace. You can use parentheses to disambiguate, i.e. `(5!)!`</span>

<span class="s">sub infix:&lt;times&gt;</span>( <span class="nb">Int</span> <span class="nv">$n</span>, <span class="nb">Block</span> <span class="nv">$r</span> ) { <span class="c1"># infix (&#39;between&#39;)</span>
    <span class="k">for</span> ^<span class="nv">$n</span> {
        <span class="c1"># You need the explicit parentheses to call the function in `$r`,</span>
        <span class="c1"># else you&#39;d be referring at the code object itself, like with `&amp;r`.</span>
        <span class="nv">$r</span>();
    }
}
<span class="mi">3</span> <span class="n">times</span> -&gt; { <span class="nb">say</span> <span class="s">&quot;hello&quot;</span> }; <span class="c1"># OUTPUT: «hello␤hello␤hello␤»</span>

<span class="c1"># It&#39;s recommended to put spaces around your infix operator calls.</span>

<span class="c1"># For circumfix and post-circumfix ones</span>
<span class="k">multi</span> <span class="n">circumfix:</span><span class="s">&lt;[ ]&gt;</span>( <span class="nb">Int</span> <span class="nv">$n</span> ) {
    <span class="nv">$n</span> ** <span class="nv">$n</span>
}
<span class="nb">say</span> [<span class="mi">5</span>]; <span class="c1"># OUTPUT: «3125␤»</span>

<span class="c1"># Circumfix means &#39;around&#39;. Again, no whitespace.</span>

<span class="k">multi</span> <span class="n">postcircumfix:</span><span class="s">&lt;{ }&gt;</span>( <span class="nb">Str</span> <span class="nv">$s</span>, <span class="nb">Int</span> <span class="nv">$idx</span> ) {
    <span class="nv">$s</span>.<span class="nb">substr</span>(<span class="nv">$idx</span>, <span class="mi">1</span>);
}
<span class="nb">say</span> <span class="s">&quot;abc&quot;</span>{<span class="mi">1</span>}; <span class="c1"># OUTPUT: «b␤», after the term `&quot;abc&quot;`, and around the index (1)</span>

<span class="c1"># Post-circumfix is &#39;after a term, around something&#39;</span>

<span class="c1"># This really means a lot -- because everything in Raku uses this.</span>
<span class="c1"># For example, to delete a key from a hash, you use the `:delete` adverb</span>
<span class="c1"># (a simple named argument underneath). For instance, the following statements</span>
<span class="c1"># are equivalent.</span>
<span class="k">my</span> <span class="nv">%person-stans</span> =
    <span class="s">&#39;Giorno Giovanna&#39;</span>  =&gt; <span class="s">&#39;Gold Experience&#39;</span>,
    <span class="s">&#39;Bruno Bucciarati&#39;</span> =&gt; <span class="s">&#39;Sticky Fingers&#39;</span>;
<span class="k">my</span> <span class="nv">$key</span> = <span class="s">&#39;Bruno Bucciarati&#39;</span>;
<span class="nv">%person-stans</span>{<span class="nv">$key</span>}:<span class="n">delete</span>;
<span class="n">postcircumfix:</span><span class="s">&lt;{ }&gt;</span>( <span class="nv">%person-stans</span>, <span class="s">&#39;Giorno Giovanna&#39;</span>, :<span class="n">delete</span> );
<span class="c1"># (you can call operators like this)</span>

<span class="c1"># It&#39;s *all* using the same building blocks! Syntactic categories</span>
<span class="c1"># (prefix infix ...), named arguments (adverbs), ..., etc. used to build</span>
<span class="c1"># the language - are available to you. Obviously, you&#39;re advised against</span>
<span class="c1"># making an operator out of *everything* -- with great power comes great</span>
<span class="c1"># responsibility.</span>

<span class="c1">#</span>
<span class="c1"># 17.4 Meta operators!</span>
<span class="c1">#</span>

<span class="c1"># Oh boy, get ready!. Get ready, because we&#39;re delving deep into the rabbit&#39;s</span>
<span class="c1"># hole, and you probably won&#39;t want to go back to other languages after</span>
<span class="c1"># reading this. (I&#39;m guessing you don&#39;t want to go back at this point but</span>
<span class="c1"># let&#39;s continue, for the journey is long and enjoyable!).</span>

<span class="c1"># Meta-operators, as their name suggests, are *composed* operators. Basically,</span>
<span class="c1"># they&#39;re operators that act on another operators.</span>

<span class="c1"># The reduce meta-operator is a prefix meta-operator that takes a binary</span>
<span class="c1"># function and one or many lists. If it doesn&#39;t get passed any argument,</span>
<span class="c1"># it either returns a &quot;default value&quot; for this operator (a meaningless value)</span>
<span class="c1"># or `Any` if there&#39;s none (examples below). Otherwise, it pops an element</span>
<span class="c1"># from the list(s) one at a time, and applies the binary function to the last</span>
<span class="c1"># result (or the first element of a list) and the popped element.</span>

<span class="c1"># To sum a list, you could use the reduce meta-operator with `+`, i.e.:</span>
<span class="nb">say</span> [+] <span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>; <span class="c1"># OUTPUT: «6␤», equivalent to (1+2)+3.</span>

<span class="c1"># To multiply a list</span>
<span class="nb">say</span> [*] <span class="mi">1</span><span class="o">..</span><span class="mi">5</span>; <span class="c1"># OUTPUT: «120␤», equivalent to ((((1*2)*3)*4)*5).</span>

<span class="c1"># You can reduce with any operator, not just with mathematical ones.</span>
<span class="c1"># For example, you could reduce with `//` to get first defined element</span>
<span class="c1"># of a list:</span>
<span class="nb">say</span> [//] <span class="nb">Nil</span>, <span class="nb">Any</span>, <span class="nb">False</span>, <span class="mi">1</span>, <span class="mi">5</span>;  <span class="c1"># OUTPUT: «False␤»</span>
                                 <span class="c1"># (Falsey, but still defined)</span>
<span class="c1"># Or with relational operators, i.e., `&gt;` to check elements of a list</span>
<span class="c1"># are ordered accordingly:</span>
<span class="nb">say</span> [&gt;] <span class="mi">234</span>, <span class="mi">156</span>, <span class="mi">6</span>, <span class="mi">3</span>, -<span class="mi">20</span>; <span class="c1"># OUTPUT: «True␤»</span>

<span class="c1"># Default value examples:</span>
<span class="nb">say</span> [*] (); <span class="c1"># OUTPUT: «1␤», empty product</span>
<span class="nb">say</span> [+] (); <span class="c1"># OUTPUT: «0␤», empty sum</span>
<span class="nb">say</span> [//];   <span class="c1"># OUTPUT: «(Any)␤»</span>
            <span class="c1"># There&#39;s no &quot;default value&quot; for `//`.</span>

<span class="c1"># You can also use it with a function you made up,</span>
<span class="c1"># You can also surround  using double brackets:</span>
<span class="k">sub</span> <span class="nb">add</span>(<span class="nv">$a</span>, <span class="nv">$b</span>) { <span class="nv">$a</span> + <span class="nv">$b</span> }
<span class="nb">say</span> [[<span class="nv">&amp;add</span>]] <span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>; <span class="c1"># OUTPUT: «6␤»</span>

<span class="c1"># The zip meta-operator is an infix meta-operator that also can be used as a</span>
<span class="c1"># &quot;normal&quot; operator. It takes an optional binary function (by default, it</span>
<span class="c1"># just creates a pair), and will pop one value off of each array and call</span>
<span class="c1"># its binary function on these until it runs out of elements. It returns an</span>
<span class="c1"># array with all of these new elements.</span>
<span class="nb">say</span> (<span class="mi">1</span>, <span class="mi">2</span>) <span class="o">Z</span> (<span class="mi">3</span>, <span class="mi">4</span>); <span class="c1"># OUTPUT: «((1, 3), (2, 4))␤»</span>
<span class="nb">say</span> <span class="mi">1</span><span class="o">..</span><span class="mi">3</span> <span class="o">Z</span>+ <span class="mi">4</span><span class="o">..</span><span class="mi">6</span>;    <span class="c1"># OUTPUT: «(5, 7, 9)␤»</span>

<span class="c1"># Since `Z` is list-associative (see the list above), you can use it on more</span>
<span class="c1"># than one list.</span>
(<span class="nb">True</span>, <span class="nb">False</span>) <span class="o">Z</span>|| (<span class="nb">False</span>, <span class="nb">False</span>) <span class="o">Z</span>|| (<span class="nb">False</span>, <span class="nb">False</span>); <span class="c1"># (True, False)</span>

<span class="c1"># And, as it turns out, you can also use the reduce meta-operator with it:</span>
[<span class="o">Z</span>||] (<span class="nb">True</span>, <span class="nb">False</span>), (<span class="nb">False</span>, <span class="nb">False</span>), (<span class="nb">False</span>, <span class="nb">False</span>); <span class="c1"># (True, False)</span>

<span class="c1"># And to end the operator list:</span>

<span class="c1"># The sequence operator (`...`) is one of Raku&#39;s most powerful features:</span>
<span class="c1"># It&#39;s composed by the list (which might include a closure) you want Raku to</span>
<span class="c1"># deduce from on the left and a value (or either a predicate or a Whatever Star</span>
<span class="c1"># for a lazy infinite list) on the right that states when to stop.</span>

<span class="c1"># Basic arithmetic sequence</span>
<span class="k">my</span> <span class="nv">@listv0</span> = <span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>..<span class="mf">.10</span>;

<span class="c1"># This dies because Raku can&#39;t figure out the end</span>
<span class="c1"># my @list = 1, 3, 6...10;</span>

<span class="c1"># As with ranges, you can exclude the last element (the iteration ends when</span>
<span class="c1"># the predicate matches).</span>
<span class="k">my</span> <span class="nv">@listv1</span> = <span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>...^<span class="mi">10</span>;

<span class="c1"># You can use a predicate (with the Whatever Star).</span>
<span class="k">my</span> <span class="nv">@listv2</span> = <span class="mi">1</span>, <span class="mi">3</span>, <span class="mi">9</span>...* &gt; <span class="mi">30</span>;

<span class="c1"># Equivalent to the example above but using a block here.</span>
<span class="k">my</span> <span class="nv">@listv3</span> = <span class="mi">1</span>, <span class="mi">3</span>, <span class="mi">9</span> ... { <span class="nv">$_</span> &gt; <span class="mi">30</span> };

<span class="c1"># Lazy infinite list of fibonacci sequence, computed using a closure!</span>
<span class="k">my</span> <span class="nv">@fibv0</span> = <span class="mi">1</span>, <span class="mi">1</span>, *+* ... *;

<span class="c1"># Equivalent to the above example but using a pointy block.</span>
<span class="k">my</span> <span class="nv">@fibv1</span> = <span class="mi">1</span>, <span class="mi">1</span>, -&gt; <span class="nv">$a</span>, <span class="nv">$b</span> { <span class="nv">$a</span> + <span class="nv">$b</span> } ... *;

<span class="c1"># Equivalent to the above example but using a block with placeholder parameters.</span>
<span class="k">my</span> <span class="nv">@fibv2</span> = <span class="mi">1</span>, <span class="mi">1</span>, { <span class="nv">$^a</span> + <span class="nv">$^b</span> } ... *;

<span class="c1"># In the examples with explicit parameters (i.e., $a and $b), $a and $b</span>
<span class="c1"># will always take the previous values, meaning that for the Fibonacci sequence,</span>
<span class="c1"># they&#39;ll start with $a = 1 and $b = 1 (values we set by hand), then $a = 1</span>
<span class="c1"># and $b = 2 (result from previous $a + $b), and so on.</span>

<span class="c1"># In the example we use a range as an index to access the sequence. However,</span>
<span class="c1"># it&#39;s worth noting that for ranges, once reified, elements aren&#39;t re-calculated.</span>
<span class="c1"># That&#39;s why, for instance, `@primes[^100]` will take a long time the first</span>
<span class="c1"># time you print it but then it will be instantaneous.</span>
<span class="nb">say</span> <span class="nv">@fibv0</span>[^<span class="mi">10</span>]; <span class="c1"># OUTPUT: «1 1 2 3 5 8 13 21 34 55␤»</span>

<span class="c1">####################################################</span>
<span class="c1"># 18. Regular Expressions</span>
<span class="c1">####################################################</span>

<span class="c1"># I&#39;m sure a lot of you have been waiting for this one. Well, now that you know</span>
<span class="c1"># a good deal of Raku already, we can get started. First off, you&#39;ll have to</span>
<span class="c1"># forget about &quot;PCRE regexps&quot; (perl-compatible regexps).</span>

<span class="c1"># IMPORTANT: Don&#39;t skip them because you know PCRE. They&#39;re different. Some</span>
<span class="c1"># things are the same (like `?`, `+`, and `*`), but sometimes the semantics</span>
<span class="c1"># change (`|`). Make sure you read carefully, because you might trip over a</span>
<span class="c1"># new behavior.</span>

<span class="c1"># Raku has many features related to RegExps. After all, Rakudo parses itself.</span>
<span class="c1"># We&#39;re first going to look at the syntax itself, then talk about grammars</span>
<span class="c1"># (PEG-like), differences between `token`, `regex` and `rule` declarators,</span>
<span class="c1"># and some more. Side note: you still have access to PCRE regexps using the</span>
<span class="c1"># `:P5` modifier which we won&#39;t be discussing this in this tutorial, though.</span>

<span class="c1"># In essence, Raku natively implements PEG (&quot;Parsing Expression Grammars&quot;).</span>
<span class="c1"># The pecking order for ambiguous parses is determined by a multi-level</span>
<span class="c1"># tie-breaking test:</span>
<span class="c1">#  - Longest token matching: `foo\s+` beats `foo` (by 2 or more positions)</span>
<span class="c1">#  - Longest literal prefix: `food\w*` beats `foo\w*` (by 1)</span>
<span class="c1">#  - Declaration from most-derived to less derived grammars</span>
<span class="c1">#    (grammars are actually classes)</span>
<span class="c1">#  - Earliest declaration wins</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;a&#39;</span> ~~<span class="sr"> /a/</span>;   <span class="c1"># OUTPUT: «True␤»</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;a&#39;</span> ~~<span class="sr"> / a /</span>; <span class="c1"># OUTPUT: «True␤», more readable with some spaces!</span>

<span class="c1"># In all our examples, we&#39;re going to use the smart-matching operator against</span>
<span class="c1"># a regexp. We&#39;re converting the result using `so` to a Boolean value because,</span>
<span class="c1"># in fact, it&#39;s returning a `Match` object. They know how to respond to list</span>
<span class="c1"># indexing, hash indexing, and return the matched string. The results of the</span>
<span class="c1"># match are available in the `$/` variable (implicitly lexically-scoped). You</span>
<span class="c1"># can also use the capture variables which start at 0: `$0`, `$1&#39;, `$2`...</span>

<span class="c1"># You can also note that `~~` does not perform start/end checking, meaning</span>
<span class="c1"># the regexp can be matched with just one character of the string. We&#39;ll</span>
<span class="c1"># explain later how you can do it.</span>

<span class="c1"># In Raku, you can have any alphanumeric as a literal, everything else has</span>
<span class="c1"># to be escaped by using a backslash or quotes.</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;a|b&#39;</span> ~~<span class="sr"> / a &#39;|&#39; b /</span>; <span class="c1"># OUTPUT: «True␤», it wouldn&#39;t mean the same</span>
                             <span class="c1"># thing if `|` wasn&#39;t escaped.</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;a|b&#39;</span> ~~<span class="sr"> / a \| b /</span>;  <span class="c1"># OUTPUT: «True␤», another way to escape it.</span>

<span class="c1"># The whitespace in a regex is actually not significant, unless you use the</span>
<span class="c1"># `:s` (`:sigspace`, significant space) adverb.</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;a b c&#39;</span> ~~<span class="sr"> / a  b  c /</span>; <span class="c1">#=&gt; `False`, space is not significant here!</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;a b c&#39;</span> ~~<span class="sr"> /:s a b c /</span>; <span class="c1">#=&gt; `True`, we added the modifier `:s` here.</span>

<span class="c1"># If we use only one space between strings in a regex, Raku will warn us</span>
<span class="c1"># about space being not signicant in the regex:</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;a b c&#39;</span> ~~<span class="sr"> / a b c /</span>;   <span class="c1"># OUTPUT: «False␤»</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;a b c&#39;</span> ~~<span class="sr"> / a  b  c /</span>; <span class="c1"># OUTPUT: «False»</span>

<span class="c1"># NOTE: Please use quotes or `:s` (`:sigspace`) modifier (or, to suppress this</span>
<span class="c1"># warning, omit the space, or otherwise change the spacing). To fix this and make</span>
<span class="c1"># the spaces less ambiguous, either use at least two spaces between strings</span>
<span class="c1"># or use the `:s` adverb.</span>

<span class="c1"># As we saw before, we can embed the `:s` inside the slash delimiters, but we</span>
<span class="c1"># can also put it outside of them if we specify `m` for &#39;match&#39;:</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;a b c&#39;</span> ~~ <span class="sr">m:s/a  b  c/</span>; <span class="c1"># OUTPUT: «True␤»</span>

<span class="c1"># By using `m` to specify &#39;match&#39;, we can also use other delimiters:</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;abc&#39;</span> ~~ <span class="sr">m{a  b  c}</span>;     <span class="c1"># OUTPUT: «True␤»</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;abc&#39;</span> ~~ <span class="sr">m[a  b  c]</span>;     <span class="c1"># OUTPUT: «True␤»</span>

<span class="c1"># `m/.../` is equivalent to `/.../`:</span>
<span class="nb">say</span> <span class="s">&#39;raku&#39;</span> ~~ <span class="sr">m/raku/</span>; <span class="c1"># OUTPUT: «True␤»</span>
<span class="nb">say</span> <span class="s">&#39;raku&#39;</span> ~~<span class="sr"> /raku/</span>;  <span class="c1"># OUTPUT: «True␤»</span>

<span class="c1"># Use the `:i` adverb to specify case insensitivity:</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;ABC&#39;</span> ~~ <span class="sr">m:i{a  b  c}</span>;   <span class="c1"># OUTPUT: «True␤»</span>

<span class="c1"># However, whitespace is important as for how modifiers are applied</span>
<span class="c1"># (which you&#39;ll see just below) ...</span>

<span class="c1">#</span>
<span class="c1"># 18.1 Quantifiers - `?`, `+`, `*` and `**`.</span>
<span class="c1">#</span>

<span class="c1"># `?` - zero or one match</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;ac&#39;</span> ~~<span class="sr"> / a  b  c /</span>;   <span class="c1"># OUTPUT: «False␤»</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;ac&#39;</span> ~~<span class="sr"> / a  b?  c /</span>;  <span class="c1"># OUTPUT: «True␤», the &quot;b&quot; matched 0 times.</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;abc&#39;</span> ~~<span class="sr"> / a  b?  c /</span>; <span class="c1"># OUTPUT: «True␤», the &quot;b&quot; matched 1 time.</span>

<span class="c1"># ... As you read before, whitespace is important because it determines which</span>
<span class="c1"># part of the regex is the target of the modifier:</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;def&#39;</span> ~~<span class="sr"> / a  b  c? /</span>; <span class="c1"># OUTPUT: «False␤», only the &quot;c&quot; is optional</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;def&#39;</span> ~~<span class="sr"> / a  b?  c /</span>; <span class="c1"># OUTPUT: «False␤», whitespace is not significant</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;def&#39;</span> ~~<span class="sr"> / &#39;abc&#39;? /</span>;   <span class="c1"># OUTPUT: «True␤»,  the whole &quot;abc&quot; group is optional</span>

<span class="c1"># Here (and below) the quantifier applies only to the &quot;b&quot;</span>

<span class="c1"># `+` - one or more matches</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;ac&#39;</span> ~~<span class="sr"> / a  b+  c /</span>;     <span class="c1"># OUTPUT: «False␤», `+` wants at least one &#39;b&#39;</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;abc&#39;</span> ~~<span class="sr"> / a  b+  c /</span>;    <span class="c1"># OUTPUT: «True␤», one is enough</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;abbbbc&#39;</span> ~~<span class="sr"> / a  b+  c /</span>; <span class="c1"># OUTPUT: «True␤», matched 4 &quot;b&quot;s</span>

<span class="c1"># `*` - zero or more matches</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;ac&#39;</span> ~~<span class="sr"> / a  b*  c /</span>;     <span class="c1"># OUTPUT: «True␤», they&#39;re all optional</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;abc&#39;</span> ~~<span class="sr"> / a  b*  c /</span>;    <span class="c1"># OUTPUT: «True␤»</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;abbbbc&#39;</span> ~~<span class="sr"> / a  b*  c /</span>; <span class="c1"># OUTPUT: «True␤»</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;aec&#39;</span> ~~<span class="sr"> / a  b*  c /</span>;    <span class="c1"># OUTPUT: «False␤», &quot;b&quot;(s) are optional, not replaceable.</span>

<span class="c1"># `**` - (Unbound) Quantifier</span>
<span class="c1"># If you squint hard enough, you might understand why exponentiation is used</span>
<span class="c1"># for quantity.</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;abc&#39;</span> ~~<span class="sr"> / a  b**1  c /</span>;         <span class="c1"># OUTPUT: «True␤», exactly one time</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;abc&#39;</span> ~~<span class="sr"> / a  b**1..3  c /</span>;      <span class="c1"># OUTPUT: «True␤», one to three times</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;abbbc&#39;</span> ~~<span class="sr"> / a  b**1..3  c /</span>;    <span class="c1"># OUTPUT: «True␤»</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;abbbbbbc&#39;</span> ~~<span class="sr"> / a  b**1..3  c /</span>; <span class="c1"># OUTPUT: «Fals␤», too much</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;abbbbbbc&#39;</span> ~~<span class="sr"> / a  b**3..*  c /</span>; <span class="c1"># OUTPUT: «True␤», infinite ranges are ok</span>

<span class="c1">#</span>
<span class="c1"># 18.2 `&lt;[]&gt;` - Character classes</span>
<span class="c1">#</span>

<span class="c1"># Character classes are the equivalent of PCRE&#39;s `[]` classes, but they use a</span>
<span class="c1"># more raku-ish syntax:</span>
<span class="nb">say</span> <span class="s">&#39;fooa&#39;</span> ~~<span class="sr"> / f &lt;[ o a ]&gt;+ /</span>;  <span class="c1"># OUTPUT: «fooa␤»</span>

<span class="c1"># You can use ranges (`..`):</span>
<span class="nb">say</span> <span class="s">&#39;aeiou&#39;</span> ~~<span class="sr"> / a &lt;[ e..w ]&gt; /</span>; <span class="c1"># OUTPUT: «ae␤»</span>

<span class="c1"># Just like in normal regexes, if you want to use a special character, escape</span>
<span class="c1"># it (the last one is escaping a space which would be equivalent to using</span>
<span class="c1"># &#39; &#39;):</span>
<span class="nb">say</span> <span class="s">&#39;he-he !&#39;</span> ~~<span class="sr"> / &#39;he-&#39; &lt;[ a..z \! \  ]&gt; + /</span>; <span class="c1"># OUTPUT: «he-he !␤»</span>

<span class="c1"># You&#39;ll get a warning if you put duplicate names (which has the nice effect</span>
<span class="c1"># of catching the raw quoting):</span>
<span class="s">&#39;he he&#39;</span> ~~<span class="sr"> / &lt;[ h e &#39; &#39; ]&gt; /</span>;
<span class="c1"># Warns &quot;Repeated character (&#39;) unexpectedly found in character class&quot;</span>

<span class="c1"># You can also negate character classes... (`&lt;-[]&gt;` equivalent to `[^]` in PCRE)</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;foo&#39;</span> ~~<span class="sr"> / &lt;-[ f o ]&gt; + /</span>; <span class="c1"># OUTPUT: «False␤»</span>

<span class="c1"># ... and compose them:</span>
<span class="c1"># any letter except &quot;f&quot; and &quot;o&quot;</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;foo&#39;</span> ~~<span class="sr"> / &lt;[ a..z ] - [ f o ]&gt; + /</span>;   <span class="c1"># OUTPUT: «False␤»</span>

<span class="c1"># no letter except &quot;f&quot; and &quot;o&quot;</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;foo&#39;</span> ~~<span class="sr"> / &lt;-[ a..z ] + [ f o ]&gt; + /</span>;  <span class="c1"># OUTPUT: «True␤»</span>

<span class="c1"># the + doesn&#39;t replace the left part</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;foo!&#39;</span> ~~<span class="sr"> / &lt;-[ a..z ] + [ f o ]&gt; + /</span>; <span class="c1"># OUTPUT: «True␤»</span>

<span class="c1">#</span>
<span class="c1"># 18.3 Grouping and capturing</span>
<span class="c1">#</span>

<span class="c1"># Group: you can group parts of your regexp with `[]`. Unlike PCRE&#39;s `(?:)`,</span>
<span class="c1"># these groups are *not* captured.</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;abc&#39;</span> ~~<span class="sr"> / a [ b ] c /</span>;  <span class="c1"># OUTPUT: «True␤», the grouping does nothing</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;foo012012bar&#39;</span> ~~<span class="sr"> / foo [ &#39;01&#39; &lt;[0..9]&gt; ] + bar /</span>; <span class="c1"># OUTPUT: «True␤»</span>

<span class="c1"># The previous line returns `True`. The regex matches &quot;012&quot; one or more time</span>
<span class="c1"># (achieved by the the `+` applied to the group).</span>

<span class="c1"># But this does not go far enough, because we can&#39;t actually get back what</span>
<span class="c1"># we matched.</span>

<span class="c1"># Capture: The results of a regexp can be *captured* by using parentheses.</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;fooABCABCbar&#39;</span> ~~<span class="sr"> / foo ( &#39;A&#39; &lt;[A..Z]&gt; &#39;C&#39; ) + bar /</span>; <span class="c1"># OUTPUT: «True␤»</span>
<span class="c1"># (using `so` here, see `$/` below)</span>

<span class="c1"># So, starting with the grouping explanations. As we said before, our `Match`</span>
<span class="c1"># object is stored inside the `$/` variable:</span>
<span class="nb">say</span> <span class="vg">$/</span>;    <span class="c1"># Will either print the matched object or `Nil` if nothing matched.</span>

<span class="c1"># As we also said before, it has array indexing:</span>
<span class="nb">say</span> <span class="vg">$/</span>[<span class="mi">0</span>]; <span class="c1"># OUTPUT: «｢ABC｣ ｢ABC｣␤»,</span>

<span class="c1"># The corner brackets (｢..｣) represent (and are) `Match` objects. In the</span>
<span class="c1"># previous example, we have an array of them.</span>

<span class="nb">say</span> <span class="nv">$0</span>;    <span class="c1"># The same as above.</span>

<span class="c1"># Our capture is `$0` because it&#39;s the first and only one capture in the</span>
<span class="c1"># regexp. You might be wondering why it&#39;s an array, and the answer is simple:</span>
<span class="c1"># Some captures (indexed using `$0`, `$/[0]` or a named one) will be an array</span>
<span class="c1"># if and only if they can have more than one element. Thus any capture with</span>
<span class="c1"># `*`, `+` and `**` (whatever the operands), but not with `?`.</span>
<span class="c1"># Let&#39;s use examples to see that:</span>

<span class="c1"># NOTE: We quoted A B C to demonstrate that the whitespace between them isn&#39;t</span>
<span class="c1"># significant. If we want the whitespace to *be* significant there, we can use the</span>
<span class="c1"># `:sigspace` modifier.</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;fooABCbar&#39;</span> ~~<span class="sr"> / foo ( &quot;A&quot; &quot;B&quot; &quot;C&quot; )? bar /</span>; <span class="c1"># OUTPUT: «True␤»</span>
<span class="nb">say</span> <span class="vg">$/</span>[<span class="mi">0</span>];   <span class="c1"># OUTPUT: «｢ABC｣␤»</span>
<span class="nb">say</span> <span class="nv">$0</span>.<span class="nb">WHAT</span>; <span class="c1"># OUTPUT: «(Match)␤»</span>
             <span class="c1"># There can&#39;t be more than one, so it&#39;s only a single match object.</span>

<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;foobar&#39;</span> ~~<span class="sr"> / foo ( &quot;A&quot; &quot;B&quot; &quot;C&quot; )? bar /</span>;    <span class="c1"># OUTPUT: «True␤»</span>
<span class="nb">say</span> <span class="nv">$0</span>.<span class="nb">WHAT</span>; <span class="c1"># OUTPUT: «(Any)␤», this capture did not match, so it&#39;s empty.</span>

<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;foobar&#39;</span> ~~<span class="sr"> / foo ( &quot;A&quot; &quot;B&quot; &quot;C&quot; ) ** 0..1 bar /</span>; <span class="c1">#=&gt; OUTPUT: «True␤»</span>
<span class="nb">say</span> <span class="nv">$0</span>.<span class="nb">WHAT</span>; <span class="c1"># OUTPUT: «(Array)␤», A specific quantifier will always capture</span>
             <span class="c1"># an Array, be a range or a specific value (even 1).</span>

<span class="c1"># The captures are indexed per nesting. This means a group in a group will be</span>
<span class="c1"># nested under its parent group: `$/[0][0]`, for this code:</span>
<span class="s">&#39;hello-~-world&#39;</span> ~~<span class="sr"> / ( &#39;hello&#39; ( &lt;[ \- \~ ]&gt; + ) ) &#39;world&#39; /</span>;
<span class="nb">say</span> <span class="vg">$/</span>[<span class="mi">0</span>].<span class="nb">Str</span>;    <span class="c1"># OUTPUT: «hello~␤»</span>
<span class="nb">say</span> <span class="vg">$/</span>[<span class="mi">0</span>][<span class="mi">0</span>].<span class="nb">Str</span>; <span class="c1"># OUTPUT: «~␤»</span>

<span class="c1"># This stems from a very simple fact: `$/` does not contain strings, integers</span>
<span class="c1"># or arrays, it only contains `Match` objects. These contain the `.list`, `.hash`</span>
<span class="c1"># and `.Str` methods but you can also just use `match&lt;key&gt;` for hash access</span>
<span class="c1"># and `match[idx]` for array access.</span>

<span class="c1"># In the following example, we can see `$_` is a list of `Match` objects.</span>
<span class="c1"># Each of them contain a wealth of information: where the match started/ended,</span>
<span class="c1"># the &quot;ast&quot; (see actions later), etc. You&#39;ll see named capture below with</span>
<span class="c1"># grammars.</span>
<span class="nb">say</span> <span class="vg">$/</span>[<span class="mi">0</span>].<span class="n">list</span>.<span class="nb">perl</span>; <span class="c1"># OUTPUT: «(Match.new(...),).list␤»</span>

<span class="c1"># Alternation - the `or` of regexes</span>
<span class="c1"># WARNING: They are DIFFERENT from PCRE regexps.</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;abc&#39;</span> ~~<span class="sr"> / a [ b | y ] c /</span>; <span class="c1"># OUTPUT: «True␤», Either &quot;b&quot; or &quot;y&quot;.</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;ayc&#39;</span> ~~<span class="sr"> / a [ b | y ] c /</span>; <span class="c1"># OUTPUT: «True␤», Obviously enough...</span>

<span class="c1"># The difference between this `|` and the one you&#39;re used to is</span>
<span class="c1"># LTM (&quot;Longest Token Matching&quot;) strategy. This means that the engine will</span>
<span class="c1"># always try to match as much as possible in the string.</span>
<span class="nb">say</span> <span class="s">&#39;foo&#39;</span> ~~<span class="sr"> / fo | foo /</span>; <span class="c1"># OUTPUT: «foo», instead of `fo`, because it&#39;s longer.</span>

<span class="c1"># To decide which part is the &quot;longest&quot;, it first splits the regex in two parts:</span>
<span class="c1">#</span>
<span class="c1">#     * The &quot;declarative prefix&quot; (the part that can be statically analyzed)</span>
<span class="c1">#     which includes alternations (`|`), conjunctions (`&amp;`), sub-rule calls (not</span>
<span class="c1">#     yet introduced), literals, characters classes and quantifiers.</span>
<span class="c1">#</span>
<span class="c1">#     * The &quot;procedural part&quot; includes everything else: back-references,</span>
<span class="c1">#     code assertions, and other things that can&#39;t traditionally be represented</span>
<span class="c1">#     by normal regexps.</span>

<span class="c1"># Then, all the alternatives are tried at once, and the longest wins.</span>

<span class="c1"># Examples:</span>
<span class="c1"># DECLARATIVE | PROCEDURAL</span>
/ <span class="s">&#39;foo&#39;</span> \<span class="nb">d</span>+     [ <span class="s">&lt;subrule1&gt;</span> || <span class="s">&lt;subrule2&gt;</span> ] /;

<span class="c1"># DECLARATIVE (nested groups are not a problem)</span>
/ \<span class="nb">s</span>* [ \<span class="nb">w</span> &amp; <span class="n">b</span> ] [ <span class="n">c</span> | <span class="nb">d</span> ] /;

<span class="c1"># However, closures and recursion (of named regexes) are procedural.</span>
<span class="c1"># There are also more complicated rules, like specificity (literals win</span>
<span class="c1"># over character classes).</span>

<span class="c1"># NOTE: The alternation in which all the branches are tried in order</span>
<span class="c1"># until the first one matches still exists, but is now spelled `||`.</span>
<span class="nb">say</span> <span class="s">&#39;foo&#39;</span> ~~<span class="sr"> / fo || foo /</span>; <span class="c1"># OUTPUT: «fo␤», in this case.</span>

<span class="c1">####################################################</span>
<span class="c1"># 19. Extra: the MAIN subroutine</span>
<span class="c1">####################################################</span>

<span class="c1"># The `MAIN` subroutine is called when you run a Raku file directly. It&#39;s</span>
<span class="c1"># very powerful, because Raku actually parses the arguments and pass them</span>
<span class="c1"># as such to the sub. It also handles named argument (`--foo`) and will even</span>
<span class="c1"># go as far as to autogenerate a `--help` flag.</span>

<span class="k">sub</span> <span class="nb">MAIN</span>(<span class="nv">$name</span>) {
    <span class="nb">say</span> <span class="s">&quot;Hello, $name!&quot;</span>;
}
<span class="c1"># Supposing the code above is in file named cli.raku, then running in the command</span>
<span class="c1"># line (e.g., $ raku cli.raku) produces:</span>
<span class="c1"># Usage:</span>
<span class="c1"># cli.raku &lt;name&gt;</span>

<span class="c1"># And since MAIN is a regular Raku sub, you can have multi-dispatch:</span>
<span class="c1"># (using a `Bool` for the named argument so that we can do `--replace`</span>
<span class="c1"># instead of `--replace=1`. The presence of `--replace` indicates truthness</span>
<span class="c1"># while its absence falseness). For example:</span>

    <span class="c1"># convert to IO object to check the file exists</span>
<span class="cm">    =begin comment</span>
<span class="cm">    subset File of Str where *.IO.d;</span>

<span class="cm">    multi MAIN(&#39;add&#39;, $key, $value, Bool :$replace) { ... }</span>
<span class="cm">    multi MAIN(&#39;remove&#39;, $key) { ... }</span>
<span class="cm">    multi MAIN(&#39;import&#39;, File, Str :$as) { ... } # omitting parameter name</span>
<span class="cm">    =end comment</span>

<span class="c1"># Thus $ raku cli.raku produces:</span>
<span class="c1"># Usage:</span>
<span class="c1">#   cli.raku [--replace] add &lt;key&gt; &lt;value&gt;</span>
<span class="c1">#   cli.raku remove &lt;key&gt;</span>
<span class="c1">#   cli.raku [--as=&lt;Str&gt;] import &lt;File&gt;</span>

<span class="c1"># As you can see, this is *very* powerful. It even went as far as to show inline</span>
<span class="c1"># the constants (the type is only displayed if the argument is `$`/is named).</span>

<span class="c1">####################################################</span>
<span class="c1"># 20. APPENDIX A:</span>
<span class="c1">####################################################</span>

<span class="c1"># It&#39;s assumed by now you know the Raku basics. This section is just here to</span>
<span class="c1"># list some common operations, but which are not in the &quot;main part&quot; of the</span>
<span class="c1"># tutorial to avoid bloating it up.</span>

<span class="c1">#</span>
<span class="c1"># 20.1 Operators</span>
<span class="c1">#</span>

<span class="c1"># Sort comparison - they return one value of the `Order` enum: `Less`, `Same`</span>
<span class="c1"># and `More` (which numerify to -1, 0 or +1 respectively).</span>
<span class="nb">say</span> <span class="mi">1</span> &lt;=&gt; <span class="mi">4</span>;     <span class="c1"># OUTPUT: «More␤»,   sort comparison for numerics</span>
<span class="nb">say</span> <span class="s">&#39;a&#39;</span> <span class="o">leg</span> <span class="s">&#39;b&#39;</span>; <span class="c1"># OUTPUT: «Lessre␤», sort comparison for string</span>
<span class="nb">say</span> <span class="mi">1</span> <span class="o">eqv</span> <span class="mi">1</span>;     <span class="c1"># OUTPUT: «Truere␤», sort comparison using eqv semantics</span>
<span class="nb">say</span> <span class="mi">1</span> <span class="o">eqv</span> <span class="mf">1.0</span>;   <span class="c1"># OUTPUT: «False␤»</span>

<span class="c1"># Generic ordering</span>
<span class="nb">say</span> <span class="mi">3</span> <span class="o">before</span> <span class="mi">4</span>;    <span class="c1"># OUTPUT: «True␤»</span>
<span class="nb">say</span> <span class="s">&#39;b&#39;</span> <span class="nb">after</span> <span class="s">&#39;a&#39;</span>; <span class="c1"># OUTPUT: «True␤»</span>

<span class="c1"># Short-circuit default operator - similar to `or` and `||`, but instead</span>
<span class="c1"># returns the first *defined* value:</span>
<span class="nb">say</span> <span class="nb">Any</span> // <span class="nb">Nil</span> // <span class="mi">0</span> // <span class="mi">5</span>;        <span class="c1"># OUTPUT: «0␤»</span>

<span class="c1"># Short-circuit exclusive or (XOR) - returns `True` if one (and only one) of</span>
<span class="c1"># its arguments is true</span>
<span class="nb">say</span> <span class="nb">True</span> ^^ <span class="nb">False</span>;               <span class="c1"># OUTPUT: «True␤»</span>

<span class="c1"># Flip flops. These operators (`ff` and `fff`, equivalent to P5&#39;s `..`</span>
<span class="c1"># and `...`) are operators that take two predicates to test: They are `False`</span>
<span class="c1"># until their left side returns `True`, then are `True` until their right</span>
<span class="c1"># side returns `True`. Similar to ranges, you can exclude the iteration when</span>
<span class="c1"># it become `True`/`False` by using `^` on either side. Let&#39;s start with an</span>
<span class="c1"># example :</span>

<span class="k">for</span> <span class="s">&lt;well met young hero we shall meet later&gt;</span> {
    <span class="c1"># by default, `ff`/`fff` smart-match (`~~`) against `$_`:</span>
    <span class="k">if</span> <span class="s">&#39;met&#39;</span> ^<span class="o">ff</span> <span class="s">&#39;meet&#39;</span> { <span class="c1"># Won&#39;t enter the if for &quot;met&quot;</span>
        .<span class="nb">say</span>              <span class="c1"># (explained in details below).</span>
    }

    <span class="k">if</span> <span class="nb">rand</span> == <span class="mi">0</span> <span class="o">ff</span> <span class="nb">rand</span> == <span class="mi">1</span> { <span class="c1"># compare variables other than `$_`</span>
        <span class="nb">say</span> <span class="s">&quot;This ... probably will never run ...&quot;</span>;
    }
}

<span class="c1"># This will print &quot;young hero we shall meet&quot; (excluding &quot;met&quot;): the flip-flop</span>
<span class="c1"># will start returning `True` when it first encounters &quot;met&quot; (but will still</span>
<span class="c1"># return `False` for &quot;met&quot; itself, due to the leading `^` on `ff`), until it</span>
<span class="c1"># sees &quot;meet&quot;, which is when it&#39;ll start returning `False`.</span>

<span class="c1"># The difference between `ff` (awk-style) and `fff` (sed-style) is that `ff`</span>
<span class="c1"># will test its right side right when its left side changes to `True`, and can</span>
<span class="c1"># get back to `False` right away (*except* it&#39;ll be `True` for the iteration</span>
<span class="c1"># that matched) while `fff` will wait for the next iteration to try its right</span>
<span class="c1"># side, once its left side changed:</span>

<span class="c1"># The output is due to the right-hand-side being tested directly (and returning</span>
<span class="c1"># `True`). &quot;B&quot;s are printed since it matched that time (it just went back to</span>
<span class="c1"># `False` right away).</span>
.<span class="nb">say</span> <span class="k">if</span> <span class="s">&#39;B&#39;</span> <span class="o">ff</span> <span class="s">&#39;B&#39;</span> <span class="k">for</span> <span class="s">&lt;A B C B A&gt;</span>; <span class="c1"># OUTPUT: «B B␤»,</span>

<span class="c1"># In this case the right-hand-side wasn&#39;t tested until `$_` became &quot;C&quot;</span>
<span class="c1"># (and thus did not match instantly).</span>
.<span class="nb">say</span> <span class="k">if</span> <span class="s">&#39;B&#39;</span> <span class="o">fff</span> <span class="s">&#39;B&#39;</span> <span class="k">for</span> <span class="s">&lt;A B C B A&gt;</span>; <span class="c1">#=&gt; «B C B␤»,</span>

<span class="c1"># A flip-flop can change state as many times as needed:</span>
<span class="k">for</span> <span class="s">&lt;test start print it stop not printing start print again stop not anymore&gt;</span> {
    <span class="c1"># exclude both &quot;start&quot; and &quot;stop&quot;,</span>
    .<span class="nb">say</span> <span class="k">if</span> <span class="nv">$_</span> <span class="o">eq</span> <span class="s">&#39;start&#39;</span> ^<span class="o">ff</span>^ <span class="nv">$_</span> <span class="o">eq</span> <span class="s">&#39;stop&#39;</span>; <span class="c1"># OUTPUT: «print it print again␤»</span>
}

<span class="c1"># You might also use a Whatever Star, which is equivalent to `True` for the</span>
<span class="c1"># left side or `False` for the right, as shown in this example.</span>
<span class="c1"># NOTE: the parenthesis are superfluous here (sometimes called &quot;superstitious</span>
<span class="c1"># parentheses&quot;). Once the flip-flop reaches a number greater than 50, it&#39;ll</span>
<span class="c1"># never go back to `False`.</span>
<span class="k">for</span> (<span class="mi">1</span>, <span class="mi">3</span>, <span class="mi">60</span>, <span class="mi">3</span>, <span class="mi">40</span>, <span class="mi">60</span>) {
    .<span class="nb">say</span> <span class="k">if</span> <span class="nv">$_</span> &gt; <span class="mi">50</span> <span class="o">ff</span> *;  <span class="c1"># OUTPUT: «60␤3␤40␤60␤»</span>
}

<span class="c1"># You can also use this property to create an `if` that&#39;ll not go through the</span>
<span class="c1"># first time. In this case, the flip-flop is `True` and never goes back to</span>
<span class="c1"># `False`, but the `^` makes it *not run* on the first iteration</span>
<span class="k">for</span> <span class="s">&lt;a b c&gt;</span> { .<span class="nb">say</span> <span class="k">if</span> * ^<span class="o">ff</span> *; }  <span class="c1"># OUTPUT: «b␤c␤»</span>

<span class="c1"># The `===` operator, which uses `.WHICH` on the objects to be compared, is</span>
<span class="c1"># the value identity operator whereas the `=:=` operator, which uses `VAR()` on</span>
<span class="c1"># the objects to compare them, is the container identity operator.</span>
</pre></div>
<p>If you want to go further and learn more about Raku, you can:</p>

<ul>
<li><p>Read the <a href="https://docs.raku.org/">Raku Docs</a>. This is a great
resource on Raku. If you are looking for something, use the search bar.
This will give you a dropdown menu of all the pages referencing your search
term (Much better than using Google to find Raku documents!).</p></li>
<li><p>Read the <a href="https://rakuadventcalendar.wordpress.com/">Raku Advent Calendar</a>. This
is a great source of Raku snippets and explanations. If the docs don&rsquo;t
describe something well enough, you may find more detailed information here.
This information may be a bit older but there are many great examples and
explanations. Posts stopped at the end of 2015 when the language was declared
stable and <code>Raku v6.c</code> was released.</p></li>
<li><p>Come along on <code>#raku</code> at <a href="https://web.libera.chat/?channel=#raku"><code>irc.libera.chat</code></a>. The folks here are
always helpful.</p></li>
<li><p>Check the <a href="https://github.com/rakudo/rakudo/tree/master/src/core.c">source of Raku&rsquo;s functions and
classes</a>. Rakudo is
mainly written in Raku (with a lot of NQP, &ldquo;Not Quite Perl&rdquo;, a Raku subset
easier to implement and optimize).</p></li>
<li><p>Read <a href="https://design.raku.org/">the language design documents</a>. They explain
Raku from an implementor point-of-view, but it&rsquo;s still very interesting.</p></li>
</ul>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the GitHub Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/raku.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by vendethiel, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/raku.html.markdown">9 contributors</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://github.com/vendethiel">vendethiel</a>,
        <a href="https://cry.nu">Samantha McVey</a>
    </p>

    <p>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
