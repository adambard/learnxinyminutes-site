<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="en-us" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="en-us" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="en-us" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="en-us" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="en-us">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Lisp Flavoured Erlang(LFE) in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/lfe/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Flfe%2F&text=Learn+X+in+Y+minutes%2C+where+X%3DLisp+Flavoured+Erlang%28LFE%29">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="/">Learn X in Y minutes</a></h1>
  <h2>Where X=Lisp Flavoured Erlang(LFE)</h2>
    <p class="filelink">
    Get the code:
    <a href="/docs/files/lispflavourederlang.lfe">lispflavourederlang.lfe</a>
    </p>
  <div id="doc">
    <p>Lisp Flavoured Erlang(LFE) is a functional, concurrent, general-purpose programming 
language and Lisp dialect(Lisp-2) built on top of Core Erlang and the Erlang Virtual Machine(BEAM). </p>

<p>LFE can be obtained from <a href="https://github.com/rvirding/lfe">LFE</a></p>

<p>The classic starting point is <a href="http://docs.lfe.io">LFE DOCS.</a></p>

<p>Another new site is being built to replace it.<a href="http://docs.lfe.io/dev">LFE DEV.</a></p>
<div class="highlight"><pre><span></span><span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;;; 0. Syntax</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;;; General form.</span>

<span class="c1">;; Lisp comprises of two syntax called: the ATOM and the S-expression.</span>
<span class="c1">;; `forms` are known as grouped S-expressions.</span>

<span class="mi">8</span><span class="w">  </span><span class="c1">; an atom; it evaluates to itself</span>

<span class="ss">:ERLANG</span><span class="w"> </span><span class="c1">;Atom; evaluates to the symbol :ERLANG.</span>

<span class="no">t</span><span class="w">  </span><span class="c1">; another atom which denotes true.</span>

<span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">21</span><span class="p">)</span><span class="w"> </span><span class="c1">; an S- expression</span>

<span class="o">&#39;</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="ss">:foo</span><span class="w"> </span><span class="no">t</span><span class="p">)</span><span class="w">  </span><span class="c1">;another one</span>


<span class="c1">;;; Comments</span>

<span class="c1">;; Single line comments start with a semicolon; use two for normal</span>
<span class="c1">;; comments, three for section comments, and four fo file-level</span>
<span class="c1">;; comments.</span>

<span class="c1">;; Block Comment</span>

<span class="w">   </span><span class="cm">#| comment text |#</span>

<span class="c1">;;; Environment</span>

<span class="c1">;; LFE is the de-facto standard.</span>

<span class="c1">;; Libraries can be used directly from the Erlang ecosystem. Rebar3 is the build tool.</span>

<span class="c1">;; LFE is usually developed with a text editor(preferably Emacs) and a REPL</span>
<span class="c1">;; (Read Evaluate Print Loop) running at the same time. The REPL </span>
<span class="c1">;; allows for interactive exploration of the program as it is &quot;live&quot;</span>
<span class="c1">;; in the system.</span>

<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;;; 1. Literals and Special Syntactic Rules</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;;; Integers</span>

<span class="mi">1234</span><span class="w"> </span><span class="mi">-123</span><span class="w">           </span><span class="c1">; Regular decimal notation</span>
<span class="mb">#b0</span><span class="w"> </span><span class="mb">#b10101</span><span class="w">         </span><span class="c1">; Binary notation</span>
<span class="err">#</span><span class="mi">0</span><span class="w"> </span><span class="err">#</span><span class="mi">10101</span><span class="w">           </span><span class="c1">; Binary notation (alternative form)</span>
<span class="mo">#o377</span><span class="w"> </span><span class="mo">#o-111</span><span class="w">        </span><span class="c1">; Octal notation</span>
<span class="err">#</span><span class="nv">d123456789</span><span class="w"> </span><span class="err">#</span><span class="nv">d+123</span><span class="w">  </span><span class="c1">; Explicitly decimal notation</span>
<span class="mh">#xc0ffe</span><span class="w"> </span><span class="nv">0x-01</span><span class="w">       </span><span class="c1">; Hexadecimal notation</span>
<span class="m">#2r1010</span><span class="w"> </span><span class="m">#8r377</span><span class="w">      </span><span class="c1">;Notation with explicit base (up to 36)</span>
<span class="sc">#\a</span><span class="w"> </span><span class="err">#</span><span class="nv">$</span><span class="w"> </span><span class="sc">#\√§</span><span class="w"> </span><span class="sc">#\üê≠</span><span class="w">     </span><span class="c1">;Character notation (the value is the Unicode code point of the character)</span>
<span class="sc">#\x1f42d</span><span class="c1">;           ;Character notation with the value in hexadecimal</span>

<span class="c1">;;; Floating point numbers</span>
<span class="mf">1.0</span><span class="w"> </span><span class="mf">+2.0</span><span class="w"> </span><span class="mf">-1.5</span><span class="w"> </span><span class="mf">1.0e10</span><span class="w"> </span><span class="mf">1.111e-10</span><span class="w">     </span>

<span class="c1">;;; Strings</span>

<span class="s">&quot;any text between double quotes where \&quot; and other special characters like \n can be escaped&quot;</span><span class="o">.</span>
<span class="c1">; List String</span>
<span class="s">&quot;Cat: \x1f639;&quot;</span><span class="w"> </span><span class="c1">; writing unicode in string for regular font ending with semicolon.</span>

<span class="l l-Other">#&quot;This is a binary string \n with some \&quot;escaped\&quot; and quoted (\x1f639;) characters&quot;</span>
<span class="c1">; Binary strings are just strings but function different in the VM. </span>
<span class="c1">; Other ways of writing it are:  #B(&quot;a&quot;), #&quot;a&quot;, and #B(97).</span>


<span class="c1">;;; Character escaping</span>

<span class="nv">\b</span><span class="w">  </span><span class="c1">; =&gt; Backspace</span>
<span class="nv">\t</span><span class="w">  </span><span class="c1">; =&gt; Tab</span>
<span class="nv">\n</span><span class="w">  </span><span class="c1">; =&gt; Newline</span>
<span class="nv">\v</span><span class="w">  </span><span class="c1">; =&gt; Vertical tab</span>
<span class="nv">\f</span><span class="w">  </span><span class="c1">; =&gt; Form Feed</span>
<span class="nv">\r</span><span class="w">  </span><span class="c1">; =&gt; Carriage Return</span>
<span class="nv">\e</span><span class="w">  </span><span class="c1">; =&gt; Escape</span>
<span class="nv">\s</span><span class="w">  </span><span class="c1">; =&gt; Space</span>
<span class="nv">\d</span><span class="w">  </span><span class="c1">; =&gt; Delete</span>

<span class="c1">;;; Binaries</span>
<span class="c1">;; It is used to create binaries with any contents.</span>
<span class="err">#</span><span class="nv">B</span><span class="p">((</span><span class="l l-Other">#&quot;a&quot;</span><span class="w"> </span><span class="nv">binary</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="l l-Other">#&quot;b&quot;</span><span class="w"> </span><span class="nv">binary</span><span class="p">))</span><span class="w">                </span><span class="c1">; #&quot;ab&quot; (Evaluated form)</span>

<span class="c1">;;; Lists are: () or (foo bar baz)</span>

<span class="c1">;;; Tuples are written in: #(value1 value2 ...). Empty tuple #() is also valid.</span>

<span class="c1">;;; Maps are written as: #M(key1 value1 key2 value2 ...). Empty map #M() is also valid.</span>

<span class="c1">;;; Symbols: Things that cannot be parsed. Eg: foo, Foo, foo-bar, :foo</span>
<span class="nv">| foo |</span><span class="w"> </span><span class="c1">; explicit construction of symbol by wrapping vertical bars.</span>

<span class="c1">;;; Evaluation </span>

<span class="c1">;; #.(... some expression ...). E.g. &#39;#.(+ 1 1) will evaluate the (+ 1 1) while it            ;; reads the expression and then be effectively &#39;2.</span>

<span class="c1">;; List comprehension in LFE REPL</span>

<span class="nv">lfe&gt;</span><span class="w"> </span><span class="p">(</span><span class="nv">list-comp</span>
<span class="w">          </span><span class="p">((</span><span class="nv">&lt;-</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)))</span>
<span class="w">          </span><span class="p">(</span><span class="nv">trunc</span><span class="w"> </span><span class="p">(</span><span class="nv">math:pow</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="nv">x</span><span class="p">)))</span>
<span class="w">       </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">27</span><span class="p">)</span>


<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; 2. Core forms</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;; These forms are same as those found at Common Lisp and Scheme.</span>

<span class="p">(</span><span class="k">quote</span><span class="w"> </span><span class="nv">e</span><span class="p">)</span>
<span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="nv">head</span><span class="w"> </span><span class="nv">tail</span><span class="p">)</span>
<span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="nv">e</span><span class="p">)</span>
<span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="nv">e</span><span class="p">)</span>
<span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">e</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="p">(</span><span class="nv">tuple</span><span class="w"> </span><span class="nv">e</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="p">(</span><span class="nv">binary</span><span class="w"> </span><span class="nv">seg</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nv">key</span><span class="w"> </span><span class="nv">val</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="o">,</span><span class="w"> </span><span class="p">(</span><span class="nv">map-get</span><span class="w"> </span><span class="nv">m</span><span class="w"> </span><span class="nv">k</span><span class="p">)</span><span class="o">,</span><span class="w"> </span><span class="p">(</span><span class="nv">map-set</span><span class="w"> </span><span class="nv">m</span><span class="w"> </span><span class="nv">k</span><span class="w"> </span><span class="nv">v</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="o">,</span><span class="w"> </span><span class="p">(</span><span class="nv">map-update</span><span class="w"> </span><span class="nv">m</span><span class="w"> </span><span class="nv">k</span><span class="w"> </span><span class="nv">v</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>

<span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nv">arg</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nv">match-lambda</span>
<span class="w">    </span><span class="p">((</span><span class="nv">arg</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="nv">{{</span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="nv">e</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="nv">}}</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="w"> </span><span class="c1">; Matches clauses</span>
<span class="w">    </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nv">pat</span><span class="w"> </span><span class="nv">{{</span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="nv">e</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="nv">}}</span><span class="w"> </span><span class="nv">e</span><span class="p">)</span>
<span class="w">      </span><span class="o">...</span><span class="p">)</span>
<span class="w">  </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="p">(</span><span class="nv">let-function</span><span class="w"> </span><span class="p">((</span><span class="nv">name</span><span class="w"> </span><span class="k">lambda</span><span class="nv">|match-lambda) ; Only define local</span>
<span class="nv">               ... )                      ; functions</span>
<span class="nv">  ... )</span>
<span class="nv">(letrec-function ((name lambda|match-lambda</span><span class="p">)</span><span class="w"> </span><span class="c1">; Only define local</span>
<span class="w">                  </span><span class="o">...</span><span class="w"> </span><span class="p">)</span><span class="w">                      </span><span class="c1">; functions</span>
<span class="w">  </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="p">(</span><span class="nv">let-macro</span><span class="w"> </span><span class="p">((</span><span class="nv">name</span><span class="w"> </span><span class="nv">lambda-match-lambda</span><span class="p">)</span><span class="w"> </span><span class="c1">; Only define local</span>
<span class="w">            </span><span class="o">...</span><span class="p">)</span><span class="w">                       </span><span class="c1">; macros</span>
<span class="w">  </span><span class="o">...</span><span class="p">)</span>
<span class="p">(</span><span class="k">progn</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">test</span><span class="w"> </span><span class="nv">true-expr</span><span class="w"> </span><span class="nv">{{false-expr}}</span><span class="p">)</span>
<span class="p">(</span><span class="nb">case</span><span class="w"> </span><span class="nv">e</span>
<span class="w">  </span><span class="p">(</span><span class="nv">pat</span><span class="w"> </span><span class="nv">{{</span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="nv">e</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="nv">}}</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>
<span class="w">   </span><span class="o">...</span><span class="w"> </span><span class="p">))</span>
<span class="p">(</span><span class="nv">receive</span>
<span class="w">  </span><span class="p">(</span><span class="nv">pat</span><span class="w"> </span><span class="nv">{{</span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="nv">e</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="nv">}}</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="w">  </span><span class="o">...</span>
<span class="w">  </span><span class="p">(</span><span class="nv">after</span><span class="w"> </span><span class="nv">timeout</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">))</span>
<span class="p">(</span><span class="k">catch</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="p">(</span><span class="nv">try</span>
<span class="w">  </span><span class="nv">e</span>
<span class="w">  </span><span class="nv">{{</span><span class="p">(</span><span class="nb">case</span><span class="w"> </span><span class="p">((</span><span class="nv">pat</span><span class="w"> </span><span class="nv">{{</span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="nv">e</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="nv">}}</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="w">          </span><span class="o">...</span><span class="w"> </span><span class="p">))</span><span class="nv">}}</span>
<span class="w">  </span><span class="nv">{{</span><span class="p">(</span><span class="k">catch</span>
<span class="w">     </span><span class="c1">; Next must be tuple of length 3!</span>
<span class="w">     </span><span class="p">(((</span><span class="nv">tuple</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="nv">value</span><span class="w"> </span><span class="k">ignore</span><span class="p">)</span><span class="w"> </span><span class="nv">{{</span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="nv">e</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="nv">}}</span>
<span class="w">      </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="w">     </span><span class="o">...</span><span class="w"> </span><span class="p">)</span><span class="nv">}}</span>
<span class="w">  </span><span class="nv">{{</span><span class="p">(</span><span class="nv">after</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span><span class="nv">}}</span><span class="p">)</span>

<span class="p">(</span><span class="nb">funcall</span><span class="w"> </span><span class="nv">func</span><span class="w"> </span><span class="nv">arg</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="p">(</span><span class="nv">call</span><span class="w"> </span><span class="nb">mod</span><span class="w"> </span><span class="nv">func</span><span class="w"> </span><span class="nv">arg</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="nb">-</span><span class="w"> </span><span class="nv">Call</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">Erlang</span><span class="w"> </span><span class="nv">Mod:Func</span><span class="p">(</span><span class="nv">Arg,</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="p">(</span><span class="nv">define-module</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="nv">declaration</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="p">(</span><span class="nv">extend-module</span><span class="w"> </span><span class="nv">declaration</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="nb">-</span><span class="w"> </span><span class="nv">Define/extend</span><span class="w"> </span><span class="nv">module</span><span class="w"> </span><span class="nb">and</span><span class="w"> </span><span class="nv">declarations.</span>
<span class="p">(</span><span class="nv">define-function</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="k">lambda</span><span class="nv">|match-lambda)</span>
<span class="nv">(define-macro name lambda|match-lambda</span><span class="p">)</span><span class="w"> </span><span class="nb">-</span><span class="w"> </span><span class="nv">Define</span><span class="w"> </span><span class="nv">functions/macros</span><span class="w"> </span><span class="nv">at</span><span class="w"> </span><span class="nv">top-level.</span>

<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; 3. Macros</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;; Macros are part of the language to allow you to create abstractions </span>
<span class="c1">;; on top of the core language and standard library that move you closer </span>
<span class="c1">;; toward being able to directly express the things you want to express.</span>

<span class="c1">;; Top-level function</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="p">(</span><span class="nv">arg</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>

<span class="c1">;; Adding comments in functions</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">name</span>
<span class="w">  </span><span class="s">&quot;Toplevel function with pattern-matching arguments&quot;</span>
<span class="w">  </span><span class="p">((</span><span class="nv">argpat</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>
<span class="w">  </span><span class="o">...</span><span class="p">)</span>

<span class="c1">;; Top-level macro</span>

<span class="p">(</span><span class="nb">defmacro</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="p">(</span><span class="nv">arg</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>
<span class="p">(</span><span class="nb">defmacro</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="nv">arg</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>

<span class="c1">;; Top-level macro with pattern matching arguments</span>

<span class="p">(</span><span class="nb">defmacro</span><span class="w"> </span><span class="nv">name</span>
<span class="w">  </span><span class="p">((</span><span class="nv">argpat</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>
<span class="w">  </span><span class="o">...</span><span class="p">)</span>

<span class="c1">;; Top-level macro using Scheme inspired syntax-rules format </span>

<span class="p">(</span><span class="nv">defsyntax</span><span class="w"> </span><span class="nv">name</span>
<span class="w">  </span><span class="p">(</span><span class="nv">pat</span><span class="w"> </span><span class="nb">exp</span><span class="p">)</span>
<span class="w">  </span><span class="o">...</span><span class="p">)</span>

<span class="c1">;;; Local macros in macro or syntax-rule format</span>

<span class="p">(</span><span class="k">macrolet</span><span class="w"> </span><span class="p">((</span><span class="nv">name</span><span class="w"> </span><span class="p">(</span><span class="nv">arg</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="o">...</span><span class="w"> </span><span class="p">)</span>

<span class="p">(</span><span class="nv">syntaxlet</span><span class="w"> </span><span class="p">((</span><span class="nv">name</span><span class="w"> </span><span class="p">(</span><span class="nv">pat</span><span class="w"> </span><span class="nb">exp</span><span class="p">)</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>
<span class="w">             </span><span class="o">...</span><span class="p">)</span>
<span class="w"> </span><span class="o">...</span><span class="p">)</span>

<span class="c1">;; Like CLISP</span>

<span class="p">(</span><span class="nb">prog1</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>
<span class="p">(</span><span class="nb">prog2</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>

<span class="c1">;; Erlang LFE module</span>

<span class="p">(</span><span class="nv">defmodule</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>

<span class="c1">;; Erlang LFE record</span>

<span class="p">(</span><span class="nv">defrecord</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>

<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; 4. Patterns and Guards</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;; Using patterns in LFE compared to that of Erlang</span>

<span class="c1">;; Erlang                     ;; LFE</span>
<span class="c1">;; {ok, X}                       (tuple &#39;ok x)</span>
<span class="c1">;; error                         &#39;error</span>
<span class="c1">;; {yes, [X|Xs]}                 (tuple &#39;yes (cons x xs))</span>
<span class="c1">;; &lt;&lt;34,F/float&gt;&gt;                (binary 34 (f float))</span>
<span class="c1">;; [P|Ps]=All                    (= (cons p ps) all)</span>

<span class="w">  </span><span class="nv">_</span><span class="w">    </span><span class="c1">; =&gt; is don&#39;t care while pattern matching</span>

<span class="w">  </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="nv">pattern1</span><span class="w"> </span><span class="nv">pattern2</span><span class="p">)</span><span class="w">     </span><span class="c1">; =&gt; easier, better version of pattern matching</span>

<span class="c1">;; Guards</span>

<span class="c1">;; Whenever pattern occurs(let, case, receive, lc, etc) it can be followed by an optional</span>
<span class="c1">;; guard which has the form (when test ...).</span>

<span class="p">(</span><span class="k">progn</span><span class="w"> </span><span class="nv">gtest</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="w">             </span><span class="c1">;; =&gt; Sequence of guard tests</span>
<span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">gexpr</span><span class="w"> </span><span class="nv">gexpr</span><span class="w"> </span><span class="nv">gexpr</span><span class="p">)</span>
<span class="p">(</span><span class="nv">type-test</span><span class="w"> </span><span class="nv">e</span><span class="p">)</span>
<span class="p">(</span><span class="nv">guard-bif</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="w">               </span><span class="c1">;; =&gt; Guard BIFs, arithmetic, boolean and comparison operators</span>

<span class="c1">;;; REPL</span>

<span class="nv">lfe&gt;</span><span class="p">(</span><span class="nb">set</span><span class="w"> </span><span class="p">(</span><span class="nv">tuple</span><span class="w"> </span><span class="nv">len</span><span class="w"> </span><span class="nv">status</span><span class="w"> </span><span class="nv">msg</span><span class="p">)</span><span class="w"> </span><span class="o">#(</span><span class="mi">8</span><span class="w"> </span><span class="nv">ok</span><span class="w"> </span><span class="s">&quot;Trillian&quot;</span><span class="p">))</span>
<span class="w">    </span><span class="o">#(</span><span class="mi">8</span><span class="w"> </span><span class="nv">ok</span><span class="w"> </span><span class="s">&quot;Trillian&quot;</span><span class="p">)</span>
<span class="nv">lfe&gt;msg</span>
<span class="w">    </span><span class="s">&quot;Trillian&quot;</span>

<span class="c1">;;; Program illustrating use of Guards</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">right-number?</span>
<span class="w">        </span><span class="p">((</span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nv">orelse</span><span class="w"> </span><span class="p">(</span><span class="nv">==</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="mi">42</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">==</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="mi">276709</span><span class="p">)))</span>
<span class="w">          </span><span class="ss">&#39;true</span><span class="p">)</span>
<span class="w">        </span><span class="p">((</span><span class="nv">_</span><span class="p">)</span><span class="w"> </span><span class="ss">&#39;false</span><span class="p">))</span>

<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; 5. Functions</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;; A simple function using if.</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nb">max</span><span class="w"> </span><span class="p">(</span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;The max function.&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;=</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">))</span>

<span class="c1">;; Same function using more clause</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nb">max</span>
<span class="w">  </span><span class="s">&quot;The max function.&quot;</span>
<span class="w">  </span><span class="p">((</span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;=</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">))</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span>
<span class="w">  </span><span class="p">((</span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span><span class="w"> </span><span class="nv">y</span><span class="p">))</span>

<span class="c1">;; Same function using similar style but using local functions defined by flet or fletrec</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">foo</span><span class="w"> </span><span class="p">(</span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;The max function.&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="k">flet</span><span class="w"> </span><span class="p">((</span><span class="nv">m</span><span class="w"> </span><span class="p">(</span><span class="nv">a</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span><span class="w"> </span><span class="s">&quot;Local comment.&quot;</span>
<span class="w">            </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;=</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">b</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">m</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">)))</span>

<span class="c1">;; LFE being Lisp-2 has separate namespaces for variables and functions</span>
<span class="c1">;; Both variables and function/macros are lexically scoped.</span>
<span class="c1">;; Variables are bound by lambda, match-lambda and let.</span>
<span class="c1">;; Functions are bound by top-level defun, flet and fletrec.</span>
<span class="c1">;; Macros are bound by top-level defmacro/defsyntax and by macrolet/syntaxlet.</span>

<span class="c1">;; (funcall func arg ...) like CL to call lambdas/match-lambdas </span>
<span class="c1">;; (funs) bound to variables are used.</span>

<span class="c1">;; separate bindings and special for apply.</span>
<span class="nb">apply</span><span class="w"> </span><span class="nv">_F</span><span class="w"> </span><span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="o">,</span><span class="w"> </span>
<span class="nb">apply</span><span class="w"> </span><span class="nv">_F/3</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nv">a1,</span><span class="w"> </span><span class="nv">a2,</span><span class="w"> </span><span class="nv">a3</span><span class="w"> </span><span class="p">)</span>

<span class="c1">;; Cons&#39;ing in function heads</span>
<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">sum</span><span class="w"> </span><span class="p">(</span><span class="nv">l</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">sum</span><span class="w"> </span><span class="nv">l</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">sum</span>
<span class="w">    </span><span class="p">((</span><span class="o">&#39;</span><span class="p">()</span><span class="w"> </span><span class="nv">total</span><span class="p">)</span><span class="w"> </span><span class="nv">total</span><span class="p">)</span>
<span class="w">    </span><span class="p">(((</span><span class="nb">cons</span><span class="w"> </span><span class="nv">h</span><span class="w"> </span><span class="no">t</span><span class="p">)</span><span class="w"> </span><span class="nv">total</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">sum</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="nv">h</span><span class="w"> </span><span class="nv">total</span><span class="p">))))</span>

<span class="c1">;; ``cons`` literal instead of constructor form</span>
<span class="w">      </span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">sum</span><span class="w"> </span><span class="p">(</span><span class="nv">l</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">sum</span><span class="w"> </span><span class="nv">l</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">sum</span>
<span class="w">        </span><span class="p">((</span><span class="o">&#39;</span><span class="p">()</span><span class="w"> </span><span class="nv">total</span><span class="p">)</span><span class="w"> </span><span class="nv">total</span><span class="p">)</span>
<span class="w">        </span><span class="p">((</span><span class="o">`</span><span class="p">(</span><span class="o">,</span><span class="nv">h</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="o">,</span><span class="no">t</span><span class="p">)</span><span class="w"> </span><span class="nv">total</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">sum</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="nv">h</span><span class="w"> </span><span class="nv">total</span><span class="p">))))</span>

<span class="c1">;; Matching records in function heads</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">handle_info</span>
<span class="w">  </span><span class="p">((</span><span class="ss">&#39;ping</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nv">match-state</span><span class="w"> </span><span class="nv">remote-pid</span><span class="w"> </span><span class="ss">&#39;undefined</span><span class="p">)</span><span class="w"> </span><span class="nv">state</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">gen_server:cast</span><span class="w"> </span><span class="p">(</span><span class="nv">self</span><span class="p">)</span><span class="w"> </span><span class="ss">&#39;ping</span><span class="p">)</span>
<span class="w">    </span><span class="o">`#(</span><span class="nv">noreply</span><span class="w"> </span><span class="o">,</span><span class="nv">state</span><span class="p">))</span>
<span class="w">  </span><span class="p">((</span><span class="ss">&#39;ping</span><span class="w"> </span><span class="nv">state</span><span class="p">)</span>
<span class="w">   </span><span class="o">`#(</span><span class="nv">noreply</span><span class="w"> </span><span class="o">,</span><span class="nv">state</span><span class="p">)))</span>

<span class="c1">;; Receiving Messages</span>
<span class="w">      </span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">universal-server</span><span class="w"> </span><span class="p">()</span>
<span class="w">        </span><span class="p">(</span><span class="nv">receive</span>
<span class="w">          </span><span class="p">((</span><span class="nv">tuple</span><span class="w"> </span><span class="ss">&#39;become</span><span class="w"> </span><span class="nv">func</span><span class="p">)</span>
<span class="w">           </span><span class="p">(</span><span class="nb">funcall</span><span class="w"> </span><span class="nv">func</span><span class="p">))))</span>

<span class="c1">;; another way for receiving messages</span>

<span class="w"> </span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">universal-server</span><span class="w"> </span><span class="p">()</span>
<span class="w">        </span><span class="p">(</span><span class="nv">receive</span>
<span class="w">          </span><span class="p">(</span><span class="o">`#(</span><span class="nv">become</span><span class="w"> </span><span class="o">,</span><span class="nv">func</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nb">funcall</span><span class="w"> </span><span class="nv">func</span><span class="p">))))</span>

<span class="c1">;; Composing a complete function for specific tasks</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">compose</span><span class="w"> </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="nv">g</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nv">x</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">funcall</span><span class="w"> </span><span class="nv">f</span>
<span class="w">     </span><span class="p">(</span><span class="nb">funcall</span><span class="w"> </span><span class="nv">g</span><span class="w"> </span><span class="nv">x</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">check</span><span class="w"> </span><span class="p">()</span>
<span class="w">  </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="p">((</span><span class="nv">sin-asin</span><span class="w"> </span><span class="p">(</span><span class="nv">compose</span><span class="w"> </span><span class="nf">#&#39;</span><span class="nv">sin/1</span><span class="w"> </span><span class="nf">#&#39;</span><span class="nv">asin/1</span><span class="p">))</span>
<span class="w">         </span><span class="p">(</span><span class="nv">expected</span><span class="w"> </span><span class="p">(</span><span class="nb">sin</span><span class="w"> </span><span class="p">(</span><span class="nb">asin</span><span class="w"> </span><span class="mf">0.5</span><span class="p">)))</span>
<span class="w">         </span><span class="p">(</span><span class="nv">compose-result</span><span class="w"> </span><span class="p">(</span><span class="nb">funcall</span><span class="w"> </span><span class="nv">sin-asin</span><span class="w"> </span><span class="mf">0.5</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">io:format</span><span class="w"> </span><span class="s">&quot;Expected answer: ~p~n&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">expected</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">io:format</span><span class="w"> </span><span class="s">&quot;Answer with compose: ~p~n&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">compose-result</span><span class="p">))))</span>


<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; 6. Concurrency</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;; Message passing as done by Erlang&#39;s light-weight &quot;processes&quot;.</span>

<span class="p">(</span><span class="nv">defmodule</span><span class="w"> </span><span class="nv">messenger-back</span>
<span class="w"> </span><span class="p">(</span><span class="nb">export</span><span class="w"> </span><span class="p">(</span><span class="nv">print-result</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">send-message</span><span class="w"> </span><span class="mi">2</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">print-result</span><span class="w"> </span><span class="p">()</span>
<span class="w">  </span><span class="p">(</span><span class="nv">receive</span>
<span class="w">    </span><span class="p">((</span><span class="nv">tuple</span><span class="w"> </span><span class="nv">pid</span><span class="w"> </span><span class="nv">msg</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nv">io:format</span><span class="w"> </span><span class="s">&quot;Received message: &#39;~s&#39;~n&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">msg</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nv">io:format</span><span class="w"> </span><span class="s">&quot;Sending message to process ~p ...~n&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">pid</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nv">!</span><span class="w"> </span><span class="nv">pid</span><span class="w"> </span><span class="p">(</span><span class="nv">tuple</span><span class="w"> </span><span class="nv">msg</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nv">print-result</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">send-message</span><span class="w"> </span><span class="p">(</span><span class="nv">calling-pid</span><span class="w"> </span><span class="nv">msg</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nv">spawned-pid</span><span class="w"> </span><span class="p">(</span><span class="nv">spawn</span><span class="w"> </span><span class="ss">&#39;messenger-back</span><span class="w"> </span><span class="ss">&#39;print-result</span><span class="w"> </span><span class="p">())))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">!</span><span class="w"> </span><span class="nv">spawned-pid</span><span class="w"> </span><span class="p">(</span><span class="nv">tuple</span><span class="w"> </span><span class="nv">calling-pid</span><span class="w"> </span><span class="nv">msg</span><span class="p">))))</span>

<span class="c1">;; Multiple simultaneous HTTP Requests:</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">parse-args</span><span class="w"> </span><span class="p">(</span><span class="nv">flag</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Given one or more command-line arguments, extract the passed values.</span>

<span class="s">  For example, if the following was passed via the command line:</span>

<span class="s">    $ erl -my-flag my-value-1 -my-flag my-value-2</span>

<span class="s">  One could then extract it in an LFE program by calling this function:</span>

<span class="s">    (let ((args (parse-args &#39;my-flag)))</span>
<span class="s">      ...</span>
<span class="s">      )</span>
<span class="s">  In this example, the value assigned to the arg variable would be a list</span>
<span class="s">  containing the values my-value-1 and my-value-2.&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="o">`#(</span><span class="nv">ok</span><span class="w"> </span><span class="o">,</span><span class="nv">data</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">init:get_argument</span><span class="w"> </span><span class="nv">flag</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">lists:merge</span><span class="w"> </span><span class="nv">data</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">get-pages</span><span class="w"> </span><span class="p">()</span>
<span class="w">  </span><span class="s">&quot;With no argument, assume &#39;url parameter was passed via command line.&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nv">urls</span><span class="w"> </span><span class="p">(</span><span class="nv">parse-args</span><span class="w"> </span><span class="ss">&#39;url</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">get-pages</span><span class="w"> </span><span class="nv">urls</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">get-pages</span><span class="w"> </span><span class="p">(</span><span class="nv">urls</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Start inets and make (potentially many) HTTP requests.&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="nv">inets:start</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nv">plists:map</span>
<span class="w">    </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nv">x</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nv">get-page</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span><span class="w"> </span><span class="nv">urls</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">get-page</span><span class="w"> </span><span class="p">(</span><span class="nv">url</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Make a single HTTP request.&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="p">((</span><span class="nc">method</span><span class="w"> </span><span class="ss">&#39;get</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="nv">headers</span><span class="w"> </span><span class="o">&#39;</span><span class="p">())</span>
<span class="w">         </span><span class="p">(</span><span class="nv">request-data</span><span class="w"> </span><span class="o">`#(,</span><span class="nv">url</span><span class="w"> </span><span class="o">,</span><span class="nv">headers</span><span class="p">))</span>
<span class="w">         </span><span class="p">(</span><span class="nv">http-options</span><span class="w"> </span><span class="p">())</span>
<span class="w">         </span><span class="p">(</span><span class="nv">request-options</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="o">#(</span><span class="nv">sync</span><span class="w"> </span><span class="nv">false</span><span class="p">))))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">httpc:request</span><span class="w"> </span><span class="nc">method</span><span class="w"> </span><span class="nv">request-data</span><span class="w"> </span><span class="nv">http-options</span><span class="w"> </span><span class="nv">request-options</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nv">receive</span>
<span class="w">      </span><span class="p">(</span><span class="o">`#(</span><span class="nv">http</span><span class="w"> </span><span class="o">#(,</span><span class="nv">request-id</span><span class="w"> </span><span class="o">#(</span><span class="nb">error</span><span class="w"> </span><span class="o">,</span><span class="nv">reason</span><span class="p">)))</span>
<span class="w">       </span><span class="p">(</span><span class="nv">io:format</span><span class="w"> </span><span class="s">&quot;Error: ~p~n&quot;</span><span class="w"> </span><span class="o">`</span><span class="p">(</span><span class="o">,</span><span class="nv">reason</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="o">`#(</span><span class="nv">http</span><span class="w"> </span><span class="o">#(,</span><span class="nv">request-id</span><span class="w"> </span><span class="o">,</span><span class="nv">result</span><span class="p">))</span>
<span class="w">       </span><span class="p">(</span><span class="nv">io:format</span><span class="w"> </span><span class="s">&quot;Result: ~p~n&quot;</span><span class="w"> </span><span class="o">`</span><span class="p">(</span><span class="o">,</span><span class="nv">result</span><span class="p">))))))</span>


<span class="c1">;; Check out Erlang&#39;s documentation for more concurrency and OTP docs.</span>
</pre></div>
<h2>Further Reading</h2>

<ul>
<li>   <a href="http://docs.lfe.io">LFE DOCS</a></li>
<li>   <a href="https://lfe.gitbooks.io/reference-guide/index.html">LFE GitBook</a></li>
<li>   <a href="https://en.wikipedia.org/wiki/LFE_(programming_language)">LFE Wiki</a></li>
</ul>

<h2>Extra Info</h2>

<ul>
<li>   <a href="http://www.erlang-factory.com/upload/presentations/61/Robertvirding-LispFlavouredErlang.pdf">LFE PDF</a></li>
<li>   <a href="https://groups.google.com/d/msg/lisp-flavoured-erlang/XA5HeLbQQDk/TUHabZCHXB0J">LFE mail</a></li>
</ul>

<h2>Credits</h2>

<p>Lots of thanks to Robert Virding for creating LFE, Duncan McGreggor for documenting it and other LFE contributors who made LFE awesome.</p>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/lfe.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by Pratik Karki, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/lfe.html.markdown">1 contributor</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="https://github.com/prertik">Pratik Karki</a>
    </p>

    <p>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
