<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="es-es" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="es-es" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="es-es" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="es-es" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="es-es">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Raku in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/es-es/raku-es/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fes-es%2Fraku-es%2F&text=Aprende+X+en+Y+minutos%2C+donde+X%3DRaku">
        Comparte esta página
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Seleccione el tema:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">ligero</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">oscuro</button>
  </div>
  <h1><a href="/">Aprende X en Y minutos</a></h1>
  <h2>Donde X=Raku</h2>
    <p class="filelink">
    Descarga el código:
    <a href="/docs/files/learnraku-es.raku">learnraku-es.raku</a>
    </p>
  <div id="doc">
    <p>Raku es un lenguaje de programación altamente capaz y con características
abundantes para hacerlo el lenguage ideal por los próximos 100 años.</p>

<p>El compilador primario de Raku se llama <a href="http://rakudo.org">Rakudo</a>, el cual
se ejecuta en JVM y en <a href="http://moarvm.com">MoarVM</a>.</p>

<p>Meta-nota: dos signos de números (##) son usados para indicar párrafos,
mientras que un solo signo de número (#) indica notas.</p>

<p><code>#=&gt;</code> representa la salida de un comando.</p>
<div class="highlight"><pre><span></span><span class="c1"># Un comentario de una sola línea comienza con un signo de número</span>

<span class="cm">#`(</span>
<span class="cm">  Comentarios multilíneas usan #` y signos de encerradura tales</span>
<span class="cm">  como (), [], {}, 「」, etc.</span>
<span class="cm">)</span>
</pre></div>
<h2>Variables</h2>
<div class="highlight"><pre><span></span><span class="c1">## En Raku, se declara una variable lexical usando `my`</span>
<span class="k">my</span> <span class="nv">$variable</span>;
<span class="c1">## Raku tiene 3 tipos básicos de variables: escalares, arrays, y hashes.</span>
</pre></div>
<h3>Escalares</h3>
<div class="highlight"><pre><span></span><span class="c1"># Un escalar representa un solo valor. Variables escalares comienzan</span>
<span class="c1"># con un `$`</span>

<span class="k">my</span> <span class="nv">$str</span> = <span class="s">&#39;Cadena&#39;</span>;
<span class="c1"># Las comillas inglesas (&quot;&quot;) permiten la intepolación (lo cual veremos</span>
<span class="c1"># luego):</span>
<span class="k">my</span> <span class="nv">$str2</span> = <span class="s">&quot;Cadena&quot;</span>;

<span class="c1">## Los nombres de variables pueden contener pero no terminar con comillas</span>
<span class="c1">## simples y guiones. Sin embargo, pueden contener</span>
<span class="c1">## (y terminar con) guiones bajos (_):</span>
<span class="k">my</span> <span class="nv">$nombre&#39;de-variable_</span> = <span class="mi">5</span>; <span class="c1"># Esto funciona!</span>

<span class="k">my</span> <span class="nv">$booleano</span> = <span class="nb">True</span>; <span class="c1"># `True` y `False` son valores booleanos en Raku.</span>
<span class="k">my</span> <span class="nv">$inverso</span> = !<span class="nv">$booleano</span>; <span class="c1"># Puedes invertir un booleano con el operador prefijo `!`</span>
<span class="k">my</span> <span class="nv">$bool-forzado</span> = <span class="nb">so</span> <span class="nv">$str</span>; <span class="c1"># Y puedes usar el operador prefijo `so` que</span>
                            <span class="c1"># convierte su operador en un Bool</span>
</pre></div>
<h3>Arrays y Listas</h3>
<div class="highlight"><pre><span></span><span class="c1">## Un array representa varios valores. Variables arrays comienzan con `@`.</span>
<span class="c1">## Las listas son similares pero son un tipo inmutable.</span>

<span class="k">my</span> <span class="nv">@array</span> = <span class="s">&#39;a&#39;</span>, <span class="s">&#39;b&#39;</span>, <span class="s">&#39;c&#39;</span>;
<span class="c1"># equivalente a:</span>
<span class="k">my</span> <span class="nv">@letras</span> = <span class="s">&lt;a b c&gt;</span>;  <span class="c1"># array de palabras, delimitado por espacios.</span>
                       <span class="c1"># Similar al qw de perl, o el %w de Ruby.</span>
<span class="k">my</span> <span class="nv">@array</span> = <span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>;

<span class="nb">say</span> <span class="nv">@array</span>[<span class="mi">2</span>]; <span class="c1"># Los índices de un array empiezan por el 0 -- Este es</span>
               <span class="c1"># el tercer elemento.</span>

<span class="nb">say</span> <span class="s">&quot;Interpola todos los elementos de un array usando [] : @array[]&quot;</span>;
<span class="c1">#=&gt; Interpola todos los elementos de un array usando [] : 1 2 3</span>

<span class="nv">@array</span>[<span class="mi">0</span>] = -<span class="mi">1</span>;      <span class="c1"># Asigna un nuevo valor a un índice del array</span>
<span class="nv">@array</span>[<span class="mi">0</span>, <span class="mi">1</span>] = <span class="mi">5</span>, <span class="mi">6</span>; <span class="c1"># Asigna varios valores</span>

<span class="k">my</span> <span class="nv">@llaves</span> = <span class="mi">0</span>, <span class="mi">2</span>;
<span class="nv">@array</span>[<span class="nv">@llaves</span>] = <span class="nv">@letras</span>; <span class="c1"># Asignación usando un array que contiene valores</span>
                           <span class="c1"># índices</span>
<span class="nb">say</span> <span class="nv">@array</span>; <span class="c1">#=&gt; a 6 b</span>
</pre></div>
<h3>Hashes, o Pairs (pares) de llaves-valores.</h3>
<div class="highlight"><pre><span></span><span class="c1">## Un hash contiene parejas de llaves y valores.</span>
<span class="c1">## Puedes construir un objeto Pair usando la sintaxis `LLave =&gt; Valor`.</span>
<span class="c1">## Tablas de hashes son bien rápidas para búsqueda, y son almacenadas</span>
<span class="c1">## sin ningún orden.</span>
<span class="c1">## Ten en cuenta que las llaves son &quot;aplanadas&quot; en contexto de hash, y</span>
<span class="c1">## cualquier llave duplicada es deduplicada.</span>
<span class="k">my</span> <span class="nv">%hash</span> = <span class="mi">1</span> =&gt; <span class="mi">2</span>,
           <span class="mi">3</span> =&gt; <span class="mi">4</span>;
<span class="k">my</span> <span class="nv">%hash</span> = <span class="n">foo</span> =&gt; <span class="s">&quot;bar&quot;</span>,            <span class="c1"># las llaves reciben sus comillas</span>
                                    <span class="c1"># automáticamente.</span>
           <span class="s">&quot;some other&quot;</span> =&gt; <span class="s">&quot;value&quot;</span>, <span class="c1"># las comas colgantes estań bien.</span>
           ;

<span class="c1">## Aunque los hashes son almacenados internamente de forma diferente a los</span>
<span class="c1">## arrays, Raku te permite crear un hash usando un array</span>
<span class="c1">## con un número par de elementos fácilmente.</span>
<span class="k">my</span> <span class="nv">%hash</span> = <span class="s">&lt;llave1 valor1 llave2 valor2&gt;</span>;

<span class="k">my</span> <span class="nv">%hash</span> = <span class="n">llave1</span> =&gt; <span class="s">&#39;valor1&#39;</span>, <span class="n">llave2</span> =&gt; <span class="s">&#39;valor2&#39;</span>; <span class="c1"># ¡el mismo resultado!</span>

<span class="c1">## También puedes usar la sintaxis &quot;pareja con dos puntos&quot;:</span>
<span class="c1">## (especialmente útil para parámetros nombrados que verás más adelante)</span>
<span class="k">my</span> <span class="nv">%hash</span> = :<span class="n">w</span>(<span class="mi">1</span>),    <span class="c1"># equivalente a `w =&gt; 1`</span>
                     <span class="c1"># esto es útil para el atajo `True`:</span>
           :<span class="n">truey</span>,   <span class="c1"># equivalente a `:truey(True)`, o `truey =&gt; True`</span>
                     <span class="c1"># y para el `False`:</span>
           :!<span class="n">falsey</span>, <span class="c1"># equivalente a `:falsey(False)`, o `falsey =&gt; False`</span>
           ;

<span class="nb">say</span> <span class="nv">%hash</span>{<span class="s">&#39;llave1&#39;</span>}; <span class="c1"># Puedes usar {} para obtener el valor de una llave</span>
<span class="nb">say</span> <span class="nv">%hash&lt;llave2&gt;</span>;   <span class="c1"># Si es una cadena de texto, puedes actualmente usar &lt;&gt;</span>
                     <span class="c1"># (`{llave1}` no funciona, debido a que Raku no tiene</span>
                     <span class="c1"># palabras desnudas (barewords en inglés))</span>
</pre></div>
<h2>Subrutinas</h2>
<div class="highlight"><pre><span></span><span class="c1">## Subrutinas, o funciones como otros lenguajes las llaman, son</span>
<span class="c1">## creadas con la palabra clave `sub`.</span>
<span class="k">sub</span> <span class="n">di-hola</span> { <span class="nb">say</span> <span class="s">&quot;¡Hola, mundo!&quot;</span> }

<span class="c1">## Puedes proveer argumentos (tipados). Si especificado,</span>
<span class="c1">## el tipo será chequeado al tiempo de compilación si es posible.</span>
<span class="c1">## De lo contrario, al tiempo de ejecución.</span>
<span class="k">sub</span> <span class="n">di-hola-a</span>(<span class="nb">Str</span> <span class="nv">$nombre</span>) {
    <span class="nb">say</span> <span class="s">&quot;¡Hola, $nombre!&quot;</span>;
}

<span class="c1">## Una subrutina devuelve el último valor evaluado del bloque.</span>
<span class="k">sub</span> <span class="n">devolver-valor</span> {
    <span class="mi">5</span>;
}
<span class="nb">say</span> <span class="n">devolver-valor</span>; <span class="c1"># imprime 5</span>
<span class="k">sub</span> <span class="n">devolver-vacio</span> {
}
<span class="nb">say</span> <span class="n">devolver-vacio</span>; <span class="c1"># imprime Nil</span>

<span class="c1">## Algunas estructuras de control producen un valor. Por ejemplo if:</span>
<span class="k">sub</span> <span class="n">devuelva-si</span> {
    <span class="k">if</span> <span class="nb">True</span> {
        <span class="s">&quot;Truthy&quot;</span>;
    }
}
<span class="nb">say</span> <span class="n">devuelva-si</span>; <span class="c1"># imprime Truthy</span>

<span class="c1">## Otras no, como un bucle for:</span>
<span class="k">sub</span> <span class="n">return-for</span> {
    <span class="k">for</span> <span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span> { }
}
<span class="nb">say</span> <span class="n">return-for</span>; <span class="c1"># imprime Nil</span>

<span class="c1">## Una subrutina puede tener argumentos opcionales:</span>
<span class="k">sub</span> <span class="n">con-opcional</span>(<span class="nv">$arg</span>?) { <span class="c1"># el signo &quot;?&quot; marca el argumento opcional</span>
  <span class="nb">say</span> <span class="s">&quot;Podría returnar `(Any)` (valor de Perl parecido al &#39;null&#39;) si no me pasan</span>
<span class="s">    un argumento, o returnaré mi argumento&quot;</span>;
  <span class="nv">$arg</span>;
}
<span class="n">con-opcional</span>;    <span class="c1"># devuelve Any</span>
<span class="n">con-opcional</span>();  <span class="c1"># devuelve Any</span>
<span class="n">con-opcional</span>(<span class="mi">1</span>); <span class="c1"># devuelve 1</span>

<span class="c1">## También puedes proveer un argumento por defecto para</span>
<span class="c1">## cuando los argumentos no son proveídos:</span>
<span class="k">sub</span> <span class="n">hola-a</span>(<span class="nv">$nombre</span> = <span class="s">&quot;Mundo&quot;</span>) {
  <span class="nb">say</span> <span class="s">&quot;¡Hola, $nombre!&quot;</span>;
}
<span class="n">hola-a</span>;       <span class="c1">#=&gt; ¡Hola, Mundo!</span>
<span class="n">hola-a</span>();     <span class="c1">#=&gt; ¡Hola, Mundo!</span>
<span class="n">hola-a</span>(<span class="s">&#39;Tú&#39;</span>); <span class="c1">#=&gt; ¡Hola, Tú!</span>

<span class="c1">## De igual manera, al usar la sintaxis parecida a la de los hashes</span>
<span class="c1">## (¡Hurra, sintaxis unificada!), puedes pasar argumentos *nombrados*</span>
<span class="c1">## a una subrutina. Ellos son opcionales, y por defecto son del tipo &quot;Any&quot;.</span>
<span class="k">sub</span> <span class="n">con-nombre</span>(<span class="nv">$arg-normal</span>, :<span class="nv">$nombrado</span>) {
  <span class="nb">say</span> <span class="nv">$arg-normal</span> + <span class="nv">$nombrado</span>;
}
<span class="n">con-nombre</span>(<span class="mi">1</span>, <span class="n">nombrado</span> =&gt; <span class="mi">6</span>); <span class="c1">#=&gt; 7</span>
<span class="c1">## Sin embargo, debes tener algo en cuenta aquí:</span>
<span class="c1">## Si pones comillas alrededor de tu llave, Raku no será capaz de verla</span>
<span class="c1">## al tiempo de compilación, y entonces tendrás un solo objeto Pair como</span>
<span class="c1">## un argumento posicional, lo que significa que el siguiente ejemplo</span>
<span class="c1">## falla:</span>
<span class="n">con-nombre</span>(<span class="mi">1</span>, <span class="s">&#39;nombrado&#39;</span> =&gt; <span class="mi">6</span>);

<span class="n">con-nombre</span>(<span class="mi">2</span>, :<span class="n">nombrado</span>(<span class="mi">5</span>)); <span class="c1">#=&gt; 7</span>

<span class="c1">## Para hacer un argumento nombrado mandatorio, puedes utilizar el</span>
<span class="c1">## inverso de `?`, `!`:</span>
<span class="k">sub</span> <span class="n">con-nombre-mandatorio</span>(:<span class="nv">$str</span>!)  {
  <span class="nb">say</span> <span class="s">&quot;$str!&quot;</span>;
}
<span class="n">con-nombre-mandatorio</span>(<span class="n">str</span> =&gt; <span class="s">&quot;Mi texto&quot;</span>); <span class="c1">#=&gt; Mi texto!</span>
<span class="n">con-nombre-mandatorio</span>;    <span class="c1"># error al tiempo de ejecución:</span>
                          <span class="c1"># &quot;Required named parameter not passed&quot;</span>
                          <span class="c1"># (&quot;Parámetro nombrado requerido no proveído&quot;)</span>
<span class="n">con-nombre-mandatorio</span>(<span class="mi">3</span>); <span class="c1"># error al tiempo de ejecución:</span>
                          <span class="c1"># &quot;Too many positional parameters passed&quot;</span>
                          <span class="c1"># (&quot;Demasiados argumentos posicionales proveídos&quot;)</span>

<span class="c1">## Si una subrutina toma un argumento booleano nombrado ...</span>
<span class="k">sub</span> <span class="n">toma-un-bool</span>(<span class="nv">$nombre</span>, :<span class="nv">$bool</span>) {
  <span class="nb">say</span> <span class="s">&quot;$nombre toma $bool&quot;</span>;
}
<span class="c1">## ... puedes usar la misma sintaxis de hash de un &quot;booleano corto&quot;:</span>
<span class="n">takes-a-bool</span>(<span class="s">&#39;config&#39;</span>, :<span class="n">bool</span>);  <span class="c1"># config toma True</span>
<span class="n">takes-a-bool</span>(<span class="s">&#39;config&#39;</span>, :!<span class="n">bool</span>); <span class="c1"># config toma False</span>

<span class="c1">## También puedes proveer tus argumentos nombrados con valores por defecto:</span>
<span class="k">sub</span> <span class="n">nombrado-definido</span>(:<span class="nv">$def</span> = <span class="mi">5</span>) {
  <span class="nb">say</span> <span class="nv">$def</span>;
}
<span class="n">nombrado-definido</span>; <span class="c1">#=&gt; 5</span>
<span class="n">nombrado-definido</span>(<span class="n">def</span> =&gt; <span class="mi">15</span>); <span class="c1">#=&gt; 15</span>

<span class="c1">## Dado que puedes omitir los paréntesis para invocar una función sin</span>
<span class="c1">## argumentos, necesitas usar &quot;&amp;&quot; en el nombre para almacenar la función</span>
<span class="c1">## `di-hola` en una variable.</span>
<span class="k">my</span> <span class="nv">&amp;s</span> = <span class="nv">&amp;di-hola</span>;
<span class="k">my</span> <span class="nv">&amp;otra-s</span> = <span class="k">sub</span> { <span class="nb">say</span> <span class="s">&quot;¡Función anónima!&quot;</span> }

<span class="c1">## Una subrutina puede tener un parámetro &quot;slurpy&quot;, o &quot;no importa cuantos&quot;,</span>
<span class="c1">## indicando que la función puede recibir cualquier número de parámetros.</span>
<span class="k">sub</span> <span class="n">muchos</span>(<span class="nv">$principal</span>, *<span class="nv">@resto</span>) {  <span class="c1">#`*@` (slurpy) consumirá lo restante</span>
<span class="c1">## Nota: Puedes tener parámetros *antes que* un parámetro &quot;slurpy&quot; (como</span>
<span class="c1">## aquí) pero no *después* de uno.</span>
  <span class="nb">say</span> <span class="nv">@resto</span>.<span class="nb">join</span>(<span class="s">&#39; / &#39;</span>) ~ <span class="s">&quot;!&quot;</span>;
}
<span class="nb">say</span> <span class="n">muchos</span>(<span class="s">&#39;Feliz&#39;</span>, <span class="s">&#39;Cumpleaño&#39;</span>, <span class="s">&#39;Cumpleaño&#39;</span>); <span class="c1">#=&gt; Feliz / Cumpleaño!</span>
                                           <span class="c1"># Nota que el asterisco (*) no</span>
                                           <span class="c1"># consumió el parámetro frontal.</span>

<span class="c1">## Puedes invocar un función con un array usando el</span>
<span class="c1">## operador &quot;aplanador de lista de argumento&quot; `|`</span>
<span class="c1">## (actualmente no es el único rol de este operador pero es uno de ellos)</span>
<span class="k">sub</span> <span class="n">concat3</span>(<span class="nv">$a</span>, <span class="nv">$b</span>, <span class="nv">$c</span>) {
  <span class="nb">say</span> <span class="s">&quot;$a, $b, $c&quot;</span>;
}
<span class="n">concat3</span>(|<span class="nv">@array</span>); <span class="c1">#=&gt; a, b, c</span>
                  <span class="c1"># `@array` fue &quot;aplanado&quot; como parte de la lista de argumento</span>
</pre></div>
<h2>Contenedores</h2>
<div class="highlight"><pre><span></span><span class="c1">## En Raku, valores son actualmente almacenados en &quot;contenedores&quot;.</span>
<span class="c1">## El operador de asignación le pregunta al contenedor en su izquierda</span>
<span class="c1">## almacenar el valor a su derecha. Cuando se pasan alrededor, contenedores</span>
<span class="c1">## son marcados como inmutables. Esto significa que, en una función, tu</span>
<span class="c1">## tendrás un error si tratas de mutar uno de tus argumentos.</span>
<span class="c1">## Si realmente necesitas hacerlo, puedes preguntar por un contenedor</span>
<span class="c1">## mutable usando `is rw`:</span>
<span class="k">sub</span> <span class="n">mutar</span>(<span class="nv">$n</span> <span class="k">is</span> <span class="k">rw</span>) {
  <span class="nv">$n</span>++;
  <span class="nb">say</span> <span class="s">&quot;¡\$n es ahora $n!&quot;</span>;
}

<span class="k">my</span> <span class="nv">$m</span> = <span class="mi">42</span>;
<span class="n">mutar</span> <span class="nv">$m</span>; <span class="c1"># ¡$n es ahora 43!</span>

<span class="c1">## Esto funciona porque estamos pasando el contenedor $m para mutarlo. Si</span>
<span class="c1">## intentamos pasar un número en vez de pasar una variable, no funcionará</span>
<span class="c1">## dado que no contenedor ha sido pasado y números enteros son inmutables</span>
<span class="c1">## por naturaleza:</span>

<span class="n">mutar</span> <span class="mi">42</span>; <span class="c1"># Parámetro &#39;$n&#39; esperaba un contenedor mutable,</span>
          <span class="c1"># pero recibió un valor Int</span>

<span class="c1">## Si en cambio quieres una copia, debes usar `is copy`.</span>

<span class="c1">## Por si misma, una subrutina devuelve un contenedor, lo que significa</span>
<span class="c1">## que puede ser marcada con rw:</span>
<span class="k">my</span> <span class="nv">$x</span> = <span class="mi">42</span>;
<span class="k">sub</span> <span class="o">x-</span><span class="n">almacena</span>() <span class="k">is</span> <span class="k">rw</span> { <span class="nv">$x</span> }
<span class="o">x-</span><span class="n">almacena</span>() = <span class="mi">52</span>; <span class="c1"># En este caso, los paréntesis son mandatorios</span>
                <span class="c1"># (porque de otra forma, Raku piensa que la función</span>
                <span class="c1"># `x-almacena` es un identificador).</span>
<span class="nb">say</span> <span class="nv">$x</span>; <span class="c1">#=&gt; 52</span>
</pre></div>
<h2>Estructuras de control</h2>

<h3>Condicionales</h3>
<div class="highlight"><pre><span></span><span class="c1">## - `if`</span>
<span class="c1">## Antes de hablar acerca de `if`, necesitamos saber cuales valores son</span>
<span class="c1">## &quot;Truthy&quot; (representa True (verdadero)), y cuales son &quot;Falsey&quot;</span>
<span class="c1">## (o &quot;Falsy&quot;) -- representa False (falso). Solo estos valores son</span>
<span class="c1">## Falsey: 0, (), {}, &quot;&quot;, Nil, un tipo (como `Str` o`Int`) y</span>
<span class="c1">## por supuesto False. Todos los valores son Truthy.</span>
<span class="k">if</span> <span class="nb">True</span> {
  <span class="nb">say</span> <span class="s">&quot;¡Es verdadero!&quot;</span>;
}

<span class="k">unless</span> <span class="nb">False</span> {
  <span class="nb">say</span> <span class="s">&quot;¡No es falso!&quot;</span>;
}

<span class="c1">## Como puedes observar, no necesitas paréntesis alrededor de condiciones.</span>
<span class="c1">## Sin embargo, necesitas las llaves `{}` alrededor del cuerpo de un bloque:</span>
<span class="c1"># if (true) say; # !Esto no funciona!</span>

<span class="c1">## También puedes usar sus versiones sufijos seguidas por la palabra clave:</span>
<span class="nb">say</span> <span class="s">&quot;Un poco verdadero&quot;</span> <span class="k">if</span> <span class="nb">True</span>;

<span class="c1">## - La condicional ternaria, &quot;?? !!&quot; (como `x ? y : z` en otros lenguajes)</span>
<span class="c1">##   devuelve $valor-si-verdadera si la condición es verdadera y</span>
<span class="c1">##   $valor-si-falsa si es falsa.</span>
<span class="c1">##   my $resultado = $valor condición ?? $valor-si-verdadera !! $valor-si-falsa;</span>

<span class="k">my</span> <span class="nv">$edad</span> = <span class="mi">30</span>;
<span class="nb">say</span> <span class="nv">$edad</span> &gt; <span class="mi">18</span> ?? <span class="s">&quot;Eres un adulto&quot;</span> !! <span class="s">&quot;Eres menor de 18&quot;</span>;
</pre></div>
<h3>given/when, ó switch</h3>
<div class="highlight"><pre><span></span><span class="c1">## - `given`-`when` se parece al `switch` de otros lenguajes, pero es más</span>
<span class="c1">## poderoso gracias a la coincidencia inteligente (&quot;smart matching&quot; en inglés)</span>
<span class="c1">## y la &quot;variable tópica&quot; $_ de Perl.</span>
<span class="c1">##</span>
<span class="c1">## Esta variable ($_) contiene los argumentos por defecto de un bloque,</span>
<span class="c1">## la iteración actual de un loop (a menos que sea explícitamente</span>
<span class="c1">## nombrado), etc.</span>
<span class="c1">##</span>
<span class="c1">## `given` simplemente pone su argumento en `$_` (como un bloque lo haría),</span>
<span class="c1">## y `when` lo compara usando el operador de &quot;coincidencia inteligente&quot; (`~~`).</span>
<span class="c1">##</span>
<span class="c1">## Dado que otras construcciones de Raku usan esta variable (por ejemplo,</span>
<span class="c1">## el bucle `for`, bloques, etc), esto se significa que el poderoso `when` no</span>
<span class="c1">## solo se aplica con un `given`, sino que se puede usar en cualquier</span>
<span class="c1">## lugar donde exista una variable `$_`.</span>

<span class="k">given</span> <span class="s">&quot;foo bar&quot;</span> {
  <span class="nb">say</span> <span class="nv">$_</span>; <span class="c1">#=&gt; foo bar</span>
  <span class="k">when</span> /<span class="n">foo</span>/ { <span class="c1"># No te preocupies acerca de la coincidencia inteligente –</span>
               <span class="c1"># solo ten presente que `when` la usa.</span>
               <span class="c1"># Esto es equivalente a `if $_ ~~ /foo/`.</span>
    <span class="nb">say</span> <span class="s">&quot;¡Yay!&quot;</span>;
  }
  <span class="k">when</span> <span class="nv">$_</span>.<span class="nb">chars</span> &gt; <span class="mi">50</span> { <span class="c1"># coincidencia inteligente con cualquier cosa True es True,</span>
                       <span class="c1"># i.e. (`$a ~~ True`)</span>
                       <span class="c1"># por lo tanto puedes también poner condiciones &quot;normales&quot;.</span>
                       <span class="c1"># Este `when` es equivalente a este `if`:</span>
                       <span class="c1">#  if $_ ~~ ($_.chars &gt; 50) {...}</span>
                       <span class="c1"># que significa:</span>
                       <span class="c1">#  if $_.chars &gt; 50 {...}</span>
    <span class="nb">say</span> <span class="s">&quot;¡Una cadena de texto bien larga!&quot;</span>;
  }
  <span class="k">default</span> { <span class="c1"># lo mismo que `when *` (usando la Whatever Star)</span>
    <span class="nb">say</span> <span class="s">&quot;Algo más&quot;</span>;
  }
}
</pre></div>
<h3>Construcciones de bucle</h3>
<div class="highlight"><pre><span></span><span class="c1">## - `loop` es un bucle infinito si no le pasas sus argumentos,</span>
<span class="c1">## pero también puede ser un bucle for al estilo de C:</span>
<span class="k">loop</span> {
  <span class="nb">say</span> <span class="s">&quot;¡Este es un bucle infinito!&quot;</span>;
  <span class="nb">last</span>; <span class="c1"># last interrumpe el bucle, como la palabra clave `break`</span>
        <span class="c1"># en otros lenguajes.</span>
}

<span class="k">loop</span> (<span class="k">my</span> <span class="nv">$i</span> = <span class="mi">0</span>; <span class="nv">$i</span> &lt; <span class="mi">5</span>; <span class="nv">$i</span>++) {
  <span class="nb">next</span> <span class="k">if</span> <span class="nv">$i</span> == <span class="mi">3</span>;  <span class="c1"># `next` salta a la siguiente iteración, al igual</span>
                    <span class="c1"># que `continue` en otros lenguajes. Ten en cuenta que</span>
                    <span class="c1"># también puedes usar la condicionales postfix (sufijas)</span>
                    <span class="c1"># bucles, etc.</span>
  <span class="nb">say</span> <span class="s">&quot;¡Este es un bucle al estilo de C!&quot;</span>;
}

<span class="c1">## - `for` - Hace iteraciones en un array</span>
<span class="k">for</span> <span class="nv">@array</span> -&gt; <span class="nv">$variable</span> {
  <span class="nb">say</span> <span class="s">&quot;¡He conseguido una $variable!&quot;</span>;
}

<span class="c1">## Como vimos con `given`, la variable de una &quot;iteración actual&quot; por defecto</span>
<span class="c1">## es `$_`. Esto significa que puedes usar `when` en un bucle `for` como</span>
<span class="c1">## normalmente lo harías con `given`.</span>
<span class="k">for</span> <span class="nv">@array</span> {
  <span class="nb">say</span> <span class="s">&quot;he conseguido a $_&quot;</span>;

  .<span class="nb">say</span>; <span class="c1"># Esto es también permitido.</span>
        <span class="c1"># Una invocación con punto (dot call) sin &quot;tópico&quot; (recibidor) es</span>
        <span class="c1"># enviada a `$_` por defecto.</span>
  <span class="nv">$_</span>.<span class="nb">say</span>; <span class="c1"># lo mismo de arriba, lo cual es equivalente.</span>
}

<span class="k">for</span> <span class="nv">@array</span> {
  <span class="c1"># Puedes...</span>
  <span class="nb">next</span> <span class="k">if</span> <span class="nv">$_</span> == <span class="mi">3</span>; <span class="c1"># Saltar a la siguiente iteración (`continue` en</span>
                   <span class="c1"># lenguages parecido a C)</span>
  <span class="nb">redo</span> <span class="k">if</span> <span class="nv">$_</span> == <span class="mi">4</span>; <span class="c1"># Re-hacer la iteración, manteniendo la</span>
                   <span class="c1"># misma variable tópica (`$_`)</span>
  <span class="nb">last</span> <span class="k">if</span> <span class="nv">$_</span> == <span class="mi">5</span>; <span class="c1"># Salir fuera del bucle (como `break`</span>
                   <span class="c1"># en lenguages parecido a C)</span>
}

<span class="c1">## La sintaxis de &quot;bloque puntiagudo&quot; no es específica al bucle for.</span>
<span class="c1">## Es solo una manera de expresar un bloque en Raku.</span>
<span class="k">if</span> <span class="n">computación-larga</span>() -&gt; <span class="nv">$resultado</span> {
  <span class="nb">say</span> <span class="s">&quot;El resultado es $resultado&quot;</span>;
}
</pre></div>
<h2>Operadores</h2>
<div class="highlight"><pre><span></span><span class="c1">## Dados que los lenguajes de la familia Perl son lenguages basados</span>
<span class="c1">## mayormente en operadores, los operadores de Raku son actualmente</span>
<span class="c1">## subrutinas un poco cómicas en las categorías sintácticas. Por ejemplo,</span>
<span class="c1">## infix:&lt;+&gt; (adición) o prefix:&lt;!&gt; (bool not).</span>

<span class="c1">## Las categorías son:</span>
<span class="c1">## - &quot;prefix&quot;  (prefijo): anterior a (como `!` en `!True`).</span>
<span class="c1">## - &quot;postfix&quot; (sufijo):  posterior a (como `++` en `$a++`).</span>
<span class="c1">## - &quot;infix&quot;   (infijo):  en medio de (como `*` en `4 * 3`).</span>
<span class="c1">## - &quot;circumfix&quot; (circunfijo): alrededor de (como `[`-`]` en `[1, 2]`).</span>
<span class="c1">## - &quot;post-circumfix&quot; (pos-circunfijo): alrededor de un término,</span>
<span class="c1">##                                      posterior a otro término.</span>
<span class="c1">##                     (como `{`-`}` en `%hash{&#39;key&#39;}`)</span>

<span class="c1">## La lista de asociatividad y precedencia se explica más abajo.</span>

<span class="c1">## ¡Bueno, ya estás listo(a)!</span>

<span class="c1">## * Chequeando igualdad</span>

<span class="c1">## - `==` se usa en comparaciones numéricas.</span>
<span class="mi">3</span> == <span class="mi">4</span>; <span class="c1"># Falso</span>
<span class="mi">3</span> != <span class="mi">4</span>; <span class="c1"># Verdadero</span>

<span class="c1">## - `eq` se usa en comparaciones de cadenas de texto.</span>
<span class="s">&#39;a&#39;</span> <span class="o">eq</span> <span class="s">&#39;b&#39;</span>;
<span class="s">&#39;a&#39;</span> <span class="o">ne</span> <span class="s">&#39;b&#39;</span>;  <span class="c1"># no igual</span>
<span class="s">&#39;a&#39;</span> !<span class="o">eq</span> <span class="s">&#39;b&#39;</span>; <span class="c1"># lo mismo que lo anterior</span>

<span class="c1">## - `eqv` es equivalencia canónica (or &quot;igualdad profunda&quot;)</span>
(<span class="mi">1</span>, <span class="mi">2</span>) <span class="o">eqv</span> (<span class="mi">1</span>, <span class="mi">3</span>);

<span class="c1">## - Operador de coincidencia inteligente (smart matching): `~~`</span>
<span class="c1">## Asocia (aliasing en inglés) el lado izquierda a la variable $_</span>
<span class="c1">## y después evalúa el lado derecho.</span>
<span class="c1">## Aquí algunas comparaciones semánticas comunes:</span>

<span class="c1">## Igualdad de cadena de texto o numérica</span>

<span class="s">&#39;Foo&#39;</span> ~~ <span class="s">&#39;Foo&#39;</span>; <span class="c1"># True si las cadenas de texto son iguales.</span>
<span class="mf">12.5</span> ~~ <span class="mf">12.50</span>; <span class="c1"># True si los números son iguales.</span>

<span class="c1">## Regex - Para la comparación de una expresión regular en contra</span>
<span class="c1">## del lado izquierdo. Devuelve un objeto (Match), el cual evalúa</span>
<span class="c1">## como True si el regex coincide con el patrón.</span>

<span class="k">my</span> <span class="nv">$obj</span> = <span class="s">&#39;abc&#39;</span> ~~<span class="sr"> /a/</span>;
<span class="nb">say</span> <span class="nv">$obj</span>; <span class="c1"># ｢a｣</span>
<span class="nb">say</span> <span class="nv">$obj</span>.<span class="nb">WHAT</span>; <span class="c1"># (Match)</span>

<span class="c1">## Hashes</span>
<span class="s">&#39;llave&#39;</span> ~~ <span class="nv">%hash</span>; <span class="c1"># True si la llave existe en el hash</span>

<span class="c1">## Tipo - Chequea si el lado izquierdo &quot;tiene un tipo&quot; (puede chequear</span>
<span class="c1">## superclases y roles)</span>

<span class="mi">1</span> ~~ <span class="nb">Int</span>; <span class="c1"># True (1 es un número entero)</span>

<span class="c1">## Coincidencia inteligente contra un booleano siempre devuelve ese</span>
<span class="c1">## booleano (y lanzará una advertencia).</span>

<span class="mi">1</span> ~~ <span class="nb">True</span>; <span class="c1"># True</span>
<span class="nb">False</span> ~~ <span class="nb">True</span>; <span class="c1"># True</span>

<span class="c1">## La sintaxis general es $arg ~~ &amp;función-returnando-bool;</span>
<span class="c1">## Para una lista completa de combinaciones, usa esta tabla:</span>
<span class="c1">## http://perlcabal.org/syn/S03.html#Smart_matching</span>

<span class="c1">## También, por supuesto, tienes `&lt;`, `&lt;=`, `&gt;`, `&gt;=`.</span>
<span class="c1">## Sus equivalentes para cadenas de texto están disponibles:</span>
<span class="c1">## `lt`, `le`, `gt`, `ge`.</span>
<span class="mi">3</span> &gt; <span class="mi">4</span>;

<span class="c1">## * Constructores de rango</span>
<span class="mi">3</span> .. <span class="mi">7</span>; <span class="c1"># 3 a 7, ambos incluidos</span>
<span class="c1">## `^` en cualquier lado excluye a ese lado:</span>
<span class="mi">3</span> ^..^ <span class="mi">7</span>; <span class="c1"># 3 a 7, no incluidos (básicamente `4 .. 6`)</span>
<span class="c1">## Esto también funciona como un atajo para `0..^N`:</span>
^<span class="mi">10</span>; <span class="c1"># significa 0..^10</span>

<span class="c1">## Esto también nos permite demostrar que Raku tiene arrays</span>
<span class="c1">## ociosos/infinitos, usando la Whatever Star:</span>
<span class="k">my</span> <span class="nv">@array</span> = <span class="mi">1</span>..*; <span class="c1"># 1 al Infinito! `1..Inf` es lo mismo.</span>
<span class="nb">say</span> <span class="nv">@array</span>[^<span class="mi">10</span>]; <span class="c1"># puedes pasar arrays como subíndices y devolverá</span>
                 <span class="c1"># un array de resultados. Esto imprimirá</span>
                 <span class="c1"># &quot;1 2 3 4 5 6 7 8 9 10&quot; (y no se quedaré sin memoria!)</span>
<span class="c1">## Nota: Al leer una lista infinita, Raku &quot;cosificará&quot; los elementos que</span>
<span class="c1">## necesita y los mantendrá en la memoria. Ellos no serán calculados más de</span>
<span class="c1">## una vez. Tampoco calculará más elementos de los que necesita.</span>

<span class="c1">## Un índice de array también puede ser una clausura (&quot;closure&quot; en inglés).</span>
<span class="c1">## Será llamada con la longitud como el argumento</span>
<span class="nb">say</span> <span class="nb">join</span>(<span class="s">&#39; &#39;</span>, <span class="nv">@array</span>[<span class="mi">15</span>..*]); <span class="c1">#=&gt; 15 16 17 18 19</span>
<span class="c1">## lo que es equivalente a:</span>
<span class="nb">say</span> <span class="nb">join</span>(<span class="s">&#39; &#39;</span>, <span class="nv">@array</span>[-&gt; <span class="nv">$n</span> { <span class="mi">15</span>..<span class="nv">$n</span> }]);
<span class="c1">## Nota: Si tratas de hacer cualquiera de esos con un array infinito,</span>
<span class="c1">##       provocará un array infinito (tu programa nunca terminará)</span>

<span class="c1">## Puedes usar eso en los lugares que esperaría, como durante la asignación</span>
<span class="c1">## a un array</span>
<span class="k">my</span> <span class="nv">@números</span> = ^<span class="mi">20</span>;

<span class="c1">## Aquí los números son incrementados por &quot;6&quot;; más acerca del</span>
<span class="c1">## operador `...` adelante.</span>
<span class="k">my</span> <span class="nv">@seq</span> =  <span class="mi">3</span>, <span class="mi">9</span> ... * &gt; <span class="mi">95</span>; <span class="c1"># 3 9 15 21 27 [...] 81 87 93 99;</span>
<span class="nv">@números</span>[<span class="mi">5</span>..*] = <span class="mi">3</span>, <span class="mi">9</span> ... *; <span class="c1"># aunque la secuencia es infinita,</span>
                             <span class="c1"># solo los 15 números necesarios será calculados.</span>
<span class="nb">say</span> <span class="nv">@números</span>; <span class="c1">#=&gt; 0 1 2 3 4 3 9 15 21 [...] 81 87</span>
              <span class="c1"># (solamente 20 valores)</span>

<span class="c1">## * And &amp;&amp;, Or ||</span>
<span class="mi">3</span> &amp;&amp; <span class="mi">4</span>; <span class="c1"># 4, el cual es Truthy. Invoca `.Bool` en `4` y obtiene `True`.</span>
<span class="mi">0</span> || <span class="nb">False</span>; <span class="c1"># False. Invoca `.Bool` en `0`</span>

<span class="c1">## * Versiones circuito corto de lo de arriba</span>
<span class="c1">## &amp;&amp; Devuelve el primer argumento que evalúa a False, o el último.</span>

<span class="k">my</span> ( <span class="nv">$a</span>, <span class="nv">$b</span>, <span class="nv">$c</span> ) = <span class="mi">1</span>, <span class="mi">0</span>, <span class="mi">2</span>;
<span class="nv">$a</span> &amp;&amp; <span class="nv">$b</span> &amp;&amp; <span class="nv">$c</span>; <span class="c1"># Devuelve 0, el primer valor que es False</span>

<span class="c1">## || Devuelve el primer argumento que evalúa a True.</span>
<span class="nv">$b</span> || <span class="nv">$a</span>; <span class="c1"># 1</span>

<span class="c1">## Y porque tu lo querrás, también tienes operadores de asignación</span>
<span class="c1">## compuestos:</span>
<span class="nv">$a</span> *= <span class="mi">2</span>;  <span class="c1"># multiplica y asigna. Equivalente a $a = $a * 2;</span>
<span class="nv">$b</span> %%= <span class="mi">5</span>; <span class="c1"># divisible por y asignación. Equivalente $b = $b %% 5;</span>
<span class="nv">@array</span> .= <span class="nb">sort</span>; <span class="c1"># invoca el método `sort` y asigna el resultado devuelto.</span>
</pre></div>
<h2>¡Más sobre subrutinas!</h2>
<div class="highlight"><pre><span></span><span class="c1">## Como dijimos anteriormente, Raku tiene subrutinas realmente poderosas.</span>
<span class="c1">## Veremos unos conceptos claves que la hacen mejores que en cualquier otro</span>
<span class="c1">## lenguaje :-).</span>
</pre></div>
<h3>!Desempacado!</h3>
<div class="highlight"><pre><span></span><span class="c1">## Es la abilidad de extraer arrays y llaves (También conocido como</span>
<span class="c1">## &quot;destructuring&quot;). También funcionará en `my` y en las listas de parámetros.</span>
<span class="k">my</span> (<span class="nv">$f</span>, <span class="nv">$g</span>) = <span class="mi">1</span>, <span class="mi">2</span>;
<span class="nb">say</span> <span class="nv">$f</span>; <span class="c1">#=&gt; 1</span>
<span class="k">my</span> ($, $, <span class="nv">$h</span>) = <span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>; <span class="c1"># mantiene los anónimos no interesante</span>
<span class="nb">say</span> <span class="nv">$h</span>; <span class="c1">#=&gt; 3</span>

<span class="k">my</span> (<span class="nv">$cabeza</span>, *<span class="nv">@cola</span>) = <span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>; <span class="c1"># Sí, es lo mismo que con subrutinas &quot;slurpy&quot;</span>
<span class="k">my</span> (*<span class="nv">@small</span>) = <span class="mi">1</span>;

<span class="k">sub</span> <span class="n">desempacar_array</span>(<span class="nv">@array</span> [<span class="nv">$fst</span>, <span class="nv">$snd</span>]) {
  <span class="nb">say</span> <span class="s">&quot;Mi primero es $fst, mi segundo es $snd! De todo en todo, soy un @array[].&quot;</span>;
  <span class="c1"># (^ recuerda que `[]` interpola el array)</span>
}
<span class="n">desempacar_array</span>(<span class="nv">@cola</span>); <span class="c1">#=&gt; My first is 2, my second is 3 ! All in all, I&#39;m 2 3</span>


<span class="c1">## Si no está usando el array, puedes también mantenerlo anónimo, como un</span>
<span class="c1">## escalar:</span>
<span class="k">sub</span> <span class="n">primero-de-array</span>(@ [<span class="nv">$fst</span>]) { <span class="nv">$fst</span> }
<span class="n">primero-de-array</span>(<span class="nv">@small</span>); <span class="c1">#=&gt; 1</span>
<span class="n">primero-de-array</span>(<span class="nv">@tail</span>); <span class="c1"># Lanza un error &quot;Demasiados argumentos posicionales</span>
                         <span class="c1"># proveídos&quot;</span>
                         <span class="c1"># (lo que significa que el array es muy grande).</span>

<span class="c1">## También puedes usar un slurp ...</span>
<span class="k">sub</span> <span class="n">slurp-en-array</span>(@ [<span class="nv">$fst</span>, *<span class="nv">@rest</span>]) { <span class="c1"># Podrías mantener `*@rest` anónimos</span>
  <span class="nb">say</span> <span class="nv">$fst</span> + <span class="nv">@rest</span>.<span class="nb">elems</span>; <span class="c1"># `.elems` returna la longitud de una lista.</span>
                          <span class="c1"># Aquí, `@rest`  es `(3,)`, since `$fst` holds the `2`.</span>
}
<span class="n">slurp-en-array</span>(<span class="nv">@tail</span>); <span class="c1">#=&gt; 3</span>

<span class="c1">## Hasta podrías hacer un extracción usando una slurpy (pero no sería útil ;-).)</span>
<span class="k">sub</span> <span class="n">fst</span>(*@ [<span class="nv">$fst</span>]) { <span class="c1"># o simplemente: `sub fst($fst) { ... }`</span>
  <span class="nb">say</span> <span class="nv">$fst</span>;
}
<span class="n">fst</span>(<span class="mi">1</span>); <span class="c1">#=&gt; 1</span>
<span class="n">fst</span>(<span class="mi">1</span>, <span class="mi">2</span>); <span class="c1"># errores con &quot;Too many positional parameters passed&quot;</span>

<span class="c1">## También puedes desestructurar hashes (y clases, las cuales</span>
<span class="c1">## veremos adelante). La sintaxis es básicamente</span>
<span class="c1">## `%nombre-del-hash (:llave($variable-para-almacenar))`.</span>
<span class="c1">## El hash puede permanecer anónimos si solo necesitas los valores extraídos.</span>
<span class="k">sub</span> <span class="n">llave-de</span>(% (:<span class="n">azul</span>(<span class="nv">$val1</span>), :<span class="n">red</span>(<span class="nv">$val2</span>))) {
  <span class="nb">say</span> <span class="s">&quot;Valores: $val1, $val2.&quot;</span>;
}
<span class="c1">## Después invócala con un hash: (necesitas mantener las llaves</span>
<span class="c1">## de los parejas de llave y valor para ser un hash)</span>
<span class="n">llave-de</span>({<span class="n">azul</span> =&gt; <span class="s">&#39;blue&#39;</span>, <span class="n">rojo</span> =&gt; <span class="s">&quot;red&quot;</span>});
<span class="c1">#llave-de(%hash); # lo mismo (para un `%hash` equivalente)</span>

<span class="c1">## La última expresión de una subrutina es devuelta inmediatamente</span>
<span class="c1">## (aunque puedes usar la palabra clave `return`):</span>
<span class="k">sub</span> <span class="n">siguiente-indice</span>(<span class="nv">$n</span>) {
  <span class="nv">$n</span> + <span class="mi">1</span>;
}
<span class="k">my</span> <span class="nv">$nuevo-n</span>= <span class="n">siguiente-indice</span>(<span class="mi">3</span>); <span class="c1"># $nuevo-n es ahora 4</span>

<span class="c1">## Este es cierto para todo, excepto para las construcciones de bucles</span>
<span class="c1">## (debido a razones de rendimiento): Hay una razón de construir una lista</span>
<span class="c1">## si la vamos a desechar todos los resultados.</span>
<span class="c1">## Si todavías quieres construir una, puedes usar la sentencia prefijo `do`:</span>
<span class="c1">## (o el prefijo `gather`, el cual veremos luego)</span>
<span class="k">sub</span> <span class="n">lista-de</span>(<span class="nv">$n</span>) {
  <span class="nb">do</span> <span class="k">for</span> ^<span class="nv">$n</span> { <span class="c1"># nota el uso del operador de rango `^` (`0..^N`)</span>
    <span class="nv">$_</span>        <span class="c1"># iteración de bucle actual</span>
  }
}
<span class="k">my</span> <span class="nv">@list3</span> = <span class="n">lista-de</span>(<span class="mi">3</span>); <span class="c1">#=&gt; (0, 1, 2)</span>
</pre></div>
<h3>lambdas</h3>
<div class="highlight"><pre><span></span><span class="c1">## Puedes crear una lambda con `-&gt; {}` (&quot;bloque puntiagudo&quot;) o `{}` (&quot;bloque&quot;)</span>
<span class="k">my</span> <span class="nv">&amp;lambda</span> = -&gt; <span class="nv">$argumento</span> { <span class="s">&quot;El argumento pasado a esta lambda es $argumento&quot;</span> }
<span class="c1">## `-&gt; {}` y `{}` son casi la misma cosa, excepto que la primerra puede</span>
<span class="c1">## tomar argumentos, y la segunda puede ser malinterpretada como un hash</span>
<span class="c1">## por el parseador.</span>

<span class="c1">## Podemos, por ejemplo, agregar 3  a cada valor de un array usando map:</span>
<span class="k">my</span> <span class="nv">@arraymas3</span> = <span class="n">map</span>({ <span class="nv">$_</span> + <span class="mi">3</span> }, <span class="nv">@array</span>); <span class="c1"># $_ es el argumento implícito</span>

<span class="c1">## Una subrutina (`sub {}`) tiene semánticas diferentes a un</span>
<span class="c1">## bloque (`{}` or `-&gt; {}`): Un bloque no tiene &quot;contexto funcional&quot;</span>
<span class="c1">## (aunque puede tener argumentos), lo que significa que si quieres devolver</span>
<span class="c1">## algo desde un bloque, vas a returnar desde la función parental. Compara:  </span>
<span class="k">sub</span> <span class="n">is-in</span>(<span class="nv">@array</span>, <span class="nv">$elem</span>) {
  <span class="c1"># esto `devolverá` desde la subrutina `is-in`</span>
  <span class="c1"># Una vez que la condición evalúa a True, el bucle terminará</span>
  <span class="n">map</span>({ <span class="k">return</span> <span class="nb">True</span> <span class="k">if</span> <span class="nv">$_</span> == <span class="nv">$elem</span> }, <span class="nv">@array</span>);
}
<span class="k">sub</span> <span class="n">truthy-array</span>(<span class="nv">@array</span>) {
  <span class="c1"># esto producirá un array de `True` Y `False`:</span>
  <span class="c1"># (también puedes decir `anon sub` para &quot;subrutina anónima&quot;)</span>
  <span class="n">map</span>(<span class="k">sub</span> (<span class="nv">$i</span>) { <span class="k">if</span> <span class="nv">$i</span> { <span class="k">return</span> <span class="nb">True</span> } <span class="k">else</span> { <span class="k">return</span> <span class="nb">False</span> } }, <span class="nv">@array</span>);
  <span class="c1"># ^ el `return` solo devuelve desde la `sub`</span>
}

<span class="c1">## También puedes usar la &quot;whatever star&quot; para crear una función anónima</span>
<span class="c1">## (terminará con el último operador en la expresión actual)</span>
<span class="k">my</span> <span class="nv">@arraymas3</span> = <span class="n">map</span>(*+<span class="mi">3</span>, <span class="nv">@array</span>); <span class="c1"># `*+3` es lo mismo que `{ $_ + 3 }`</span>
<span class="k">my</span> <span class="nv">@arraymas3</span> = <span class="n">map</span>(*+*+<span class="mi">3</span>, <span class="nv">@array</span>); <span class="c1"># lo mismo que `-&gt; $a, $b { $a + $b + 3 }`</span>
                                     <span class="c1"># también `sub ($a, $b) { $a + $b + 3 }`</span>
<span class="nb">say</span> (*/<span class="mi">2</span>)(<span class="mi">4</span>); <span class="c1">#=&gt; 2</span>
                  <span class="c1"># Inmediatamente ejecuta la función que Whatever creó.</span>
<span class="nb">say</span> ((*+<span class="mi">3</span>)/<span class="mi">5</span>)(<span class="mi">5</span>); <span class="c1">#=&gt; 1.6</span>
                  <span class="c1"># ¡funciona hasta con los paréntesis!</span>

<span class="c1">## Pero si necesitas más que un argumento (`$_`) en un bloque</span>
<span class="c1">## (sin depender en `-&gt; {}`), también puedes usar la sintaxis implícita</span>
<span class="c1">## de argumento, `$` :</span>
<span class="n">map</span>({ <span class="nv">$^a</span> + <span class="nv">$^b</span> + <span class="mi">3</span> }, <span class="nv">@array</span>); <span class="c1"># equivalente a lo siguiente:</span>
<span class="n">map</span>(<span class="k">sub</span> (<span class="nv">$a</span>, <span class="nv">$b</span>) { <span class="nv">$a</span> + <span class="nv">$b</span> + <span class="mi">3</span> }, <span class="nv">@array</span>); <span class="c1"># (aquí con `sub`)</span>

<span class="c1">## Nota : Esos son ordernados lexicográficamente.</span>
<span class="c1"># `{ $^b / $^a }` es como `-&gt; $a, $b { $b / $a }`</span>
</pre></div>
<h3>Acerca de tipos&hellip;</h3>
<div class="highlight"><pre><span></span><span class="c1">## Raku es gradualmente tipado. Esto quiere decir que tu especifica el</span>
<span class="c1">## tipo de tus variables/argumentos/devoluciones (return), o puedes omitirlos</span>
<span class="c1">## y serán &quot;Any&quot; por defecto.</span>
<span class="c1">## Obviamente tienes acceso a algunas tipos básicos, como Int y Str.</span>
<span class="c1">## Las construcciones para declarar tipos son &quot;class&quot;, &quot;role&quot;, lo cual</span>
<span class="c1">## verás más adelante.</span>

<span class="c1">## Por ahora, examinemos &quot;subset&quot; (subconjunto).</span>
<span class="c1">## Un &quot;subset&quot; es un &quot;sub-tipo&quot; con chequeos adicionales.</span>
<span class="c1">## Por ejemplo: &quot;un número entero bien grande es un Int que es mayor que 500&quot;</span>
<span class="c1">## Puedes especificar el tipo del que creas el subconjunto (por defecto, Any),</span>
<span class="c1">## y añadir chequeos adicionales con la palabra clave &quot;where&quot; (donde):</span>
<span class="k">subset</span> <span class="n">EnteroGrande</span> <span class="nb">of</span> <span class="nb">Int</span> <span class="n">where</span> * &gt; <span class="mi">500</span>;
</pre></div>
<h3>Despacho Múltiple (Multiple Dispatch)</h3>
<div class="highlight"><pre><span></span><span class="c1">## Raku puede decidir que variante de una subrutina invocar basado en el</span>
<span class="c1">## tipo de los argumento, o precondiciones arbitrarias, como con un tipo o</span>
<span class="c1">## un `where`:</span>

<span class="c1">## con tipos</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="n">dilo</span>(<span class="nb">Int</span> <span class="nv">$n</span>) { <span class="c1"># nota la palabra clave `multi` aquí</span>
  <span class="nb">say</span> <span class="s">&quot;Número: $n&quot;</span>;
}
<span class="k">multi</span> <span class="n">dilo</span>(<span class="nb">Str</span> <span class="nv">$s</span>) { <span class="c1"># un multi es una subrutina por defecto</span>
  <span class="nb">say</span> <span class="s">&quot;Cadena de texto: $s&quot;</span>;
}
<span class="n">dilo</span>(<span class="s">&quot;azul&quot;</span>); <span class="c1"># prints &quot;Cadena de texto: azul&quot;</span>
<span class="n">dilo</span>(<span class="nb">True</span>); <span class="c1"># falla al *tiempo de compilación* con</span>
            <span class="c1"># (invocar &#39;dilo&#39; nunca funcionará con argumentos de tipos ...&quot;)</span>
<span class="c1">## con precondición arbitraria (¿recuerdas los subconjuntos?):</span>
<span class="k">multi</span> <span class="n">es-grande</span>(<span class="nb">Int</span> <span class="nv">$n</span> <span class="n">where</span> * &gt; <span class="mi">50</span>) { <span class="s">&quot;¡Sí!&quot;</span> } <span class="c1"># usando una clausura</span>
<span class="k">multi</span> <span class="n">es-grande</span>(<span class="nb">Int</span> $ <span class="n">where</span> <span class="mi">10</span><span class="o">..</span><span class="mi">50</span>) { <span class="s">&quot;Tal vez.&quot;</span> } <span class="c1"># Usando coincidencia inteligente</span>
                                              <span class="c1"># (podrías usar un regexp, etc)</span>
<span class="k">multi</span> <span class="n">es-grande</span>(<span class="nb">Int</span> $) { <span class="s">&quot;No&quot;</span> }

<span class="k">subset</span> <span class="n">Par</span> <span class="nb">of</span> <span class="nb">Int</span> <span class="n">where</span> * %% <span class="mi">2</span>;

<span class="k">multi</span> <span class="n">inpar-o-par</span>(<span class="n">Par</span>) { <span class="s">&quot;Par&quot;</span> } <span class="c1"># El caso principal usando el tipo.</span>
                                   <span class="c1"># No nombramos los argumentos,</span>
<span class="k">multi</span> <span class="n">inpar-o-par</span>($) { <span class="s">&quot;Inpar&quot;</span> } <span class="c1"># &quot;else&quot;</span>

<span class="c1">## ¡Podrías despachar basado en la presencia de argumentos posicionales!</span>
<span class="k">multi</span> <span class="n">sin_ti-o-contigo</span>(:<span class="nv">$with</span>!) { <span class="c1"># Necesitas hacerlo mandatorio</span>
                                  <span class="c1"># para despachar en contra del argumento.</span>
  <span class="nb">say</span> <span class="s">&quot;¡Puedo vivir! Actualmente, no puedo.&quot;</span>;
}
<span class="k">multi</span> <span class="n">sin_ti-o-contigo</span> {
  <span class="nb">say</span> <span class="s">&quot;Definitivamente no puedo vivir.&quot;</span>;
}
<span class="c1">## Esto es muy útil para muchos propósitos, como subrutinas `MAIN` (de las</span>
<span class="c1">## cuales hablaremos luego), y hasta el mismo lenguaje la está usando</span>
<span class="c1">## en muchos lugares.</span>
<span class="c1">##</span>
<span class="c1">## - `is`, por ejemplo, es actualmente un `multi sub` llamado</span>
<span class="c1">## `trait_mod:&lt;is&gt;`.</span>
<span class="c1">## - `is rw`, es simplemente un despacho a una función con esta signatura:</span>
<span class="c1">## sub trait_mod:&lt;is&gt;(Routine $r, :$rw!) {}</span>
<span class="c1">##</span>
<span class="c1">## (¡lo pusimos en un comentario dado que ejecutando esto sería una terrible</span>
<span class="c1">## idea!)</span>
</pre></div>
<h2>Ámbito (Scoping)</h2>
<div class="highlight"><pre><span></span><span class="c1">## En Raku, a diferencia de otros lenguajes de scripting, (tales como</span>
<span class="c1">## (Python, Ruby, PHP), debes declarar tus variables antes de usarlas. El</span>
<span class="c1">## declarador `my`, del cual aprendiste anteriormente, usa &quot;ámbito léxical&quot;.</span>
<span class="c1">## Hay otros declaradores (`our`, `state`, ..., ) los cuales veremos luego.</span>
<span class="c1">## Esto se llama &quot;ámbito léxico&quot;, donde en los bloques internos,</span>
<span class="c1">## puedes acceder variables de los bloques externos.</span>
<span class="k">my</span> <span class="nv">$archivo-en-ámbito</span> = <span class="s">&#39;Foo&#39;</span>;
<span class="k">sub</span> <span class="n">externo</span> {
  <span class="k">my</span> <span class="nv">$ámbito-externo</span> = <span class="s">&#39;Bar&#39;</span>;
  <span class="k">sub</span> <span class="n">interno</span> {
    <span class="nb">say</span> <span class="s">&quot;$archivo-en-ámbito $ámbito-externo&quot;</span>;
  }
  <span class="nv">&amp;interno</span>; <span class="c1"># devuelve la función</span>
}
<span class="n">outer</span>()(); <span class="c1">#=&gt; &#39;Foo Bar&#39;</span>

<span class="c1">## Como puedes ver, `$archivo-en-ámbito` y `$ámbito-externo`</span>
<span class="c1">## fueron capturados. Pero si intentaramos usar `$bar` fuera de `foo`,</span>
<span class="c1">## la variable estaría indefinida (y obtendrías un error al tiempo de</span>
<span class="c1">## compilación).</span>
</pre></div>
<h2>Twigils</h2>
<div class="highlight"><pre><span></span><span class="c1">## Hay muchos `twigils` especiales (sigilos compuestos) en Raku.</span>
<span class="c1">## Los twigils definen el ámbito de las variables.</span>
<span class="c1">## Los twigils * y ? funcionan con variables regulares:</span>
<span class="c1">## * Variable dinámica</span>
<span class="c1">## ? Variable al tiempo de compilación</span>
<span class="c1">## Los twigils ! y . son usados con los objetos de Raku:</span>
<span class="c1">## ! Atributo (miembro de la clase)</span>
<span class="c1">## . Método (no una variable realmente)</span>

<span class="c1">## El twigil `*`: Ámbito dinámico</span>
<span class="c1">## Estas variables usan el twigil `*` para marcar variables con ámbito</span>
<span class="c1">## dinámico. Variables con ámbito dinámico son buscadas a través del</span>
<span class="c1">## invocador, no a través del ámbito externo.</span>

<span class="k">my</span> <span class="vg">$*ambito_din_1</span> = <span class="mi">1</span>;
<span class="k">my</span> <span class="vg">$*ambito_din_2</span> = <span class="mi">10</span>;

<span class="k">sub</span> <span class="n">di_ambito</span> {
  <span class="nb">say</span> <span class="s">&quot;$*ambito_din_1 $*ambito_din_2&quot;</span>;
}

<span class="k">sub</span> <span class="n">invoca_a_di_ambito</span> {
  <span class="k">my</span> <span class="vg">$*ambito_din_1</span> = <span class="mi">25</span>; <span class="c1"># Define a $*ambito_din_1 solo en esta subrutina.</span>
  <span class="vg">$*ambito_din_2</span> = <span class="mi">100</span>; <span class="c1"># Cambiará el valor de la variable en ámbito.</span>
  <span class="n">di_ambito</span>(); <span class="c1">#=&gt; 25 100 $*ambito_din_1 y 2 serán buscadas en la invocación.</span>
             <span class="c1"># Se usa el valor de $*ambito_din_1 desde el ámbito léxico de esta</span>
             <span class="c1"># subrutina aunque los bloques no están anidados (están anidados por</span>
             <span class="c1"># invocación).</span>
}
<span class="n">di_ambito</span>(); <span class="c1">#=&gt; 1 10</span>
<span class="n">invoca_a_di_ambito</span>(); <span class="c1">#=&gt; 25 100</span>
                <span class="c1"># Se usa a $*ambito_din_1 como fue definida en invoca_a_di_ambito</span>
                <span class="c1"># aunque la estamos invocando desde afuera.</span>
<span class="n">di_ambito</span>(); <span class="c1">#=&gt; 1 100 Cambiamos el valor de $*ambito_din_2 en invoca_a_di_ambito</span>
             <span class="c1">#         por lo tanto su valor a cambiado.</span>
</pre></div>
<h2>Modelo de Objeto</h2>
<div class="highlight"><pre><span></span><span class="c1">## Para invocar a un método en un objeto, agrega un punto seguido por el</span>
<span class="c1">## nombre del objeto:</span>
<span class="c1">## =&gt; $object.method</span>
<span class="c1">## Las classes son declaradas usando la palabra clave `class`. Los atributos</span>
<span class="c1">## son declarados con la palabra clave `has`, y los métodos con `method`.</span>
<span class="c1">## Cada atributo que es privado usa el twigil `!`. Por ejemplo: `$!attr`.</span>
<span class="c1">## Atributos públicos inmutables usan el twigil `.` (los puedes hacer</span>
<span class="c1">## mutables con `is rw`).</span>
<span class="c1">## La manera más fácil de recordar el twigil `$.` is comparándolo</span>
<span class="c1">## con como los métodos son llamados.</span>

<span class="c1">## El modelo de objeto de Raku (&quot;SixModel&quot;) es muy flexible, y te permite</span>
<span class="c1">## agregar métodos dinámicamente, cambiar la semántica, etc ...</span>
<span class="c1">## (no hablaremos de todo esto aquí. Por lo tanto, refiérete a:</span>
<span class="c1">## https://docs.raku.org/language/objects.html).</span>

<span class="k">class</span> <span class="n">Clase-Atrib</span> {
  <span class="k">has</span> <span class="nv">$.atrib</span>; <span class="c1"># `$.atrib` es inmutable.</span>
               <span class="c1"># Desde dentro de la clase, usa `$!atrib` para modificarlo.</span>
  <span class="k">has</span> <span class="nv">$.otro-atrib</span> <span class="k">is</span> <span class="k">rw</span>; <span class="c1"># Puedes marcar un atributo como público con `rw`.</span>
  <span class="k">has</span> <span class="nb">Int</span> <span class="nv">$!atrib-privado</span> = <span class="mi">10</span>;

  <span class="k">method</span> <span class="n">devolver-valor</span> {
    <span class="nv">$.atrib</span> + <span class="nv">$!atrib-privado</span>;
  }

  <span class="k">method</span> <span class="n">asignar-valor</span>(<span class="nv">$param</span>) { <span class="c1"># Métodos pueden tomar parámetros.</span>
    <span class="nv">$!attrib</span> = <span class="nv">$param</span>;   <span class="c1"># Esto funciona porque `$!` es siempre mutable.</span>
    <span class="c1"># $.attrib = $param; # Incorrecto: No puedes usar la versión inmutable `$.`.</span>

    <span class="nv">$.otro-atrib</span> = <span class="mi">5</span>; <span class="c1"># Esto funciona porque `$.otro-atrib` es `rw`.</span>
  }

  <span class="k">method</span> !<span class="n">metodo-privado</span> {
    <span class="nb">say</span> <span class="s">&quot;Este método es privado para la clase !&quot;</span>;
  }
};

<span class="c1">## Crear una nueva instancia de Clase-Atrib con $.atrib asignado con 5:</span>
<span class="c1">## Nota: No puedes asignarle un valor a atrib-privado desde aquí (más de</span>
<span class="c1">## esto adelante).</span>
<span class="k">my</span> <span class="nv">$class-obj</span> = <span class="n">Clase-Atrib</span>.<span class="nb">new</span>(<span class="n">atrib</span> =&gt; <span class="mi">5</span>);
<span class="nb">say</span> <span class="nv">$class-obj</span>.<span class="n">devolver-valor</span>; <span class="c1">#=&gt; 5</span>
<span class="c1"># $class-obj.atrib = 5; # Esto falla porque `has $.atrib` es inmutable</span>
<span class="nv">$class-obj</span>.<span class="n">otro-atrib</span> = <span class="mi">10</span>; <span class="c1"># En cambio, esto funciona porque el atributo</span>
                            <span class="c1"># público es mutable (`rw`).</span>
</pre></div>
<h3>Herencia de Objeto</h3>
<div class="highlight"><pre><span></span><span class="c1">## Raku también tiene herencia (junto a herencia múltiple)</span>
<span class="c1">## Mientras los métodos declarados con `method` son heredados, aquellos</span>
<span class="c1">## declarados con `submethod` no lo son.</span>
<span class="c1">## Submétodos son útiles para la construcción y destrucción de tareas,</span>
<span class="c1">## tales como BUILD, o métodos que deben ser anulados por subtipos.</span>
<span class="c1">## Aprenderemos acerca de BUILD más adelante.</span>

<span class="k">class</span> <span class="n">Padre</span> {
  <span class="k">has</span> <span class="nv">$.edad</span>;
  <span class="k">has</span> <span class="nv">$.nombre</span>;
  <span class="c1"># Este submétodo no será heredado por la clase Niño.</span>
  <span class="k">submethod</span> <span class="n">color-favorito</span> {
    <span class="nb">say</span> <span class="s">&quot;Mi color favorito es Azul&quot;</span>;
  }
  <span class="c1"># Este método será heredado</span>
  <span class="k">method</span> <span class="n">hablar</span> { <span class="nb">say</span> <span class="s">&quot;Hola, mi nombre es $!nombre&quot;</span> }
}
<span class="c1"># Herencia usa la palabra clave `is`</span>
<span class="k">class</span> <span class="n">Niño</span> <span class="k">is</span> <span class="n">Padre</span> {
  <span class="k">method</span> <span class="n">hablar</span> { <span class="nb">say</span> <span class="s">&quot;Goo goo ga ga&quot;</span> }
  <span class="c1"># Este método opaca el método `hablar` de Padre.</span>
  <span class="c1"># Este niño no ha aprendido a hablar todavía.</span>
}
<span class="k">my</span> <span class="n">Padre</span> <span class="nv">$Richard</span> .= <span class="nb">new</span>(<span class="n">edad</span> =&gt; <span class="mi">40</span>, <span class="n">nombre</span> =&gt; <span class="s">&#39;Richard&#39;</span>);
<span class="nv">$Richard</span>.<span class="n">color-favorito</span>; <span class="c1">#=&gt; &quot;Mi color favorito es Azul&quot;</span>
<span class="nv">$Richard</span>.<span class="n">hablar</span>; <span class="c1">#=&gt; &quot;Hola, mi nombre es Richard&quot;</span>
<span class="c1">## $Richard es capaz de acceder el submétodo; él sabe como decir su nombre.</span>

<span class="k">my</span> <span class="n">Niño</span> <span class="nv">$Madison</span> .= <span class="nb">new</span>(<span class="n">edad</span> =&gt; <span class="mi">1</span>, <span class="n">nombre</span> =&gt; <span class="s">&#39;Madison&#39;</span>);
<span class="nv">$Madison</span>.<span class="n">hablar</span>; <span class="c1"># imprime &quot;Goo goo ga ga&quot; dado que el método fue cambiado</span>
                 <span class="c1"># en la clase Niño.</span>
<span class="c1"># $Madison.color-favorito # no funciona porque no es heredado</span>

<span class="c1">## Cuando se usa `my T $var` (donde `T` es el nombre de la clase), `$var`</span>
<span class="c1">## inicia con `T` en si misma, por lo tanto puedes invocar `new` en `$var`.</span>
<span class="c1">## (`.=` es sólo la invocación por punto y el operador de asignación:</span>
<span class="c1">## `$a .= b` es lo mismo que `$a = $a.b`)</span>
<span class="c1">## Por ejemplo, la instancia $Richard pudo también haber sido declarada así:</span>
<span class="c1">## my $Richard = Padre.new(edad =&gt; 40, nombre =&gt; &#39;Richard&#39;);</span>

<span class="c1">## También observa que `BUILD` (el método invocado dentro de `new`)</span>
<span class="c1">## asignará propiedades de la clase padre, por lo que puedes pasar</span>
<span class="c1">## `val =&gt; 5`.</span>
</pre></div>
<h3>Roles, o Mixins</h3>
<div class="highlight"><pre><span></span><span class="c1">## Roles son suportados también (comúnmente llamados Mixins en otros</span>
<span class="c1">## lenguajes)</span>
<span class="k">role</span> <span class="n">PrintableVal</span> {
  <span class="k">has</span> <span class="nv">$!counter</span> = <span class="mi">0</span>;
  <span class="k">method</span> <span class="nb">print</span> {
    <span class="nb">say</span> <span class="nv">$.val</span>;
  }
}

<span class="c1">## Se &quot;importa&quot; un mixin (un &quot;role&quot;) con &quot;does&quot;:</span>
<span class="k">class</span> <span class="n">Item</span> <span class="k">does</span> <span class="n">PrintableVal</span> {
  <span class="k">has</span> <span class="nv">$.val</span>;

  <span class="c1">## Cuando se utiliza `does`, un `rol` se mezcla en al clase literalmente:</span>
  <span class="c1">## los métodos y atributos se ponen juntos, lo que significa que una clase</span>
  <span class="c1">## puede acceder los métodos y atributos privados de su rol (pero no lo inverso!):</span>
  <span class="k">method</span> <span class="n">access</span> {
    <span class="nb">say</span> <span class="nv">$!counter</span>++;
  }

  <span class="c1">## Sin embargo, esto:</span>
  <span class="c1">## method print {}</span>
  <span class="c1">## es SÓLO válido cuando `print` no es una `multi` con el mismo dispacho.</span>
  <span class="c1">## (esto significa que una clase padre puede opacar una `multi print() {}`</span>
  <span class="c1">## de su clase hijo/a, pero es un error sin un rol lo hace)</span>

  <span class="c1">## NOTA: Puedes usar un rol como una clase (con `is ROLE`). En este caso,</span>
  <span class="c1">##       métodos serán opacados, dado que el compilador considerará `ROLE`</span>
  <span class="c1">##       como una clase.</span>
}
</pre></div>
<h2>Excepciones</h2>
<div class="highlight"><pre><span></span><span class="c1">## Excepciones están construidas al tope de las clases, en el paquete</span>
<span class="c1">## `X` (como `X::IO`).</span>
<span class="c1">## En Raku, excepciones son lanzadas automáticamente.</span>
<span class="nb">open</span> <span class="s">&#39;foo&#39;</span>; <span class="c1">#=&gt; Failed to open file foo: no such file or directory</span>
<span class="c1">## También imprimirá la línea donde el error fue lanzado y otra información</span>
<span class="c1">## concerniente al error.</span>

<span class="c1">## Puedes lanzar una excepción usando `die`:</span>
<span class="nb">die</span> <span class="s">&#39;Error!&#39;</span>; <span class="c1">#=&gt; Error!</span>

<span class="c1">## O más explícitamente:</span>
<span class="nb">die</span> <span class="o">X</span>::<span class="n">AdHoc</span>.<span class="nb">new</span>(<span class="nb">payload</span> =&gt; <span class="s">&#39;Error!&#39;</span>);

<span class="c1">## En Raku, `orelse` es similar al operador `or`, excepto que solamente</span>
<span class="c1">## coincide con variables indefinidas, en cambio de cualquier cosa</span>
<span class="c1">## que evalúa a falso.</span>
<span class="c1">## Valores indefinidos incluyen: `Nil`, `Mu` y `Failure`, también como</span>
<span class="c1">## `Int`, `Str` y otros tipos que no han sido inicializados a ningún valor</span>
<span class="c1">## todavía.</span>
<span class="c1">## Puedes chequear si algo está definido o no usando el método defined:</span>
<span class="k">my</span> <span class="nv">$no-inicializada</span>;
<span class="nb">say</span> <span class="nv">$no-inicializada</span>.<span class="nb">defined</span>; <span class="c1">#=&gt; False</span>
<span class="c1">## Al usar `orelse`, se desarmará la excepción y creará un alias de dicho</span>
<span class="c1">## fallo en $_</span>
<span class="c1">## Esto evitará que sea automáticamente manejado e imprima una marejada de</span>
<span class="c1">## mensajes de errores en la pantalla.</span>
<span class="c1">## Podemos usar el método de excepción en $_ para acceder la excepción:</span>
<span class="nb">open</span> <span class="s">&#39;foo&#39;</span> <span class="o">orelse</span> <span class="nb">say</span> <span class="s">&quot;Algo pasó {.exception}&quot;</span>;

<span class="c1">## Esto también funciona:</span>
<span class="nb">open</span> <span class="s">&#39;foo&#39;</span> <span class="o">orelse</span> <span class="nb">say</span> <span class="s">&quot;Algo pasó $_&quot;</span>; <span class="c1">#=&gt; Algo pasó</span>
              <span class="c1">#=&gt;  Failed to open file foo: no such file or directory</span>
<span class="c1">## Ambos ejemplos anteriores funcionan pero en caso de que consigamos un</span>
<span class="c1">## objeto desde el lado izquierdo que no es un fallo, probablemente</span>
<span class="c1">## obtendremos una advertencia. Más abajo vemos como usar `try` y `CATCH`</span>
<span class="c1">## para ser más expecíficos con las excepciones que capturamos.</span>
</pre></div>
<h3>Usando <code>try</code> y <code>CATCH</code></h3>
<div class="highlight"><pre><span></span><span class="c1">## Al usar `try` y `CATCH`, puedes contener y manejar excepciones sin</span>
<span class="c1">## interrumpir el resto del programa. `try` asignará la última excepción</span>
<span class="c1">## a la variable especial `$!`.</span>
<span class="c1">## Nota: Esto no tiene ninguna relación con las variables $!.</span>

<span class="k">try</span> <span class="nb">open</span> <span class="s">&#39;foo&#39;</span>;
<span class="nb">say</span> <span class="s">&quot;Bueno, lo intenté! $!&quot;</span> <span class="k">if</span> <span class="nb">defined</span> <span class="vg">$!</span>; <span class="c1">#=&gt; Bueno, lo intenté! Failed to open file</span>
                                       <span class="c1">#foo: no such file or directory</span>
<span class="c1">## Ahora, ¿qué debemos hacer si queremos más control sobre la excepción?</span>
<span class="c1">## A diferencia de otros lenguajes, en Raku se pone el bloque `CATCH`</span>
<span class="c1">## *dentro* del bloque a intentar (`try`). Similarmente como $_ fue asignada</span>
<span class="c1">## cuando &#39;disarmamos&#39; la excepción con `orelse`, también usamos $_ en el</span>
<span class="c1">## bloque CATCH.</span>
<span class="c1">## Nota: ($! es solo asignada *después* del bloque `try`)</span>
<span class="c1">## Por defecto, un bloque `try` tiene un bloque `CATCH` que captura</span>
<span class="c1">## cualquier excepción (`CATCH { default {} }`).</span>

<span class="k">try</span> { <span class="k">my</span> <span class="nv">$a</span> = (<span class="mi">0</span> %% <span class="mi">0</span>);  <span class="k">CATCH</span> { <span class="nb">say</span> <span class="s">&quot;Algo pasó: $_&quot;</span> } }
 <span class="c1">#=&gt; Algo pasó: Attempt to divide by zero using infix:&lt;%%&gt;</span>

<span class="c1">## Puedes redefinir lo anterior usando `when` y (`default`)</span>
<span class="c1">## para manejar las excepciones que desees:</span>
<span class="k">try</span> {
  <span class="nb">open</span> <span class="s">&#39;foo&#39;</span>;
  <span class="k">CATCH</span> {     <span class="c1"># En el bloque `CATCH`, la excepción es asignada a $_</span>
    <span class="k">when</span> <span class="o">X</span>::<span class="n">AdHoc</span> { <span class="nb">say</span> <span class="s">&quot;Error: $_&quot;</span> }
     <span class="c1">#=&gt;Error: Failed to open file /dir/foo: no such file or directory</span>

    <span class="c1">## Cualquier otra excepción será levantada de nuevo, dado que no</span>
    <span class="c1">## tenemos un `default`.</span>
    <span class="c1">## Básicamente, si un `when`</span>
    <span class="c1">## Basically, if a `when` matches (or there&#39;s a `default`) marks the</span>
    <span class="c1">## exception as</span>
    <span class="c1">## &quot;handled&quot; so that it doesn&#39;t get re-thrown from the `CATCH`.</span>
    <span class="c1">## You still can re-throw the exception (see below) by hand.</span>
  }
}

<span class="c1">## En Raku, excepciones poseen ciertas sutilezas. Algunas</span>
<span class="c1">## subrutinas en Raku devuelven un `Failure`, el cual es un tipo de</span>
<span class="c1">## &quot;excepción no levantada&quot;. Ellas no son levantadas hasta que tu intentas</span>
<span class="c1">## mirar a sus contenidos, a menos que invoques `.Bool`/`.defined` sobre</span>
<span class="c1">## ellas - entonces, son manejadas.</span>
<span class="c1">## (el método `.handled` es `rw`, por lo que puedes marcarlo como `False`</span>
<span class="c1">## por ti mismo)</span>
<span class="c1">## Puedes levantar un `Failure` usando `fail`. Nota que si el pragma</span>
<span class="c1">## `use fatal` estás siendo utilizado, `fail` levantará una excepión (como</span>
<span class="c1">## `die`).</span>
<span class="nb">fail</span> <span class="s">&quot;foo&quot;</span>; <span class="c1"># No estamos intentando acceder el valor, por lo tanto no problema.</span>
<span class="k">try</span> {
  <span class="nb">fail</span> <span class="s">&quot;foo&quot;</span>;
  <span class="k">CATCH</span> {
    <span class="k">default</span> { <span class="nb">say</span> <span class="s">&quot;Levantó un error porque intentamos acceder el valor del fallo!&quot;</span> }
  }
}

<span class="c1">## También hay otro tipo de excepción: Excepciones de control.</span>
<span class="c1">## Esas son excepciones &quot;buenas&quot;, las cuales suceden cuando cambias el flujo</span>
<span class="c1">## de tu programa, usando operadores como `return`, `next` or `last`.</span>
<span class="c1">## Puedes capturarlas con `CONTROL` (no lista un 100% en Rakudo todavía).</span>
</pre></div>
<h2>Paquetes</h2>
<div class="highlight"><pre><span></span><span class="c1">## Paquetes son una manera de reusar código. Paquetes son como</span>
<span class="c1">## &quot;espacio de nombres&quot; (namespaces en inglés), y cualquier elemento del</span>
<span class="c1">## modelo seis (`module`, `role`, `class`, `grammar`, `subset` y `enum`)</span>
<span class="c1">## son paquetes por ellos mismos. (Los paquetes son como el mínimo común</span>
<span class="c1">## denominador)</span>
<span class="c1">## Los paquetes son importantes - especialmente dado que Perl es bien</span>
<span class="c1">## reconocido por CPAN, the Comprehensive Perl Archive Nertwork.</span>

<span class="c1">## Puedes usar un módulo (traer sus declaraciones al ámbito) con `use`</span>
<span class="k">use</span> <span class="n">JSON::Tiny</span>; <span class="c1"># si intalaste Rakudo* o Panda, tendrás este módulo</span>
<span class="nb">say</span> <span class="n">from-json</span>(<span class="s">&#39;[1]&#39;</span>).<span class="nb">perl</span>; <span class="c1">#=&gt; [1]</span>

<span class="c1">## A diferencia de Perl, no deberías declarar paquetes usando</span>
<span class="c1">## la palabra clave `package`. En vez, usa `class Nombre::Paquete::Aquí;`</span>
<span class="c1">## para declarar una clase, o si solamente quieres exportar</span>
<span class="c1">## variables/subrutinas, puedes usar `module`.</span>

<span class="k">module</span> <span class="n">Hello::World</span> { <span class="c1"># forma de llaves</span>
                      <span class="c1"># Si `Hello` no existe todavía, solamente será una cola (&quot;stub&quot;),</span>
                      <span class="c1">#  que puede ser redeclarada más tarde.</span>
  <span class="c1"># ... declaraciones aquí ...</span>
}
<span class="k">unit</span> <span class="k">module</span> <span class="n">Parse::Text</span>; <span class="c1"># forma de ámbito de archivo</span>

<span class="k">grammar</span> <span class="n">Parse::Text::Grammar</span> { <span class="c1"># Una gramática (grammar en inglés) es un paquete,</span>
                               <span class="c1"># en el cual puedes usar `use`</span>
}                    <span class="c1"># Aprenderás más acerca de gramáticas en la sección de regex</span>

<span class="c1">## Como se dijo anteriormente, cualquier parte del modelo seis es también un</span>
<span class="c1">## paquete. Dado que `JSON::Tiny` usa su propia clase `JSON::Tiny::Actions`,</span>
<span class="c1">## tu puedes usarla de la manera siguiente:</span>
<span class="k">my</span> <span class="nv">$acciones</span> = <span class="n">JSON::Tiny::Actions</span>.<span class="nb">new</span>;

<span class="c1">## Veremos como exportar variables y subrutinas en la siguiente parte:</span>
</pre></div>
<h2>Declaradores</h2>
<div class="highlight"><pre><span></span><span class="c1">## En Raku, tu obtienes diferentes comportamientos basado en como declaras</span>
<span class="c1">## una variable.</span>
<span class="c1">## Ya has visto `my` y `has`, ahora exploraremos el resto.</span>

<span class="c1">## * las declaraciones `our` ocurren al tiempo `INIT` (ve &quot;Phasers&quot; más abajo)</span>
<span class="c1">## Es como `my`, pero también crea una variable paquete.</span>
<span class="c1">## (Todas las cosas relacionadas con paquetes (`class`, `role`, etc) son</span>
<span class="c1">## `our` por defecto)</span>
<span class="k">module</span> <span class="n">Var::Incrementar</span> {
  <span class="k">our</span> <span class="nv">$nuestra-var</span> = <span class="mi">1</span>; <span class="c1"># Nota: No puedes colocar una restricción de tipo</span>
  <span class="k">my</span> <span class="nv">$mi-var</span> = <span class="mi">22</span>;      <span class="c1"># como Int (por ejemplo) en una variable `our`.</span>
  <span class="k">our</span> <span class="k">sub</span> <span class="n">Inc</span> {

    <span class="k">our</span> <span class="k">sub</span> <span class="n">disponible</span> { <span class="c1"># Si tratas de hacer subrutinas internas `our`...</span>
                        <span class="c1"># Mejor que sepas lo que haces (No lo haga!).</span>
      <span class="nb">say</span> <span class="s">&quot;No hagas eso. En serio. Estás jugando con fuego y te quemarás.&quot;</span>;
    }

    <span class="k">my</span> <span class="k">sub</span> <span class="n">no-disponible</span> { <span class="c1"># `my sub` es por defecto</span>
      <span class="nb">say</span> <span class="s">&quot;No puedes acceder aquí desde fuera. Soy &#39;my&#39;!&quot;</span>;
    }
    <span class="nb">say</span> ++<span class="nv">$nuestra-var</span>; <span class="c1"># Incrementa la variable paquete y muestra su valor</span>
  }

}
<span class="nb">say</span> <span class="nv">$Var::Incrementar::nuestra-var</span>; <span class="c1">#=&gt; 1 Esto funciona</span>
<span class="nb">say</span> <span class="nv">$Var::Incrementar::mi-var</span>; <span class="c1">#=&gt; (Any) Esto no funcionará.</span>

<span class="n">Var::Incrementar::Inc</span>; <span class="c1">#=&gt; 2</span>
<span class="n">Var::Incrementar::Inc</span>; <span class="c1">#=&gt; 3 # Nota como el valor de $nuestra-var fue</span>
                            <span class="c1"># retenido</span>
<span class="n">Var::Incrementar::no-disponible</span>; <span class="c1">#=&gt; Could not find symbol &#39;&amp;no-disponible&#39;</span>

<span class="c1">## * `constant` (ocurre al tiempo `BEGIN`)</span>
<span class="c1">## Puedes usar la palabra clave `constant` para declarar una</span>
<span class="c1">## variable/símbolo al tiempo de compilación:</span>
<span class="k">constant</span> <span class="n">Pi</span> = <span class="mf">3.14</span>;
<span class="k">constant</span> <span class="nv">$var</span> = <span class="mi">1</span>;

<span class="c1">## Y por si te estás preguntando, sí, también puede contener listas infinitas.</span>
<span class="k">constant</span> <span class="n">porque-no</span> = <span class="mi">5</span>, <span class="mi">15</span> ... *;
<span class="nb">say</span> <span class="n">porque-no</span>[^<span class="mi">5</span>]; <span class="c1">#=&gt; 5 15 25 35 45</span>

<span class="c1">## * `state` (ocurre al tiempo de ejecución, pero una sola vez)</span>
<span class="c1">## Variables &quot;states&quot; son solo inicializadas una vez.</span>
<span class="c1">## (ellas existen en otros lenguaje como `static` en C)</span>
<span class="k">sub</span> <span class="n">aleatorio-fijo</span> {
  <span class="k">state</span> <span class="nv">$valor</span> = <span class="nb">rand</span>;
  <span class="nb">say</span> <span class="nv">$valor</span>;
}
<span class="n">aleatorio-fijo</span> <span class="k">for</span> ^<span class="mi">10</span>; <span class="c1"># imprimirá el mismo número 10 veces</span>

<span class="c1">## Nota, sin embargo, que ellas existen separadamente en diferentes contextos.</span>
<span class="c1">## Si declaras una función con un `state` dentro de un bucle, recreará la</span>
<span class="c1">## variable por cada iteración del bucle. Observa:</span>
<span class="k">for</span> ^<span class="mi">5</span> -&gt; <span class="nv">$a</span> {
  <span class="k">sub</span> <span class="n">foo</span> {
    <span class="k">state</span> <span class="nv">$valor</span> = <span class="nb">rand</span>; <span class="c1"># Esto imprimirá un valor diferente</span>
                         <span class="c1"># por cada valor de `$a`</span>
  }
  <span class="k">for</span> ^<span class="mi">5</span> -&gt; <span class="nv">$b</span> {
    <span class="nb">say</span> <span class="n">foo</span>; <span class="c1"># Esto imprimirá el mismo valor 5 veces, pero sólo 5.</span>
             <span class="c1"># La siguiente iteración ejecutará `rand` nuevamente.</span>
  }
}
</pre></div>
<h2>Phasers</h2>
<div class="highlight"><pre><span></span><span class="c1">## Un phaser en Raku es un bloque que ocurre a determinados puntos de tiempo</span>
<span class="c1">## en tu programa. Se les llama phaser porque marca un cambio en la fase de</span>
<span class="c1">## de tu programa. Por ejemplo, cuando el programa es compilado, un bucle</span>
<span class="c1">## for se ejecuta, dejas un bloque, o una excepción se levanta.</span>
<span class="c1">## (¡`CATCH` es actualmente un phaser!)</span>
<span class="c1">## Algunos de ellos pueden ser utilizados por sus valores devueltos, otros</span>
<span class="c1">## no pueden (aquellos que tiene un &quot;[*]&quot; al inicio de su texto de</span>
<span class="c1">## explicación).</span>
<span class="c1">## ¡Tomemos una mirada!</span>

<span class="c1">## * Phasers al tiempo de compilación</span>
<span class="k">BEGIN</span> { <span class="nb">say</span> <span class="s">&quot;[*] Se ejecuta al tiempo de compilación, &quot;</span> ~
            <span class="s">&quot;tan pronto como sea posible, una sola vez&quot;</span> }
<span class="k">CHECK</span> { <span class="nb">say</span> <span class="s">&quot;[*] Se ejecuta al tiempo de compilación, &quot;</span> ~
            <span class="s">&quot;tan tarde como sea posible, una sola vez&quot;</span> }

<span class="c1">## * Phasers al tiempo de ejecución</span>
<span class="k">INIT</span> { <span class="nb">say</span> <span class="s">&quot;[*] Se ejecuta al tiempo de ejecución, &quot;</span> ~
           <span class="s">&quot;tan pronto como sea posible, una sola vez&quot;</span> }
<span class="k">END</span> { <span class="nb">say</span> <span class="s">&quot;Se ejecuta al tiempo de ejecución, &quot;</span> ~
          <span class="s">&quot;tan tarde como sea posible, una sola vez&quot;</span> }

<span class="c1">## * Phasers de bloques</span>
<span class="k">ENTER</span> { <span class="nb">say</span> <span class="s">&quot;[*] Se ejecuta cada vez que entra en un bloque, &quot;</span> ~
            <span class="s">&quot;se repite en bloques de bucle&quot;</span> }
<span class="k">LEAVE</span> { <span class="nb">say</span> <span class="s">&quot;Se ejecuta cada vez que abandona un bloque, incluyendo &quot;</span> ~
            <span class="s">&quot;cuando una excepción ocurre. Se repite en bloques de bucle&quot;</span>}

<span class="k">PRE</span> {
    <span class="nb">say</span> <span class="s">&quot;Impone una precondición a cada entrada de un bloque, &quot;</span> ~
        <span class="s">&quot;antes que ENTER (especialmente útil para bucles)&quot;</span>;
    <span class="nb">say</span> <span class="s">&quot;Si este bloque no returna un valor truthy, &quot;</span> ~
        <span class="s">&quot;una excepción del tipo X::Phaser::PrePost será levantada.&quot;</span>;
}

<span class="c1">## Ejemplos:</span>
<span class="k">for</span> <span class="mi">0</span><span class="o">..</span><span class="mi">2</span> {
    <span class="k">PRE</span> { <span class="nv">$_</span> &gt; <span class="mi">1</span> } <span class="c1"># Esto fallará con un &quot;Precondition failed&quot;</span>
}

<span class="k">POST</span> {
    <span class="nb">say</span> <span class="s">&quot;Impone una postcondAsserts a poscondición a la salida de un bloque, &quot;</span> ~
        <span class="s">&quot;después de LEAVE (especialmente útil para bucles)&quot;</span>;
    <span class="nb">say</span> <span class="s">&quot;Si este bloque no returna un valor truthy, &quot;</span> ~
        <span class="s">&quot;una excepción del tipo X::Phaser::PrePost será levantada, como con PRE.&quot;</span>;
}
<span class="k">for</span> <span class="mi">0</span><span class="o">..</span><span class="mi">2</span> {
    <span class="k">POST</span> { <span class="nv">$_</span> &lt; <span class="mi">2</span> } <span class="c1"># Esto fallará con un &quot;Postcondition failed&quot;</span>
}

<span class="c1">## * Phasers de bloques/excepciones</span>
<span class="k">sub</span> {
    <span class="k">KEEP</span> { <span class="nb">say</span> <span class="s">&quot;Se ejecuta cuando sales de un bloque exitosamente</span>
<span class="s">                (sin lanzar un excepción)&quot;</span> }
    <span class="k">UNDO</span> { <span class="nb">say</span> <span class="s">&quot;Se ejecuta cuando sale de bloque sin éxito</span>
<span class="s">                (al lanzar una excepción)&quot;</span> }
}

<span class="c1">## * Phasers de bucle</span>
<span class="k">for</span> ^<span class="mi">5</span> {
  <span class="k">FIRST</span> { <span class="nb">say</span> <span class="s">&quot;[*] La primera vez que un bucle se ejecuta, antes que ENTER&quot;</span> }
  <span class="k">NEXT</span> { <span class="nb">say</span> <span class="s">&quot;Al tiempo de la continuación del bucle, antes que LEAVE&quot;</span> }
  <span class="k">LAST</span> { <span class="nb">say</span> <span class="s">&quot;Al tiempo de la terminación del bucle, después de LEAVE&quot;</span> }
}

<span class="c1">## * Phasers de rol/clase</span>
<span class="n">COMPOSE</span> { <span class="s">&quot;Cuando un rol es compuesto en una clase. /!\ NO IMPLEMENTADO TODAVÍA&quot;</span> }

<span class="c1">## Ellos permite pequeños trucos o código brillante...:</span>
<span class="nb">say</span> <span class="s">&quot;Este código tomó &quot;</span> ~ (<span class="n">time</span> - <span class="k">CHECK</span> <span class="n">time</span>) ~ <span class="s">&quot;s para compilar&quot;</span>;

<span class="c1">## ... o brillante organización:</span>
<span class="k">sub</span> <span class="n">do-db-stuff</span> {
  <span class="nv">$db</span>.<span class="n">start-transaction</span>; <span class="c1"># comienza una transacción nueva</span>
  <span class="k">KEEP</span> <span class="nv">$db</span>.<span class="n">commit</span>; <span class="c1"># commit (procede con) la transacción si todo estuvo bien</span>
  <span class="k">UNDO</span> <span class="nv">$db</span>.<span class="n">rollback</span>; <span class="c1"># o retrocede si todo falló</span>
}
</pre></div>
<h2>Prefijos de sentencias</h2>
<div class="highlight"><pre><span></span><span class="c1">## Los prefijos de sentencias actúan como los phasers: Ellos afectan el</span>
<span class="c1">## comportamiento del siguiente código.</span>
<span class="c1">## Debido a que son ejecutados en línea con el código ejecutable, ellos</span>
<span class="c1">## se escriben en letras minúsculas. (`try` and `start` están teoréticamente</span>
<span class="c1">## en esa lista, pero serán explicados en otra parte)</span>
<span class="c1">## Nota: Ningunos de estos (excepto `start`) necesitan las llaves `{` y `}`.</span>

<span class="c1">## - `do` (el cual ya viste) - ejecuta un bloque o una sentencia como un</span>
<span class="c1">## término.</span>
<span class="c1">## Normalmente no puedes usar una sentencia como un valor (o término):</span>
<span class="c1">##</span>
<span class="c1">##    my $valor = if True { 1 } # `if` es una sentencia - error del parseador</span>
<span class="c1">##</span>
<span class="c1">## Esto funciona:</span>
<span class="k">my</span> <span class="nv">$a</span> = <span class="nb">do</span> <span class="k">if</span> <span class="nb">True</span> { <span class="mi">5</span> } <span class="c1"># con `do`, `if` ahora se comporta como un término.</span>

<span class="c1">## - `once` - se asegura que una porción de código se ejecute una sola vez.</span>
<span class="k">for</span> ^<span class="mi">5</span> { <span class="n">once</span> <span class="nb">say</span> <span class="mi">1</span> }; <span class="c1">#=&gt; 1</span>
                       <span class="c1"># solo imprime ... una sola vez.</span>
<span class="c1">## Al igual que `state`, ellos son clonados por ámbito</span>
<span class="k">for</span> ^<span class="mi">5</span> { <span class="k">sub</span> { <span class="n">once</span> <span class="nb">say</span> <span class="mi">1</span> }() } <span class="c1">#=&gt; 1 1 1 1 1</span>
                                <span class="c1"># Imprime una sola vez por ámbito léxico</span>

<span class="c1">## - `gather` - Hilo de co-rutina</span>
<span class="c1">## `gather` te permite tomar (`take`) varios valores en un array,</span>
<span class="c1">##  al igual que `do`. Encima de esto, te permite tomar cualquier expresión.</span>
<span class="nb">say</span> <span class="k">gather</span> <span class="k">for</span> ^<span class="mi">5</span> {
  <span class="nb">take</span> <span class="nv">$_</span> * <span class="mi">3</span> - <span class="mi">1</span>;
  <span class="nb">take</span> <span class="nv">$_</span> * <span class="mi">3</span> + <span class="mi">1</span>;
} <span class="c1">#=&gt; -1 1 2 4 5 7 8 10 11 13</span>
<span class="nb">say</span> <span class="nb">join</span> <span class="s">&#39;,&#39;</span>, <span class="k">gather</span> <span class="k">if</span> <span class="nb">False</span> {
  <span class="nb">take</span> <span class="mi">1</span>;
  <span class="nb">take</span> <span class="mi">2</span>;
  <span class="nb">take</span> <span class="mi">3</span>;
} <span class="c1"># no imprime nada.</span>

<span class="c1">## - `eager` - Evalúa una sentencia ávidamente (forza contexto ávido)</span>
<span class="c1">## No intentes esto en casa:</span>
<span class="c1">##</span>
<span class="c1">##    eager 1..*; # esto probablemente se colgará por un momento</span>
<span class="c1">##                # (y podría fallar...).</span>
<span class="c1">##</span>
<span class="c1">## Pero considera lo siguiente:</span>
<span class="k">constant</span> <span class="n">tres-veces</span> = <span class="k">gather</span> <span class="k">for</span> ^<span class="mi">3</span> { <span class="nb">say</span> <span class="nb">take</span> <span class="nv">$_</span> }; <span class="c1"># No imprime nada</span>

<span class="c1">## frente a esto:</span>
<span class="k">constant</span> <span class="n">tres-veces</span> = <span class="nb">eager</span> <span class="k">gather</span> <span class="k">for</span> ^<span class="mi">3</span> { <span class="nb">say</span> <span class="nb">take</span> <span class="nv">$_</span> }; <span class="c1">#=&gt; 0 1 2</span>
</pre></div>
<h2>Iterables</h2>
<div class="highlight"><pre><span></span><span class="c1">## En Raku, los iterables son objetos que pueden ser iterados similar</span>
<span class="c1">## a la construcción `for`.</span>
<span class="c1">## `flat`, aplana iterables:</span>
<span class="nb">say</span> (<span class="mi">1</span>, <span class="mi">10</span>, (<span class="mi">20</span>, <span class="mi">10</span>) ); <span class="c1">#=&gt; (1 10 (20 10)) Nota como la agrupación se mantiene</span>
<span class="nb">say</span> (<span class="mi">1</span>, <span class="mi">10</span>, (<span class="mi">20</span>, <span class="mi">10</span>) ).<span class="nb">flat</span>; <span class="c1">#=&gt; (1 10 20 10) Ahora el iterable es plano</span>

<span class="c1">## - `lazy` - Aplaza la evaluación actual hasta que el valor sea requirido</span>
<span class="c1">## (forza contexto perezoso)</span>
<span class="k">my</span> <span class="nv">@lazy-array</span> = (<span class="mi">1</span><span class="o">..</span><span class="mi">100</span>).<span class="nb">lazy</span>;
<span class="nb">say</span> <span class="nv">@lazy-array</span>.<span class="nb">is-lazy</span>; <span class="c1">#=&gt; True # Chequea por &quot;pereza&quot; con el método `is-lazy`.</span>
<span class="nb">say</span> <span class="nv">@lazy-array</span>; <span class="c1">#=&gt; [...] No se ha iterado sobre la lista</span>
<span class="k">for</span> <span class="nv">@lazy-array</span> { .<span class="nb">print</span> }; <span class="c1"># Esto funciona y hará tanto trabajo como sea necesario.</span>

[//]: <span class="c1"># ( TODO explica que gather/take y map son todos perezosos)</span>
<span class="c1">## - `sink` - Un `eager` que desecha los resultados (forza el contexto sink)</span>
<span class="k">constant</span> <span class="n">nilthingie</span> = <span class="nb">sink</span> <span class="k">for</span> ^<span class="mi">3</span> { .<span class="nb">say</span> } <span class="c1">#=&gt; 0 1 2</span>
<span class="nb">say</span> <span class="n">nilthingie</span>.<span class="nb">perl</span>; <span class="c1">#=&gt; Nil</span>

<span class="c1">## - `quietly` - Un bloque `quietly` reprime las advertencias:</span>
<span class="n">quietly</span> { <span class="nb">warn</span> <span class="s">&#39;Esto es una advertencia!&#39;</span> }; <span class="c1">#=&gt; No salida</span>

<span class="c1">## - `contend` - Intenta efectos secundarios debajo de STM</span>
<span class="c1">## ¡No implementado todavía!</span>
</pre></div>
<h2>¡Más operadores!</h2>
<div class="highlight"><pre><span></span><span class="c1">## ¡Todo el mundo ama los operadores! Tengamos más de ellos.</span>

<span class="c1">## La lista de precedencia puede ser encontrada aquí:</span>
<span class="c1">## https://docs.raku.org/language/operators#Operator_Precedence</span>
<span class="c1">## Pero primero, necesitamos un poco de explicación acerca</span>
<span class="c1">## de la asociatividad:</span>

<span class="c1">## * Operadores binarios:</span>
<span class="nv">$a</span> ! <span class="nv">$b</span> ! <span class="nv">$c</span>; <span class="c1"># con asociatividad izquierda `!`, esto es `($a ! $b) ! $c`</span>
<span class="nv">$a</span> ! <span class="nv">$b</span> ! <span class="nv">$c</span>; <span class="c1"># con asociatividad derecha `!`, esto es `$a ! ($b ! $c)`</span>
<span class="nv">$a</span> ! <span class="nv">$b</span> ! <span class="nv">$c</span>; <span class="c1"># sin asociatividad `!`, esto es ilegal</span>
<span class="nv">$a</span> ! <span class="nv">$b</span> ! <span class="nv">$c</span>; <span class="c1"># con una cadena de asociatividad `!`, esto es `($a ! $b) and ($b ! $c)`</span>
<span class="nv">$a</span> ! <span class="nv">$b</span> ! <span class="nv">$c</span>; <span class="c1"># con asociatividad de lista `!`, esto es `infix:&lt;&gt;`</span>

<span class="c1">## * Operadores unarios:</span>
!<span class="nv">$a</span>! <span class="c1"># con asociatividad izquierda `!`, esto es `(!$a)!`</span>
!<span class="nv">$a</span>! <span class="c1"># con asociatividad derecha `!`, esto es `!($a!)`</span>
!<span class="nv">$a</span>! <span class="c1"># sin asociatividad `!`, esto es ilegal</span>
</pre></div>
<h3>¡Crea tus propios operadores!</h3>
<div class="highlight"><pre><span></span><span class="c1">## Okay, has leído todo esto y me imagino que debería mostrarte</span>
<span class="c1">## algo interesante.</span>
<span class="c1">## Te mostraré un pequeño secreto (o algo no tan secreto):</span>
<span class="c1">## En Raku, todos los operadores son actualmente solo subrutinas.</span>

<span class="c1">## Puedes declarar un operador como declaras una subrutina:</span>
<span class="k">sub</span> <span class="n">prefix:</span><span class="s">&lt;ganar&gt;</span>(<span class="nv">$ganador</span>) { <span class="c1"># se refiere a las categorías de los operadores</span>
                               <span class="c1"># (exacto, es el &quot;operador de palabras&quot; `&lt;&gt;`)</span>
  <span class="nb">say</span> <span class="s">&quot;¡$ganador ganó!&quot;</span>;
}
<span class="n">ganar</span> <span class="s">&quot;El Rey&quot;</span>; <span class="c1">#=&gt; ¡El Rey Ganó!</span>
                <span class="c1"># (prefijo se pone delante)</span>

<span class="c1">## todavías puedes invocar la subrutina con su &quot;nombre completo&quot;:</span>
<span class="nb">say</span> <span class="n">prefix:</span><span class="s">&lt;!&gt;(True); #=&gt;</span> <span class="nb">False</span>

<span class="k">sub</span> <span class="n">postfix:</span><span class="s">&lt;!&gt;(Int $n) {</span>
<span class="s">  [*] 2..$n; # usando el meta-operador reduce ... Ve más abajo!</span>
<span class="s">}</span>
<span class="s">say 5!; #=&gt;</span> <span class="mi">120</span>
        <span class="c1"># Operadores sufijos (postfix) van *directamente* después del témino.</span>
        <span class="c1"># No espacios en blanco. Puedes usar paréntesis para disambiguar,</span>
        <span class="c1"># i.e. `(5!)!`</span>


<span class="k">sub</span> <span class="n">infix:</span><span class="s">&lt;veces&gt;</span>(<span class="nb">Int</span> <span class="nv">$n</span>, <span class="nb">Block</span> <span class="nv">$r</span>) { <span class="c1"># infijo va en el medio</span>
  <span class="k">for</span> ^<span class="nv">$n</span> {
    <span class="nv">$r</span>(); <span class="c1"># Necesitas los paréntesis explícitos para invocar la función</span>
          <span class="c1"># almacenada en la variable `$r`. De lo contrario, te estaría</span>
          <span class="c1"># refiriendo a la variable (no a la función), como con `&amp;r`.</span>
  }
}
<span class="mi">3</span> <span class="n">veces</span> -&gt; { <span class="nb">say</span> <span class="s">&quot;hola&quot;</span> }; <span class="c1">#=&gt; hola</span>
                            <span class="c1">#=&gt; hola</span>
                            <span class="c1">#=&gt; hola</span>
                            <span class="c1"># Se te recomienda que ponga espacios</span>
                            <span class="c1"># alrededor de la invocación de operador infijo.</span>

<span class="c1">## Para los circunfijos y pos-circunfijos</span>
<span class="k">sub</span> <span class="n">circumfix:</span><span class="s">&lt;[ ]&gt;</span>(<span class="nb">Int</span> <span class="nv">$n</span>) {
  <span class="nv">$n</span> ** <span class="nv">$n</span>
}
<span class="nb">say</span> [<span class="mi">5</span>]; <span class="c1">#=&gt; 3125</span>
         <span class="c1"># un circunfijo va alrededor. De nuevo, no espacios en blanco.</span>

<span class="k">sub</span> <span class="n">postcircumfix:</span><span class="s">&lt;{ }&gt;</span>(<span class="nb">Str</span> <span class="nv">$s</span>, <span class="nb">Int</span> <span class="nv">$idx</span>) {
  <span class="c1">## un pos-circunfijo es</span>
  <span class="c1">## &quot;después de un término y alrededor de algo&quot;</span>
  <span class="nv">$s</span>.<span class="nb">substr</span>(<span class="nv">$idx</span>, <span class="mi">1</span>);
}
<span class="nb">say</span> <span class="s">&quot;abc&quot;</span>{<span class="mi">1</span>}; <span class="c1">#=&gt; b</span>
              <span class="c1"># depués del término `&quot;abc&quot;`, y alrededor del índice (1)</span>

<span class="c1">## Esto es de gran valor -- porque todo en Raku usa esto.</span>
<span class="c1">## Por ejemplo, para eliminar una llave de un hash, tu usas el adverbio</span>
<span class="c1">## `:delete` (un simple argumento con nombre debajo):</span>
<span class="nv">%h</span>{<span class="nv">$llave</span>}:<span class="n">delete</span>;
<span class="c1">## es equivalente a:</span>
<span class="n">postcircumfix:</span><span class="s">&lt;{ }&gt;</span>(<span class="nv">%h</span>, <span class="nv">$llave</span>, :<span class="n">delete</span>); <span class="c1"># (puedes invocar</span>
                                          <span class="c1"># operadores de esta forma)</span>
<span class="c1">## ¡*Todos* usan los mismos bloques básicos!</span>
<span class="c1">## Categorías sintácticas (prefix, infix, ...), argumentos nombrados</span>
<span class="c1">## (adverbios), ... - usados para construir el lenguaje - están al alcance</span>
<span class="c1">## de tus manos y disponibles para ti.</span>
<span class="c1">## (obviamente, no se te recomienda que hagas un operador de *cualquier</span>
<span class="c1">## cosa* -- Un gran poder conlleva una gran responsabilidad.)</span>
</pre></div>
<h3>Meta-operadores!</h3>
<div class="highlight"><pre><span></span><span class="c1">## ¡Prepárate! Prepárate porque nos estamos metiendo bien hondo</span>
<span class="c1">## en el agujero del conejo, y probablemente no querrás regresar a</span>
<span class="c1">## otros lenguajes después de leer esto.</span>
<span class="c1">## (Me imagino que ya no quieres a este punto).</span>
<span class="c1">## Meta-operadores, como su nombre lo sugiere, son operadores *compuestos*.</span>
<span class="c1">## Básicamente, ellos son operadores que se aplican a otros operadores.</span>

<span class="c1">## * El meta-operador reduce (reducir)</span>
<span class="c1">## Es un meta-operador prefijo que toman una función binaria y</span>
<span class="c1">## una o varias listas. Sino se pasa ningún argumento,</span>
<span class="c1">## returna un &quot;valor por defecto&quot; para este operador</span>
<span class="c1">## (un valor sin significado) o `Any` si no hay ningún valor.</span>
<span class="c1">##</span>
<span class="c1">## De lo contrario, remueve un elemento de la(s) lista(s) uno a uno, y</span>
<span class="c1">## aplica la función binaria al último resultado (o al primer elemento de</span>
<span class="c1">## la lista y el elemento que ha sido removido).</span>
<span class="c1">##</span>
<span class="c1">## Para sumar una lista, podrías usar el meta-operador &quot;reduce&quot; con `+`,</span>
<span class="c1">## i.e.:</span>
<span class="nb">say</span> [+] <span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>; <span class="c1">#=&gt; 6</span>
<span class="c1">## es equivalente a `(1+2)+3`</span>

<span class="nb">say</span> [*] <span class="mi">1</span><span class="o">..</span><span class="mi">5</span>; <span class="c1">#=&gt; 120</span>
<span class="c1">## es equivalente a `((((1*2)*3)*4)*5)`.</span>

<span class="c1">## Puedes reducir con cualquier operador, no solo con operadores matemáticos.</span>
<span class="c1">## Por ejemplo, podrías reducir con `//` para conseguir</span>
<span class="c1">## el primer elemento definido de una lista:</span>
<span class="nb">say</span> [//] <span class="nb">Nil</span>, <span class="nb">Any</span>, <span class="nb">False</span>, <span class="mi">1</span>, <span class="mi">5</span>; <span class="c1">#=&gt; False</span>
                                <span class="c1"># (Falsey, pero definido)</span>

<span class="c1">## Ejemplos con valores por defecto:</span>
<span class="nb">say</span> [*] (); <span class="c1">#=&gt; 1</span>
<span class="nb">say</span> [+] (); <span class="c1">#=&gt; 0</span>
            <span class="c1"># valores sin significado, dado que N*1=N y N+0=N.</span>
<span class="nb">say</span> [//];   <span class="c1">#=&gt; (Any)</span>
            <span class="c1"># No hay valor por defecto para `//`.</span>
<span class="c1">## También puedes invocarlo con una función de tu creación usando</span>
<span class="c1">## los dobles corchetes:</span>
<span class="k">sub</span> <span class="nb">add</span>(<span class="nv">$a</span>, <span class="nv">$b</span>) { <span class="nv">$a</span> + <span class="nv">$b</span> }
<span class="nb">say</span> [[<span class="nv">&amp;add</span>]] <span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>; <span class="c1">#=&gt; 6</span>

<span class="c1">## * El meta-operador zip</span>
<span class="c1">## Este es un meta-operador infijo que también puede ser usado como un</span>
<span class="c1">## operador &quot;normal&quot;. Toma una función binaria opcional (por defecto, solo</span>
<span class="c1">## crear un par), y remueve un valor de cada array e invoca su función</span>
<span class="c1">## binaria hasta que no tenga más elementos disponibles. Al final, returna</span>
<span class="c1">## un array con todos estos nuevos elementos.</span>
(<span class="mi">1</span>, <span class="mi">2</span>) <span class="o">Z</span> (<span class="mi">3</span>, <span class="mi">4</span>); <span class="c1"># ((1, 3), (2, 4)), dado que por defecto, la función</span>
                 <span class="c1"># crea un array.</span>
<span class="mi">1</span><span class="o">..</span><span class="mi">3</span> <span class="o">Z</span>+ <span class="mi">4</span><span class="o">..</span><span class="mi">6</span>; <span class="c1"># (5, 7, 9), usando la función personalizada infix:&lt;+&gt;</span>

<span class="c1">## Dado que `Z` tiene asociatividad de lista (ve la lista más arriba),</span>
<span class="c1">## puedes usarlo en más de una lista</span>
(<span class="nb">True</span>, <span class="nb">False</span>) <span class="o">Z</span>|| (<span class="nb">False</span>, <span class="nb">False</span>) <span class="o">Z</span>|| (<span class="nb">False</span>, <span class="nb">False</span>); <span class="c1"># (True, False)</span>

<span class="c1">## Y pasa que también puedes usarlo con el meta-operador reduce:</span>
[<span class="o">Z</span>||] (<span class="nb">True</span>, <span class="nb">False</span>), (<span class="nb">False</span>, <span class="nb">False</span>), (<span class="nb">False</span>, <span class="nb">False</span>); <span class="c1"># (True, False)</span>


<span class="c1">## Y para terminar la lista de operadores:</span>

<span class="c1">## * El operador secuencia</span>
<span class="c1">## El operador secuencia es uno de la más poderosas características de</span>
<span class="c1">## Raku: Está compuesto, en la izquierda, de la lista que quieres que</span>
<span class="c1">## Raku use para deducir (y podría incluir una clausura), y en la derecha,</span>
<span class="c1">## un valor o el predicado que dice cuando parar (o Whatever para una</span>
<span class="c1">## lista infinita perezosa).</span>
<span class="k">my</span> <span class="nv">@list</span> = <span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span> ... <span class="mi">10</span>; <span class="c1"># deducción básica</span>
<span class="c1">#my @list = 1, 3, 6 ... 10; # esto muere porque Raku no puede deducir el final</span>
<span class="k">my</span> <span class="nv">@list</span> = <span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span> ...^ <span class="mi">10</span>; <span class="c1"># como con rangos, puedes excluir el último elemento</span>
                            <span class="c1"># (la iteración cuando el predicado iguala).</span>
<span class="k">my</span> <span class="nv">@list</span> = <span class="mi">1</span>, <span class="mi">3</span>, <span class="mi">9</span> ... * &gt; <span class="mi">30</span>; <span class="c1"># puedes usar un predicado</span>
                               <span class="c1"># (con la Whatever Star, aquí).</span>
<span class="k">my</span> <span class="nv">@list</span> = <span class="mi">1</span>, <span class="mi">3</span>, <span class="mi">9</span> ... { <span class="nv">$_</span> &gt; <span class="mi">30</span> }; <span class="c1"># (equivalente a lo de arriba)</span>

<span class="k">my</span> <span class="nv">@fib</span> = <span class="mi">1</span>, <span class="mi">1</span>, *+* ... *; <span class="c1"># lista infinita perezosa de la serie fibonacci,</span>
                           <span class="c1">#  computada usando una clausura!</span>
<span class="k">my</span> <span class="nv">@fib</span> = <span class="mi">1</span>, <span class="mi">1</span>, -&gt; <span class="nv">$a</span>, <span class="nv">$b</span> { <span class="nv">$a</span> + <span class="nv">$b</span> } ... *; <span class="c1"># (equivalene a lo de arriba)</span>
<span class="k">my</span> <span class="nv">@fib</span> = <span class="mi">1</span>, <span class="mi">1</span>, { <span class="nv">$^a</span> + <span class="nv">$^b</span> } ... *; <span class="c1">#(... también equivalene a lo de arriba)</span>
<span class="c1">## $a and $b siempre tomarán el valor anterior, queriendo decir que</span>
<span class="c1">## ellos comenzarán con $a = 1 y $b = 1 (valores que hemos asignado</span>
<span class="c1">## de antemano). Por lo tanto, $a = 1 y $b = 2 (resultado del anterior $a+$b),</span>
<span class="c1">## etc.</span>

<span class="nb">say</span> <span class="nv">@fib</span>[^<span class="mi">10</span>]; <span class="c1">#=&gt; 1 1 2 3 5 8 13 21 34 55</span>
               <span class="c1"># (usandi un rango como el índice)</span>
<span class="c1">## Nota: Los elementos de un rango, una vez cosificados, no son re-calculados.</span>
<span class="c1">## Esta es la razón por la cual `@primes[^100]` tomará más tiempo la primera</span>
<span class="c1">## vez que se imprime. Después de esto, será hará en un instante.</span>
</pre></div>
<h2>Expresiones Regulares</h2>
<div class="highlight"><pre><span></span><span class="c1">## Estoy seguro que has estado esperando por esta parte. Bien, ahora que</span>
<span class="c1">## sabes algo acerca de Raku, podemos comenzar. Primeramente, tendrás</span>
<span class="c1">## que olvidarte acerca de &quot;PCRE regexps&quot; (perl-compatible regexps)</span>
<span class="c1">## (expresiones regulares compatible de perl).</span>
<span class="c1">##</span>
<span class="c1">## IMPORTANTE: No salte esto porque ya sabes acerca de PCRE. Son totalmente</span>
<span class="c1">## distintos. Algunas cosas son las mismas (como `?`, `+`, y `*`) pero</span>
<span class="c1">## algunas veces la semántica cambia (`|`). Asegúrate de leer esto</span>
<span class="c1">## cuidadosamente porque podrías trospezarte sino lo haces.</span>
<span class="c1">##</span>
<span class="c1">## Raku tiene muchas características relacionadas con RegExps. Después de</span>
<span class="c1">## todo, Rakudo se parsea a si mismo. Primero vamos a estudiar la sintaxis</span>
<span class="c1">## por si misma, después hablaremos acerca de gramáticas (parecido a PEG),</span>
<span class="c1">## las diferencias entre los declaradores `token`, `regex`, y `rule` y</span>
<span class="c1">## mucho más.</span>
<span class="c1">## Nota aparte: Todavía tienes acceso a los regexes PCRE usando el</span>
<span class="c1">## mofificador `:P5` (Sin embargo, no lo discutiremos en este tutorial).</span>
<span class="c1">##</span>
<span class="c1">## En esencia, Raku implementa PEG (&quot;Parsing Expression Grammars&quot;)</span>
<span class="c1">## (&quot;Parseado de Expresiones de Gramáticas&quot;) nativamente. El orden jerárquico</span>
<span class="c1">## para los parseos ambiguos es determinado por un examen multi-nivel de</span>
<span class="c1">## desempate:</span>
<span class="c1">##  - La coincidencia de token más larga. `foo\s+` le gana a `foo`</span>
<span class="c1">##     (por 2 o más posiciones)</span>
<span class="c1">##  - El prefijo literal más largo. `food\w*` le gana a `foo\w*` (por 1)</span>
<span class="c1">##  - Declaración desde la gramática más derivada a la menos derivada</span>
<span class="c1">##     (las gramáticas son actualmente clases)</span>
<span class="c1">##  - La declaración más temprana gana</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;a&#39;</span> ~~<span class="sr"> /a/</span>; <span class="c1">#=&gt; True</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;a&#39;</span> ~~<span class="sr"> / a /</span>; <span class="c1">#=&gt; True #  ¡Más legible con los espacios!</span>

<span class="c1">## Nota al lector (del traductor):</span>
<span class="c1">## Como pudiste haber notado, he decidido traducir &quot;match&quot; y sus diferentes</span>
<span class="c1">## formas verbales como &quot;coincidir&quot; y sus diferentes formas. Cuando digo que</span>
<span class="c1">## un regex (o regexp) coincide con cierto texto, me refiero a que el regex</span>
<span class="c1">## describe cierto patrón dentro del texto. Por ejemplo, el regex &quot;cencia&quot;</span>
<span class="c1">## coincide con el texto &quot;reminiscencia&quot;, lo que significa que dentro del</span>
<span class="c1">## texto aparece ese patrón de caracteres (una `c`, seguida de una `e`,</span>
<span class="c1">## (seguida de una `n`, etc.)</span>

<span class="c1">## En todos nuestros ejemplos, vamos a usar el operador de</span>
<span class="c1">## &quot;coincidencia inteligente&quot; contra una expresión regular (&quot;regexp&quot; or</span>
<span class="c1">## &quot;regex&quot; de aquí en adelante). Estamos convirtiendo el resultado usando `so`,</span>
<span class="c1">## pero en efecto, está devolviendo un objeto Match. Ellos saben como responder</span>
<span class="c1">## a la indexación de lista, indexación de hash, y devolver la cadena de</span>
<span class="c1">## texto coincidente.</span>
<span class="c1">## Los resultados de la coincidencia están disponible como `$/` (en</span>
<span class="c1">## ámbito implícito lexical). También puedes usar las variables de captura</span>
<span class="c1">## las cuales comienzan con 0:</span>
<span class="c1">##    `$0`, `$1&#39;, `$2`...</span>
<span class="c1">##</span>
<span class="c1">## Nota que `~~` no hace un chequeo de inicio/final (es decir,</span>
<span class="c1">## el regexp puede coincider con solo un carácter de la cadena de texto).</span>
<span class="c1">## Explicaremos luego como hacerlo.</span>

<span class="c1">## En Raku, puedes tener un carácter alfanumérico como un literal,</span>
<span class="c1">## todo lo demás debe escaparse usando una barra invertida o comillas.</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;a|b&#39;</span> ~~<span class="sr"> / a &#39;|&#39; b /</span>; <span class="c1"># `True`. No sería lo mismo si no se escapara `|`</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;a|b&#39;</span> ~~<span class="sr"> / a \| b /</span>;  <span class="c1"># `True`. Otra forma de escaparlo</span>

<span class="c1">## El espacio en blanco actualmente no se significa nada en un regexp,</span>
<span class="c1">## a menos que uses el adverbio `:s` (`:sigspace`, espacio significante).</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;a b c&#39;</span> ~~<span class="sr"> / a  b  c /</span>; <span class="c1">#=&gt; `False`. Espacio no significa nada aquí.</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;a b c&#39;</span> ~~<span class="sr"> /:s a b c /</span>; <span class="c1">#=&gt; `True`. Agregamos el modificador `:s` aquí.</span>
<span class="c1">## Si usamos solo un espacio entre cadenas de texto en un regexp, Raku</span>
<span class="c1">## nos advertirá:</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;a b c&#39;</span> ~~<span class="sr"> / a b c /</span>; <span class="c1">#=&gt; &#39;False&#39; # Espacio no significa nada aquí.</span>
<span class="c1">## Por favor usa comillas o el modificador :s (:sigspace) para suprimir</span>
<span class="c1">## esta advertencia, omitir el espacio, o cambiar el espaciamiento. Para</span>
<span class="c1">## arreglar esto y hacer los espacios menos ambiguos, usa por lo menos</span>
<span class="c1">## dos espacios entre las cadenas de texto o usa el adverbio `:s`.</span>

<span class="c1">## Como vimos anteriormente, podemos incorporar `:s` dentro de los</span>
<span class="c1">## delimitadores de barras. También podemos ponerlos fuera de ellos si</span>
<span class="c1">## especificamos `m` for `match` (coincidencia):</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;a b c&#39;</span> ~~ <span class="sr">m:s/a  b  c/</span>; <span class="c1">#=&gt; `True`</span>
<span class="c1">## Al usar `m` para especificar &#39;match&#39;, podemos también otros delimitadore:</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;abc&#39;</span> ~~ <span class="sr">m{a  b  c}</span>; <span class="c1">#=&gt; `True`</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;abc&#39;</span> ~~ <span class="sr">m[a  b  c]</span>; <span class="c1">#=&gt; `True`</span>

<span class="c1">## Usa el adverbio :i para especificar que no debería haber distinción entre</span>
<span class="c1">## minúsculas y mayúsculas:</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="s">&#39;ABC&#39;</span> ~~ <span class="sr">m:i{a  b  c}</span>; <span class="c1">#=&gt; `True`</span>

<span class="c1">## Sin embargo, es importante para como los modificadores son aplicados</span>
<span class="c1">## (lo cual verás más abajo)...</span>

<span class="c1">## Cuantificando - `?`, `+`, `*` y `**`.</span>
<span class="c1">## - `?` - 0 o 1</span>
<span class="nb">so</span> <span class="s">&#39;ac&#39;</span> ~~<span class="sr"> / a  b  c /</span>; <span class="c1"># `False`</span>
<span class="nb">so</span> <span class="s">&#39;ac&#39;</span> ~~<span class="sr"> / a  b?  c /</span>; <span class="c1"># `True`, la &quot;b&quot; coincidió (apareció) 0 veces.</span>
<span class="nb">so</span> <span class="s">&#39;abc&#39;</span> ~~<span class="sr"> / a  b?  c /</span>; <span class="c1"># `True`, la &quot;b&quot; coincidió 1 vez.</span>

<span class="c1">## ... Como debes saber, espacio en blancos son importante porque</span>
<span class="c1">## determinan en que parte del regexp es el objetivo del modificador:</span>
<span class="nb">so</span> <span class="s">&#39;def&#39;</span> ~~<span class="sr"> / a  b  c? /</span>; <span class="c1"># `False`. Solamente la `c` es opcional</span>
<span class="nb">so</span> <span class="s">&#39;def&#39;</span> ~~<span class="sr"> / a  b?  c /</span>; <span class="c1"># `False`. Espacio en blanco no es significante</span>
<span class="nb">so</span> <span class="s">&#39;def&#39;</span> ~~<span class="sr"> / &#39;abc&#39;? /</span>; <span class="c1"># `True`. El grupo &quot;abc&quot;completo es opcional.</span>

<span class="c1">## Aquí (y más abajo) el cuantificador aplica solamente a la `b`</span>

<span class="c1">## - `+` - 1 o más</span>
<span class="nb">so</span> <span class="s">&#39;ac&#39;</span> ~~<span class="sr"> / a  b+  c /</span>; <span class="c1"># `False`; `+` quiere por lo menos una coincidencia</span>
<span class="nb">so</span> <span class="s">&#39;abc&#39;</span> ~~<span class="sr"> / a  b+  c /</span>; <span class="c1"># `True`; una es suficiente</span>
<span class="nb">so</span> <span class="s">&#39;abbbbc&#39;</span> ~~<span class="sr"> / a  b+  c /</span>; <span class="c1"># `True`, coincidió con 4 &quot;b&quot;s</span>

<span class="c1">## - `*` - 0 o más</span>
<span class="nb">so</span> <span class="s">&#39;ac&#39;</span> ~~<span class="sr"> / a  b*  c /</span>; <span class="c1"># `True`, todos son opcionales.</span>
<span class="nb">so</span> <span class="s">&#39;abc&#39;</span> ~~<span class="sr"> / a  b*  c /</span>; <span class="c1"># `True`</span>
<span class="nb">so</span> <span class="s">&#39;abbbbc&#39;</span> ~~<span class="sr"> / a  b*  c /</span>; <span class="c1"># `True`</span>
<span class="nb">so</span> <span class="s">&#39;aec&#39;</span> ~~<span class="sr"> / a  b*  c /</span>; <span class="c1"># `False`. &quot;b&quot;(s) son opcionales, no reemplazables.</span>

<span class="c1">## - `**` - Cuantificador (sin límites)</span>
<span class="c1">## Si entrecierras los ojos lo suficiente, pueder ser que entiendas</span>
<span class="c1">## por qué la exponenciación es usada para la cantidad.</span>
<span class="nb">so</span> <span class="s">&#39;abc&#39;</span> ~~<span class="sr"> / a  b**1  c /</span>; <span class="c1"># `True` (exactamente una vez)</span>
<span class="nb">so</span> <span class="s">&#39;abc&#39;</span> ~~<span class="sr"> / a  b**1..3  c /</span>; <span class="c1"># `True` (entre una y tres veces)</span>
<span class="nb">so</span> <span class="s">&#39;abbbc&#39;</span> ~~<span class="sr"> / a  b**1..3  c /</span>; <span class="c1"># `True`</span>
<span class="nb">so</span> <span class="s">&#39;abbbbbbc&#39;</span> ~~<span class="sr"> / a  b**1..3  c /</span>; <span class="c1"># `False` (demasiado)</span>
<span class="nb">so</span> <span class="s">&#39;abbbbbbc&#39;</span> ~~<span class="sr"> / a  b**3..*  c /</span>; <span class="c1"># `True` (rangos infinitos no son un problema)</span>

<span class="c1">## - `&lt;[]&gt;` - Clases de carácteres</span>
<span class="c1">## Las clases de carácteres son equivalentes a las clases `[]` de PCRE,</span>
<span class="c1">## pero usan una sintaxis de Raku:</span>
<span class="nb">say</span> <span class="s">&#39;fooa&#39;</span> ~~<span class="sr"> / f &lt;[ o a ]&gt;+ /</span>; <span class="c1">#=&gt; &#39;fooa&#39;</span>

<span class="c1">## Puedes usar rangos:</span>
<span class="nb">say</span> <span class="s">&#39;aeiou&#39;</span> ~~<span class="sr"> / a &lt;[ e..w ]&gt; /</span>; <span class="c1">#=&gt; &#39;ae&#39;</span>

<span class="c1">## Al igual que regexes normales, si quieres usar un carácter especial,</span>
<span class="c1">## escápalo (el último está escapando un espacio)</span>
<span class="nb">say</span> <span class="s">&#39;he-he !&#39;</span> ~~<span class="sr"> / &#39;he-&#39; &lt;[ a..z \! \  ]&gt; + /</span>; <span class="c1">#=&gt; &#39;he-he !&#39;</span>

<span class="c1">## Obtendrás una advertencia si pones nombres duplicados</span>
<span class="c1">## (lo cual tiene el efecto de capturar la frase escrita)</span>
<span class="s">&#39;he he&#39;</span> ~~<span class="sr"> / &lt;[ h e &#39; &#39; ]&gt; /</span>; <span class="c1"># Advierte &quot;Repeated characters found in characters</span>
                              <span class="c1"># class&quot;</span>

<span class="c1">## También puedes negarlos... (equivalenta a `[^]` en PCRE)</span>
<span class="nb">so</span> <span class="s">&#39;foo&#39;</span> ~~<span class="sr"> / &lt;-[ f o ]&gt; + /</span>; <span class="c1"># False</span>

<span class="c1">## ... y componerlos:</span>
<span class="nb">so</span> <span class="s">&#39;foo&#39;</span> ~~<span class="sr"> / &lt;[ a..z ] - [ f o ]&gt; + /</span>;   <span class="c1"># False (cualquier letra excepto f y o)</span>
<span class="nb">so</span> <span class="s">&#39;foo&#39;</span> ~~<span class="sr"> / &lt;-[ a..z ] + [ f o ]&gt; + /</span>;  <span class="c1"># True (no letra excepto f and o)</span>
<span class="nb">so</span> <span class="s">&#39;foo!&#39;</span> ~~<span class="sr"> / &lt;-[ a..z ] + [ f o ]&gt; + /</span>; <span class="c1"># True (el signo + no reemplaza la</span>
                                          <span class="c1"># parte de la izquierda)</span>
</pre></div>
<h3>Grupos y Capturas</h3>
<div class="highlight"><pre><span></span><span class="c1">## Grupo: Puedes agrupar partes de tu regexp con `[]`.</span>
<span class="c1">## Estos grupos *no son* capturados (como con `(?:)` en PCRE).</span>
<span class="nb">so</span> <span class="s">&#39;abc&#39;</span> ~~<span class="sr"> / a [ b ] c /</span>; <span class="c1"># `True`. El agrupamiento no hace casi nada</span>
<span class="nb">so</span> <span class="s">&#39;foo012012bar&#39;</span> ~~<span class="sr"> / foo [ &#39;01&#39; &lt;[0..9]&gt; ] + bar /</span>;
<span class="c1">## La línea anterior returna `True`.</span>
<span class="c1">## Coincidimos (o encotramos el patrón) &quot;012&quot; una o más de una vez (</span>
<span class="c1">## (el signo `+` fue aplicado al grupo).</span>
<span class="c1">## Pero esto no va demasiado lejos, porque no podemos actualmente obtener</span>
<span class="c1">## devuelta el patrón que coincidió.</span>

<span class="c1">## Captura: Podemos actualmente *capturar* los resultados del regexp,</span>
<span class="c1">## usando paréntesis.</span>
<span class="nb">so</span> <span class="s">&#39;fooABCABCbar&#39;</span> ~~<span class="sr"> / foo ( &#39;A&#39; &lt;[A..Z]&gt; &#39;C&#39; ) + bar /</span>; <span class="c1"># `True`. (usando `so`</span>
                                                         <span class="c1">#  aquí, `$/` más abajo)</span>

<span class="c1">## Ok. Comenzando con las explicaciones de grupos. Como dijimos,</span>
<span class="c1">### nuestra objeto `Match` está disponible en la variable `$/`:</span>
<span class="nb">say</span> <span class="vg">$/</span>; <span class="c1"># Imprimirá algo extraño (explicaremos luego) o</span>
        <span class="c1"># &quot;Nil&quot; si nada coincidió</span>

<span class="c1">## Como dijimos anteriormente, un objeto Match tiene indexación de array:</span>
<span class="nb">say</span> <span class="vg">$/</span>[<span class="mi">0</span>]; <span class="c1">#=&gt; ｢ABC｣ ｢ABC｣</span>
           <span class="c1"># Estos corchetes extranos son los objetos `Match`.</span>
           <span class="c1"># Aquí, tenemos un array de ellos.</span>
<span class="nb">say</span> <span class="nv">$0</span>; <span class="c1"># Lo mismo que lo anterior.</span>

<span class="c1">## Nuestra captura es `$0` porque es la primera y única captura en el</span>
<span class="c1">## regexp. Podrías estarte preguntando porque un array y la respuesta es</span>
<span class="c1">## simple: Algunas capturas (indezadas usando `$0`, `$/[0]` o una nombrada)</span>
<span class="c1">## será un array si y solo si puedes tener más de un elemento.</span>
<span class="c1">## (Así que, con `*`, `+` y `**` (cualquiera los operandos), pero no con `?`).</span>
<span class="c1">## Usemos algunos ejemplos para ver como funciona:</span>

<span class="c1">## Nota: Pusimos A B C entre comillas para demostrar que el espacio en blanco</span>
<span class="c1">## entre ellos no es significante. Si queremos que el espacio en blanco</span>
<span class="c1">## *sea* significante, podemos utilizar el modificador `:sigspace`.</span>
<span class="nb">so</span> <span class="s">&#39;fooABCbar&#39;</span> ~~<span class="sr"> / foo ( &quot;A&quot; &quot;B&quot; &quot;C&quot; )? bar /</span>; <span class="c1"># `True`</span>
<span class="nb">say</span> <span class="vg">$/</span>[<span class="mi">0</span>]; <span class="c1">#=&gt; ｢ABC｣</span>
<span class="nb">say</span> <span class="nv">$0</span>.<span class="nb">WHAT</span>; <span class="c1">#=&gt; (Match)</span>
             <span class="c1"># Puede haber más de uno, por lo tanto es solo un solo objeto match.</span>
<span class="nb">so</span> <span class="s">&#39;foobar&#39;</span> ~~<span class="sr"> / foo ( &quot;A&quot; &quot;B&quot; &quot;C&quot; )? bar /</span>; <span class="c1">#=&gt; True</span>
<span class="nb">say</span> <span class="nv">$0</span>.<span class="nb">WHAT</span>; <span class="c1">#=&gt; (Any)</span>
             <span class="c1"># Esta captura no coincidió, por lo tanto está vacía</span>
<span class="nb">so</span> <span class="s">&#39;foobar&#39;</span> ~~<span class="sr"> / foo ( &quot;A&quot; &quot;B&quot; &quot;C&quot; ) ** 0..1 bar /</span>; <span class="c1"># `True`</span>
<span class="nb">say</span> <span class="nv">$0</span>.<span class="nb">WHAT</span>; <span class="c1">#=&gt; (Array)</span>
             <span class="c1"># Un cuantificador específico siempre capturará un Array,</span>
             <span class="c1">#  puede ser un rango o un valor específico (hasta 1).</span>

<span class="c1">## Las capturas son indezadas por anidación. Esto quiere decir que un grupo</span>
<span class="c1">## dentro de un grup estará anidado dentro de su grupo padre: `$/[0][0]`,</span>
<span class="c1">## para este código:</span>
<span class="s">&#39;hello-~-world&#39;</span> ~~<span class="sr"> / ( &#39;hello&#39; ( &lt;[ \- \~ ]&gt; + ) ) &#39;world&#39; /</span>;
<span class="nb">say</span> <span class="vg">$/</span>[<span class="mi">0</span>].<span class="nb">Str</span>; <span class="c1">#=&gt; hello~</span>
<span class="nb">say</span> <span class="vg">$/</span>[<span class="mi">0</span>][<span class="mi">0</span>].<span class="nb">Str</span>; <span class="c1">#=&gt; ~</span>

<span class="c1">## Esto se origina de un hecho bien simple: `$/` no contiene cadenas de</span>
<span class="c1">## texto, números enteros o arrays sino que solo contiene objetos Match.</span>
<span class="c1">## Estos objetos contienen los métodos `.list`, `.hash` y `.Str`. (Pero</span>
<span class="c1">## también puedes usar `match&lt;llave&gt;` para accesar un hash y `match[indice]`</span>
<span class="c1">## para accesar un array.</span>
<span class="nb">say</span> <span class="vg">$/</span>[<span class="mi">0</span>].<span class="n">list</span>.<span class="nb">perl</span>; <span class="c1">#=&gt; (Match.new(...),).list</span>
                     <span class="c1"># Podemos ver que es una lista de objetos Match.</span>
                     <span class="c1"># Estos contienen un montón de información: dónde la</span>
                     <span class="c1"># coincidencia comenzó o terminó, el &quot;ast&quot;</span>
                     <span class="c1"># (chequea las acciones más abajo), etc.</span>
                     <span class="c1"># Verás capturas nombradas más abajo con las gramáticas.</span>

<span class="c1">## Alternativas - el `or` de regexes</span>
<span class="c1">## Advertencia: Es diferente a los regexes de PCRE.</span>
<span class="nb">so</span> <span class="s">&#39;abc&#39;</span> ~~<span class="sr"> / a [ b | y ] c /</span>; <span class="c1"># `True`. o &quot;b&quot; o &quot;y&quot;.</span>
<span class="nb">so</span> <span class="s">&#39;ayc&#39;</span> ~~<span class="sr"> / a [ b | y ] c /</span>; <span class="c1"># `True`. Obviamente suficiente...</span>

<span class="c1">## La diferencia entre este `|` y el otro al que estás acustombrado es LTM.</span>
<span class="c1">## LTM significa &quot;Longest Token Matching&quot;, traducido libremente como</span>
<span class="c1">## &quot;Coincidencia de Token Más Larga&quot;. Esto significa que el motor (&quot;engine&quot;)</span>
<span class="c1">## siempre intentará coindidir tanto como sea posible en la cadena de texto.</span>
<span class="c1">## Básicamente, intentará el patrón más largo que concuerde con el regexp.</span>
<span class="s">&#39;foo&#39;</span> ~~<span class="sr"> / fo | foo /</span>; <span class="c1"># `foo` porque es más largo.</span>
<span class="c1">## Para decidir cual parte es la &quot;más larga&quot;, primero separa el regex en</span>
<span class="c1">## dos partes:</span>
<span class="c1">## El &quot;prefijo declarativo&quot; (la parte que puede ser analizada estáticamente)</span>
<span class="c1">## y las partes procedimentales.</span>
<span class="c1">## Los prefijos declarativos incluyen alternaciones (`|`), conjunciones (`&amp;`),</span>
<span class="c1">## invocaciones de sub-reglas (no han sido introducidos todavía), clases de</span>
<span class="c1">## caracteres y cuantificadores.</span>
<span class="c1">## Las partes procidimentales incluyen todo lo demás: referencias a elementos</span>
<span class="c1">## anteriores, aserciones de código, y otras cosas que tradicionalmente no pueden</span>
<span class="c1">## ser representadas por regexes normales.</span>
<span class="c1">##</span>
<span class="c1">## Entonces, todas las alternativas se intentan al mismo tiempo, y la</span>
<span class="c1">## más larga gana.</span>
<span class="c1">## Ejemplos:</span>
<span class="c1">## DECLARATIVO | PROCEDIMENTAL</span>
/ <span class="s">&#39;foo&#39;</span> \<span class="nb">d</span>+     [ <span class="s">&lt;subrule1&gt;</span> || <span class="s">&lt;subrule2&gt;</span> ] /;
<span class="c1">## DECLARATIVO (grupos anidados no son un problema)</span>
/ \<span class="nb">s</span>* [ \<span class="nb">w</span> &amp; <span class="n">b</span> ] [ <span class="n">c</span> | <span class="nb">d</span> ] /;
<span class="c1">## Sin embargo, las clausuras y la recursión (de regexes nombrados)</span>
<span class="c1">## son procedimentales.</span>
<span class="c1">## ... Hay más reglas complicadas, como la especifidad (los literales ganan</span>
<span class="c1">## son las clases de caracteres)</span>
+
<span class="c1">## Nota: la primera coincidencia `or` todavía existen, pero ahora se</span>
<span class="c1">## deletrea `||`</span>
<span class="s">&#39;foo&#39;</span> ~~<span class="sr"> / fo || foo /</span>; <span class="c1"># `fo` ahora.</span>
</pre></div>
<h2>Extra: la subrutina MAIN</h2>
<div class="highlight"><pre><span></span><span class="c1">## La subrutina `MAIN` se invoca cuando tu ejecuta un archivo de Raku</span>
<span class="c1">## directamente. Es realmente poderosa porque Raku actualmente parsea</span>
<span class="c1">## los argumentos y los pasas a la subrutina. También maneja argumentos</span>
<span class="c1">## nombrados (`--foo`) y hasta autogenerará un `--help`.</span>
<span class="k">sub</span> <span class="nb">MAIN</span>(<span class="nv">$nombre</span>) { <span class="nb">say</span> <span class="s">&quot;¡Hola, $nombre!&quot;</span> }
<span class="c1">## Esto produce:</span>
<span class="c1">##    $ raku cli.pl</span>
<span class="c1">##    Uso:</span>
<span class="c1">##      t.pl &lt;nombre&gt;</span>

<span class="c1">## Y dado que una subrutina regular en Raku, puedes tener múltiples</span>
<span class="c1">## despachos:</span>
<span class="c1">## (usando un &quot;Bool&quot; por un argumento nombrado para que podamos hacer</span>
<span class="c1">## `--replace` a cambio de `--replace=1`)</span>
<span class="k">subset</span> <span class="n">File</span> <span class="nb">of</span> <span class="nb">Str</span> <span class="n">where</span> *.<span class="nb">IO</span>.<span class="nb">d</span>; <span class="c1"># convierte a un objeto IO para chequear si</span>
                                 <span class="c1"># un archivo existe</span>

<span class="k">multi</span> <span class="nb">MAIN</span>(<span class="s">&#39;add&#39;</span>, <span class="nv">$key</span>, <span class="nv">$value</span>, <span class="nb">Bool</span> :<span class="nv">$replace</span>) { ... }
<span class="k">multi</span> <span class="nb">MAIN</span>(<span class="s">&#39;remove&#39;</span>, <span class="nv">$key</span>) { ... }
<span class="k">multi</span> <span class="nb">MAIN</span>(<span class="s">&#39;import&#39;</span>, <span class="n">File</span>, <span class="nb">Str</span> :<span class="nv">$as</span>) { ... } <span class="c1"># omitiendo parámetros nombrados</span>
<span class="c1">## Esto produce:</span>
<span class="c1">##    $ raku cli.pl</span>
<span class="c1">##    Uso:</span>
<span class="c1">##      t.pl [--replace] add &lt;key&gt; &lt;value&gt;</span>
<span class="c1">##      t.pl remove &lt;key&gt;</span>
<span class="c1">##      t.pl [--as=&lt;Str&gt;] import (File)</span>
<span class="c1">## Como puedes ver, esto es *realmente* poderoso.</span>
<span class="c1">## Fue tan lejos como para mostrar las constantes en líneas.</span>
<span class="c1">## (el tipo solo se muestra cuando el argumento `$`/ es nombrado)</span>
</pre></div>
<h2>APÉNDICE A:</h2>

<h3>Lista de cosas</h3>
<div class="highlight"><pre><span></span><span class="c1">## Consideramos que por ahora ya sabes lo básico de Raku.</span>
<span class="c1">## Esta sección es solo para listar algunas operaciones comunes</span>
<span class="c1">## las cuales no están en la &quot;parte principal&quot; del tutorial.</span>

<span class="c1">## Operadores</span>

<span class="c1">## * Comparación para ordenar</span>
<span class="c1">## Ellos returnan un valor de los enum `Order`:  `Less`, `Same` y `More`</span>
<span class="c1">##  (los cuales representan los números -1, 0 o +1).</span>
<span class="mi">1</span> &lt;=&gt; <span class="mi">4</span>; <span class="c1"># comparación de orden para caracteres numéricos</span>
<span class="s">&#39;a&#39;</span> <span class="o">leg</span> <span class="s">&#39;b&#39;</span>; <span class="c1"># comparación de orden para cadenas de texto</span>
<span class="nv">$obj</span> <span class="o">eqv</span> <span class="nv">$obj2</span>; <span class="c1"># comparación de orden usando la semántica eqv</span>

<span class="c1">## * Ordenación genérica</span>
<span class="mi">3</span> <span class="o">before</span> <span class="mi">4</span>; <span class="c1"># True</span>
<span class="s">&#39;b&#39;</span> <span class="nb">after</span> <span class="s">&#39;a&#39;</span>; <span class="c1"># True</span>

<span class="c1">## * Operador (por defecto) de circuito corto</span>
<span class="c1">## Al igual que `or` y `||`, pero devuelve el primer valor *defined*</span>
<span class="c1">## (definido):</span>
<span class="nb">say</span> <span class="nb">Any</span> // <span class="nb">Nil</span> // <span class="mi">0</span> // <span class="mi">5</span>; <span class="c1">#=&gt; 0</span>

<span class="c1">## * Circuito corto exclusivo or (XOR)</span>
<span class="c1">## Devuelve `True` si uno (y solo uno) de sus argumentos es verdadero:</span>
<span class="nb">say</span> <span class="nb">True</span> ^^ <span class="nb">False</span>; <span class="c1">#=&gt; True</span>

<span class="c1">## * Flip Flop</span>
<span class="c1">## Los operadores flip flop (`ff` y `fff`, equivalente a `..`/`...` en P5)</span>
<span class="c1">## son operadores que toman dos predicados para evalualarlos:</span>
<span class="c1">## Ellos son `False` hasta que su lado izquierdo devuelve `True`, entonces</span>
<span class="c1">## son `True` hasta que su lado derecho devuelve `True`.</span>
<span class="c1">## Como los rangos, tu puedes excluir la iteración cuando se convierte en</span>
<span class="c1">## `True`/`False` usando `^` en cualquier lado.</span>
<span class="c1">## Comencemos con un ejemplo:</span>
<span class="k">for</span> <span class="s">&lt;well met young hero we shall meet later&gt;</span> {
  <span class="c1"># por defecto, `ff`/`fff` hace coincidencia inteligente (`~~`) contra `$_`:</span>
  <span class="k">if</span> <span class="s">&#39;met&#39;</span> ^<span class="o">ff</span> <span class="s">&#39;meet&#39;</span> { <span class="c1"># no entrará el bucle if por &quot;met&quot;</span>
                        <span class="c1"># (se explica más abajo).</span>
    .<span class="nb">say</span>
  }

  <span class="k">if</span> <span class="nb">rand</span> == <span class="mi">0</span> <span class="o">ff</span> <span class="nb">rand</span> == <span class="mi">1</span> { <span class="c1"># compara variables más que `$_`</span>
    <span class="nb">say</span> <span class="s">&quot;Esto ... probablemente nunca se ejecutará ...&quot;</span>;
  }
}
<span class="c1">## Esto imprimirá &quot;young hero we shall meet&quot; (exluyendo &quot;met&quot;):</span>
<span class="c1">## el flip-flop comenzará devolviendo `True` cuando primero encuentra &quot;met&quot;</span>
<span class="c1">## (pero no returnará `False` por &quot;met&quot; dabido al `^` al frente de `ff`),</span>
<span class="c1">## hasta que ve &quot;meet&quot;, lo cual es cuando comenzará devolviendo `False`.</span>

<span class="c1">## La diferencia entre `ff` (al estilo de awk) y `fff` (al estilo de sed)</span>
<span class="c1">## es que `ff` probará su lado derecho cuando su lado izquierdo cambia</span>
<span class="c1">## a `True`, y puede returnar a `False` inmediamente (*excepto* que será</span>
<span class="c1">## `True` por la iteración con la cual coincidió). Por lo contrario,</span>
<span class="c1">## `fff` esperará por la próxima iteración para intentar su lado</span>
<span class="c1">## derecho, una vez que su lado izquierdo ha cambiado:</span>
.<span class="nb">say</span> <span class="k">if</span> <span class="s">&#39;B&#39;</span> <span class="o">ff</span> <span class="s">&#39;B&#39;</span> <span class="k">for</span> <span class="s">&lt;A B C B A&gt;</span>; <span class="c1">#=&gt; B B</span>
                                    <span class="c1"># porque el lado derecho se puso a prueba</span>
                                    <span class="c1"># directamente (y returnó `True`).</span>
                                    <span class="c1"># Las &quot;B&quot;s se imprimen dadó que coincidió</span>
                                    <span class="c1"># en ese momento (returnó a `False`</span>
                                    <span class="c1"># inmediatamente).</span>
.<span class="nb">say</span> <span class="k">if</span> <span class="s">&#39;B&#39;</span> <span class="o">fff</span> <span class="s">&#39;B&#39;</span> <span class="k">for</span> <span class="s">&lt;A B C B A&gt;</span>; <span class="c1">#=&gt; B C B</span>
                                     <span class="c1"># El lado derecho no se puso a prueba</span>
                                     <span class="c1"># hasta que `$_` se convirtió en &quot;C&quot;</span>
                                     <span class="c1"># (y por lo tanto no coincidió</span>
                                     <span class="c1"># inmediamente).</span>

<span class="c1">## Un flip-flop puede cambiar estado cuantas veces se necesite:</span>
<span class="k">for</span> <span class="s">&lt;test start print it stop not printing start print again stop not anymore&gt;</span> {
  .<span class="nb">say</span> <span class="k">if</span> <span class="nv">$_</span> <span class="o">eq</span> <span class="s">&#39;start&#39;</span> ^<span class="o">ff</span>^ <span class="nv">$_</span> <span class="o">eq</span> <span class="s">&#39;stop&#39;</span>; <span class="c1"># excluye a &quot;start&quot; y &quot;stop&quot;,</span>
                                           <span class="c1">#=&gt; &quot;print it print again&quot;</span>
}

<span class="c1">## También podrías usar una Whatever Star, lo cual es equivalente</span>
<span class="c1">## a `True` para el lado izquierdo o `False` para el lado derecho:</span>
<span class="k">for</span> (<span class="mi">1</span>, <span class="mi">3</span>, <span class="mi">60</span>, <span class="mi">3</span>, <span class="mi">40</span>, <span class="mi">60</span>) { <span class="c1"># Nota: los paréntesis son superfluos aquí</span>
                            <span class="c1"># (algunas veces se les llaman &quot;paréntesis superticiosos&quot;)</span>
 .<span class="nb">say</span> <span class="k">if</span> <span class="nv">$_</span> &gt; <span class="mi">50</span> <span class="o">ff</span> *; <span class="c1"># Una vez el flip-flop alcanza un número mayor que 50,</span>
                       <span class="c1"># no returnará jamás a `False`</span>
                       <span class="c1">#=&gt; 60 3 40 60</span>
}

<span class="c1">## También puedes usar esta propiedad para crear un `If`</span>
<span class="c1">## que no pasará la primera vez:</span>
<span class="k">for</span> <span class="s">&lt;a b c&gt;</span> {
  .<span class="nb">say</span> <span class="k">if</span> * ^<span class="o">ff</span> *; <span class="c1"># el flip-flop es `True` y nunca returna a `False`,</span>
                   <span class="c1"># pero el `^` lo hace *que no se ejecute* en la</span>
                   <span class="c1"># primera iteración</span>
                   <span class="c1">#=&gt; b c</span>
}

<span class="c1">## - `===` es la identidad de valor y usa `.WHICH`</span>
<span class="c1">## en los objetos para compararlos.</span>
<span class="c1">## - `=:=` es la identidad de contenedor y usa `VAR()`</span>
<span class="c1">## en los objetos para compararlos.</span>
</pre></div>
<p>Si quieres ir más allá de lo que se muestra aquí, puedes:</p>

<ul>
<li>Leer la <a href="https://docs.raku.org/">documentación de Raku</a>. Esto es un recurso
grandioso acerca de Raku. Si estás buscando por algo en particular, usa la
barra de búsquedas. Esto te dará un menú de todas las páginas concernientes
a tu término de búsqueda (¡Es mucho mejor que usar Google para encontrar
documentos acerca de Raku!)</li>
<li>Leer el <a href="https://rakuadventcalendar.wordpress.com/">Raku Advent Calendar</a>. Este es
un gran recurso de fragmentos de código de Raku y explicaciones. Si la documentación
no describe algo lo suficientemente bien, puedes encontrar información más detallada
aquí. Esta información puede ser un poquito más antigua pero hay muchos ejemplos y
explicaciones. Las publicaciones fueron suspendidas al final del 2015 cuando
el lenguaje fue declarado estable y Raku.c fue lanzado.</li>
<li>Unirte a <code>#raku</code> en <code>irc.freenode.net</code>. Las personas aquí son siempre serviciales.</li>
<li>Chequear la <a href="https://github.com/rakudo/rakudo/tree/master/src/core.c">fuente de las funciones y clases de Raku</a>. Rakudo está principalmente
escrito en Raku (con mucho de NQP, &ldquo;Not Quite Perl&rdquo; (&ldquo;No Perl Todavía&rdquo;), un
subconjunto de Raku que es más fácil de implementar y optimizar).</li>
<li>Leer <a href="http://design.raku.org">documentos acerca del diseño del lenguaje</a>.
Estos explican P6 desde la perspectiva de un implementador, lo cual es bastante
interesante.</li>
</ul>

    <hr>
    <p>¿Tienes una sugerencia o rectificación? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Abre un issue</a> en el repositorio de GitHub, o haz un <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/es-es/raku-es.html.markdown">pull request</a> tu mismo
    </p>
    <p class="contributed">
    Originalmente contribuido por vendethiel, y actualizado por <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/es-es/raku-es.html.markdown">4 colaborador(es)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://github.com/vendethiel">vendethiel</a>,
        <a href="https://cry.nu">Samantha McVey</a>
    </p>

    <p>
      Translated by:
        <a href="https://github.com/uzluisf">Luis F. Uceta</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
