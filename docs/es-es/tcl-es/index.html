<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="es-es" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="es-es" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="es-es" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="es-es" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="es-es">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Tcl in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/es-es/tcl-es/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fes-es%2Ftcl-es%2F&text=Aprende+X+en+Y+minutos%2C+donde+X%3DTcl">
        Comparte esta página
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Seleccione el tema:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">ligero</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">oscuro</button>
  </div>
  <h1><a href="/">Aprende X en Y minutos</a></h1>
  <h2>Donde X=Tcl</h2>
    <p class="filelink">
    Descarga el código:
    <a href="/docs/files/learntcl-es.tcl">learntcl-es.tcl</a>
    </p>
  <div id="doc">
    <p>Tcl fue creado por <a href="https://wiki.tcl.tk/John%20Ousterout">John Ousterhout</a> como
un lenguaje reutilizable de scripting para herramientas de diseño de circuitos
de las que él era autor.  En 1997 recibió el 
<a href="https://en.wikipedia.org/wiki/ACM_Software_System_Award">ACM Software System Award</a> 
por Tcl.   Tcl puede ser utilizado tanto como lenguaje de scripting embebido, 
como lenguaje de programación general.  Puede ser utilizado también como una
biblioteca portable de C, incluso en casos donde no se requieren capacidades
de scripting, ya que provee de estructuras de datos tales como cadenas (<em>string</em>)
de caracteres dinámicas, listas y tablas hash.  La biblioteca de C también
provee funcionalidad portable para cargar bibliotecas dinámicas, formato de
cadenas y conversión de código, operaciones sobre el sistema de ficheros,
operaciones de red y más.  Algunas características reseñables de Tcl:</p>

<ul>
<li><p>Conveniente API de red multiplataforma</p></li>
<li><p>Sistema de ficheros totalmente virtualizado</p></li>
<li><p>Canales apilables de E/S</p></li>
<li><p>Asíncrono hasta el núcleo</p></li>
<li><p>Corrutinas completas</p></li>
<li><p>Un modelo de hebras reconocido como robusto y fácil de usar</p></li>
</ul>

<p>Tcl tiene mucho en común con Lisp pero, en lugar de listas, Tcl utiliza cadenas
de caracteres como moneda de cambio del lenguaje.  Todos los valores son cadenas.
Una lista es una cadena con un formato definido, y el cuerpo de un procedimiento
(un script) es también una cadena en lugar de un bloque.  Para incrementar el
rendimiento, Tcl cachea internamente representaciones estructuradas de estos
valores.  Las rutinas con listas, por ejemplo, operan en la representación interna
en caché, y Tcl se ocupa de actualizar la representación en cadenas si es realmente
necesario en el script.  El diseño <em>copy-on-write</em> de Tcl permite a los autores
de scripts mover grandes volúmenes de datos sin incurrir en el consumo adicional
de memoria.  Los procedimientos son automáticamente compilados (<em>byte-compiled</em>)
a no ser que utilicen rutinas dinámicas como &ldquo;uplevel&rdquo;, &ldquo;upvar&rdquo; o &ldquo;trace&rdquo;.</p>

<p>Programar en Tcl es un placer.  Le resultará atractivo a hackers que encuentren
atractivo Lisp, Forth o Smalltalk, y a ingenieros y científicos que simplemente
quieren ponerse a trabajar con una herramienta que se doblega a su voluntad.  La
disciplina de exponer toda la funcionalidad programática como rutinas, incluyendo
cosas como iteraciones y operaciones matemáticas que normalmente están en la
sintaxis de otros lenguajes, permitiendo fundirse en el fondo de cualquier
funcionalidad específica del dominio que necesita un proyecto.  Su sintaxis,
incluso más simple que la de lisp, simplemente se quita de en medio.</p>
<div class="highlight"><pre><span></span><span class="c">#! /bin/env tclsh</span>

<span class="c">###############################################################################</span>
<span class="c">## 1. Directrices</span>
<span class="c">###############################################################################</span>

<span class="c"># ¡Tcl no es ni Sh ni C!  Es necesario decirlo porque el entrecomillado estándar</span>
<span class="c"># de shell casi funciona en Tcl, y es común que la gente empiece con Tcl e</span>
<span class="c"># intente utilizar sintaxis de otros lenguajes.  Funciona al principio, pero</span>
<span class="c"># rápidamente conduce a frustración cuando los scripts se vuelven más complejos.</span>

<span class="c"># Las llaves son un mecanismo de entrecomillado, no de sintaxis para la construcción</span>
<span class="c"># de bloques de código o listas.  Tcl no tiene ninguna de ellas.  Las llaves se</span>
<span class="c"># usan para escapar caracteres especiales, lo que las hace apropiadas para </span>
<span class="c"># entrecomillar cuerpos de procedimientos y cadenas que deberían ser interpretadas</span>
<span class="c"># como listas.</span>


<span class="c">###############################################################################</span>
<span class="c">## 2. Sintaxis</span>
<span class="c">###############################################################################</span>

<span class="c"># Un script consiste en comandos delimitados por saltos de línea o puntos y coma.</span>
<span class="c"># Cada comando es una llamada a una rutina.  La primera palabra es el nombre de</span>
<span class="c"># la rutina a llamar, y las siguientes palabras son argumentos de la rutina.</span>
<span class="c"># Las palabras están delimitadas por espacios.  Puesto que cada argumento es una</span>
<span class="c"># palabra en el comando, y una cadena de caracteres, puede no ser entrecomillada:</span>
<span class="k">set</span><span class="w"> </span>part1<span class="w"> </span>Sal
<span class="k">set</span><span class="w"> </span>part2<span class="w"> </span>ut<span class="k">;</span><span class="w"> </span><span class="k">set</span><span class="w"> </span>part3<span class="w"> </span>ations


<span class="c"># el símbolo del dólar introduce la sustitución de variables:</span>
<span class="k">set</span><span class="w"> </span>greeting<span class="w"> </span><span class="nv">$part1$part2$part3</span>


<span class="c"># Cuando &quot;set&quot;recibe sólamente el nombre de una variable, devuelve su valor:</span>
<span class="k">set</span><span class="w"> </span>part3<span class="w"> </span><span class="k">;</span><span class="c"># Returns the value of the variable.</span>


<span class="c"># Los corchetes delimitan un script que será evaluado y sustituido por su resultado:</span>
<span class="k">set</span><span class="w"> </span>greeting<span class="w"> </span><span class="nv">$part1$part2</span><span class="k">[set</span><span class="w"> </span>part3<span class="k">]</span>


<span class="c"># Un script incrustado puede estar compuesto de múltiples comandos, el último de</span>
<span class="c"># los cuales devuelve el resultado de la sustitución:</span>
<span class="k">set</span><span class="w"> </span>greeting<span class="w"> </span><span class="nv">$greeting</span><span class="k">[</span>
<span class="w">    </span><span class="nb">incr</span><span class="w"> </span>i
<span class="w">    </span><span class="nb">incr</span><span class="w"> </span>i
<span class="w">    </span><span class="nb">incr</span><span class="w"> </span>i
<span class="k">]</span>
<span class="nb">puts</span><span class="w"> </span><span class="nv">$greeting</span><span class="w"> </span><span class="k">;</span><span class="c"># La salida es &quot;Salutations3&quot;</span>

<span class="c"># Cada palabra en un comando es una cadena, incluyendo el nombre de la rutina,</span>
<span class="c"># así que se pueden utilizar sustituciones allí también. Dada esta asignación</span>
<span class="c"># de variable,</span>

<span class="k">set</span><span class="w"> </span>action<span class="w"> </span>pu

<span class="c"># los siguientes tres comandos son equivalentes:</span>
<span class="nb">puts</span><span class="w"> </span><span class="nv">$greeting</span>
<span class="nv">${action}ts</span><span class="w"> </span><span class="nv">$greeting</span><span class="w"> </span>
<span class="k">[set</span><span class="w"> </span>action<span class="k">]</span>ts<span class="w"> </span><span class="nv">$greeting</span>


<span class="c"># La barra invertida suprime el significado especial de los caracteres:</span>
<span class="k">set</span><span class="w"> </span>amount<span class="w"> </span><span class="err">\</span><span class="nv">$16.42</span>


<span class="c"># La barra invertida añade significado especial a ciertos caracteres:</span>
<span class="nb">puts</span><span class="w"> </span>lots<span class="err">\</span>nof<span class="err">\</span>n<span class="err">\</span>n<span class="err">\</span>n<span class="err">\</span>n<span class="err">\</span>n<span class="err">\</span>nnewlines


<span class="c"># Una palabra encerrada entre llaves no está sujeta a interpretación especial o</span>
<span class="c"># sustitución, excepto que una barra invertida antes de una llave no cuenta al</span>
<span class="c"># buscar la llave de cierre:</span>
<span class="k">set</span><span class="w"> </span>somevar<span class="w"> </span><span class="k">{</span>
<span class="w">    </span><span class="nv">This</span><span class="w"> </span>is<span class="w"> </span>a<span class="w"> </span>literal<span class="w"> </span><span class="err">$</span><span class="w"> </span>sign,<span class="w"> </span>and<span class="w"> </span>this<span class="w"> </span><span class="err">\</span><span class="k">}</span><span class="w"> </span>escaped
<span class="w">    </span><span class="nv">brace</span><span class="w"> </span>remains<span class="w"> </span>uninterpreted
<span class="k">}</span>


<span class="c"># En una palabra delimitada por comillas dobles, los espacios pierden su significado</span>
<span class="c"># especial:</span>
<span class="k">set</span><span class="w"> </span>name<span class="w"> </span>Neo
<span class="k">set</span><span class="w"> </span>greeting<span class="w"> </span><span class="s2">&quot;Hello, $name&quot;</span>


<span class="c"># Un nombre de variable puede ser cualquier cadena:</span>
<span class="k">set</span><span class="w"> </span><span class="k">{</span><span class="nv">first</span><span class="w"> </span>name<span class="k">}</span><span class="w"> </span>New


<span class="c"># La forma de sustitución de variables utilizando llaves permite nombres de</span>
<span class="c"># variable más complejos:</span>
<span class="k">set</span><span class="w"> </span>greeting<span class="w"> </span><span class="s2">&quot;Hello, ${first name}&quot;</span>


<span class="c"># &quot;set&quot; puede utilizarse siempre en lugar de la sustitución de variables, y permite</span>
<span class="c"># utilizar cualquier nombre de variable:</span>
<span class="k">set</span><span class="w"> </span>greeting<span class="w"> </span><span class="s2">&quot;Hello, [set {first name}]&quot;</span>


<span class="c"># Para desempaquetar una lista en un el comando, se utiliza el operador de expansión,</span>
<span class="c"># &quot;{*}&quot;.  Estos dos comandos son equivalentes:</span>
<span class="k">set</span><span class="w"> </span>name<span class="w"> </span>Neo
<span class="k">set</span><span class="w"> </span><span class="k">{</span><span class="o">*</span><span class="k">}{</span><span class="nv">name</span><span class="w"> </span>Neo<span class="k">}</span>


<span class="c"># Un array es una variable especial que sirve como contenedor de otras variables.</span>
<span class="k">set</span><span class="w"> </span>person<span class="k">(</span><span class="nv">name</span><span class="k">)</span><span class="w"> </span>Neo
<span class="k">set</span><span class="w"> </span>person<span class="k">(</span><span class="nv">destiny</span><span class="k">)</span><span class="w"> </span><span class="k">{</span><span class="nv">The</span><span class="w"> </span>One<span class="k">}</span>
<span class="k">set</span><span class="w"> </span>greeting<span class="w"> </span><span class="s2">&quot;Hello, $person(name)&quot;</span>


<span class="c"># &quot;variable&quot; se puede utilizar para declarar o asignar variables. Al contrario</span>
<span class="c"># que &quot;set&quot;, que utiliza el espacio de nombres global y el actual para resolver</span>
<span class="c"># un nombre de variable, &quot;variable&quot; usa solamente el actual:</span>
<span class="k">variable</span><span class="w"> </span>name<span class="w"> </span>New


<span class="c"># &quot;namespace eval&quot; crea un nuevo espacio de nombres en caso de no existir.</span>
<span class="c"># Un espacio de nombres puede contener tanto rutinas como variables:</span>
<span class="k">namespace</span><span class="w"> </span>eval<span class="w"> </span>people<span class="w"> </span><span class="k">{</span>
<span class="w">    </span><span class="k">namespace</span><span class="w"> </span>eval<span class="w"> </span>person1<span class="w"> </span><span class="k">{</span>
<span class="w">        </span><span class="k">variable</span><span class="w"> </span>name<span class="w"> </span>Neo
<span class="w">    </span><span class="k">}</span>
<span class="k">}</span>


<span class="c"># Use dos o más &quot;:&quot; para delimitar componentes del espacio de nombres en nombres</span>
<span class="c"># de variables:</span>
<span class="k">namespace</span><span class="w"> </span>eval<span class="w"> </span>people<span class="w"> </span><span class="k">{</span>
<span class="w">    </span><span class="k">set</span><span class="w"> </span>greeting<span class="w"> </span><span class="s2">&quot;Hello $person1::name&quot;</span>
<span class="k">}</span>

<span class="c"># Dos o más &quot;:&quot; también delimitan componentes del espacio de nombres en nombres</span>
<span class="c"># de rutinas:</span>
<span class="k">proc</span><span class="w"> </span>people::person1::speak<span class="w"> </span><span class="k">{}</span><span class="w"> </span><span class="k">{</span>
<span class="w">    </span><span class="nb">puts</span><span class="w"> </span><span class="k">{</span><span class="nv">I</span><span class="w"> </span>am<span class="w"> </span>The<span class="w"> </span>One.<span class="k">}</span>
<span class="k">}</span>

<span class="c"># Nombres completos comienzan con dos &quot;:&quot;:</span>
<span class="k">set</span><span class="w"> </span>greeting<span class="w"> </span><span class="s2">&quot;Hello $::people::person1::name&quot;</span>



<span class="c">###############################################################################</span>
<span class="c">## 3. No más sintaxis</span>
<span class="c">###############################################################################</span>

<span class="c"># El resto de funcionalidades se implementa mediante rutinas.  Desde este punto,</span>
<span class="c"># no hay nueva sintaxis.  Todo lo que queda para aprender Tcl es acerca del</span>
<span class="c"># comportamiento de rutinas individuales y el significado que asignan a sus</span>
<span class="c"># argumentos.</span>



<span class="c">###############################################################################</span>
<span class="c">## 4. Variables y espacios de nombres</span>
<span class="c">###############################################################################</span>

<span class="c"># Cada variable y cada rutina están asociadas a algún espacio de nombres</span>

<span class="c"># Para terminar con un intérprete inútil, sólo hay que eliminar el espacio de</span>
<span class="c"># nombres global.  No es algo muy útil, pero sirve para ilustrar la naturaleza</span>
<span class="c"># de Tcl.  El nombre del espacio de nombres global es en realidad la cadena</span>
<span class="c"># vacía, pero la única forma de representarlo es como un nombre completo. Para</span>
<span class="c"># probarlo, se puede usar esta rutina.</span>
<span class="k">proc</span><span class="w"> </span>delete_global_namespace<span class="w"> </span><span class="k">{}</span><span class="w"> </span><span class="k">{</span>
<span class="w">    </span><span class="k">namespace</span><span class="w"> </span>delete<span class="w"> </span><span class="o">::</span>
<span class="k">}</span>

<span class="c"># Como &quot;set&quot; siempre mantiene su vista en los espacios de nombres global y actual,</span>
<span class="c"># es más seguro utilizar &quot;variable&quot; para declarar o asignar un valor a una</span>
<span class="c"># variable.  Si una variable llamada &quot;nombre&quot; ya existe en el espacio de nombres</span>
<span class="c"># global, usar &quot;set&quot; asignará un valor a la variable local en lugar de a la</span>
<span class="c"># variable del espacio de nombres actual, mientras que &quot;variable&quot; opera en el</span>
<span class="c"># espacio de nombres actual solamente.</span>
<span class="k">namespace</span><span class="w"> </span>eval<span class="w"> </span>people<span class="w"> </span><span class="k">{</span>
<span class="w">    </span><span class="k">namespace</span><span class="w"> </span>eval<span class="w"> </span>person1<span class="w"> </span><span class="k">{</span>
<span class="w">        </span><span class="k">variable</span><span class="w"> </span>name<span class="w"> </span>Neo
<span class="w">    </span><span class="k">}</span>
<span class="k">}</span>

<span class="c"># Una vez que una variable es declarada en un espacio de nombres, [set] la vé</span>
<span class="c"># en lugar de una variable de idéntico nombre en el espacio de nombres global:</span>
<span class="k">namespace</span><span class="w"> </span>eval<span class="w"> </span>people<span class="w"> </span><span class="k">{</span>
<span class="w">    </span><span class="k">namespace</span><span class="w"> </span>eval<span class="w"> </span>person1<span class="w"> </span><span class="k">{</span>
<span class="w">        </span><span class="k">variable</span><span class="w"> </span>name
<span class="w">        </span><span class="k">set</span><span class="w"> </span>name<span class="w"> </span>Neo
<span class="w">    </span><span class="k">}</span>
<span class="k">}</span>

<span class="c"># En cambio, si &quot;set&quot; tiene que crear una nueva variable, siempre lo hace en el</span>
<span class="c"># espacio de nombres actual:</span>
<span class="k">unset</span><span class="w"> </span>name
<span class="k">namespace</span><span class="w"> </span>eval<span class="w"> </span>people<span class="w"> </span><span class="k">{</span>
<span class="w">    </span><span class="k">namespace</span><span class="w"> </span>eval<span class="w"> </span>person1<span class="w"> </span><span class="k">{</span>
<span class="w">        </span><span class="k">set</span><span class="w"> </span>name<span class="w"> </span>neo
<span class="w">    </span><span class="k">}</span>

<span class="k">}</span>
<span class="k">set</span><span class="w"> </span>people::person1::name


<span class="c"># Un nombre absoluto siempre comienza con el nombre del espacio de nombres global</span>
<span class="c"># (cadena vacía), seguido de dos &quot;:&quot;:</span>
<span class="k">set</span><span class="w"> </span><span class="o">::</span>people::person1::name<span class="w"> </span>Neo


<span class="c"># En el interior de un procedimiento, la variable enlaza una variable en el espacio</span>
<span class="c"># de nombres actual en el ámbito local:</span>
<span class="k">namespace</span><span class="w"> </span>eval<span class="w"> </span>people::person1<span class="w"> </span><span class="k">{</span>
<span class="w">    </span><span class="k">proc</span><span class="w"> </span>fly<span class="w"> </span><span class="k">{}</span><span class="w"> </span><span class="k">{</span>
<span class="w">        </span><span class="k">variable</span><span class="w"> </span>name
<span class="w">        </span><span class="nb">puts</span><span class="w"> </span><span class="s2">&quot;$name is flying!&quot;</span>
<span class="w">    </span><span class="k">}</span>
<span class="k">}</span>




<span class="c">###############################################################################</span>
<span class="c">## 4. Rutinas incorporadas</span>
<span class="c">###############################################################################</span>

<span class="c"># Las operaciones matemáticas se pueden hacer con &quot;expr&quot;:</span>
<span class="k">set</span><span class="w"> </span>a<span class="w"> </span><span class="mi">3</span>
<span class="k">set</span><span class="w"> </span>b<span class="w"> </span><span class="mi">4</span>
<span class="k">set</span><span class="w"> </span>c<span class="w"> </span><span class="k">[expr</span><span class="w"> </span><span class="k">{</span><span class="nv">$a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">$b</span><span class="k">}]</span>

<span class="c"># Como &quot;expr&quot; realiza sustituciones de variables por sí mismo, es necesario</span>
<span class="c"># poner la expresión entre llaves para prevenir a Tcl sustituir las variables</span>
<span class="c"># primero. Ver &quot;http://wiki.tcl.tk/Brace%20your%20#%20expr-essions&quot; para más</span>
<span class="c"># detalles.</span>


<span class="c"># &quot;expr&quot; entiende sustitución de variables y scripts:</span>
<span class="k">set</span><span class="w"> </span>c<span class="w"> </span><span class="k">[expr</span><span class="w"> </span><span class="k">{</span><span class="nv">$a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">[set</span><span class="w"> </span>b<span class="k">]}]</span>


<span class="c"># &quot;expr&quot; provee de un conjunto de funciones matemáticas:</span>
<span class="k">set</span><span class="w"> </span>c<span class="w"> </span><span class="k">[expr</span><span class="w"> </span><span class="k">{</span><span class="nv">pow</span><span class="k">(</span><span class="nv">$a</span>,<span class="nv">$b</span><span class="k">)}]</span>


<span class="c"># Los operadores matemáticos están disponibles como rutinas en el espacio de</span>
<span class="c"># nombres ::tcl::mathop</span>
<span class="o">::</span><span class="nv">tcl</span><span class="o">::</span>mathop::<span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">3</span>

<span class="c"># Las rutinas pueden ser importadas desde otros espacios de nombres:</span>
<span class="k">namespace</span><span class="w"> </span>import<span class="w"> </span><span class="o">::</span>tcl::mathop::<span class="o">+</span>
<span class="k">set</span><span class="w"> </span>result<span class="w"> </span><span class="k">[</span><span class="o">+</span><span class="w"> </span><span class="nv">5</span><span class="w"> </span><span class="mi">3</span><span class="k">]</span>


<span class="c"># Los valores no numéricos deben ser entrecomillados, y los operadores como &quot;eq&quot;</span>
<span class="c"># pueden utilizarse para restringir la operación a una comparación de cadenas:</span>
<span class="k">set</span><span class="w"> </span>name<span class="w"> </span>Neo
<span class="k">expr</span><span class="w"> </span><span class="k">{{</span><span class="nv">Bob</span><span class="k">}</span><span class="w"> </span><span class="nv">eq</span><span class="w"> </span><span class="nv">$name</span><span class="k">}</span>

<span class="c"># Los operadores generales recurren a la comparación de cadenas si una operación</span>
<span class="c"># numérica no es factible.</span>
<span class="k">expr</span><span class="w"> </span><span class="k">{{</span><span class="nv">Bob</span><span class="k">}</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nv">$name</span><span class="k">}</span>


<span class="c"># &quot;proc&quot; crea nuevas rutinas:</span>
<span class="k">proc</span><span class="w"> </span>greet<span class="w"> </span>name<span class="w"> </span><span class="k">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="s2">&quot;Hello, $name!&quot;</span>
<span class="k">}</span>

<span class="c"># Se pueden especificar múltiples parámetros:</span>
<span class="k">proc</span><span class="w"> </span>greet<span class="w"> </span><span class="k">{</span><span class="nv">greeting</span><span class="w"> </span>name<span class="k">}</span><span class="w"> </span><span class="k">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="s2">&quot;$greeting, $name!&quot;</span>
<span class="k">}</span>


<span class="c"># Como se dijo antes, las llaves no construyen un bloque de código.  Cada valor,</span>
<span class="c"># incluso el tercer argumento de &quot;proc&quot;, es una cadena.  El comando anterior</span>
<span class="c"># puede ser reescrito sin usar llaves:</span>
<span class="k">proc</span><span class="w"> </span>greet<span class="w"> </span>greeting<span class="err">\</span><span class="w"> </span>name<span class="w"> </span>return<span class="err">\</span><span class="w"> </span><span class="err">\</span><span class="s2">&quot;\$greeting,\ \$name!\&quot;</span>



<span class="s2"># Cuando el último parámetro es el valor literal &quot;</span>args<span class="s2">&quot;, todos los argumentos</span>
<span class="s2"># extra pasados a la rutina son recogidos en una lista y asignado a &quot;</span>args<span class="s2">&quot;:</span>
<span class="s2">proc fold {cmd first args} {</span>
<span class="s2">    foreach arg $args {</span>
<span class="s2">        set first [$cmd $first $arg]</span>
<span class="s2">    }</span>
<span class="s2">    return $first</span>
<span class="s2">}</span>
<span class="s2">fold ::tcl::mathop::* 5 3 3 ;# -&gt;  45</span>


<span class="s2"># La ejecución condicional se implementa como una rutina:</span>
<span class="s2">if {3 &gt; 4} {</span>
<span class="s2">    puts {This will never happen}</span>
<span class="s2">} elseif {4 &gt; 4} {</span>
<span class="s2">    puts {This will also never happen}</span>
<span class="s2">} else {</span>
<span class="s2">    puts {This will always happen}</span>
<span class="s2">}</span>


<span class="s2"># Los bucles se implementan como rutinas.  Los primer y tercer argumentos de &quot;</span>for<span class="s2">&quot;</span>
<span class="s2"># son tratados como scripts, mientras que el segundo lo es como una expresión:</span>
<span class="s2">set res 0</span>
<span class="s2">for {set i 0} {$i &lt; 10} {incr i} {</span>
<span class="s2">    set res [expr {$res + $i}]</span>
<span class="s2">}</span>
<span class="s2">unset res</span>


<span class="s2"># El primer argumento de &quot;</span>while<span class="s2">&quot; se trata también como una expresión:</span>
<span class="s2">set i 0</span>
<span class="s2">while {$i &lt; 10} {</span>
<span class="s2">    incr i 2</span>
<span class="s2">}</span>


<span class="s2"># Una lista es una cadena, y los elementos de la lista se delimitan con espacios</span>
<span class="s2"># en blanco:</span>
<span class="s2">set amounts 10\ 33\ 18</span>
<span class="s2">set amount [lindex $amounts 1]</span>

<span class="s2"># El espacio en blanco dentro de una lista debe ser entrecomillado:</span>
<span class="s2">set inventory {&quot;</span>item<span class="w"> </span><span class="mi">1</span><span class="s2">&quot; item\ 2 {item 3}}</span>


<span class="s2"># Generalmente, es mejor idea usar rutinas de listas al modificarlas:</span>
<span class="s2">lappend inventory {item 1} {item 2} {item 3}</span>


<span class="s2"># Las llaves y barras invertidas pueden utilizarse para formatear valores más</span>
<span class="s2"># complejos en una lista.  Una lista parece un script, excepto en que el carácter</span>
<span class="s2"># de nueva línea y el &quot;</span><span class="o">:</span><span class="s2">&quot; pierden su significado especial, y no hay sustitución</span>
<span class="s2"># de variable o scripts.  Esta característica hace Tcl homoicónico.  Hay tres</span>
<span class="s2"># elementos en la siguiente lista:</span>
<span class="s2">set values {</span>

<span class="s2">    one\ two</span>

<span class="s2">    {three four}</span>

<span class="s2">    five\{six</span>

<span class="s2">}</span>


<span class="s2"># Como, al igual que todos los valores, una lista es una cadena, operaciones de</span>
<span class="s2"># cadenas pueden ser realizadas sobre ellas, corriendo el riesgo de corromper</span>
<span class="s2"># el formato de la lista:</span>
<span class="s2">set values {one two three four}</span>
<span class="s2">set values [string map {two \{} $values] ;# $values is no-longer a \</span>
<span class="s2">    properly-formatted list</span>


<span class="s2"># La forma segura de conseguir una lista debidamente formateada es utilizando</span>
<span class="s2"># las rutinas propias de lista:</span>
<span class="s2">set values [list one \{ three four]</span>
<span class="s2">lappend values { } ;# add a single space as an item in the list</span>


<span class="s2"># Se puede utilizar &quot;</span>eval<span class="s2">&quot; para evaluar un valor como un script:</span>
<span class="s2">eval {</span>
<span class="s2">    set name Neo</span>
<span class="s2">    set greeting &quot;</span>Hello,<span class="w"> </span><span class="nv">$name</span><span class="s2">&quot;</span>
<span class="s2">}</span>


<span class="s2"># Una lista siempre puede ser pasada a &quot;</span>eval<span class="s2">&quot; como un script compuesto de un único</span>
<span class="s2"># comando:</span>
<span class="s2">eval {set name Neo}</span>
<span class="s2">eval [list set greeting &quot;Hello, $name&quot;]</span>


<span class="s2"># Por lo tanto, cuando se utiliza &quot;</span>eval<span class="s2">&quot;, use &quot;</span>list<span class="s2">&quot; para construir el comando</span>
<span class="s2"># deseado:</span>
<span class="s2">set command {set name}</span>
<span class="s2">lappend command {Archibald Sorbisol}</span>
<span class="s2">eval $command</span>


<span class="s2"># Un error común es no usar funciones de listas al construir un comando:</span>
<span class="s2">set command {set name}</span>
<span class="s2">append command { Archibald Sorbisol}</span>
<span class="s2">try {</span>
<span class="s2">    eval $command ;# El error es que &quot;</span>set<span class="s2">&quot; tiene demasiados argumentos en \</span>
<span class="s2">        {set name Archibald Sorbisol}</span>
<span class="s2">} on error {result eoptions} {</span>
<span class="s2">    puts [list {received an error} $result]</span>
<span class="s2">}</span>

<span class="s2"># Este error puede ocurrir fácilmente con &quot;</span>subst<span class="s2">&quot;:</span>

<span class="s2">set replacement {Archibald Sorbisol}</span>
<span class="s2">set command {set name $replacement}</span>
<span class="s2">set command [subst $command] </span>
<span class="s2">try {</span>
<span class="s2">    eval $command ;# El mismo error que antes:  demasiados argumentos a &quot;</span>set<span class="s2">&quot; en \</span>
<span class="s2">        {set name Archibald Sorbisol}</span>
<span class="s2">} trap {TCL WRONGARGS} {result options} {</span>
<span class="s2">    puts [list {received another error} $result]</span>
<span class="s2">}</span>


<span class="s2"># &quot;</span>list<span class="s2">&quot; formatea correctamente un valor para su sustitución:</span>
<span class="s2">set replacement [list {Archibald Sorbisol}]</span>
<span class="s2">set command {set name $replacement}</span>
<span class="s2">set command [subst $command]</span>
<span class="s2">eval $command</span>


<span class="s2"># &quot;</span>list<span class="s2">&quot; se utiliza normalmente para formatear valores para su sustitución en</span>
<span class="s2"># scripts: Hay muchos ejemplos de esto más abajo.</span>


<span class="s2"># &quot;</span>apply<span class="s2">&quot; evalúa una lista de dos elementos como una rutina:</span>
<span class="s2">set cmd {{greeting name} {</span>
<span class="s2">    return &quot;</span><span class="nv">$greeting</span>,<span class="w"> </span><span class="nv">$name</span><span class="o">!</span><span class="s2">&quot;</span>
<span class="s2">}}</span>
<span class="s2">apply $cmd Whaddup Neo</span>

<span class="s2"># Un tercer elemento puede ser utilizado para especificar el espacio de nombres</span>
<span class="s2"># donde aplicar la rutina:</span>
<span class="s2">set cmd [list {greeting name} {</span>
<span class="s2">    return &quot;$greeting, $name!&quot;</span>
<span class="s2">} [namespace current]]</span>
<span class="s2">apply $cmd Whaddup Neo</span>


<span class="s2"># &quot;</span>uplevel<span class="s2">&quot; evalúa un script en un nivel superior de la pila de llamadas:</span>
<span class="s2">proc greet {} {</span>
<span class="s2">    uplevel {puts &quot;</span><span class="nv">$greeting</span>,<span class="w"> </span><span class="nv">$name</span><span class="s2">&quot;}</span>
<span class="s2">}</span>

<span class="s2">proc set_double {varname value} {</span>
<span class="s2">    if {[string is double $value]} {</span>
<span class="s2">        uplevel [list variable $varname $value]</span>
<span class="s2">    } else {</span>
<span class="s2">        error [list {not a double} $value]</span>
<span class="s2">    }</span>
<span class="s2">}</span>


<span class="s2"># &quot;</span>upvar<span class="s2">&quot; enlaza una variable en el nivel actual de la pila de llamadas a una</span>
<span class="s2"># variable en un nivel superior:</span>
<span class="s2">proc set_double {varname value} {</span>
<span class="s2">    if {[string is double $value]} {</span>
<span class="s2">        upvar 1 $varname var</span>
<span class="s2">        set var $value</span>
<span class="s2">    } else {</span>
<span class="s2">        error [list {not a double} $value]</span>
<span class="s2">    }</span>
<span class="s2">}</span>


<span class="s2"># Deshacerse de la rutina &quot;</span>while<span class="s2">&quot; incorporada, y utilizar &quot;</span>proc<span class="s2">&quot; para definir</span>
<span class="s2"># una nueva:</span>
<span class="s2">rename ::while {}</span>
<span class="s2"># la manipulación se deja como ejercicio:</span>
<span class="s2">proc while {condition script} {</span>
<span class="s2">    if {[uplevel 1 [list expr $condition]]} {</span>
<span class="s2">        uplevel 1 $script</span>
<span class="s2">        tailcall [namespace which while] $condition $script</span>
<span class="s2">    }</span>
<span class="s2">}</span>


<span class="s2"># &quot;</span>coroutine<span class="s2">&quot; crea una nueva pila de llamadas, una nueva rutina en la que</span>
<span class="s2"># introducir esa pila de llamadas, y luego llama a dicha rutina. &quot;</span>yield<span class="s2">&quot; suspende</span>
<span class="s2"># la evaluación en esa pila y devuelve el control a la pila que efectúa la llamada.</span>
<span class="s2">proc countdown count {</span>
<span class="s2">    # devuelve algo al creador de la corrutina, efectivamente pausando esta</span>
<span class="s2">    # pila de llamadas por ahora.</span>
<span class="s2">    yield [info coroutine]</span>

<span class="s2">    while {$count &gt; 1} {</span>
<span class="s2">        yield [incr count -1]</span>
<span class="s2">    }</span>
<span class="s2">    return 0</span>
<span class="s2">}</span>
<span class="s2">coroutine countdown1 countdown 3</span>
<span class="s2">coroutine countdown2 countdown 5</span>
<span class="s2">puts [countdown1] ;# -&gt; 2 </span>
<span class="s2">puts [countdown2] ;# -&gt; 4 </span>
<span class="s2">puts [countdown1] ;# -&gt; 1 </span>
<span class="s2">puts [countdown1] ;# -&gt; 0 </span>
<span class="s2">catch {</span>
<span class="s2">    puts [coundown1] ;# -&gt; invalid command name &quot;</span>countdown1<span class="s2">&quot;</span>
<span class="s2">} cres copts </span>
<span class="s2">puts $cres</span>
<span class="s2">puts [countdown2] ;# -&gt; 3 </span>


<span class="s2"># Pilas de corrutinas pueden cederse el control entre sí:</span>

<span class="s2">proc pass {whom args} {</span>
<span class="s2">    return [yieldto $whom {*}$args]</span>
<span class="s2">}</span>

<span class="s2">coroutine a apply {{} {</span>
<span class="s2">        yield</span>
<span class="s2">        set result [pass b {please pass the salt}]</span>
<span class="s2">        puts [list got the $result]</span>
<span class="s2">        set result [pass b {please pass the pepper}]</span>
<span class="s2">        puts [list got the $result]</span>
<span class="s2">}}</span>

<span class="s2">coroutine b apply {{} {</span>
<span class="s2">    set request [yield]</span>
<span class="s2">    while 1 {</span>
<span class="s2">        set response [pass c $request]</span>
<span class="s2">        puts [list [info coroutine] is now yielding]</span>
<span class="s2">        set request [pass a $response]</span>
<span class="s2">    }</span>
<span class="s2">}}</span>

<span class="s2">coroutine c apply {{} {</span>
<span class="s2">    set request [yield]</span>
<span class="s2">    while 1 {</span>
<span class="s2">        if {[string match *salt* $request]} {</span>
<span class="s2">            set request [pass b salt]</span>
<span class="s2">        } else {</span>
<span class="s2">            set request [pass b huh?]</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">}}</span>

<span class="s2"># Pon las cosas en marcha</span>
<span class="s2">a</span>
</pre></div>
<h2>Reference</h2>

<p><a href="http://www.tcl.tk/man/tcl/">Documentación oficial de Tcl</a></p>

<p><a href="http://wiki.tcl.tk">Tcl Wiki</a></p>

<p><a href="http://www.reddit.com/r/Tcl">Tcl Subreddit</a></p>

    <hr>
    <p>¿Tienes una sugerencia o rectificación? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Abre un issue</a> en el repositorio de Github, o haz un <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/es-es/tcl-es.html.markdown">pull request</a> tu mismo
    </p>
    <p class="contributed">
    Originalmente contribuido por Poor Yorick, y actualizado por <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/es-es/tcl-es.html.markdown">0 colaborador(es)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="https://pooryorick.com/">Poor Yorick</a>
    </p>

    <p>
      Translated by:
        <a href="https://github.com/hromojaro">Héctor Romojaro</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
