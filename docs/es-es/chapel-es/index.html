<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="es-es" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="es-es" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="es-es" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="es-es" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="es-es">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn chapel in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/es-es/chapel-es/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fes-es%2Fchapel-es%2F&text=Aprende+X+en+Y+minutos%2C+donde+X%3Dchapel">
        Comparte esta página
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Seleccione el tema:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">ligero</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">oscuro</button>
  </div>
  <h1><a href="/">Aprende X en Y minutos</a></h1>
  <h2>Donde X=chapel</h2>
    <p class="filelink">
    Descarga el código:
    <a href="/docs/files/learnchapel.chpl">learnchapel.chpl</a>
    </p>
  <div id="doc">
    <p>Puede leer todo sobre Chapel en <a href="https://chapel-lang.org">el sitio web oficial de Chapel de Cray</a>.
En resumen, Chapel es un lenguaje de programación paralela, código abierto, de alta productividad
desarrolladp en Cray Inc. y está diseñado para ejecutarse en PC multi-nucleos, 
así como en supercomputadoras multi-kilocore.</p>

<p>Puede encontrar más información y asistencia al final de este documento.</p>
<div class="highlight"><pre><span></span><span class="c1">// Los comentarios son de estilo de la familia C</span>

<span class="c1">// comentario de una línea</span>
<span class="cm">/*</span>
<span class="cm"> comentario de múltiples lineas</span>
<span class="cm">*/</span>

<span class="c1">// Impresión básica</span>

<span class="nx">write</span><span class="p">(</span><span class="s">&quot;Hola, &quot;</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Mundo!&quot;</span><span class="p">);</span>

<span class="c1">// write y writeln pueden tomar una lista de cosas para imprimir.</span>
<span class="c1">// Cada cosa está impresa justo al lado de las demás, ¡así que incluye espacios!</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;hay &quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; comas (\&quot;,\&quot;) en esta línea de código&quot;</span><span class="p">);</span>

<span class="c1">// Diferentes canales de salida:</span>
<span class="nx">stdout</span><span class="p">.</span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Esto va a la salida estándar, al igual que lo hace writeln()&quot;</span><span class="p">);</span>
<span class="nx">stderr</span><span class="p">.</span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Esto va al error estándar&quot;</span><span class="p">);</span>


<span class="c1">// Las variables no tienen que escribirse explícitamente </span>
<span class="c1">// mientras el compilador pueda determinar el tipo que contendrá.</span>

<span class="c1">// 10 es un entero, asi que myVar es explícitamente un entero</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="nx">myVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">10</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">mySecondVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">myVar</span><span class="p">;</span>
<span class="c1">// var anError; sería un error en tiempo de compilación</span>

<span class="c1">// Podemos (y debemos) escribir cosas explícitamente.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myThirdVar</span><span class="p">:</span><span class="w"> </span><span class="kt">real</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myFourthVar</span><span class="p">:</span><span class="w"> </span><span class="kt">real</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">1.234</span><span class="p">;</span>
<span class="nx">myThirdVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">myFourthVar</span><span class="p">;</span>

<span class="c1">// Tipos</span>

<span class="c1">// Hay varios tipos básicos.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myInt</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="c1">// Enteros firmados</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myUint</span><span class="p">:</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1234</span><span class="p">;</span><span class="w"> </span><span class="c1">// Enteros sin-firmar</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myReal</span><span class="p">:</span><span class="w"> </span><span class="kt">real</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">9.876</span><span class="p">;</span><span class="w"> </span><span class="c1">// Números de punto flotante</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myImag</span><span class="p">:</span><span class="w"> </span><span class="kt">imag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">5.0i</span><span class="p">;</span><span class="w"> </span><span class="c1">// Números imaginarios</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myCplx</span><span class="p">:</span><span class="w"> </span><span class="kt">complex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">9i</span><span class="p">;</span><span class="w"> </span><span class="c1">// Números complejos</span>
<span class="nx">myCplx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">myInt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">myImag</span><span class="p">;</span><span class="w"> </span><span class="c1">// Otra manera de formar números complejos</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myBool</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Booleanos</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myStr</span><span class="p">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Una cadena...&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Cadenas</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">singleQuoteStr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#39;Otra cadena...&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Cadena literal con comillas simples</span>

<span class="c1">// Algunos tipos pueden tener tamaños.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">my8Int</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="c1">// Entero de 8 bit (one byte);</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">my64Real</span><span class="p">:</span><span class="w"> </span><span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.516</span><span class="p">;</span><span class="w"> </span><span class="c1">// Real de 64 bit (8 bytes)</span>

<span class="c1">// Conversion de tipos.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">intFromReal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">myReal</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">intFromReal2</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">myReal</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>

<span class="c1">// Alias de tipo.</span>
<span class="kd">type</span><span class="w"> </span><span class="nx">chroma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w">        </span><span class="c1">// Tipo de un solo tono</span>
<span class="kd">type</span><span class="w"> </span><span class="nx">RGBColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">*</span><span class="nx">chroma</span><span class="p">;</span><span class="w"> </span><span class="c1">// Tipo que representa un color completo</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">black</span><span class="p">:</span><span class="w"> </span><span class="nx">RGBColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">white</span><span class="p">:</span><span class="w"> </span><span class="nx">RGBColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">255</span><span class="p">,</span><span class="w"> </span><span class="mi">255</span><span class="p">,</span><span class="w"> </span><span class="mi">255</span><span class="p">);</span>

<span class="c1">// Constantes y Parámetros</span>

<span class="c1">// una variable const es una constante y no se puede cambiar después de</span>
<span class="c1">// establecerla en tiempo de ejecución.</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">almostPi</span><span class="p">:</span><span class="w"> </span><span class="kt">real</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">22.0</span><span class="o">/</span><span class="mf">7.0</span><span class="p">;</span>

<span class="c1">// Un parámetro es una constante cuyo valor debe conocerse estáticamente </span>
<span class="c1">// en tiempo de compilación.</span>

<span class="kd">param</span><span class="w"> </span><span class="nx">compileTimeConst</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>

<span class="c1">// El modificador de configuración permite establecer valores en la línea de comando.</span>
<span class="c1">// Establece valores con --varCmdLineArg=Value o --varCmdLineArg Value en tiempo de ejecución.</span>
<span class="kd">config</span><span class="w"> </span><span class="kd">var</span><span class="w"> </span><span class="nx">varCmdLineArg</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">123</span><span class="p">;</span>
<span class="kd">config</span><span class="w"> </span><span class="kd">const</span><span class="w"> </span><span class="nx">constCmdLineArg</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">777</span><span class="p">;</span>

<span class="c1">// config param se puede configurar en tiempo de compilación.</span>
<span class="c1">// Establece valores con --set paramCmdLineArg=value  en tiempo de compilación.</span>
<span class="kd">config</span><span class="w"> </span><span class="kd">param</span><span class="w"> </span><span class="nx">paramCmdLineArg</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">varCmdLineArg</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">constCmdLineArg</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">paramCmdLineArg</span><span class="p">);</span>

<span class="c1">// Referencias</span>

<span class="c1">// ref funciona de manera muy similar a una referencia en C ++. En Chapel, </span>
<span class="c1">// no se puede hacer una referencia como alias a una variable distinta </span>
<span class="c1">// de la variable con la que se inicializa.</span>

<span class="c1">// Aquí, refToActual se refiere a actual.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">actual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="kd">ref</span><span class="w"> </span><span class="nx">refToActual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">actual</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">actual</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; == &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">refToActual</span><span class="p">);</span><span class="w"> </span><span class="c1">// imprime el mismo valor</span>
<span class="nx">actual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">123</span><span class="p">;</span><span class="w"> </span><span class="c1">// modificar actual (a lo que refToActual se refiere)</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">actual</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; == &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">refToActual</span><span class="p">);</span><span class="w"> </span><span class="c1">// imprime el mismo valor</span>
<span class="nx">refToActual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">99999999</span><span class="p">;</span><span class="w"> </span><span class="c1">//  modificar a qué se refiere refToActual (que es actual)</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">actual</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; == &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">refToActual</span><span class="p">);</span><span class="w"> </span><span class="c1">// imprime el mismo valor</span>

<span class="c1">// Operadores</span>

<span class="c1">// Operadores matemáticos:</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">a</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1234</span><span class="p">,</span><span class="w"> </span><span class="nx">thatInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5678</span><span class="p">;</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">  </span><span class="c1">// Adicción</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">  </span><span class="c1">// Multiplicación</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">  </span><span class="c1">// Substracción</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">  </span><span class="c1">// División</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w"> </span><span class="c1">// Exponenciación</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">  </span><span class="c1">// residuo (módulo)</span>

<span class="c1">// Operadores logicos:</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">b</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="nx">thisBool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="nx">thatBool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisBool</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">thatBool</span><span class="p">;</span><span class="w"> </span><span class="c1">// Lógico y</span>
<span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisBool</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">thatBool</span><span class="p">;</span><span class="w"> </span><span class="c1">// Lógico o</span>
<span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="nx">thisBool</span><span class="p">;</span><span class="w">            </span><span class="c1">// Lógico negación</span>

<span class="c1">// Operadores relacionales:</span>
<span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">           </span><span class="c1">// Mas grande que</span>
<span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">          </span><span class="c1">// Mas grande o igual que</span>
<span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w"> </span><span class="c1">// Menor que, y, Menor o igual que</span>
<span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">          </span><span class="c1">// No es igual a</span>
<span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">          </span><span class="c1">// es igual a</span>

<span class="c1">// Operadores bit a bit:</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">     </span><span class="c1">// Desplazamiento de bit izquierdo por 10 bits;</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thatInt</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">      </span><span class="c1">// Desplazamiento de bit derecho por 5 bits;</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">~</span><span class="nx">thisInt</span><span class="p">;</span><span class="w">          </span><span class="c1">// Negación bit a bit</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w"> </span><span class="c1">// bit a bit exclusivo o</span>

<span class="c1">// Operadores de asignación compuesta:</span>
<span class="nx">a</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">thisInt</span><span class="p">;</span><span class="w">          </span><span class="c1">// Adición-igual (a = a + thisInt;)</span>
<span class="nx">a</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">          </span><span class="c1">// Multiplicación-igual (a = a * thatInt;)</span>
<span class="nx">b</span><span class="w"> </span><span class="o">&amp;&amp;=</span><span class="w"> </span><span class="nx">thatBool</span><span class="p">;</span><span class="w">        </span><span class="c1">// Lógico e igual (b = b &amp;&amp; thatBool;)</span>
<span class="nx">a</span><span class="w"> </span><span class="o">&lt;&lt;=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">               </span><span class="c1">// Desplazamiento a la izquierda igual (a = a &lt;&lt; 10;)</span>

<span class="c1">// A diferencia de otros lenguajes de familia C, no hay operadores de </span>
<span class="c1">// pre / post-incremento / decremento, tales como:</span>
<span class="c1">//</span>
<span class="c1">// ++j, --j, j++, j--</span>

<span class="c1">// Operador de intercambio:</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">old_this</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">old_that</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span>
<span class="nx">thisInt</span><span class="w"> </span><span class="o">&lt;=&gt;</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w"> </span><span class="c1">// Intercambia los valores de thisInt y thatInt</span>
<span class="nx">writeln</span><span class="p">((</span><span class="nx">old_this</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="nx">old_that</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">thisInt</span><span class="p">));</span>

<span class="c1">// También se pueden definir sobrecargas del operador, como veremos con los procedimientos.</span>

<span class="c1">// Tuplas</span>

<span class="c1">// Las tuplas pueden ser del mismo tipo o de diferentes tipos.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">sameTup</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">sameTup2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">6</span><span class="p">);</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">diffTup</span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">real</span><span class="p">,</span><span class="kt">complex</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mf">1.928</span><span class="p">,</span><span class="w"> </span><span class="nx">myCplx</span><span class="p">);</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">diffTupe2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mf">5.64</span><span class="p">,</span><span class="w"> </span><span class="mf">6.0</span><span class="o">+</span><span class="m">1.5i</span><span class="p">);</span>

<span class="c1">// Se puede acceder a las tuplas usando corchetes o paréntesis,</span>
<span class="c1">// y están indexadas en base 1.</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;(&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">sameTup</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">sameTup</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">diffTup</span><span class="p">);</span>

<span class="c1">// Las tuplas también se pueden escribir.</span>
<span class="nx">diffTup</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="c1">// Los valores de tupla se pueden expandir a sus propias variables.</span>
<span class="kd">var</span><span class="w"> </span><span class="p">(</span><span class="nx">tupInt</span><span class="p">,</span><span class="w"> </span><span class="nx">tupReal</span><span class="p">,</span><span class="w"> </span><span class="nx">tupCplx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">diffTup</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">diffTup</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="nx">tupInt</span><span class="p">,</span><span class="w"> </span><span class="nx">tupReal</span><span class="p">,</span><span class="w"> </span><span class="nx">tupCplx</span><span class="p">));</span>

<span class="c1">// También son útiles para imprimit una lista de variables, </span>
<span class="c1">// como es común en la depuración.</span>
<span class="nx">writeln</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">thisInt</span><span class="p">,</span><span class="nx">thatInt</span><span class="p">,</span><span class="nx">thisBool</span><span class="p">,</span><span class="nx">thatBool</span><span class="p">));</span>

<span class="c1">// Flujo de control</span>

<span class="c1">// if - then - else funciona como cualquier otro lenguaje de la familia C.</span>
<span class="k">if</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="k">then</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;All is well&quot;</span><span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">then</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Continuando creyendo en la realidad&quot;</span><span class="p">);</span>
<span class="k">else</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;¡Envia un matemático!, algo está mal&quot;</span><span class="p">);</span>

<span class="c1">// Puedes usar paréntesis si lo prefieres.</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">10</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;El Universo está roto, Por favor reinicie el universo.&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; es par.&quot;</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; es impar.&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; es divisible entre 3.&quot;</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; es divisible entre 3 con un residuo de 1.&quot;</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; es divisible entre 3 con un residuo de 2.&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Ternario:  if - then - else en una declaración.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">maximum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">thatInt</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="nx">thatInt</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="nx">thisInt</span><span class="p">;</span>

<span class="c1">// las declaraciones select son muy parecidas a las declaraciones switch</span>
<span class="c1">// en otros idiomas. Sin embargo, las declaraciones select no caen </span>
<span class="c1">// en cascada como en C o Java.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">inputOption</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;anOption&quot;</span><span class="p">;</span>
<span class="k">select</span><span class="w"> </span><span class="nx">inputOption</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">when</span><span class="w"> </span><span class="s">&quot;anOption&quot;</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Escoge &#39;anOption&#39;&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">when</span><span class="w"> </span><span class="s">&quot;otherOption&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Escoge &#39;otherOption&#39;&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Que tiene un cuerpo&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">otherwise</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Cualquier otra entrada&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;El caso otherwise no necesita hacerse si el cuerpo es de una línea&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Los bucles while y do-while también se comportan como sus contrapartes en C.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">j</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">jSum</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nx">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1000</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">jSum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">j</span><span class="p">;</span>
<span class="w">  </span><span class="nx">j</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">jSum</span><span class="p">);</span>

<span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">jSum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">j</span><span class="p">;</span>
<span class="w">  </span><span class="nx">j</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nx">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">10000</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">jSum</span><span class="p">);</span>

<span class="c1">// Los bucles for son muy parecidos a los de Python porque iteran en un rango. </span>
<span class="c1">// Los rangos (como la expresión 1..10 a continuación) son un objeto de primera clase</span>
<span class="c1">// en Chapel, y como tal pueden almacenarse en variables.</span>
<span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">write</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">();</span>

<span class="kd">var</span><span class="w"> </span><span class="nx">iSum</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">1000</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">iSum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">i</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">iSum</span><span class="p">);</span>

<span class="k">for</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">write</span><span class="p">((</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;\t&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Rangos y Dominios</span>

<span class="c1">// Los bucles y matrices utilizan rangos y dominios para definir un conjunto de índices</span>
<span class="c1">// que se pueden iterar. Los rangos son índices enteros unidimensionales, mientras </span>
<span class="c1">// que los dominios pueden ser multidimensionales y representan índices </span>
<span class="c1">// de diferentes tipos.</span>

<span class="c1">// Son tipos ciudadanos de primera clase y pueden asignarse a variables.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">range1to10</span><span class="p">:</span><span class="w"> </span><span class="kt">range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">;</span><span class="w">  </span><span class="c1">// 1, 2, 3, ..., 10</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">range2to11</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="o">..</span><span class="mi">11</span><span class="p">;</span><span class="w"> </span><span class="c1">// 2, 3, 4, ..., 11</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">rangeThisToThat</span><span class="p">:</span><span class="w"> </span><span class="kt">range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="o">..</span><span class="nx">thatInt</span><span class="p">;</span><span class="w"> </span><span class="c1">// usando variables</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">rangeEmpty</span><span class="p">:</span><span class="w"> </span><span class="kt">range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="o">..-</span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="c1">// esto es válido pero no contiene índices</span>

<span class="c1">// Los rangos pueden ser ilimitados.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">range1toInf</span><span class="p">:</span><span class="w"> </span><span class="kt">range</span><span class="p">(</span><span class="nx">boundedType</span><span class="o">=</span><span class="nx">BoundedRangeType</span><span class="p">.</span><span class="nx">boundedLow</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="c1">// 1, 2, 3, 4, 5, ...</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">rangeNegInfTo1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">..</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// ..., -4, -3, -2, -1, 0, 1</span>

<span class="c1">// Los rangos se pueden andar (y revertir) utilizando el operador by.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">range2to10by2</span><span class="p">:</span><span class="w"> </span><span class="kt">range</span><span class="p">(</span><span class="nx">stridable</span><span class="o">=</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// 2, 4, 6, 8, 10</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">reverse2to10by2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// 10, 8, 6, 4, 2</span>

<span class="kd">var</span><span class="w"> </span><span class="nx">trapRange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="o">..</span><span class="mi">1</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// No te dejes engañar, esto sigue siendo un rango vacío</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Size of range &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">trapRange</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; = &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">trapRange</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>

<span class="c1">// Note: range(boundedType= ...) and range(stridable= ...) solo son necesarios </span>
<span class="c1">// si escribimos explícitamente la variable.</span>

<span class="c1">// El punto final de un rango se puede determinar utilizando el operador de conteo (#).</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">rangeCount</span><span class="p">:</span><span class="w"> </span><span class="kt">range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">5</span><span class="o">..#</span><span class="mi">12</span><span class="p">;</span><span class="w"> </span><span class="c1">// intervalo de -5 to 6</span>

<span class="c1">// Los operadores pueden ser mixtos.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">rangeCountBy</span><span class="p">:</span><span class="w"> </span><span class="kt">range</span><span class="p">(</span><span class="nx">stridable</span><span class="o">=</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">5</span><span class="o">..#</span><span class="mi">12</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// -5, -3, -1, 1, 3, 5</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">rangeCountBy</span><span class="p">);</span>

<span class="c1">// Se pueden consultar las propiedades del rango.</span>
<span class="c1">// En este ejemplo, imprime el primer índice, el último índice, el número de índices,</span>
<span class="c1">// el paso y si 2 se incluye en el rango.</span>
<span class="nx">writeln</span><span class="p">((</span><span class="nx">rangeCountBy</span><span class="p">.</span><span class="nx">first</span><span class="p">,</span><span class="w"> </span><span class="nx">rangeCountBy</span><span class="p">.</span><span class="nx">last</span><span class="p">,</span><span class="w"> </span><span class="nx">rangeCountBy</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span>
<span class="w">           </span><span class="nx">rangeCountBy</span><span class="p">.</span><span class="nx">stride</span><span class="p">,</span><span class="w"> </span><span class="nx">rangeCountBy</span><span class="p">.</span><span class="nx">member</span><span class="p">(</span><span class="mi">2</span><span class="p">)));</span>

<span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">rangeCountBy</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">write</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">rangeCountBy</span><span class="p">.</span><span class="nx">last</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="s">&quot;\n&quot;</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Los dominios rectangulares se definen usando la misma sintaxis de rango, </span>
<span class="c1">// pero se requiere que estén delimitados (a diferencia de los rangos).</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">domain1to10</span><span class="p">:</span><span class="w"> </span><span class="k">domain</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">};</span><span class="w">        </span><span class="c1">// 1D domain from 1..10;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">twoDimensions</span><span class="p">:</span><span class="w"> </span><span class="k">domain</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="o">..</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="o">..</span><span class="mi">2</span><span class="p">};</span><span class="w"> </span><span class="c1">// 2D domain over product of ranges</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">thirdDim</span><span class="p">:</span><span class="w"> </span><span class="kt">range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">16</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">threeDims</span><span class="p">:</span><span class="w"> </span><span class="k">domain</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="nx">thirdDim</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="o">..</span><span class="mi">10</span><span class="p">};</span><span class="w"> </span><span class="c1">// using a range variable</span>

<span class="c1">// Los dominios también pueden ser redimensionados</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">resizedDom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">};</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;antes, resizedDom = &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">resizedDom</span><span class="p">);</span>
<span class="nx">resizedDom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="o">-</span><span class="mi">10</span><span class="o">..#</span><span class="mi">10</span><span class="p">};</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;despues, resizedDom = &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">resizedDom</span><span class="p">);</span>

<span class="c1">// Los índices pueden iterarse como tuplas.</span>
<span class="k">for</span><span class="w"> </span><span class="nx">idx</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">twoDimensions</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="nx">write</span><span class="p">(</span><span class="nx">idx</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">();</span>

<span class="c1">// Estas tuplas también pueden ser deconstruidas.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">)</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">twoDimensions</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">write</span><span class="p">(</span><span class="s">&quot;(&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">writeln</span><span class="p">();</span>

<span class="c1">// Los dominios asociativos actúan como conjuntos.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">stringSet</span><span class="p">:</span><span class="w"> </span><span class="k">domain</span><span class="p">(</span><span class="kt">string</span><span class="p">);</span><span class="w"> </span><span class="c1">// empty set of strings</span>
<span class="nx">stringSet</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="p">;</span>
<span class="nx">stringSet</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;b&quot;</span><span class="p">;</span>
<span class="nx">stringSet</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;c&quot;</span><span class="p">;</span>
<span class="nx">stringSet</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Redundant add &quot;a&quot;</span>
<span class="nx">stringSet</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="s">&quot;c&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Remove &quot;c&quot;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">stringSet</span><span class="p">.</span><span class="nx">sorted</span><span class="p">());</span>

<span class="c1">// Los dominios asociativos también pueden tener una sintaxis literal</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">intSet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">};</span>

<span class="c1">// Tanto los rangos como los dominios se pueden dividir para producir un rango </span>
<span class="c1">// o dominio con la intersección de los índices.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">rangeA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="c1">// range from 1 to infinity</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">rangeB</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="o">..</span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// range from negative infinity to 5</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">rangeC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">rangeA</span><span class="p">[</span><span class="nx">rangeB</span><span class="p">];</span><span class="w"> </span><span class="c1">// resulting range is 1..5</span>
<span class="nx">writeln</span><span class="p">((</span><span class="nx">rangeA</span><span class="p">,</span><span class="w"> </span><span class="nx">rangeB</span><span class="p">,</span><span class="w"> </span><span class="nx">rangeC</span><span class="p">));</span>

<span class="kd">var</span><span class="w"> </span><span class="nx">domainA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="o">..</span><span class="mi">20</span><span class="p">};</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">domainB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="o">-</span><span class="mi">5</span><span class="o">..</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">};</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">domainC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">domainA</span><span class="p">[</span><span class="nx">domainB</span><span class="p">];</span>
<span class="nx">writeln</span><span class="p">((</span><span class="nx">domainA</span><span class="p">,</span><span class="w"> </span><span class="nx">domainB</span><span class="p">,</span><span class="w"> </span><span class="nx">domainC</span><span class="p">));</span>

<span class="c1">// Matrices</span>

<span class="c1">// Las matrices son similares a otros lenguajes.</span>
<span class="c1">// Sus tamaños son definidos usndo dominions que repretsenten sus indices.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">intArray</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">intArray2</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">}]</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w"> </span><span class="c1">// equivalent</span>

<span class="c1">// Pueden ser accedidos usando brackets o paréntesis</span>
<span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="nx">intArray</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="nx">i</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">intArray</span><span class="p">);</span>

<span class="c1">// No podemos acceder a intArray[0] porque existe fuera del conjunto de índices,</span>
<span class="c1">// {1..10}, que definimos al principio. </span>
<span class="c1">// intArray [11] es ilegal por la misma razón.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">realDomain</span><span class="p">:</span><span class="w"> </span><span class="k">domain</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="o">..</span><span class="mi">7</span><span class="p">};</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">realArray</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="nx">realDomain</span><span class="p">]</span><span class="w"> </span><span class="kt">real</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">realArray2</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="o">..</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="kt">real</span><span class="p">;</span><span class="w">   </span><span class="c1">// equivalent</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">realArray3</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="o">..</span><span class="mi">7</span><span class="p">}]</span><span class="w"> </span><span class="kt">real</span><span class="p">;</span><span class="w"> </span><span class="c1">// equivalent</span>

<span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">realDomain</span><span class="p">.</span><span class="nx">dim</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">   </span><span class="c1">// Solo use la segunda dimensión del dominio</span>
<span class="w">    </span><span class="nx">realArray</span><span class="p">[</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">1.61803</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">j</span><span class="p">;</span><span class="w">  </span><span class="c1">// Acceso usando la lista de índice</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">idx</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">);</span><span class="w">                   </span><span class="c1">// Nota: &#39;índice&#39; es una palabra reservada</span>
<span class="w">    </span><span class="nx">realArray</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">realArray</span><span class="p">[(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)];</span><span class="w">      </span><span class="c1">// Indice usando tuplas</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Las matrices tienen dominios como miembros y pueden ser iterados de manera normal.</span>
<span class="k">for</span><span class="w"> </span><span class="nx">idx</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">realArray</span><span class="p">.</span><span class="k">domain</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// De nuevo, idx es una tupla 2*int</span>
<span class="w">  </span><span class="nx">realArray</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">realArray</span><span class="p">[</span><span class="nx">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="nx">idx</span><span class="p">[</span><span class="mi">2</span><span class="p">]];</span><span class="w"> </span><span class="c1">// Acceso por tupla y lista</span>
<span class="p">}</span>

<span class="nx">writeln</span><span class="p">(</span><span class="nx">realArray</span><span class="p">);</span>

<span class="c1">// Los valores de una matriz también se pueden iterar directamente.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">rSum</span><span class="p">:</span><span class="w"> </span><span class="kt">real</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">realArray</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">rSum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">value</span><span class="p">;</span><span class="w"> </span><span class="c1">// Read a value</span>
<span class="w">  </span><span class="nx">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">rSum</span><span class="p">;</span><span class="w">  </span><span class="c1">// Write a value</span>
<span class="p">}</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">rSum</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">realArray</span><span class="p">);</span>

<span class="c1">// Las matrices asociativas (diccionarios) se pueden crear utilizando dominios asociativos.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">dictDomain</span><span class="p">:</span><span class="w"> </span><span class="k">domain</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;one&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;two&quot;</span><span class="w"> </span><span class="p">};</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">dict</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="nx">dictDomain</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;one&quot;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;two&quot;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span>
<span class="nx">dict</span><span class="p">[</span><span class="s">&quot;three&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// Adiciona &#39;three&#39; a &#39;dictDomain&#39; implícitamente</span>
<span class="k">for</span><span class="w"> </span><span class="nx">key</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">dictDomain</span><span class="p">.</span><span class="nx">sorted</span><span class="p">()</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">dict</span><span class="p">[</span><span class="nx">key</span><span class="p">]);</span>

<span class="c1">// Las matrices se pueden asignar entre sí de diferentes maneras.</span>
<span class="c1">// Estos arreglos se usarán en el ejemplo.</span>

<span class="kd">var</span><span class="w"> </span><span class="nx">thisArray</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">thatArray</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>

<span class="c1">// Primero, simplemente asigna uno al otro. Esto copia esta matriz en</span>
<span class="c1">// thatArray, en lugar de simplemente crear una referencia. Por lo tanto, modificando</span>
<span class="c1">// thisArray tampoco modifica thatArray.</span>
<span class="nx">thatArray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisArray</span><span class="p">;</span>
<span class="nx">thatArray</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">((</span><span class="nx">thisArray</span><span class="p">,</span><span class="w"> </span><span class="nx">thatArray</span><span class="p">));</span>

<span class="c1">// Asigna un segmento de una matriz a un segmento (del mismo tamaño) en el otro.</span>
<span class="nx">thatArray</span><span class="p">[</span><span class="mi">4</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisArray</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">2</span><span class="p">];</span>
<span class="nx">writeln</span><span class="p">((</span><span class="nx">thisArray</span><span class="p">,</span><span class="w"> </span><span class="nx">thatArray</span><span class="p">));</span>

<span class="c1">// Las operaciones también se pueden promover para trabajar en arreglos. </span>
<span class="c1">// &#39;thisPlusThat&#39; también es una matriz.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">thisPlusThat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisArray</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">thatArray</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">thisPlusThat</span><span class="p">);</span>

<span class="c1">// Continuando, las matrices y los bucles también pueden ser expresiones, donde </span>
<span class="c1">// la expresión del cuerpo del bucle es el resultado de cada iteración.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">arrayFromLoop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">i</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">arrayFromLoop</span><span class="p">);</span>

<span class="c1">// Una expresión puede resultar en nada, como cuando se filtra con una expresión if.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">evensOrFives</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="nx">i</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="nx">arrayFromLoop</span><span class="p">);</span>

<span class="c1">// Las expresiones de matriz también se pueden escribir con una notación de paréntesis.</span>
<span class="c1">// Nota: esta sintaxis utiliza el concepto paralelo forall discutido más adelante.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">evensOrFivesAgain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="nx">i</span><span class="p">;</span>

<span class="c1">// They can also be written over the values of the array.</span>
<span class="nx">arrayFromLoop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nx">value</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">arrayFromLoop</span><span class="p">]</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>


<span class="c1">// Procedimientos</span>

<span class="c1">// Los procedimientos de Chapel tienen funciones de sintaxis similares en otros idiomas.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">fibonacci</span><span class="p">(</span><span class="nx">n</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">n</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">fibonacci</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">fibonacci</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Los parámetros de entrada pueden estar sin tipo para crear un procedimiento genérico.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">doublePrint</span><span class="p">(</span><span class="nx">thing</span><span class="p">):</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">write</span><span class="p">(</span><span class="nx">thing</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">thing</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;\n&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Se puede inferir el tipo de retorno, siempre que el compilador pueda resolverlo.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">addThree</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">doublePrint</span><span class="p">(</span><span class="nx">addThree</span><span class="p">(</span><span class="nx">fibonacci</span><span class="p">(</span><span class="mi">20</span><span class="p">)));</span>

<span class="c1">// También es posible tomar un número variable de parámetros.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">maxOf</span><span class="p">(</span><span class="nx">x</span><span class="w"> </span><span class="o">..</span><span class="p">.?</span><span class="nx">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// x se refiere a una tupla de un tipo, con k elementos</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">maximum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">x</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">2</span><span class="o">..</span><span class="nx">k</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">maximum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nx">maximum</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="nx">maximum</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">maximum</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">maxOf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">189</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">9071982</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">17</span><span class="p">,</span><span class="w"> </span><span class="mi">20001</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">));</span>

<span class="c1">// Los procedimientos pueden tener valores de parámetros predeterminados, y</span>
<span class="c1">// los parámetros pueden nombrarse en la llamada, incluso fuera de orden.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">defaultsProc</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="p">:</span><span class="w"> </span><span class="kt">real</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.2634</span><span class="p">):</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">real</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">writeln</span><span class="p">(</span><span class="nx">defaultsProc</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">defaultsProc</span><span class="p">(</span><span class="nx">x</span><span class="o">=</span><span class="mi">11</span><span class="p">));</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">defaultsProc</span><span class="p">(</span><span class="nx">x</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="o">=</span><span class="mf">5.432</span><span class="p">));</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">defaultsProc</span><span class="p">(</span><span class="nx">y</span><span class="o">=</span><span class="mf">9.876</span><span class="p">,</span><span class="w"> </span><span class="nx">x</span><span class="o">=</span><span class="mi">13</span><span class="p">));</span>

<span class="c1">// El operador ? se llama operador de consulta y se usa para tomar valores </span>
<span class="c1">// indeterminados como tuplas o tamaños de matriz y tipos genéricos. </span>
<span class="c1">// Por ejemplo, tomar matrices como parámetros. </span>

<span class="c1">// El operador de consulta se utiliza para determinar el dominio de A. </span>
<span class="c1">// Esto es útil para definir el tipo de retorno, aunque no es obligatorio.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">invertArray</span><span class="p">(</span><span class="nx">A</span><span class="p">:</span><span class="w"> </span><span class="p">[?</span><span class="nx">D</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="p">):</span><span class="w"> </span><span class="p">[</span><span class="nx">D</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">A</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="nx">a</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">A</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">writeln</span><span class="p">(</span><span class="nx">invertArray</span><span class="p">(</span><span class="nx">intArray</span><span class="p">));</span>

<span class="c1">// Podemos consultar el tipo de argumentos a los procedimientos genéricos.</span>
<span class="c1">// Aquí definimos un procedimiento que toma dos argumentos del mismo tipo,</span>
<span class="c1">// pero no definimos cuál es ese tipo.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">genericProc</span><span class="p">(</span><span class="nx">arg1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">?</span><span class="nx">valueType</span><span class="p">,</span><span class="w"> </span><span class="nx">arg2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">valueType</span><span class="p">):</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">select</span><span class="p">(</span><span class="nx">valueType</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">when</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">arg1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; and &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">arg2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; are ints&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">when</span><span class="w"> </span><span class="kt">real</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">arg1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; and &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">arg2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; are reals&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">otherwise</span><span class="w"> </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">arg1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; and &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">arg2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; are somethings!&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="nx">genericProc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="nx">genericProc</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span><span class="w"> </span><span class="mf">2.3</span><span class="p">);</span>
<span class="nx">genericProc</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="m">2.0i</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0</span><span class="o">+</span><span class="m">4.0i</span><span class="p">);</span>

<span class="c1">// También podemos imponer una forma de polimorfismo con la cláusula where</span>
<span class="c1">// Esto permite que el compilador decida qué función usar. </span>

<span class="c1">// Nota: Eso significa que toda la información debe conocerse en tiempo de compilación. </span>
<span class="c1">// El modificador param en el argumento se usa para imponer esta restricción.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">whereProc</span><span class="p">(</span><span class="kd">param</span><span class="w"> </span><span class="nx">N</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">):</span><span class="w"> </span><span class="kt">void</span>
<span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="p">(</span><span class="nx">N</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;N is greater than 0&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">proc</span><span class="w"> </span><span class="nf">whereProc</span><span class="p">(</span><span class="kd">param</span><span class="w"> </span><span class="nx">N</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">):</span><span class="w"> </span><span class="kt">void</span>
<span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="p">(</span><span class="nx">N</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;N is less than 0&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">whereProc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="nx">whereProc</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">// whereProc(0) daría lugar a un error del compilador porque no hay funciones</span>
<span class="c1">// que satisfagan la condición de la cláusula where. </span>
<span class="c1">// Podríamos haber definido un whereProc sin una cláusula where que</span>
<span class="c1">// hubiera servido como captura para todos los demás casos (de los cuales solo hay uno).</span>

<span class="c1">// Las cláusulas where también se pueden usar para restringir según el tipo de argumento.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">whereType</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span><span class="w"> </span><span class="p">?</span><span class="nx">t</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="nx">t</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Inside &#39;int&#39; version of &#39;whereType&#39;: &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">proc</span><span class="w"> </span><span class="nf">whereType</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span><span class="w"> </span><span class="p">?</span><span class="nx">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Inside general version of &#39;whereType&#39;: &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">whereType</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="nx">whereType</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">);</span>

<span class="c1">// Intenciones</span>

<span class="cm">/* Los modificadores de intención en los argumentos transmiten cómo esos argumentos se pasan al procedimiento.</span>

<span class="cm">     * in: copia arg adentro, pero no afuera</span>
<span class="cm">     * out: copia arg, pero no dentro</span>
<span class="cm">     * inout: copia arg adentro, copia arg afuera</span>
<span class="cm">     * ref: pasa arg por referencia</span>
<span class="cm">*/</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">intentsProc</span><span class="p">(</span><span class="kd">in</span><span class="w"> </span><span class="nx">inarg</span><span class="p">,</span><span class="w"> </span><span class="kd">out</span><span class="w"> </span><span class="nx">outarg</span><span class="p">,</span><span class="w"> </span><span class="kd">inout</span><span class="w"> </span><span class="nx">inoutarg</span><span class="p">,</span><span class="w"> </span><span class="kd">ref</span><span class="w"> </span><span class="nx">refarg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Adentro antes: &quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="nx">inarg</span><span class="p">,</span><span class="w"> </span><span class="nx">outarg</span><span class="p">,</span><span class="w"> </span><span class="nx">inoutarg</span><span class="p">,</span><span class="w"> </span><span class="nx">refarg</span><span class="p">));</span>
<span class="w">  </span><span class="nx">inarg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">inarg</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w">  </span><span class="nx">outarg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">outarg</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w">  </span><span class="nx">inoutarg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">inoutarg</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w">  </span><span class="nx">refarg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">refarg</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Adentro después: &quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="nx">inarg</span><span class="p">,</span><span class="w"> </span><span class="nx">outarg</span><span class="p">,</span><span class="w"> </span><span class="nx">inoutarg</span><span class="p">,</span><span class="w"> </span><span class="nx">refarg</span><span class="p">));</span>
<span class="p">}</span>

<span class="kd">var</span><span class="w"> </span><span class="nx">inVar</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">outVar</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">inoutVar</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">refVar</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Afuera antes: &quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="nx">inVar</span><span class="p">,</span><span class="w"> </span><span class="nx">outVar</span><span class="p">,</span><span class="w"> </span><span class="nx">inoutVar</span><span class="p">,</span><span class="w"> </span><span class="nx">refVar</span><span class="p">));</span>
<span class="nx">intentsProc</span><span class="p">(</span><span class="nx">inVar</span><span class="p">,</span><span class="w"> </span><span class="nx">outVar</span><span class="p">,</span><span class="w"> </span><span class="nx">inoutVar</span><span class="p">,</span><span class="w"> </span><span class="nx">refVar</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Afuera después: &quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="nx">inVar</span><span class="p">,</span><span class="w"> </span><span class="nx">outVar</span><span class="p">,</span><span class="w"> </span><span class="nx">inoutVar</span><span class="p">,</span><span class="w"> </span><span class="nx">refVar</span><span class="p">));</span>

<span class="c1">// Del mismo modo, podemos definir intentos en el tipo de retorno. </span>
<span class="c1">// refElement devuelve una referencia a un elemento de la matriz. Esto tiene más sentido </span>
<span class="c1">// práctico para los métodos de clase donde las referencias a elementos en una estructura </span>
<span class="c1">// de datos se devuelven a través de un método o iterador.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">refElement</span><span class="p">(</span><span class="nx">array</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[?</span><span class="nx">D</span><span class="p">]</span><span class="w"> </span><span class="p">?</span><span class="nx">T</span><span class="p">,</span><span class="w"> </span><span class="nx">idx</span><span class="p">)</span><span class="w"> </span><span class="kd">ref</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">T</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">array</span><span class="p">[</span><span class="nx">idx</span><span class="p">];</span>
<span class="p">}</span>

<span class="kd">var</span><span class="w"> </span><span class="nx">myChangingArray</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">myChangingArray</span><span class="p">);</span>
<span class="kd">ref</span><span class="w"> </span><span class="nx">refToElem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">refElement</span><span class="p">(</span><span class="nx">myChangingArray</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// Almacena una referencia al elemento en variable de referencia</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">refToElem</span><span class="p">);</span>
<span class="nx">refToElem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// modifica referencia que, a su vez, modifica el valor real en la matriz</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">refToElem</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">myChangingArray</span><span class="p">);</span>

<span class="c1">// Definiciones del operador</span>

<span class="c1">// Chapel permite que los operadores se sobrecarguen.</span>
<span class="c1">// Podemos definir los operadores unarios:</span>
<span class="c1">// + - ! ~</span>
<span class="c1">// y los operadores binarios:</span>
<span class="c1">// + - * / % ** == &lt;= &gt;= &lt; &gt; &lt;&lt; &gt;&gt; &amp; | ˆ by</span>
<span class="c1">// += -= *= /= %= **= &amp;= |= ˆ= &lt;&lt;= &gt;&gt;= &lt;=&gt;</span>

<span class="c1">// Exclusivo u operador booleano.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">^</span><span class="p">(</span><span class="nx">left</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="nx">right</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">):</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nx">left</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">right</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="nx">left</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">right</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">writeln</span><span class="p">(</span><span class="kc">true</span><span class="w">  </span><span class="o">^</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="kc">false</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="kc">true</span><span class="w">  </span><span class="o">^</span><span class="w"> </span><span class="kc">false</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="kc">false</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="kc">false</span><span class="p">);</span>

<span class="c1">// Define un operador * en cualquiera de los dos tipos que devuelve una tupla de esos tipos.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">*</span><span class="p">(</span><span class="nx">left</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">?</span><span class="nx">ltype</span><span class="p">,</span><span class="w"> </span><span class="nx">right</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">?</span><span class="nx">rtype</span><span class="p">):</span><span class="w"> </span><span class="p">(</span><span class="nx">ltype</span><span class="p">,</span><span class="w"> </span><span class="nx">rtype</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;\tIn our &#39;*&#39; overload!&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nx">left</span><span class="p">,</span><span class="w"> </span><span class="nx">right</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">writeln</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Utiliza nuestro * operador.</span>
<span class="nx">writeln</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">   </span><span class="c1">// Utiliza el operador predeterminado *.</span>

<span class="c1">//  Note: Podrías romper todo si te descuidas con tus sobrecargas.</span>
<span class="c1">//  Esto aquí lo romperá todo. No lo hagas</span>

<span class="cm">/*</span>
<span class="cm">    proc +(left: int, right: int): int {</span>
<span class="cm">      return left - right;</span>
<span class="cm">    }</span>
<span class="cm">*/</span>

<span class="c1">// Iteradores</span>

<span class="c1">// Los iteradores son hermanas del procedimiento, y casi todo lo relacionado </span>
<span class="c1">// con los procedimientos también se aplica a los iteradores. Sin embargo, en lugar de </span>
<span class="c1">// devolver un solo valor, los iteradores pueden generar múltiples valores en un bucle.</span>

<span class="c1">// Esto es útil cuando se necesita un conjunto u orden complicado de iteraciones, </span>
<span class="c1">// ya que permite que el código que define las iteraciones </span>
<span class="c1">// se separe del cuerpo del bucle.</span>
<span class="k">iter</span><span class="w"> </span><span class="nf">oddsThenEvens</span><span class="p">(</span><span class="nx">N</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">):</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="nx">N</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="k">yield</span><span class="w"> </span><span class="nx">i</span><span class="p">;</span><span class="w"> </span><span class="c1">// yield values instead of returning.</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">2</span><span class="o">..</span><span class="nx">N</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="k">yield</span><span class="w"> </span><span class="nx">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">oddsThenEvens</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">write</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">();</span>

<span class="c1">// Los iteradores también pueden ceder condicionalmente, cuyo resultado puede ser nada</span>
<span class="k">iter</span><span class="w"> </span><span class="nf">absolutelyNothing</span><span class="p">(</span><span class="nx">N</span><span class="p">):</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="nx">N</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">N</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Always false</span>
<span class="w">      </span><span class="k">yield</span><span class="w"> </span><span class="nx">i</span><span class="p">;</span><span class="w">     </span><span class="c1">// Yield statement never happens</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">absolutelyNothing</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Woa there! absolutelyNothing yielded &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Podemos comprimir dos o más iteradores (que tienen el mismo número de iteraciones) </span>
<span class="c1">// usando zip () para crear un solo iterador comprimido, donde cada iteración </span>
<span class="c1">// del iterador comprimido produce una tupla de un valor de cada iterador.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">positive</span><span class="p">,</span><span class="w"> </span><span class="nx">negative</span><span class="p">)</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="k">zip</span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">5</span><span class="o">..-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">((</span><span class="nx">positive</span><span class="p">,</span><span class="w"> </span><span class="nx">negative</span><span class="p">));</span>

<span class="c1">// La iteración de la cremallera es bastante importante en la asignación de matrices, </span>
<span class="c1">// segmentos de matrices y expresiones de matriz / bucle.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">fromThatArray</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..#</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">toThisArray</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">100</span><span class="o">..#</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>

<span class="c1">// Algunas operaciones de cierre implementan otras operaciones.</span>
<span class="c1">// La primera declaración y el bucle son equivalentes.</span>
<span class="nx">toThisArray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">fromThatArray</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="k">zip</span><span class="p">(</span><span class="nx">toThisArray</span><span class="p">.</span><span class="k">domain</span><span class="p">,</span><span class="w"> </span><span class="nx">fromThatArray</span><span class="p">.</span><span class="k">domain</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">toThisArray</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">fromThatArray</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// Estos dos pedazos también son equivalentes.</span>
<span class="nx">toThisArray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nx">j</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="o">-</span><span class="mi">100</span><span class="o">..#</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="nx">j</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">toThisArray</span><span class="p">);</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">j</span><span class="p">)</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="k">zip</span><span class="p">(</span><span class="nx">toThisArray</span><span class="p">.</span><span class="k">domain</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">100</span><span class="o">..#</span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">toThisArray</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">j</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">toThisArray</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> Esto es muy importante para entender por qué esta declaración </span>
<span class="cm"> exhibe un error de tiempo de ejecución.</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">  var iterArray : [1..10] int = [i in 1..10] if (i % 2 == 1) then i;</span>
<span class="cm">*/</span>

<span class="c1">// Aunque el dominio de la matriz y la expresión de bucle son del mismo tamaño,</span>
<span class="c1">// el cuerpo de la expresión puede considerarse como un iterador.</span>
<span class="c1">// Debido a que los iteradores pueden producir nada, ese iterador produce un número</span>
<span class="c1">// diferente de cosas que el dominio de la matriz o bucle, que no está permitido.</span>

<span class="c1">// Clases</span>

<span class="c1">// Las clases son similares a las de C ++ y Java, asignadas en el montón.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="w"> </span><span class="p">{</span>

<span class="c1">// Variables miembro</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">memberInt</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">memberBool</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>

<span class="c1">// Inicializador definido explícitamente. </span>
<span class="c1">// También obtenemos el inicializador generado por el compilador, con un argumento por campo.</span>
<span class="c1">// Tenga en cuenta que pronto no habrá un inicializador generado por el compilador </span>
<span class="c1">// cuando definamos los inicializadores explícitamente.</span>
<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="nx">val</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">real</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">memberInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">ceil</span><span class="p">(</span><span class="nx">val</span><span class="p">):</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// Desinicializador explícitamente definido.</span>
<span class="c1">// Si no escribiéramos uno, obtendríamos el desinicializador generado por el compilador, </span>
<span class="c1">// que tiene un cuerpo vacío.</span>
<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">deinit</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;MyClass deinitializer called &quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">memberInt</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">memberBool</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// Métodos de clase.</span>
<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">setMemberInt</span><span class="p">(</span><span class="nx">val</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">memberInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">val</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">setMemberBool</span><span class="p">(</span><span class="nx">val</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">memberBool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">val</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">getMemberInt</span><span class="p">():</span><span class="w"> </span><span class="kt">int</span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">memberInt</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">getMemberBool</span><span class="p">():</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">memberBool</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// termina MyClass</span>

<span class="c1">// Llame al inicializador generado por el compilador, </span>
<span class="c1">// utilizando el valor predeterminado para memberBool.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nx">MyClass</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="nx">myObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nx">MyClass</span><span class="p">(</span><span class="nx">memberInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="c1">// Equivalente</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">myObject</span><span class="p">.</span><span class="nx">getMemberInt</span><span class="p">());</span>

<span class="c1">// Same, but provide a memberBool value explicitly.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myDiffObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nx">MyClass</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span>
<span class="w">    </span><span class="nx">myDiffObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nx">MyClass</span><span class="p">(</span><span class="nx">memberInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nx">memberBool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span><span class="w"> </span><span class="c1">// Equivalente</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">myDiffObject</span><span class="p">);</span>

<span class="c1">// Llame al inicializador que escribimos.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myOtherObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nx">MyClass</span><span class="p">(</span><span class="mf">1.95</span><span class="p">);</span>
<span class="w">    </span><span class="nx">myOtherObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nx">MyClass</span><span class="p">(</span><span class="nx">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.95</span><span class="p">);</span><span class="w"> </span><span class="c1">// Equivalente</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">myOtherObject</span><span class="p">.</span><span class="nx">getMemberInt</span><span class="p">());</span>

<span class="c1">// También podemos definir un operador en nuestra clase,</span>
<span class="c1">// pero la definición tiene que estar fuera de la definición de la clase.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">+</span><span class="p">(</span><span class="nx">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">MyClass</span><span class="p">,</span><span class="w"> </span><span class="nx">B</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">MyClass</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">MyClass</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nx">MyClass</span><span class="p">(</span><span class="nx">memberInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">A</span><span class="p">.</span><span class="nx">getMemberInt</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">B</span><span class="p">.</span><span class="nx">getMemberInt</span><span class="p">(),</span>
<span class="w">                      </span><span class="nx">memberBool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">A</span><span class="p">.</span><span class="nx">getMemberBool</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">B</span><span class="p">.</span><span class="nx">getMemberBool</span><span class="p">());</span>
<span class="p">}</span>

<span class="kd">var</span><span class="w"> </span><span class="nx">plusObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">myObject</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">myDiffObject</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">plusObject</span><span class="p">);</span>

<span class="c1">// Destrucción.</span>
<span class="k">delete</span><span class="w"> </span><span class="nx">myObject</span><span class="p">;</span>
<span class="k">delete</span><span class="w"> </span><span class="nx">myDiffObject</span><span class="p">;</span>
<span class="k">delete</span><span class="w"> </span><span class="nx">myOtherObject</span><span class="p">;</span>
<span class="k">delete</span><span class="w"> </span><span class="nx">plusObject</span><span class="p">;</span>

<span class="c1">// Las clases pueden heredar de una o más clases primarias</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MyChildClass</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">MyClass</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">memberComplex</span><span class="p">:</span><span class="w"> </span><span class="kt">complex</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Aquí hay un ejemplo de clases genéricas.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">GenericClass</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">type</span><span class="w"> </span><span class="nx">classType</span><span class="p">;</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">classDomain</span><span class="p">:</span><span class="w"> </span><span class="k">domain</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">classArray</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="nx">classDomain</span><span class="p">]</span><span class="w"> </span><span class="nx">classType</span><span class="p">;</span>

<span class="c1">// Constructor explícito.</span>
<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">GenericClass</span><span class="p">(</span><span class="kd">type</span><span class="w"> </span><span class="nx">classType</span><span class="p">,</span><span class="w"> </span><span class="nx">elements</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">classDomain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="o">..#</span><span class="nx">elements</span><span class="p">};</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// Copiar constructor.</span>
<span class="c1">// Nota: Todavía tenemos que poner el tipo como argumento, pero podemos usar</span>
<span class="c1">// el operador de consulta (?) como predeterminado para el tipo del otro objeto. </span>
<span class="c1">// Además, podemos aprovechar esto para permitir a nuestro constructor de copias </span>
<span class="c1">// copiar clases de diferentes tipos y emitir sobre la marcha.</span>
<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">GenericClass</span><span class="p">(</span><span class="nx">other</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">GenericClass</span><span class="p">(?</span><span class="nx">otherType</span><span class="p">),</span>
<span class="w">                     </span><span class="kd">type</span><span class="w"> </span><span class="nx">classType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">otherType</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">classDomain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">other</span><span class="p">.</span><span class="nx">classDomain</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Copiar y Convertir</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">idx</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">classDomain</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="k">this</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">other</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">classType</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// Defina la notación de corchetes en un objeto GenericClass</span>
<span class="c1">// para que pueda comportarse como una matriz normal</span>
<span class="c1">// i.e. objVar[i] or objVar(i)</span>
<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">this</span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kd">ref</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">classType</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">classArray</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// Definir un iterador implícito para que la clase produzca </span>
<span class="c1">// valores de la matriz a un bucle</span>
<span class="c1">// i.e. for i in objVar do ...</span>
<span class="w">  </span><span class="k">iter</span><span class="w"> </span><span class="nf">these</span><span class="p">()</span><span class="w"> </span><span class="kd">ref</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">classType</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">classDomain</span><span class="w"> </span><span class="k">do</span>
<span class="w">      </span><span class="k">yield</span><span class="w"> </span><span class="k">this</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// end GenericClass</span>

<span class="c1">// Podemos asignar a la matriz de miembros del objeto usando la notación de </span>
<span class="c1">// corchete que definimos.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">realList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nx">GenericClass</span><span class="p">(</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">realList</span><span class="p">.</span><span class="nx">classDomain</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">realList</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>

<span class="c1">// Podemos iterar sobre los valores en nuestra lista con el iterador </span>
<span class="c1">// que definimos.</span>
<span class="k">for</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">realList</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">write</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">();</span>

<span class="c1">// Haga una copia de realList usando el constructor de copias.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">copyList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nx">GenericClass</span><span class="p">(</span><span class="nx">realList</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">copyList</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">write</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">();</span>

<span class="c1">// Haga una copia de realList y cambie el tipo, también utilizando el constructor de copias.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">copyNewTypeList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nx">GenericClass</span><span class="p">(</span><span class="nx">realList</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">copyNewTypeList</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">write</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">();</span>


<span class="c1">// Módulos</span>

<span class="c1">// Los módulos son la forma en que Chapel administra los espacios de nombres.</span>
<span class="c1">// Los archivos que contienen estos módulos no necesitan ser nombrados después</span>
<span class="c1">// de los módulos (como en Java), pero los archivos implícitamente nombran módulos. </span>
<span class="c1">// Por ejemplo, este archivo nombra implícitamente el módulo learnChapelInYMinutes</span>

<span class="k">module</span><span class="w"> </span><span class="nc">OurModule</span><span class="w"> </span><span class="p">{</span>

<span class="c1">// Podemos usar módulos dentro de otros módulos.</span>
<span class="c1">// Time es uno de los módulos estándar.</span>
<span class="w">  </span><span class="k">use</span><span class="w"> </span><span class="nx">Time</span><span class="p">;</span>

<span class="c1">// Usaremos este procedimiento en la sección de paralelismo.</span>
<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">countdown</span><span class="p">(</span><span class="nx">seconds</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="nx">seconds</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
<span class="w">      </span><span class="nx">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// Es posible crear nidos de módulos arbitrariamente profundos.</span>
<span class="c1">// i.e. submódulos de OurModule</span>
<span class="w">  </span><span class="k">module</span><span class="w"> </span><span class="nc">ChildModule</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">proc</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;ChildModule.foo()&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">module</span><span class="w"> </span><span class="nc">SiblingModule</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">proc</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;SiblingModule.foo()&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// end OurModule</span>

<span class="c1">// Usando OurModule también usa todos los módulos que usa.</span>
<span class="c1">// Como OurModule usa Time, nosotros también usamos Time.</span>
<span class="k">use</span><span class="w"> </span><span class="nx">OurModule</span><span class="p">;</span>

<span class="c1">// En este punto no hemos usado ChildModule o SiblingModule, por lo que sus símbolos </span>
<span class="c1">// (es decir, foo) no están disponibles para nosotros. Sin embargo, los nombres de</span>
<span class="c1">// los módulos están disponibles y podemos llamar explícitamente a foo () a través de ellos.</span>
<span class="nx">SiblingModule</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span>
<span class="nx">OurModule</span><span class="p">.</span><span class="nx">ChildModule</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span>

<span class="c1">// Ahora usamos ChildModule, que permite llamadas no calificadas.</span>
<span class="k">use</span><span class="w"> </span><span class="nx">ChildModule</span><span class="p">;</span>
<span class="nx">foo</span><span class="p">();</span>

<span class="c1">// Paralelismo</span>

<span class="c1">// En otros idiomas, el paralelismo generalmente se realiza con librerias complicadas</span>
<span class="c1">// y extrañas jerarquías de estructura de clases. </span>
<span class="c1">// Chapel lo tiene directamente en el idioma.</span>

<span class="c1">// Podemos declarar un procedimiento principal, pero todo el código anterior</span>
<span class="c1">// a main todavía se ejecuta.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="c1">// Una declaración de inicio hará girar el cuerpo de esa declaración en una nueva tarea.</span>
<span class="c1">// Una declaración de sincronización garantizará que el progreso de la tarea principal </span>
<span class="c1">// no avance hasta que los hijos hayan sincronizado nuevamente.</span>

<span class="w">  </span><span class="k">sync</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">begin</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Inicio del cuerpo de la nueva tarea.</span>
<span class="w">      </span><span class="kd">var</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">1000</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Done: &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">a</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// Fin del nuevo cuerpo de tareas</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;escindió una tarea!&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;De nuevo juntos&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">printFibb</span><span class="p">(</span><span class="nx">n</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;fibonacci(&quot;</span><span class="p">,</span><span class="nx">n</span><span class="p">,</span><span class="s">&quot;) = &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">fibonacci</span><span class="p">(</span><span class="nx">n</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// Una declaración de cobegin girará cada declaración del cuerpo en una nueva tarea.</span>
<span class="c1">// Observe aquí que las impresiones de cada declaración pueden ocurrir en </span>
<span class="c1">// cualquier orden.</span>
<span class="w">  </span><span class="k">cobegin</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">printFibb</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w"> </span><span class="c1">// nueva tarea</span>
<span class="w">    </span><span class="nx">printFibb</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="c1">// nueva tarea</span>
<span class="w">    </span><span class="nx">printFibb</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w">  </span><span class="c1">// nueva tarea</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Este es un cuerpo de declaración anidado y, por lo tanto, es una </span>
<span class="w">      </span><span class="c1">// declaración única para la declaración principal, ejecutada </span>
<span class="w">      </span><span class="c1">// por una sola tarea.</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;esto se &quot;</span><span class="p">);</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;ejecuta&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;como un todo&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// Un bucle coforall creará una nueva tarea para CADA iteración. </span>
<span class="c1">// Nuevamente vemos que las impresiones suceden en cualquier orden. </span>
<span class="c1">// NOTA: ¡coforall debe usarse solo para crear tareas! </span>
<span class="c1">// ¡Usarlo para iterar sobre una estructura es una muy mala idea!</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">num_tasks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="c1">// Number of tasks we want</span>
<span class="w">  </span><span class="k">coforall</span><span class="w"> </span><span class="nx">taskID</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..#</span><span class="nx">num_tasks</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Hola de tarea# &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">taskID</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// los bucles forall son otro bucle paralelo, pero solo crean un número </span>
<span class="c1">// menor de tareas, específicamente --dataParTasksPerLocale = número de tareas.</span>
<span class="w">  </span><span class="k">forall</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">write</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">();</span>

<span class="c1">// Aquí vemos que hay secciones que están en orden, seguidas de una sección </span>
<span class="c1">// que no seguiría (por ejemplo, 1, 2, 3, 7, 8, 9, 4, 5, 6,). </span>
<span class="c1">// Esto se debe a que cada tarea está asumiendo un fragmento del rango 1..10</span>
<span class="c1">// (1..3, 4..6 o 7..9) haciendo ese fragmento en serie, pero cada tarea ocurre en paralelo. </span>
<span class="c1">// Sus resultados pueden depender de su máquina y configuración</span>

<span class="c1">// Para los bucles forall y coforall, la ejecución de la tarea principal </span>
<span class="c1">// no continuará hasta que todos los hijos se sincronicen.</span>

<span class="c1">// los bucles forall son particularmente útiles para la iteración paralela sobre matrices.</span>
<span class="c1">// Hagamos un experimento para ver qué tan rápido es un ciclo paralelo.</span>

<span class="w">  </span><span class="k">use</span><span class="w"> </span><span class="nx">Time</span><span class="p">;</span><span class="w"> </span><span class="c1">// Importe el módulo Time para usar objetos de Timer</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">timer</span><span class="p">:</span><span class="w"> </span><span class="nx">Timer</span><span class="p">;</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">myBigArray</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="mi">1</span><span class="o">..</span><span class="mi">4000</span><span class="p">,</span><span class="mi">1</span><span class="o">..</span><span class="mi">4000</span><span class="p">}]</span><span class="w"> </span><span class="kt">real</span><span class="p">;</span><span class="w"> </span><span class="c1">// Gran matriz en la que escribiremos</span>

<span class="c1">// Experimento en serie:</span>
<span class="w">  </span><span class="nx">timer</span><span class="p">.</span><span class="nx">start</span><span class="p">();</span><span class="w"> </span><span class="c1">// Iniciar temporizador</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">)</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">myBigArray</span><span class="p">.</span><span class="k">domain</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Iteración en serie</span>
<span class="w">    </span><span class="nx">myBigArray</span><span class="p">[</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">x</span><span class="p">:</span><span class="kt">real</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="nx">y</span><span class="p">:</span><span class="kt">real</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nx">timer</span><span class="p">.</span><span class="nx">stop</span><span class="p">();</span><span class="w"> </span><span class="c1">// Detener temporizador</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Serial: &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">timer</span><span class="p">.</span><span class="nx">elapsed</span><span class="p">());</span><span class="w"> </span><span class="c1">// Imprimir tiempo transcurrido</span>
<span class="w">  </span><span class="nx">timer</span><span class="p">.</span><span class="nx">clear</span><span class="p">();</span><span class="w"> </span><span class="c1">// Limpia el temporizador para bucle paralelo</span>

<span class="c1">// Experimento Paralelo:</span>
<span class="w">  </span><span class="nx">timer</span><span class="p">.</span><span class="nx">start</span><span class="p">();</span><span class="w"> </span><span class="c1">// Iniciar temporizador</span>
<span class="w">  </span><span class="k">forall</span><span class="w"> </span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">)</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">myBigArray</span><span class="p">.</span><span class="k">domain</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Iteración paralela</span>
<span class="w">    </span><span class="nx">myBigArray</span><span class="p">[</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">x</span><span class="p">:</span><span class="kt">real</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="nx">y</span><span class="p">:</span><span class="kt">real</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nx">timer</span><span class="p">.</span><span class="nx">stop</span><span class="p">();</span><span class="w"> </span><span class="c1">// Detener temporizador</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Parallel: &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">timer</span><span class="p">.</span><span class="nx">elapsed</span><span class="p">());</span><span class="w"> </span><span class="c1">// Imprimir tiempo transcurrido</span>
<span class="w">  </span><span class="nx">timer</span><span class="p">.</span><span class="nx">clear</span><span class="p">();</span>

<span class="c1">// Puede que hayas notado que (dependiendo de cuántos núcleos tengas)</span>
<span class="c1">// el ciclo paralelo fue más rápido que el ciclo serial.</span>

<span class="c1">// La expresión de bucle estilo corchete descrita mucho antes utiliza</span>
<span class="c1">// implícitamente un bucle forall.</span>
<span class="w">  </span><span class="p">[</span><span class="nx">val</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">myBigArray</span><span class="p">]</span><span class="w"> </span><span class="nx">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">val</span><span class="p">;</span><span class="w"> </span><span class="c1">// Operación paralela</span>

<span class="c1">// Las variables atómicas, comunes a muchos idiomas, son aquellas cuyas operaciones</span>
<span class="c1">// ocurren sin interrupciones. Por lo tanto, varios subprocesos pueden modificar</span>
<span class="c1">// las variables atómicas y pueden saber que sus valores son seguros. </span>
<span class="c1">// Las variables atómicas de la capilla pueden ser de tipo bool, int, uint y real.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">uranium</span><span class="p">:</span><span class="w"> </span><span class="k">atomic</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>
<span class="w">  </span><span class="nx">uranium</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="mi">238</span><span class="p">);</span><span class="w">      </span><span class="c1">// escribir atómicamente una variable</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">uranium</span><span class="p">.</span><span class="nx">read</span><span class="p">());</span><span class="w"> </span><span class="c1">// leer atómicamente una variable</span>

<span class="c1">// Las operaciones atómicas se describen como funciones, por lo que puede definir</span>
<span class="c1">// las suyas propias.</span>
<span class="w">  </span><span class="nx">uranium</span><span class="p">.</span><span class="nx">sub</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"> </span><span class="c1">// restar atómicamente una variable</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">uranium</span><span class="p">.</span><span class="nx">read</span><span class="p">());</span>

<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">replaceWith</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">239</span><span class="p">;</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">was</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">uranium</span><span class="p">.</span><span class="nx">exchange</span><span class="p">(</span><span class="nx">replaceWith</span><span class="p">);</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;El uranio era&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">was</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, pero ahora es &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">replaceWith</span><span class="p">);</span>

<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">isEqualTo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">235</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">uranium</span><span class="p">.</span><span class="nx">compareExchange</span><span class="p">(</span><span class="nx">isEqualTo</span><span class="p">,</span><span class="w"> </span><span class="nx">replaceWith</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;El uranio era igual a &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">isEqualTo</span><span class="p">,</span>
<span class="w">             </span><span class="s">&quot; pero valor reemplazado por&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">replaceWith</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;uranio no era igual a &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">isEqualTo</span><span class="p">,</span>
<span class="w">             </span><span class="s">&quot; así que el valor permanece igual... sea lo que sea&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">sync</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">begin</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Tarea del lector</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Lector: esperando que el uranio sea &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">isEqualTo</span><span class="p">);</span>
<span class="w">      </span><span class="nx">uranium</span><span class="p">.</span><span class="nx">waitFor</span><span class="p">(</span><span class="nx">isEqualTo</span><span class="p">);</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Lector: el uranio fue configurado (por alguien) para &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">isEqualTo</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">begin</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Tarea de escritor</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Escritor: establecerá uranio en el valor &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">isEqualTo</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; en...&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="nx">countdown</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="w">      </span><span class="nx">uranium</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">isEqualTo</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// las variables de sincronización tienen dos estados: vacío y lleno.</span>
<span class="c1">// Si lee una variable vacía o escribe una variable completa, </span>
<span class="c1">// se espera hasta que la variable esté llena o vacía nuevamente.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">someSyncVar$</span><span class="p">:</span><span class="w"> </span><span class="k">sync</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w"> </span><span class="c1">// varName$ Es una convención, no una ley.</span>
<span class="w">  </span><span class="k">sync</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">begin</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Tarea del lector</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Lector: esperando leer.&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="kd">var</span><span class="w"> </span><span class="nx">read_sync</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">someSyncVar$</span><span class="p">;</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Lector: el valor es &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">read_sync</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">begin</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Tarea de escritor</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Escritor: escribirá en...&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="nx">countdown</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="w">      </span><span class="nx">someSyncVar$</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">123</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// las variales individuales solo se pueden escribir una vez. </span>
<span class="c1">// Una lectura en un solo no escrito da como resultado una espera,</span>
<span class="c1">// pero cuando la variable tiene un valor, puede leerse indefinidamente.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">someSingleVar$</span><span class="p">:</span><span class="w"> </span><span class="k">single</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w"> </span><span class="c1">// varName$ Es una convención, no una ley.</span>
<span class="w">  </span><span class="k">sync</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">begin</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Tarea del lector</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Lector: esperando leer.&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">var</span><span class="w"> </span><span class="nx">read_single</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">someSingleVar$</span><span class="p">;</span>
<span class="w">        </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Lector: iteración &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">,</span><span class="s">&quot;, y el valor es &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">read_single</span><span class="p">);</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">begin</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Tarea de escritor</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Escritor: escribirá en ...&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="nx">countdown</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="w">      </span><span class="nx">someSingleVar$</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// primero y único escrito.</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// Aquí hay un ejemplo usando atómica y una variable de sincronización </span>
<span class="c1">// para crear un mutex de cuenta regresiva</span>
<span class="c1">//  (también conocido como multiplexor).</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">count</span><span class="p">:</span><span class="w"> </span><span class="k">atomic</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w"> </span><span class="c1">// nuestro mostrador</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">lock$</span><span class="p">:</span><span class="w"> </span><span class="k">sync</span><span class="w"> </span><span class="kt">bool</span><span class="p">;</span><span class="w">   </span><span class="c1">// la cerradura mutex</span>

<span class="w">  </span><span class="nx">count</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w">       </span><span class="c1">// Solo deje dos tareas a la vez.</span>
<span class="w">  </span><span class="nx">lock$</span><span class="p">.</span><span class="nx">writeXF</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span><span class="w">  </span><span class="c1">// Establezca lock$ en completo (desbloqueado)</span>
<span class="w">  </span><span class="c1">// Nota: el valor en realidad no importa, solo el estado</span>
<span class="w">  </span><span class="c1">// (completo: desbloqueado / vacio: bloqueado)</span>
<span class="w">  </span><span class="c1">// Además, writeXF() llena (F) la variable de sincronización independientemente de su estado (X)</span>

<span class="w">  </span><span class="k">coforall</span><span class="w"> </span><span class="nx">task</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..#</span><span class="mi">5</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Generar tareas</span>
<span class="w">    </span><span class="c1">// Create a barrier</span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">lock$</span><span class="p">;</span><span class="w">                 </span><span class="c1">// Leer lock$ (espera)</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nx">count</span><span class="p">.</span><span class="nx">read</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// Sigue esperando hasta que se abra un lugar</span>

<span class="w">    </span><span class="nx">count</span><span class="p">.</span><span class="nx">sub</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">          </span><span class="c1">//disminuir el contador</span>
<span class="w">    </span><span class="nx">lock$</span><span class="p">.</span><span class="nx">writeXF</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span><span class="w"> </span><span class="c1">// Establezca lock$ en completo (señal)</span>

<span class="w">    </span><span class="c1">// &#39;Trabajo&#39; actual</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Tarea #&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">task</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; trabajando&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="nx">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="w">    </span><span class="nx">count</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">        </span><span class="c1">// Incrementa el contador</span>
<span class="w">    </span><span class="nx">lock$</span><span class="p">.</span><span class="nx">writeXF</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span><span class="w"> </span><span class="c1">// Establezca lock$ en completo (señal)</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// Podemos definir las operaciones + * &amp; | ^ &amp;&amp; || min max minloc maxloc</span>
<span class="c1">// sobre una matriz completa usando escaneos y reducciones.</span>
<span class="c1">// Las reducciones aplican la operación en toda la matriz</span>
<span class="c1">// y dan como resultado un valor escalar.</span>

<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">listOfValues</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">15</span><span class="p">,</span><span class="mi">57</span><span class="p">,</span><span class="mi">354</span><span class="p">,</span><span class="mi">36</span><span class="p">,</span><span class="mi">45</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">456</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">678</span><span class="p">,</span><span class="mi">2</span><span class="p">];</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">sumOfValues</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">reduce</span><span class="w"> </span><span class="nx">listOfValues</span><span class="p">;</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">maxValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">max</span><span class="w"> </span><span class="k">reduce</span><span class="w"> </span><span class="nx">listOfValues</span><span class="p">;</span><span class="w"> </span><span class="c1">// &#39;max&#39; da solo el valor máximo</span>

<span class="c1">// maxloc proporciona el valor máximo y el índice del valor máximo.</span>
<span class="c1">// Nota: Tenemos que comprimir la matriz y el dominio junto con el iterador zip.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="p">(</span><span class="nx">theMaxValue</span><span class="p">,</span><span class="w"> </span><span class="nx">idxOfMax</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">maxloc</span><span class="w"> </span><span class="k">reduce</span><span class="w"> </span><span class="k">zip</span><span class="p">(</span><span class="nx">listOfValues</span><span class="p">,</span>
<span class="w">                                                  </span><span class="nx">listOfValues</span><span class="p">.</span><span class="k">domain</span><span class="p">);</span>

<span class="w">  </span><span class="nx">writeln</span><span class="p">((</span><span class="nx">sumOfValues</span><span class="p">,</span><span class="w"> </span><span class="nx">maxValue</span><span class="p">,</span><span class="w"> </span><span class="nx">idxOfMax</span><span class="p">,</span><span class="w"> </span><span class="nx">listOfValues</span><span class="p">[</span><span class="nx">idxOfMax</span><span class="p">]));</span>

<span class="c1">// Los escaneos aplican la operación de forma incremental y devuelven una matriz</span>
<span class="c1">// con los valores de la operación en ese índice a medida que avanza a través</span>
<span class="c1">// de la matriz desde array.domain.low hasta array.domain.high.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">runningSumOfValues</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">scan</span><span class="w"> </span><span class="nx">listOfValues</span><span class="p">;</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">maxScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">max</span><span class="w"> </span><span class="k">scan</span><span class="w"> </span><span class="nx">listOfValues</span><span class="p">;</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">runningSumOfValues</span><span class="p">);</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">maxScan</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// end main()</span>
</pre></div>
<h2>¿Para quién es este tutorial?</h2>

<p>Este tutorial es para personas que desean aprender las cuerdas de chapel sin tener
que escuchar sobre qué mezcla de fibras son las cuerdas, o cómo fueron trenzadas,
o cómo las configuraciones de trenzas difieren entre sí. No le enseñará cómo
desarrollar código increíblemente eficaz, y no es exhaustivo.
Referirse a <a href="https://chapel-lang.org/docs/latest/language/spec.html">especificación de idioma</a>(en) y
a <a href="https://chapel-lang.org/docs/latest/">documentación del módulo</a>(en) para más detalles.</p>

<p>Ocasionalmente, vuelva aquí en el <a href="https://chapel-lang.org">website de Chapel</a>
para ver si se han agregado más temas o se han creado más tutoriales.</p>

<h3>Lo que le falta a este tutorial:</h3>

<ul>
<li>Exposición de los <a href="https://chapel-lang.org/docs/latest/modules/standard.html">módulos estándar</a></li>
<li>Múltiples configuraciones regionales (sistema de memoria distribuida)</li>
<li>Registros</li>
<li>Iteradores paralelos</li>
</ul>

<h2>¡Sus comentarios, preguntas y descubrimientos son importantes para los desarrolladores!</h2>

<p>El lenguaje Chapel todavía está en desarrollo activo, por lo que 
ocasionalmente hay problemas con el rendimiento y 
las características del lenguaje.</p>

<p>Cuanta más información brinde al equipo de desarrollo de Chapel 
sobre los problemas que encuentre o las características que le gustaría ver, 
mejor será el lenguaje.</p>

<p>Hay varias formas de interactuar con los desarrolladores:
+ <a href="https://gitter.im/chapel-lang/chapel">Chat de Gitter</a>
+ <a href="https://sourceforge.net/p/chapel/mailman">lista de emails de Sourceforge</a></p>

<p>Si está realmente interesado en el desarrollo del compilador o en contribuir al proyecto,
<a href="https://github.com/chapel-lang/chapel">consulte el repositorio maestro de GitHub</a>.
Está bajo el <a href="http://www.apache.org/licenses/LICENSE-2.0">La licencia Apache 2.0</a>.</p>

<h2>Instalar el compilador</h2>

<p><a href="https://chapel-lang.org/docs/usingchapel/QUICKSTART.html">La documentación oficial de Chapel detalla cómo descargar y compilar el compilador de Chapel.</a></p>

<p>Chapel se puede construir e instalar en su máquina promedio &lsquo;nix (y cygwin). 
<a href="https://github.com/chapel-lang/chapel/releases/">Descargue la última versión de lanzamiento</a>
y es tan fácil como</p>

<ol>
<li><code>tar -xvf chapel-&lt;VERSION&gt;.tar.gz</code></li>
<li><code>cd chapel-&lt;VERSION&gt;</code></li>
<li><code>source util/setchplenv.bash # or .sh or .csh or .fish</code></li>
<li><code>make</code></li>
<li><code>make check # optional</code></li>
</ol>

<p>You will need to <code>source util/setchplenv.EXT</code> from within the Chapel directory
(<code>$CHPL_HOME</code>) every time your terminal starts so it&rsquo;s suggested that you drop
that command in a script that will get executed on startup (like .bashrc).</p>

<p>Necesitará <code>source util/setchplenv.EXT</code> desde el directorio de Chapel (<code>$CHPL_HOME</code>)
cada vez que se inicie su terminal, por lo que se sugiere que suelte ese comando 
en un script que se ejecutará al inicio (como .bashrc).</p>

<p>Chapel se instala fácilmente con Brew para OS X</p>

<ol>
<li><code>brew update</code></li>
<li><code>brew install chapel</code></li>
</ol>

<h2>Compilando Código</h2>

<p>Construye como otros compiladores:</p>

<p><code>chpl myFile.chpl -o myExe</code></p>

<p>Argumentos notables:</p>

<ul>
<li><code>--fast</code>: habilita varias optimizaciones y deshabilita las comprobaciones 
de los límites de la matriz Solo debe habilitarse cuando la aplicación es estable.</li>
<li><code>--set &lt;Nombre del Symbolo&gt;=&lt;Valor&gt;</code>: establece el param de configuracion 
<code>&lt;Nombre del Symbolo&gt;</code> a <code>&lt;Valor&gt;</code>en tiempo de compilación.</li>
<li><code>--main-module &lt;Nombre del módulo&gt;</code>: use el procedimiento main() que se encuentra en el módulo
    <code>&lt;Nombre del módulo&gt;</code> como principal del ejecutable.</li>
<li><code>--module-dir &lt;Directorio&gt;</code>: incluye <code>&lt;Directorio&gt;</code> en la ruta de búsqueda del módulo.</li>
</ul>

    <hr>
    <p>¿Tienes una sugerencia o rectificación? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Abre un issue</a> en el repositorio de Github, o haz un <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/es-es/chapel-es.html.markdown">pull request</a> tu mismo
    </p>
    <p class="contributed">
    Originalmente contribuido por Ian J. Bertolacci, y actualizado por <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/es-es/chapel-es.html.markdown">1 colaborador(es)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="https://www.cs.arizona.edu/~ianbertolacci/">Ian J. Bertolacci</a>,
        <a href="https://github.com/benharsh/">Ben Harshbarger</a>
    </p>

    <p>
      Translated by:
        <a href="https://github.com/AlburIvan">Ivan Alburquerque</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
