<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="es-es" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="es-es" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="es-es" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="es-es" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="es-es">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn clojure in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/es-es/clojure-es/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fes-es%2Fclojure-es%2F&text=Aprende+X+en+Y+minutos%2C+donde+X%3Dclojure">
        Comparte esta página
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Seleccione el tema:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">ligero</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">oscuro</button>
  </div>
  <h1><a href="/">Aprende X en Y minutos</a></h1>
  <h2>Donde X=clojure</h2>
    <p class="filelink">
    Descarga el código:
    <a href="/docs/files/learnclojure-es.clj">learnclojure-es.clj</a>
    </p>
  <div id="doc">
    <p>Clojure es un lenguaje de la familia Lisp desarrollado para la Máquina Virtual
de Java. Tiene un énfasis mayor en la
<a href="https://es.wikipedia.org/wiki/Programación_funcional">programación funcional</a>
pura que Common Lisp, pero incluye varias utilidades de
<a href="https://es.wikipedia.org/wiki/Memoria_transacional">SMT</a> para manipular
el estado según se presente.</p>

<p>Esta combinación le permite gestionar el procesamiento concurrente de manera
muy sencilla, y a menudo automáticamente.</p>

<p>(Necesitas la versión de Clojure 1.2 o reciente)</p>
<div class="highlight"><pre><span></span><span class="c1">; Los comentarios comienzan con punto y coma.</span>

<span class="c1">; Clojure se escribe mediante patrones (&quot;forms&quot;), los cuales son</span>
<span class="c1">; listas de cosas entre paréntesis, separados por espacios en blanco.</span>

<span class="c1">; El lector (&quot;reader&quot;) de Clojure asume que la primera cosa es una</span>
<span class="c1">; función o una macro a llamar, y el resto son argumentos.</span>

<span class="c1">; La primera llamada en un archivo debe ser ns, para establecer el espacio de</span>
<span class="c1">; nombres (&quot;namespace&quot;)</span>
<span class="p">(</span><span class="kd">ns </span><span class="nv">learnclojure</span><span class="p">)</span>

<span class="c1">; Algunos ejemplos básicos:</span>

<span class="c1">; str crea una cadena de caracteres a partir de sus argumentos</span>
<span class="p">(</span><span class="nb">str </span><span class="s">&quot;Hello&quot;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="s">&quot;World&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; &quot;Hello World&quot;</span>

<span class="c1">; Las operaciones matemáticas son sencillas</span>
<span class="p">(</span><span class="nb">+ </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; 2</span>
<span class="p">(</span><span class="nb">- </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; 1</span>
<span class="p">(</span><span class="nb">* </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; 2</span>
<span class="p">(</span><span class="nb">/ </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; 2</span>

<span class="c1">; La igualdad es =</span>
<span class="p">(</span><span class="nb">= </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; true</span>
<span class="p">(</span><span class="nb">= </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; false</span>

<span class="c1">; También es necesaria la negación para las operaciones lógicas</span>
<span class="p">(</span><span class="nb">not </span><span class="nv">true</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; false</span>

<span class="c1">; Los patrones anidados funcionan como esperas</span>
<span class="p">(</span><span class="nb">+ </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="nb">- </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="c1">; = 1 + (3 - 2) =&gt; 2</span>

<span class="c1">; Tipos</span>
<span class="c1">;;;;;;;;;;;;;</span>

<span class="c1">; Clojure usa los tipos de objetos de Java para booleanos, cadenas de</span>
<span class="c1">; caracteres (&quot;strings&quot;) y números.</span>
<span class="c1">; Usa class para inspeccionarlos.</span>
<span class="p">(</span><span class="nb">class </span><span class="mi">1</span><span class="p">)</span><span class="c1">; Los números enteros literales son java.lang.Long por defecto</span>
<span class="p">(</span><span class="nb">class </span><span class="mi">1</span><span class="nv">.</span><span class="p">)</span><span class="c1">; Los números en coma flotante literales son java.lang.Double</span>
<span class="p">(</span><span class="nb">class </span><span class="s">&quot;&quot;</span><span class="p">)</span><span class="c1">; Los strings siempre van entre comillas dobles, y son</span>
<span class="w">          </span><span class="c1">; java.lang.String</span>
<span class="p">(</span><span class="nb">class </span><span class="nv">false</span><span class="p">)</span><span class="c1">; Los booleanos son java.lang.Boolean</span>
<span class="p">(</span><span class="nb">class </span><span class="nv">nil</span><span class="p">)</span><span class="c1">; El valor &quot;null&quot; se escribe nil</span>

<span class="c1">; Si quieres crear una lista literal de datos, usa &#39; para evitar su evaluación</span>
<span class="o">&#39;</span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; (+ 1 2)</span>
<span class="c1">; (que es una abreviatura de (quote (+ 1 2)))</span>

<span class="c1">; Puedes evaluar una lista precedida por una comilla con eval</span>
<span class="p">(</span><span class="nb">eval </span><span class="o">&#39;</span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="c1">; =&gt; 3</span>

<span class="c1">; Colecciones &amp; Secuencias</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">; Las Listas están basadas en listas enlazadas, mientras que los Vectores en</span>
<span class="c1">; arreglos.</span>
<span class="c1">; ¡Los Vectores y las Listas también son clases de Java!</span>
<span class="p">(</span><span class="nb">class </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="c1">; =&gt; clojure.lang.PersistentVector</span>
<span class="p">(</span><span class="nb">class </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="c1">; =&gt; clojure.lang.PersistentList</span>

<span class="c1">; Una lista podría ser escrita como (1 2 3), pero debemos precederle una</span>
<span class="c1">; comilla para evitar que el lector (&quot;reader&quot;) piense que es una función.</span>
<span class="c1">; Además, (list 1 2 3) es lo mismo que &#39;(1 2 3)</span>

<span class="c1">; Las Colecciones (&quot;collections&quot;) son solo grupos de datos</span>
<span class="c1">; Tanto las Listas como los Vectores son colecciones:</span>
<span class="p">(</span><span class="nf">coll?</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="c1">; =&gt; true</span>
<span class="p">(</span><span class="nf">coll?</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="c1">; =&gt; true</span>

<span class="c1">; Las Secuencias (&quot;seqs&quot;) son descripciones abstractas de listas de datos.</span>
<span class="c1">; Solo las listas son secuencias (&quot;seqs&quot;).</span>
<span class="p">(</span><span class="nb">seq? </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="c1">; =&gt; true</span>
<span class="p">(</span><span class="nb">seq? </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="c1">; =&gt; false</span>

<span class="c1">; Una secuencia solo necesita proporcionar uno de sus elementos cuando es</span>
<span class="c1">; accedido.</span>
<span class="c1">; Así que, las secuencias pueden ser perezosas -- pueden definir series</span>
<span class="c1">; infinitas:</span>
<span class="p">(</span><span class="nb">range </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; (0 1 2 3)</span>
<span class="p">(</span><span class="nf">range</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; (0 1 2 3 4 ...) (una serie infinita)</span>
<span class="p">(</span><span class="nb">take </span><span class="mi">4</span><span class="w"> </span><span class="p">(</span><span class="nf">range</span><span class="p">))</span><span class="w"> </span><span class="c1">;  (0 1 2 3)</span>

<span class="c1">; Usa cons para agregar un elemento al inicio de una Lista o Vector</span>
<span class="p">(</span><span class="nb">cons </span><span class="mi">4</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="c1">; =&gt; (4 1 2 3)</span>
<span class="p">(</span><span class="nb">cons </span><span class="mi">4</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="c1">; =&gt; (4 1 2 3)</span>

<span class="c1">; conj agregará un elemento a una colección en la forma más eficiente.</span>
<span class="c1">; Para Listas, se añade al inicio. Para vectores, al final.</span>
<span class="p">(</span><span class="nb">conj </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; [1 2 3 4]</span>
<span class="p">(</span><span class="nb">conj </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; (4 1 2 3)</span>

<span class="c1">; Usa concat para concatenar Listas o Vectores</span>
<span class="p">(</span><span class="nb">concat </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="c1">; =&gt; (1 2 3 4)</span>

<span class="c1">; Usa filter y map para actuar sobre colecciones</span>
<span class="p">(</span><span class="nb">map inc </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="c1">; =&gt; (2 3 4)</span>
<span class="p">(</span><span class="nb">filter </span><span class="nv">even?</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="c1">; =&gt; (2)</span>

<span class="c1">; Usa reduce para combinar sus elementos</span>
<span class="p">(</span><span class="nb">reduce + </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">])</span>
<span class="c1">; = (+ (+ (+ 1 2) 3) 4)</span>
<span class="c1">; =&gt; 10</span>

<span class="c1">; reduce puede tomar un argumento como su valor inicial también</span>
<span class="p">(</span><span class="nb">reduce conj </span><span class="p">[]</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>
<span class="c1">; = (conj (conj (conj [] 3) 2) 1)</span>
<span class="c1">; =&gt; [3 2 1]</span>

<span class="c1">; Funciones</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">; Usa fn para crear nuevas funciones. Una función siempre devuelve</span>
<span class="c1">; su última expresión</span>
<span class="p">(</span><span class="k">fn </span><span class="p">[]</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; fn</span>

<span class="c1">; (Necesitas rodearlo con paréntesis para llamarla)</span>
<span class="p">((</span><span class="k">fn </span><span class="p">[]</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">))</span><span class="w"> </span><span class="c1">; =&gt; &quot;Hello World&quot;</span>

<span class="c1">; Puedes definir una variable (&quot;var&quot;) mediante def</span>
<span class="p">(</span><span class="k">def </span><span class="nv">x</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="nv">x</span><span class="w"> </span><span class="c1">; =&gt; 1</span>

<span class="c1">; Asignar una función a una variable (&quot;var&quot;)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">hello-world</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="p">[]</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="nf">hello-world</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; &quot;Hello World&quot;</span>

<span class="c1">; Puedes usar defn como atajo para lo anterior</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">hello-world</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">)</span>

<span class="c1">; El [] es el Vector de argumentos de la función.</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">hello</span><span class="w"> </span><span class="p">[</span><span class="nv">name</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">str </span><span class="s">&quot;Hello &quot;</span><span class="w"> </span><span class="nv">name</span><span class="p">))</span>
<span class="p">(</span><span class="nf">hello</span><span class="w"> </span><span class="s">&quot;Steve&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; &quot;Hello Steve&quot;</span>

<span class="c1">; Puedes usar esta abreviatura para definir funciones:</span>
<span class="p">(</span><span class="k">def </span><span class="nv">hello2</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">str </span><span class="s">&quot;Hello &quot;</span><span class="w"> </span><span class="nv">%1</span><span class="p">))</span>
<span class="p">(</span><span class="nf">hello2</span><span class="w"> </span><span class="s">&quot;Fanny&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; &quot;Hello Fanny&quot;</span>

<span class="c1">; Puedes tener funciones multi-variables (&quot;multi-variadic&quot;) también</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">hello3</span>
<span class="w">  </span><span class="p">([]</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">([</span><span class="nv">name</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">str </span><span class="s">&quot;Hello &quot;</span><span class="w"> </span><span class="nv">name</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">hello3</span><span class="w"> </span><span class="s">&quot;Jake&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; &quot;Hello Jake&quot;</span>
<span class="p">(</span><span class="nf">hello3</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; &quot;Hello World&quot;</span>

<span class="c1">; Las funciones pueden empaquetar argumentos extras en una secuencia para ti</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">count-args</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="nv">args</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">str </span><span class="s">&quot;You passed &quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">count </span><span class="nv">args</span><span class="p">)</span><span class="w"> </span><span class="s">&quot; args: &quot;</span><span class="w"> </span><span class="nv">args</span><span class="p">))</span>
<span class="p">(</span><span class="nf">count-args</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; &quot;You passed 3 args: (1 2 3)&quot;</span>

<span class="c1">; Puedes combinar los argumentos regulares y los empaquetados</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">hello-count</span><span class="w"> </span><span class="p">[</span><span class="nb">name </span><span class="o">&amp;</span><span class="w"> </span><span class="nv">args</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">str </span><span class="s">&quot;Hello &quot;</span><span class="w"> </span><span class="nb">name </span><span class="s">&quot;, you passed &quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">count </span><span class="nv">args</span><span class="p">)</span><span class="w"> </span><span class="s">&quot; extra args&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="nf">hello-count</span><span class="w"> </span><span class="s">&quot;Finn&quot;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
<span class="c1">; =&gt; &quot;Hello Finn, you passed 3 extra args&quot;</span>


<span class="c1">; Mapas</span>
<span class="c1">;;;;;;;;;;</span>

<span class="c1">; Los Mapas de Hash (&quot;HashMap&quot;) y Mapas de Arreglo (&quot;ArrayMap&quot;) comparten una</span>
<span class="c1">; interfaz. Los Mapas de Hash tienen búsquedas más rápidas pero no mantienen el</span>
<span class="c1">; orden de las llaves.</span>
<span class="p">(</span><span class="nb">class </span><span class="p">{</span><span class="ss">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ss">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ss">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w"> </span><span class="c1">; =&gt; clojure.lang.PersistentArrayMap</span>
<span class="p">(</span><span class="nb">class </span><span class="p">(</span><span class="nb">hash-map </span><span class="ss">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ss">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ss">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="c1">; =&gt; clojure.lang.PersistentHashMap</span>

<span class="c1">; Los Mapas de Arreglo se convierten automáticamente en Mapas de Hash en la</span>
<span class="c1">; mayoría de operaciones si crecen mucho, por lo que no debes preocuparte.</span>

<span class="c1">; Los Mapas pueden usar cualquier tipo para sus llaves, pero generalmente las</span>
<span class="c1">; Claves (&quot;keywords&quot;) son lo habitual.</span>
<span class="c1">; Las Claves son como strings con algunas ventajas de eficiencia</span>
<span class="p">(</span><span class="nb">class </span><span class="ss">:a</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; clojure.lang.Keyword</span>

<span class="p">(</span><span class="k">def </span><span class="nv">stringmap</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;a&quot;</span><span class="w"> </span><span class="mi">1</span>,<span class="w"> </span><span class="s">&quot;b&quot;</span><span class="w"> </span><span class="mi">2</span>,<span class="w"> </span><span class="s">&quot;c&quot;</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span>
<span class="nv">stringmap</span><span class="w">  </span><span class="c1">; =&gt; {&quot;a&quot; 1, &quot;b&quot; 2, &quot;c&quot; 3}</span>

<span class="p">(</span><span class="k">def </span><span class="nv">keymap</span><span class="w"> </span><span class="p">{</span><span class="ss">:a</span><span class="w"> </span><span class="mi">1</span>,<span class="w"> </span><span class="ss">:b</span><span class="w"> </span><span class="mi">2</span>,<span class="w"> </span><span class="ss">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span>
<span class="nv">keymap</span><span class="w"> </span><span class="c1">; =&gt; {:a 1, :c 3, :b 2}</span>

<span class="c1">; Por cierto, las comas son equivalentes a espacios en blanco y no hacen</span>
<span class="c1">; nada.</span>

<span class="c1">; Recupera un valor de un Mapa tratándola como una función</span>
<span class="p">(</span><span class="nf">stringmap</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; 1</span>
<span class="p">(</span><span class="nf">keymap</span><span class="w"> </span><span class="ss">:a</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; 1</span>

<span class="c1">; ¡Las Claves pueden ser usadas para recuperar su valor del mapa, también!</span>
<span class="p">(</span><span class="ss">:b</span><span class="w"> </span><span class="nv">keymap</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; 2</span>

<span class="c1">; No lo intentes con strings.</span>
<span class="c1">;(&quot;a&quot; stringmap)</span>
<span class="c1">; =&gt; Exception: java.lang.String cannot be cast to clojure.lang.IFn</span>

<span class="c1">; Recuperando una clave no existente nos devuelve nil</span>
<span class="p">(</span><span class="nf">stringmap</span><span class="w"> </span><span class="s">&quot;d&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; nil</span>

<span class="c1">; Usa assoc para añadir nuevas claves a los Mapas de Hash</span>
<span class="p">(</span><span class="k">def </span><span class="nv">newkeymap</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc </span><span class="nv">keymap</span><span class="w"> </span><span class="ss">:d</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span>
<span class="nv">newkeymap</span><span class="w"> </span><span class="c1">; =&gt; {:a 1, :b 2, :c 3, :d 4}</span>

<span class="c1">; Pero recuerda, ¡los tipos de Clojure son inmutables!</span>
<span class="nv">keymap</span><span class="w"> </span><span class="c1">; =&gt; {:a 1, :b 2, :c 3}</span>

<span class="c1">; Usa dissoc para eliminar claves</span>
<span class="p">(</span><span class="nb">dissoc </span><span class="nv">keymap</span><span class="w"> </span><span class="ss">:a</span><span class="w"> </span><span class="ss">:b</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; {:c 3}</span>

<span class="c1">; Conjuntos</span>
<span class="c1">;;;;;;</span>

<span class="p">(</span><span class="nb">class </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w"> </span><span class="c1">; =&gt; clojure.lang.PersistentHashSet</span>
<span class="p">(</span><span class="nb">set </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="c1">; =&gt; #{1 2 3}</span>

<span class="c1">; Añade un elemento con conj</span>
<span class="p">(</span><span class="nb">conj </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; #{1 2 3 4}</span>

<span class="c1">; Elimina uno con disj</span>
<span class="p">(</span><span class="nb">disj </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; #{2 3}</span>

<span class="c1">; Comprueba su existencia usando al Conjunto como una función:</span>
<span class="p">(</span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; 1</span>
<span class="p">(</span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; nil</span>

<span class="c1">; Hay más funciones en el espacio de nombres clojure.sets</span>

<span class="c1">; Patrones útiles</span>
<span class="c1">;;;;;;;;;;;;;;;;;</span>

<span class="c1">; Los operadores lógicos en clojure son solo macros, y presentan el mismo</span>
<span class="c1">; aspecto que el resto de patrones.</span>
<span class="p">(</span><span class="k">if </span><span class="nv">false</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="w"> </span><span class="s">&quot;b&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; &quot;b&quot;</span>
<span class="p">(</span><span class="k">if </span><span class="nv">false</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; nil</span>

<span class="c1">; Usa let para definir (&quot;binding&quot;) una variable temporal</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">a</span><span class="w"> </span><span class="nv">b</span><span class="p">))</span><span class="w"> </span><span class="c1">; =&gt; false</span>

<span class="c1">; Agrupa sentencias mediante do</span>
<span class="p">(</span><span class="nf">do</span>
<span class="w">  </span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;Hello&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;World&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; &quot;World&quot; (prints &quot;Hello&quot;)</span>

<span class="c1">; Las funciones tienen un do implícito</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">print-and-say-hello</span><span class="w"> </span><span class="p">[</span><span class="nv">name</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;Saying hello to &quot;</span><span class="w"> </span><span class="nv">name</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">str </span><span class="s">&quot;Hello &quot;</span><span class="w"> </span><span class="nv">name</span><span class="p">))</span>
<span class="p">(</span><span class="nf">print-and-say-hello</span><span class="w"> </span><span class="s">&quot;Jeff&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">;=&gt; &quot;Hello Jeff&quot; (prints &quot;Saying hello to Jeff&quot;)</span>

<span class="c1">; Y let también</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nb">name </span><span class="s">&quot;Urkel&quot;</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;Saying hello to &quot;</span><span class="w"> </span><span class="nv">name</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">str </span><span class="s">&quot;Hello &quot;</span><span class="w"> </span><span class="nv">name</span><span class="p">))</span><span class="w"> </span><span class="c1">; =&gt; &quot;Hello Urkel&quot; (prints &quot;Saying hello to Urkel&quot;)</span>

<span class="c1">; Usa las macros de tubería (&quot;threading&quot;, &quot;arrow&quot;, &quot;pipeline&quot; o &quot;chain&quot;)</span>
<span class="c1">; (-&gt; y -&gt;&gt;) para expresar la transformación de datos de una manera más clara.</span>

<span class="c1">; La macro Tubería-primero (&quot;Thread-first&quot;) (-&gt;) inserta en cada patrón el</span>
<span class="c1">; resultado de los previos, como el primer argumento (segundo elemento)</span>
<span class="p">(</span><span class="nf">-&gt;</span>
<span class="w">   </span><span class="p">{</span><span class="ss">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ss">:b</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span>
<span class="w">   </span><span class="p">(</span><span class="nb">assoc </span><span class="ss">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">;=&gt; (assoc {:a 1 :b 2} :c 3)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">dissoc </span><span class="ss">:b</span><span class="p">))</span><span class="w"> </span><span class="c1">;=&gt; (dissoc (assoc {:a 1 :b 2} :c 3) :b)</span>

<span class="c1">; Esta expresión podría ser escrita como:</span>
<span class="c1">; (dissoc (assoc {:a 1 :b 2} :c 3) :b)</span>
<span class="c1">; y evalua a {:a 1 :c 3}</span>

<span class="c1">; La macro Tubería-último (&quot;Thread-last&quot;) hace lo mismo, pero inserta el</span>
<span class="c1">; resultado de cada línea al *final* de cada patrón. Esto es útil para las</span>
<span class="c1">; operaciones de colecciones en particular:</span>
<span class="p">(</span><span class="nf">-&gt;&gt;</span>
<span class="w">   </span><span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">map </span><span class="nv">inc</span><span class="p">)</span><span class="w">     </span><span class="c1">;=&gt; (map inc (range 10)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">filter </span><span class="nv">odd?</span><span class="p">)</span><span class="w"> </span><span class="c1">;=&gt; (filter odd? (map inc (range 10))</span>
<span class="w">   </span><span class="p">(</span><span class="nb">into </span><span class="p">[]))</span><span class="w">    </span><span class="c1">;=&gt; (into [] (filter odd? (map inc (range 10)))</span>
<span class="w">                 </span><span class="c1">; Result: [1 3 5 7 9]</span>

<span class="c1">; Cuando estés en una situación donde quieras tener más libertad en donde</span>
<span class="c1">; poner el resultado de transformaciones previas de datos en una expresión,</span>
<span class="c1">; puedes usar la macro as-&gt;. Con ella, puedes asignar un nombre especifico</span>
<span class="c1">; a la salida de la transformaciones y usarlo como identificador en tus</span>
<span class="c1">; expresiones encadenadas (&quot;chain&quot;).</span>

<span class="p">(</span><span class="nf">as-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="nv">input</span>
<span class="w">  </span><span class="p">(</span><span class="nb">map inc </span><span class="nv">input</span><span class="p">)</span><span class="c1">;=&gt; You can use last transform&#39;s output at the last position</span>
<span class="w">  </span><span class="p">(</span><span class="nb">nth </span><span class="nv">input</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">;=&gt;  and at the second position, in the same expression</span>
<span class="w">  </span><span class="p">(</span><span class="nb">conj </span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="nv">input</span><span class="w"> </span><span class="p">[</span><span class="mi">8</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">10</span><span class="p">]))</span><span class="w"> </span><span class="c1">;=&gt; or in the middle !</span>


<span class="c1">; Módulos</span>
<span class="c1">;;;;;;;;;;;;;;;</span>

<span class="c1">; Usa use para obtener todas las funciones del módulo</span>
<span class="p">(</span><span class="nf">use</span><span class="w"> </span><span class="ss">&#39;clojure.set</span><span class="p">)</span>

<span class="c1">; Ahora podemos usar más operaciones de Conjuntos</span>
<span class="p">(</span><span class="nb">intersection </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">})</span><span class="w"> </span><span class="c1">; =&gt; #{2 3}</span>
<span class="p">(</span><span class="nb">difference </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">})</span><span class="w"> </span><span class="c1">; =&gt; #{1}</span>

<span class="c1">; Puedes escoger un subgrupo de funciones a importar, también</span>
<span class="p">(</span><span class="nf">use</span><span class="w"> </span><span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.set</span><span class="w"> </span><span class="ss">:only</span><span class="w"> </span><span class="p">[</span><span class="nv">intersection</span><span class="p">]])</span>

<span class="c1">; Usa require para importar un módulo</span>
<span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="ss">&#39;clojure.string</span><span class="p">)</span>

<span class="c1">; Usa / para llamar las funciones de un módulo</span>
<span class="c1">; Aquí, el módulo es clojure.string y la función es blank?</span>
<span class="p">(</span><span class="nf">clojure.string/blank?</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; true</span>

<span class="c1">; Puedes asignarle una sobrenombre a un modulo al importarlo</span>
<span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.string</span><span class="w"> </span><span class="ss">:as</span><span class="w"> </span><span class="nv">str</span><span class="p">])</span>
<span class="p">(</span><span class="nf">str/replace</span><span class="w"> </span><span class="s">&quot;This is a test.&quot;</span><span class="w"> </span><span class="o">#</span><span class="s">&quot;[a-o]&quot;</span><span class="w"> </span><span class="nv">str/upper-case</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; &quot;THIs Is A tEst.&quot;</span>
<span class="c1">; (#&quot;&quot; es una expresión regular literal)</span>

<span class="c1">; Puedes usar require (y use, pero no lo hagas) desde un espacio de nombres</span>
<span class="c1">; usando :require,</span>
<span class="c1">; No necesitas preceder con comilla tus módulos si lo haces de esta manera.</span>
<span class="p">(</span><span class="kd">ns </span><span class="nv">test</span>
<span class="w">  </span><span class="p">(</span><span class="ss">:require</span>
<span class="w">    </span><span class="p">[</span><span class="nv">clojure.string</span><span class="w"> </span><span class="ss">:as</span><span class="w"> </span><span class="nv">str</span><span class="p">]</span>
<span class="w">    </span><span class="p">[</span><span class="nv">clojure.set</span><span class="w"> </span><span class="ss">:as</span><span class="w"> </span><span class="nv">set</span><span class="p">]))</span>

<span class="c1">; Java</span>
<span class="c1">;;;;;;;;;;;;;;;;;</span>

<span class="c1">; Java tiene una enorme y útil librería estándar, por lo que querrás</span>
<span class="c1">; aprender como hacer uso de ella.</span>

<span class="c1">; Usa import para cargar un módulo de java</span>
<span class="p">(</span><span class="nb">import </span><span class="nv">java.util.Date</span><span class="p">)</span>

<span class="c1">; Puedes importar desde un ns también.</span>
<span class="p">(</span><span class="kd">ns </span><span class="nv">test</span>
<span class="w">  </span><span class="p">(</span><span class="ss">:import</span><span class="w"> </span><span class="nv">java.util.Date</span>
<span class="w">           </span><span class="nv">java.util.Calendar</span><span class="p">))</span>

<span class="c1">; Usa el nombre de la clase con un &quot;.&quot; al final para crear una nueva instancia</span>
<span class="p">(</span><span class="nf">Date.</span><span class="p">)</span><span class="w"> </span><span class="c1">; &lt;un objeto Date&gt;</span>

<span class="c1">; Usa &quot;.&quot; para llamar métodos. O, usa el atajo &quot;.método&quot;</span>
<span class="p">(</span><span class="k">. </span><span class="p">(</span><span class="nf">Date.</span><span class="p">)</span><span class="w"> </span><span class="nv">getTime</span><span class="p">)</span><span class="w"> </span><span class="c1">; &lt;un timestamp&gt;</span>
<span class="p">(</span><span class="nf">.getTime</span><span class="w"> </span><span class="p">(</span><span class="nf">Date.</span><span class="p">))</span><span class="w"> </span><span class="c1">; exactamente lo mismo.</span>

<span class="c1">; Usa / para llamar métodos estáticos.</span>
<span class="p">(</span><span class="nf">System/currentTimeMillis</span><span class="p">)</span><span class="w"> </span><span class="c1">; &lt;un timestamp&gt; (System siempre está presente)</span>

<span class="c1">; Usa doto para lidiar con el uso de clases (mutables) de una manera más</span>
<span class="c1">; tolerable</span>
<span class="p">(</span><span class="nb">import </span><span class="nv">java.util.Calendar</span><span class="p">)</span>
<span class="p">(</span><span class="nb">doto </span><span class="p">(</span><span class="nf">Calendar/getInstance</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">.set</span><span class="w"> </span><span class="mi">2000</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">  </span><span class="nv">.getTime</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; A Date. set to 2000-01-01 00:00:00</span>

<span class="c1">; STM</span>
<span class="c1">;;;;;;;;;;;;;;;;;</span>

<span class="c1">; La Memoria Transaccional (&quot;Software Transactional Memory&quot; / &quot;STM&quot;) es un</span>
<span class="c1">; mecanismo que usa clojure para gestionar la persistecia de estado. Hay unas</span>
<span class="c1">; cuantas construcciones en clojure que hacen uso de él.</span>

<span class="c1">; Un atom es el más sencillo. Se le da un valor inicial</span>
<span class="p">(</span><span class="k">def </span><span class="nv">my-atom</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="p">{}))</span>

<span class="c1">; Actualiza un atom con swap!</span>
<span class="c1">; swap! toma una función y la llama con el valor actual del atom</span>
<span class="c1">; como su primer argumento, y cualquier argumento restante como el segundo</span>
<span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="nv">my-atom</span><span class="w"> </span><span class="nb">assoc </span><span class="ss">:a</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">; Establece my-atom al resultado</span>
<span class="w">                           </span><span class="c1">; de (assoc {} :a 1)</span>
<span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="nv">my-atom</span><span class="w"> </span><span class="nb">assoc </span><span class="ss">:b</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">; Establece my-atom al resultado</span>
<span class="w">                           </span><span class="c1">; de (assoc {:a 1} :b 2)</span>

<span class="c1">; Usa &#39;@&#39; para no referenciar al atom y obtener su valor</span>
<span class="nv">my-atom</span><span class="w">  </span><span class="c1">;=&gt; Atom&lt;#...&gt; (Regresa el objeto Atom)</span>
<span class="o">@</span><span class="nv">my-atom</span><span class="w"> </span><span class="c1">; =&gt; {:a 1 :b 2}</span>

<span class="c1">; Aquí está un sencillo contador usando un atom</span>
<span class="p">(</span><span class="k">def </span><span class="nv">counter</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">inc-counter</span><span class="w"> </span><span class="p">[]</span>
<span class="w">  </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="nv">counter</span><span class="w"> </span><span class="nv">inc</span><span class="p">))</span>

<span class="p">(</span><span class="nf">inc-counter</span><span class="p">)</span>
<span class="p">(</span><span class="nf">inc-counter</span><span class="p">)</span>
<span class="p">(</span><span class="nf">inc-counter</span><span class="p">)</span>
<span class="p">(</span><span class="nf">inc-counter</span><span class="p">)</span>
<span class="p">(</span><span class="nf">inc-counter</span><span class="p">)</span>

<span class="o">@</span><span class="nv">counter</span><span class="w"> </span><span class="c1">; =&gt; 5</span>

<span class="c1">; Otras construcciones de STM son refs y agents.</span>
<span class="c1">; Refs: http://clojure.org/refs</span>
<span class="c1">; Agents: http://clojure.org/agents</span>
</pre></div>
<h3>Lectura adicional</h3>

<p>Ésto queda lejos de ser exhaustivo, pero ojalá que sea suficiente para que
puedas empezar tu camino.</p>

<p>Clojure.org tiene muchos artículos:
<a href="http://clojure.org">http://clojure.org</a></p>

<p>Clojuredocs.org contiene documentación con ejemplos para la mayoría de
funciones principales (pertenecientes al core):
<a href="http://clojuredocs.org/quickref">http://clojuredocs.org/quickref</a></p>

<p>4Clojure es una genial forma de mejorar tus habilidades con clojure/FP:
<a href="https://4clojure.oxal.org/">https://4clojure.oxal.org/</a></p>

<p>Clojure-doc.org (sí, de verdad) tiene un buen número de artículos con los que
iniciarse en Clojure: <a href="http://clojure-doc.org">http://clojure-doc.org</a></p>

    <hr>
    <p>¿Tienes una sugerencia o rectificación? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Abre un issue</a> en el repositorio de Github, o haz un <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/es-es/clojure-es.html.markdown">pull request</a> tu mismo
    </p>
    <p class="contributed">
    Originalmente contribuido por Adam Bard, y actualizado por <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/es-es/clojure-es.html.markdown">2 colaborador(es)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://adambard.com/">Adam Bard</a>
    </p>

    <p>
      Translated by:
        <a href="https://twitter.com/nihilipster">Antonio Hernández Blas</a>
        <a href="http://willyfrog.es">Guillermo Vayá Pérez</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
