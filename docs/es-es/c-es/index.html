<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="es-es" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="es-es" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="es-es" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="es-es" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="es-es">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn C in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/es-es/c-es/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }
                el.className = theme === "dark" ? "dark" : "light";
                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (!theme) {
                theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"
              }
              set_theme(theme)
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.onload = function(){
              load_theme();
            };

            // Listen for system preference change
            window
              .matchMedia("(prefers-color-scheme: dark)")
              .addEventListener("change", ({matches:isDark}) => {
                set_theme(isDark ? "dark" : "light")
              })
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fes-es%2Fc-es%2F&text=Aprende+X+en+Y+minutos%2C+donde+X%3DC">
        Comparte esta página
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Seleccione el tema:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">ligero</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">oscuro</button>
  </div>
  <h1><a href="/">Aprende X en Y minutos</a></h1>
  <h2>Donde X=C</h2>
    <p class="filelink">
    Descarga el código:
    <a href="/docs/files/learnc-es.c">learnc-es.c</a>
    </p>
  <div id="doc">
    <p>¡Ah!, C. Aun hoy en día sigue siendo el lenguaje por excelencia de la 
computación moderna de alto rendimiento.</p>

<p>C es el lenguaje de más bajo nivel que la mayoría de los programadores
llegarán a usar, pero lo compensa de sobra con pura velocidad. Solo
ten en cuenta el manejo manual de memoria y te llevará tan lejos como
necesites.</p>
<div class="highlight"><pre><span></span><span class="c1">// Los comentarios de una sola línea comienzan con //</span>

<span class="cm">/*</span>
<span class="cm">Los comentarios multilínea tienen este aspecto.</span>
<span class="cm">*/</span>

<span class="c1">// Importa cabeceras con #include</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>

<span class="c1">// Declara por adelantado las armaduras de las funciones en un archivo .h,</span>
<span class="c1">// o al principio de tu archivo .c .</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">function_1</span><span class="p">();</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">function_2</span><span class="p">();</span>

<span class="c1">// El punto de entrada de tu programa es una función llamada main con</span>
<span class="c1">// retorno de tipo entero (integer).</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="c1">// Muestra la salida usando printf, para el &quot;formato print&quot;</span>
<span class="c1">// %d es un entero, \n es una nueva línea</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Muestra 0</span>
<span class="c1">// Todas las sentencias deben terminar con un punto y coma.</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Tipos</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// Tienes que declarar una variable antes de usarla. La declaración de una</span>
<span class="c1">// variable necesites que especifiques su tipo; el tipo de una variable</span>
<span class="c1">// determina su tamaño en bytes.</span>

<span class="c1">// &#39;ints&#39; (enteros) son normalmente de 4 bytes</span>
<span class="kt">int</span><span class="w"> </span><span class="n">x_int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// &#39;shorts&#39; son normalmente de 2 bytes</span>
<span class="kt">short</span><span class="w"> </span><span class="n">x_short</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// &#39;chars&#39; son fijo de 1 byte</span>
<span class="kt">char</span><span class="w"> </span><span class="n">x_char</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kt">char</span><span class="w"> </span><span class="n">y_char</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;y&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Los caracteres literales se entrecomillan con &#39;&#39;</span>

<span class="c1">// &#39;longs&#39; son a menudo de 4 a 8 bytes; &#39;long longs&#39; son fijo de por lo</span>
<span class="c1">// menos 64 bits</span>
<span class="kt">long</span><span class="w"> </span><span class="n">x_long</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x_long_long</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span>

<span class="c1">// &#39;floats&#39; son normalmente números de coma flotante de 32 bits</span>
<span class="kt">float</span><span class="w"> </span><span class="n">x_float</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>

<span class="c1">// &#39;doubles&#39; son normalmente números de coma flotante de 64 bits</span>
<span class="kt">double</span><span class="w"> </span><span class="n">x_double</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>

<span class="c1">// Todos los tipos enteros pueden ser &#39;unsigned&#39;. Esto significa que no</span>
<span class="c1">// pueden ser negativos, pero el valor máximo de una variable &#39;unsigned&#39;</span>
<span class="c1">// es mayor que el de una no &#39;unsigned&#39; del mismo tamaño.</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">ux_char</span><span class="p">;</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">ux_short</span><span class="p">;</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ux_int</span><span class="p">;</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">ux_long_long</span><span class="p">;</span>

<span class="c1">// Todos menos &#39;char&#39;, que es siempre de 1 byte, varían el tamaño </span>
<span class="c1">// dependiendo de tu máquina. sizeof(T) te dice el tamaño de una variable</span>
<span class="c1">// de tipo T en bytes por lo que podemos expresar el tamaño de estos tipos</span>
<span class="c1">// portatilmente.</span>
<span class="c1">// Por ejemplo,</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"> </span><span class="c1">// =&gt; 4 (en máquinas con &#39;words&#39; de 4 bytes)</span>

<span class="c1">// Los arrays deben ser inicializados con un tamaño concreto.</span>
<span class="kt">char</span><span class="w"> </span><span class="n">my_char_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span><span class="w"> </span><span class="c1">// Este array ocupa 1 * 20 = 20 bytes</span>
<span class="kt">int</span><span class="w"> </span><span class="n">my_int_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span><span class="w"> </span><span class="c1">// Este array ocupa 4 * 20 = 80 bytes</span>
<span class="w">                      </span><span class="c1">// (suponiendo que tenemos &#39;words&#39; de 4-byte)</span>


<span class="c1">// Puedes inicializar un array a 0 así:</span>
<span class="kt">char</span><span class="w"> </span><span class="n">my_array</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>

<span class="c1">// Indexar un array es como en otros lenguajes -o, más bien, otros</span>
<span class="c1">// lenguajes son como C-</span>
<span class="n">my_array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="c1">// =&gt; 0</span>

<span class="c1">// Los arrays varían; ¡son sólo memoria!</span>
<span class="n">my_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">my_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"> </span><span class="c1">// =&gt; 2</span>

<span class="c1">// Las cadenas (strings) son sólo arrays de &#39;chars&#39; (caracteres)</span>
<span class="c1">// terminados en un byte NUL (0x00), representado en las cadenas como el</span>
<span class="c1">// carácter especial &#39;\0&#39;.</span>
<span class="c1">// (No tenemos porqué añadir el byte nulo en cadenas literales; el</span>
<span class="c1">// compilador lo añade al final por nosotros.)</span>
<span class="kt">char</span><span class="w"> </span><span class="n">a_string</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Esto es una cadena&quot;</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a_string</span><span class="p">);</span><span class="w"> </span><span class="c1">// %s se sutituye por una cadena.</span>

<span class="cm">/*</span>
<span class="cm">Te habrás dado cuenta de que a_string es solo de 18 caracteres.</span>
<span class="cm">El &#39;char&#39; #19 es el byte nulo. </span>
<span class="cm">El &#39;char&#39; #20 es de valor indefinido.</span>
<span class="cm">*/</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a_string</span><span class="p">[</span><span class="mi">18</span><span class="p">]);</span><span class="w"> </span><span class="c1">// =&gt; 0</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Operadores</span>
<span class="c1">///////////////////////////////////////</span>

<span class="kt">int</span><span class="w"> </span><span class="n">i1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">i2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// Forma corta de declaración múltiple</span>
<span class="kt">float</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="n">f2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span>

<span class="c1">// La aritmética es sencilla</span>
<span class="n">i1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 3</span>
<span class="n">i2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">i1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>
<span class="n">i2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 2</span>
<span class="n">i1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">i2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0 (0.5, pero es truncado tras el 0)</span>

<span class="n">f1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0.5, más o menos épsilon</span>
<span class="c1">// Módulo está también</span>
<span class="mi">11</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 2</span>

<span class="c1">// Los operadores de comparación te resultaran familiares, pero no hay</span>
<span class="c1">// booleanos en C. Usamos enteros (ints) en su lugar. 0 es falso,</span>
<span class="c1">// cualquier otra cosa es verdadero. (Los operadores de comparación </span>
<span class="c1">// siempre devuelven 0 o 1)</span>
<span class="mi">3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0 (Falso)</span>
<span class="mi">3</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1 (Verdadero)</span>
<span class="mi">3</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>
<span class="mi">3</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0</span>
<span class="mi">2</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>
<span class="mi">2</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>

<span class="c1">// La lógica funiona en enteros</span>
<span class="o">!</span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0 (not lógico)</span>
<span class="o">!</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>
<span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1 (and lógico)</span>
<span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0</span>
<span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1 (or lógico)</span>
<span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0</span>

<span class="c1">// ¡Operadores de bits!</span>
<span class="o">~</span><span class="mh">0x0F</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0xF0 (Negación)</span>
<span class="mh">0x0F</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xF0</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0x00 (AND)</span>
<span class="mh">0x0F</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0xF0</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0xFF (OR)</span>
<span class="mh">0x04</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="mh">0x0F</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0x0B (XOR)</span>
<span class="mh">0x01</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0x02 (desplazar hacia la izquierda (por 1))</span>
<span class="mh">0x02</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0x01 (desplazar hacia la derecha (por 1))</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Estructuras de Control</span>
<span class="c1">///////////////////////////////////////</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Yo nunca ocurro</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Yo tampoco ocurro nunca</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Yo me muestro</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Mientras el bucle exista</span>
<span class="kt">int</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">ii</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ii</span><span class="o">++</span><span class="p">);</span><span class="w"> </span><span class="c1">// ii++ incrementa ii en uno, después de usar su valor.</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// =&gt; muestra &quot;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="kt">int</span><span class="w"> </span><span class="n">kk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">kk</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">++</span><span class="n">kk</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="c1">// ++kk incrementa kk en uno, antes de usar su valor.</span>
<span class="c1">// =&gt; muestra &quot;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="c1">// Bucles &#39;for&#39; también</span>
<span class="kt">int</span><span class="w"> </span><span class="n">jj</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">jj</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">jj</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">jj</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">jj</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// =&gt; muestra &quot;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Cambios de Tipo</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// Cada valor en C tiene un tipo,  pero tu puedes ingresar un valor en</span>
<span class="c1">// otro tipo si quieres.</span>

<span class="kt">int</span><span class="w"> </span><span class="n">x_hex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x01</span><span class="p">;</span><span class="w"> </span><span class="c1">// Puedes asignar hexadecimales a variables</span>

<span class="c1">// El cambio de tipos intentará mantener sus valores numéricos</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x_hex</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Muestra 1</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">short</span><span class="p">)</span><span class="w"> </span><span class="n">x_hex</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Muestra 1</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="n">x_hex</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Muestra 1</span>

<span class="c1">// Los tipos se desbordan sin aviso</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="mi">257</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; 1 (El valor máximo de un &#39;char&#39; es 255)</span>

<span class="c1">// Los tipos enteros puden cambiarse a tipos de coma flotante, y viceversa</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="mi">100</span><span class="p">);</span><span class="w"> </span><span class="c1">// %f se sustituye por un &#39;float&#39;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="mi">100</span><span class="p">);</span><span class="w"> </span><span class="c1">// %lf se sustituye por un &#39;double&#39;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mf">100.0</span><span class="p">);</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Punteros</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// Un puntero es una variable declarada para almacenar una dirección de </span>
<span class="c1">// memoria. Su declaración además nos dirá el tipo de dato al que apunta. </span>
<span class="c1">// Puedes obtener la dirección de memoria de tus variables, y después</span>
<span class="c1">// enlazarlas con ellos.</span>

<span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// Usa &amp; para obtener la dirección de una variable.</span>
<span class="c1">// (%p se sustituye por un puntero)</span>
<span class="c1">// =&gt; Muestra alguna dirección de memoria;</span>

<span class="c1">// Los tipos de puntero terminan con * en su declaración</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">px</span><span class="p">;</span><span class="w"> </span><span class="c1">// px es un puntero a un &#39;int&#39;</span>
<span class="n">px</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// Almacena la dirección de x en px</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">px</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Muestra alguna dirección de memoria</span>

<span class="c1">// Para obtener el valor de la dirección a la que apunta un puntero, pon</span>
<span class="c1">// * delante para desreferenciarle. </span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">px</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Muestra 0, el valor de x y de la dirección a la</span>
<span class="w">                     </span><span class="c1">//    que apunta px</span>

<span class="c1">// También puedes cambiar el valor al que está apuntando el puntero.</span>
<span class="c1">// Tenemos que meter la desreferencia entre paréntesis porque ++ tiene</span>
<span class="c1">// prioridad frente a *.</span>
<span class="p">(</span><span class="o">*</span><span class="n">px</span><span class="p">)</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">// Incrementa el valor al que apunta px en 1</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">px</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Muestra 1</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Muestra 1</span>

<span class="kt">int</span><span class="w"> </span><span class="n">x_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span><span class="w"> </span><span class="c1">// Los arrays son una buena manera de distribuir bloques</span>
<span class="kt">int</span><span class="w"> </span><span class="n">xx</span><span class="p">;</span><span class="w">          </span><span class="c1">// continuos de memoria.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">xx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">xx</span><span class="o">&lt;</span><span class="mi">20</span><span class="p">;</span><span class="w"> </span><span class="n">xx</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x_array</span><span class="p">[</span><span class="n">xx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">xx</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// Inicializa x_array a 20, 19, 18,... 2, 1</span>

<span class="c1">// Declara un puntero de tipo &#39;int&#39; y lo inicializa para apuntar a x_array</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">x_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x_array</span><span class="p">;</span>
<span class="c1">// x_ptr ahira apunta al primer elemento del &#39;array&#39; (el entero 20).</span>
<span class="c1">// Esto funciona porque las &#39;arrays&#39; actualmente son solo punteros a su</span>
<span class="c1">// primer elemento.</span>

<span class="c1">// Los &#39;arrays&#39; son punteros a su primer elemento.</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">x_ptr</span><span class="p">));</span><span class="w"> </span><span class="c1">// =&gt; Muestra 20</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"> </span><span class="c1">// =&gt; Muestra 20</span>

<span class="c1">// Los punteros aumentan y disminuyen en función de su tipo.</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">x_ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w"> </span><span class="c1">// =&gt; Muestra 19</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"> </span><span class="c1">// =&gt; Muestra 19</span>

<span class="c1">// Puedes también asigner dinamicamente bloques contiguos de memoria con</span>
<span class="c1">// la función malloc de la librería estándard, que toma un entero como</span>
<span class="c1">// argumento representando el número de bytes a asignar de la pila.</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">my_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">20</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">xx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">xx</span><span class="o">&lt;</span><span class="mi">20</span><span class="p">;</span><span class="w"> </span><span class="n">xx</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">*</span><span class="p">(</span><span class="n">my_ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">xx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">xx</span><span class="p">;</span><span class="w"> </span><span class="c1">// my_ptr[xx] = 20-xx funcionaría también aquí</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// Inicializa la memoria a 20, 19, 18, 17... 2, 1 (como &#39;ints&#39;)</span>

<span class="c1">// Desreferenciando la memoria que no has asignado te dará resultados</span>
<span class="c1">// impredecibles</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">my_ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">21</span><span class="p">));</span><span class="w"> </span><span class="c1">// =&gt; Prints who-knows-what?</span>

<span class="c1">// Cuando hayas acabado con el bloque de memoría malloc, necesitas </span>
<span class="c1">// liberarlo o sino nadie más podrá usarlo hasta que tu programa se cierre</span>
<span class="n">free</span><span class="p">(</span><span class="n">my_ptr</span><span class="p">);</span>

<span class="c1">// Las cadenas pueden ser &#39;arrays&#39; de chars, pero normalmente se</span>
<span class="c1">// representan con punteros &#39;char&#39;:</span>
<span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">my_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;This is my very own string&quot;</span><span class="p">;</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">my_str</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; &#39;T&#39;</span>

<span class="n">function_1</span><span class="p">();</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// fin de la función main</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Funciones</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// Sintexis de la declaración de funciones:</span>
<span class="c1">// &lt;tipo de retorno&gt; &lt;nombre&gt;(&lt;argumentos&gt;)</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">add_two_ints</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x2</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x2</span><span class="p">;</span><span class="w"> </span><span class="c1">// Usa &#39;return&#39; para dar una salida</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">Las funciones son de paso por valor, pero puedes hacer tus propias </span>
<span class="cm">referencias con punteros de manera que las funciones puedan cambiar sus </span>
<span class="cm">valores.</span>

<span class="cm">Ejemplo: invertidor de cadenas in-situ</span>
<span class="cm">*/</span>

<span class="c1">// Una función &#39;void&#39; no retorna valor</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">str_reverse</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">str_in</span><span class="p">){</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ii</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">str_in</span><span class="p">);</span><span class="w"> </span><span class="c1">// Strlen es parte de la librería </span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">ii</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">ii</span><span class="o">&lt;</span><span class="n">len</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">ii</span><span class="o">++</span><span class="p">){</span><span class="w">      </span><span class="c1">// estándard</span>
<span class="w">        </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str_in</span><span class="p">[</span><span class="n">ii</span><span class="p">];</span>
<span class="w">        </span><span class="n">str_in</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str_in</span><span class="p">[</span><span class="n">len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="c1">// ii-th último &#39;char&#39;</span>
<span class="w">        </span><span class="n">str_in</span><span class="p">[</span><span class="n">len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">char c[] = &quot;Esto es una prueba.&quot;;</span>
<span class="cm">str_reverse(c);</span>
<span class="cm">printf(&quot;%s\n&quot;, c); // =&gt; &quot;.abeurp anu se otsE&quot;</span>
<span class="cm">*/</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Definición de tipos y estructuras</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// Los &#39;Typedefs&#39; pueden ser utilizados para crear alias de tipos.</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">my_type</span><span class="p">;</span>
<span class="n">my_type</span><span class="w"> </span><span class="n">my_type_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// Las estructuras son sólo grupos de datos.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">height</span><span class="p">;</span>
<span class="p">};</span>


<span class="kt">void</span><span class="w"> </span><span class="nf">function_1</span><span class="p">(){</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="n">my_rec</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Utiliza los miembros de una estructura con .</span>
<span class="w">    </span><span class="n">my_rec</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">    </span><span class="n">my_rec</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Puedes declarar punteros a estructuras</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="o">*</span><span class="w"> </span><span class="n">my_rec_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">my_rec</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Usa la desreferencia para modificar sus miembros...</span>
<span class="w">    </span><span class="p">(</span><span class="o">*</span><span class="n">my_rec_ptr</span><span class="p">).</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// ... o usa la abreviatura -&gt;</span>
<span class="w">    </span><span class="n">my_rec_ptr</span><span class="o">-&gt;</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="c1">// Lo mismo que (*my_rec_ptr).height = 10;</span>
<span class="p">}</span>

<span class="c1">// Puedes aplicar un &#39;typedef&#39; a una estructura por conveniencía.</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="n">rect</span><span class="p">;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">area</span><span class="p">(</span><span class="n">rect</span><span class="w"> </span><span class="n">r</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Punteros a Funciones</span>
<span class="c1">///////////////////////////////////////</span>
<span class="cm">/*</span>
<span class="cm">En tiempo de ejecución,  las funciones se localizan en unas direcciones de</span>
<span class="cm">memoria concretas. Los punteros a funciones son como cualquier otro </span>
<span class="cm">puntero (almacenan una dirección de memoria), pero pueden ser usados para </span>
<span class="cm">utilizar funciones directamente, o para pasar &#39;handlers&#39; (o funciones </span>
<span class="cm">&#39;callback&#39;) por todos lados.</span>
<span class="cm">Sin embargo, la sintaxis de definición parecera confusa al principio.</span>

<span class="cm">Ejemplo: usar str_reverse desde un puntero</span>
<span class="cm">*/</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">str_reverse_through_pointer</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">str_in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Define un puntero a una función, llamado f.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// La armadura debe coincidir exactamente con al función objetivo.</span>

<span class="w">    </span><span class="c1">// Assigna la dirección de la función (determinado en tiempo de ejecuión)</span>
<span class="w">    </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">str_reverse</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Llamando la función desde el puntero</span>
<span class="w">    </span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="n">str_in</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Esta es una alternativa para llamarla pero con una sintaxis igual de válida.</span>
<span class="w">    </span><span class="c1">// f(str_in);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">Tanto tiempo como las armaduras de las funciones coincidan, podrás asignar</span>
<span class="cm">cualquier función al mismo puntero.</span>
<span class="cm">Los punteros a funciones  son normalmente envueltos en &#39;typedef&#39; para</span>
<span class="cm">simplificar su legibilidad, como sigue:</span>
<span class="cm">*/</span>

<span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">my_fnp_type</span><span class="p">)(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>

<span class="c1">// Es usado para declarar la variable puntero actual:</span>
<span class="c1">// ...</span>
<span class="c1">// my_fnp_type f; </span>
</pre></div>
<h2>Otras lecturas</h2>

<p>Lo mejor que puedes encontrar es una copia de <a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">K&amp;R, aka &ldquo;The C Programming Language&rdquo;</a>. Es <em>el</em>
libro de C, escrito por Dennis Ritchie, creador de C y Brian Kernighan. Aún así,
se cuidadoso, es antiguo, contiene algunas inexactitudes, y algunas prácticas 
han cambiado.</p>

<p>Otro buen recurso es <a href="http://learncodethehardway.org/c/">Learn C the hard way</a>.</p>

<p>Si tienes una pregunta, lee <a href="http://c-faq.com">compl.lang.c Frequently Asked Questions</a>.</p>

<p>Es muy importante utilizar el espaciado y la sangría apropiados y ser coherente 
con su estilo de codificación en general. El código legible es mejor que el 
código rápido. Para adoptar un buen estilo de codificación, vea el
<a href="https://www.kernel.org/doc/Documentation/CodingStyle">Estilo de codificación del kernel Linux</a>.</p>

    <hr>
    <p>¿Tienes una sugerencia o rectificación? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Abre un issue</a> en el repositorio de GitHub, o haz un <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/es-es/c-es.html.markdown">pull request</a> tu mismo
    </p>
    <p class="contributed">
    Originalmente contribuido por Adam Bard, y actualizado por <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/es-es/c-es.html.markdown">5 colaborador(es)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://adambard.com/">Adam Bard</a>
    </p>

    <p>
      Translated by:
        <a href="http://flaskbreaker.tumblr.com/">Francisco García</a>
        <a href="https://github.com/heitorPB/">Heitor P. de Bittencourt</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
