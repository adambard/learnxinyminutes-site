<!DOCTYPE html lang="es-es" xml:lang="es-es" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="es-es">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn C in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/es-es/c-es/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fes-es%2Fc-es%2F&text=Aprende+X+en+Y+minutos%2C+donde+X%3DC">
        Comparte esta página
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Seleccione el tema:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">ligero</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">oscuro</button>
  </div>
  <h1><a href="/">Aprende X en Y minutos</a></h1>
  <h2>Donde X=C</h2>
    <p class="filelink">
    Descarga el código:
    <a href="/docs/files/learnc-es.c">learnc-es.c</a>
    </p>
  <div id="doc">
    <p>¡Ah!, C. Aun hoy en día sigue siendo el lenguaje por excelencia de la 
computación moderna de alto rendimiento.</p>

<p>C es el lenguaje de más bajo nivel que la mayoría de los programadores
llegarán a usar, pero lo compensa de sobra con pura velocidad. Solo
ten en cuenta el manejo manual de memoria y te llevará tan lejos como
necesites.</p>
<div class="highlight"><pre class="highlight c"><code><span class="c1">// Los comentarios de una sola línea comienzan con //</span>

<span class="cm">/*
Los comentarios multilínea tienen este aspecto.
*/</span>

<span class="c1">// Importa cabeceras con #include</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="c1">// Declara por adelantado las armaduras de las funciones en un archivo .h,</span>
<span class="c1">// o al principio de tu archivo .c .</span>
<span class="kt">void</span> <span class="nf">function_1</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">function_2</span><span class="p">();</span>

<span class="c1">// El punto de entrada de tu programa es una función llamada main con</span>
<span class="c1">// retorno de tipo entero (integer).</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

<span class="c1">// Muestra la salida usando printf, para el "formato print"</span>
<span class="c1">// %d es un entero, \n es una nueva línea</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// =&gt; Muestra 0</span>
<span class="c1">// Todas las sentencias deben terminar con un punto y coma.</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Tipos</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// Tienes que declarar una variable antes de usarla. La declaración de una</span>
<span class="c1">// variable necesites que especifiques su tipo; el tipo de una variable</span>
<span class="c1">// determina su tamaño en bytes.</span>

<span class="c1">// 'ints' (enteros) son normalmente de 4 bytes</span>
<span class="kt">int</span> <span class="n">x_int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// 'shorts' son normalmente de 2 bytes</span>
<span class="kt">short</span> <span class="n">x_short</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// 'chars' son fijo de 1 byte</span>
<span class="kt">char</span> <span class="n">x_char</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">y_char</span> <span class="o">=</span> <span class="sc">'y'</span><span class="p">;</span> <span class="c1">// Los caracteres literales se entrecomillan con ''</span>

<span class="c1">// 'longs' son a menudo de 4 a 8 bytes; 'long longs' son fijo de por lo</span>
<span class="c1">// menos 64 bits</span>
<span class="kt">long</span> <span class="n">x_long</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="n">x_long_long</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 

<span class="c1">// 'floats' son normalmente números de coma flotante de 32 bits</span>
<span class="kt">float</span> <span class="n">x_float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// 'doubles' son normalmente números de coma flotante de 64 bits</span>
<span class="kt">double</span> <span class="n">x_double</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// Todos los tipos enteros pueden ser 'unsigned'. Esto significa que no</span>
<span class="c1">// pueden ser negativos, pero el valor máximo de una variable 'unsigned'</span>
<span class="c1">// es mayor que el de una no 'unsigned' del mismo tamaño.</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ux_char</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ux_short</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ux_int</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ux_long_long</span><span class="p">;</span>

<span class="c1">// Todos menos 'char', que es siempre de 1 byte, varían el tamaño </span>
<span class="c1">// dependiendo de tu máquina. sizeof(T) te dice el tamaño de una variable</span>
<span class="c1">// de tipo T en bytes por lo que podemos expresar el tamaño de estos tipos</span>
<span class="c1">// portatilmente.</span>
<span class="c1">// Por ejemplo,</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span> <span class="c1">// =&gt; 4 (en máquinas con 'words' de 4 bytes)</span>

<span class="c1">// Los arrays deben ser inicializados con un tamaño concreto.</span>
<span class="kt">char</span> <span class="n">my_char_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span> <span class="c1">// Este array ocupa 1 * 20 = 20 bytes</span>
<span class="kt">int</span> <span class="n">my_int_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span> <span class="c1">// Este array ocupa 4 * 20 = 80 bytes</span>
                      <span class="c1">// (suponiendo que tenemos 'words' de 4-byte)</span>


<span class="c1">// Puedes inicializar un array a 0 así:</span>
<span class="kt">char</span> <span class="n">my_array</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

<span class="c1">// Indexar un array es como en otros lenguajes -o, más bien, otros</span>
<span class="c1">// lenguajes son como C-</span>
<span class="n">my_array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// =&gt; 0</span>

<span class="c1">// Los arrays varían; ¡son sólo memoria!</span>
<span class="n">my_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">my_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// =&gt; 2</span>

<span class="c1">// Las cadenas (strings) son sólo arrays de 'chars' (caracteres)</span>
<span class="c1">// terminados en un byte NUL (0x00), representado en las cadenas como el</span>
<span class="c1">// carácter especial '\0'.</span>
<span class="c1">// (No tenemos porqué añadir el byte nulo en cadenas literales; el</span>
<span class="c1">// compilador lo añade al final por nosotros.)</span>
<span class="kt">char</span> <span class="n">a_string</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Esto es una cadena"</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a_string</span><span class="p">);</span> <span class="c1">// %s se sutituye por una cadena.</span>

<span class="cm">/*
Te habrás dado cuenta de que a_string es solo de 18 caracteres.
El 'char' #19 es el byte nulo. 
El 'char' #20 es de valor indefinido.
*/</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a_string</span><span class="p">[</span><span class="mi">18</span><span class="p">]);</span> <span class="c1">// =&gt; 0</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Operadores</span>
<span class="c1">///////////////////////////////////////</span>

<span class="kt">int</span> <span class="n">i1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// Forma corta de declaración múltiple</span>
<span class="kt">float</span> <span class="n">f1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">f2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// La aritmética es sencilla</span>
<span class="n">i1</span> <span class="o">+</span> <span class="n">i2</span><span class="p">;</span> <span class="c1">// =&gt; 3</span>
<span class="n">i2</span> <span class="o">-</span> <span class="n">i1</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>
<span class="n">i2</span> <span class="o">*</span> <span class="n">i1</span><span class="p">;</span> <span class="c1">// =&gt; 2</span>
<span class="n">i1</span> <span class="o">/</span> <span class="n">i2</span><span class="p">;</span> <span class="c1">// =&gt; 0 (0.5, pero es truncado tras el 0)</span>

<span class="n">f1</span> <span class="o">/</span> <span class="n">f2</span><span class="p">;</span> <span class="c1">// =&gt; 0.5, más o menos épsilon</span>
<span class="c1">// Módulo está también</span>
<span class="mi">11</span> <span class="o">%</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// =&gt; 2</span>

<span class="c1">// Los operadores de comparación te resultaran familiares, pero no hay</span>
<span class="c1">// booleanos en C. Usamos enteros (ints) en su lugar. 0 es falso,</span>
<span class="c1">// cualquier otra cosa es verdadero. (Los operadores de comparación </span>
<span class="c1">// siempre devuelven 0 o 1)</span>
<span class="mi">3</span> <span class="o">==</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 0 (Falso)</span>
<span class="mi">3</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 1 (Verdadero)</span>
<span class="mi">3</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>
<span class="mi">3</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 0</span>
<span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>
<span class="mi">2</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>

<span class="c1">// La lógica funiona en enteros</span>
<span class="o">!</span><span class="mi">3</span><span class="p">;</span> <span class="c1">// =&gt; 0 (not lógico)</span>
<span class="o">!</span><span class="mi">0</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>
<span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 1 (and lógico)</span>
<span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 0</span>
<span class="mi">0</span> <span class="o">||</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 1 (or lógico)</span>
<span class="mi">0</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// =&gt; 0</span>

<span class="c1">// ¡Operadores de bits!</span>
<span class="o">~</span><span class="mh">0x0F</span><span class="p">;</span> <span class="c1">// =&gt; 0xF0 (Negación)</span>
<span class="mh">0x0F</span> <span class="o">&amp;</span> <span class="mh">0xF0</span><span class="p">;</span> <span class="c1">// =&gt; 0x00 (AND)</span>
<span class="mh">0x0F</span> <span class="o">|</span> <span class="mh">0xF0</span><span class="p">;</span> <span class="c1">// =&gt; 0xFF (OR)</span>
<span class="mh">0x04</span> <span class="o">^</span> <span class="mh">0x0F</span><span class="p">;</span> <span class="c1">// =&gt; 0x0B (XOR)</span>
<span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 0x02 (desplazar hacia la izquierda (por 1))</span>
<span class="mh">0x02</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 0x01 (desplazar hacia la derecha (por 1))</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Estructuras de Control</span>
<span class="c1">///////////////////////////////////////</span>

<span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Yo nunca ocurro</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Yo tampoco ocurro nunca</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Yo me muestro</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Mientras el bucle exista</span>
<span class="kt">int</span> <span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">ii</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d, "</span><span class="p">,</span> <span class="n">ii</span><span class="o">++</span><span class="p">);</span> <span class="c1">// ii++ incrementa ii en uno, después de usar su valor.</span>
<span class="p">}</span> <span class="c1">// =&gt; muestra "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">kk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">do</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d, "</span><span class="p">,</span> <span class="n">kk</span><span class="p">);</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">kk</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">);</span> <span class="c1">// ++kk incrementa kk en uno, antes de usar su valor.</span>
<span class="c1">// =&gt; muestra "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

<span class="c1">// Bucles 'for' también</span>
<span class="kt">int</span> <span class="n">jj</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">jj</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">jj</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">jj</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d, "</span><span class="p">,</span> <span class="n">jj</span><span class="p">);</span>
<span class="p">}</span> <span class="c1">// =&gt; muestra "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Cambios de Tipo</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// Cada valor en C tiene un tipo,  pero tu puedes ingresar un valor en</span>
<span class="c1">// otro tipo si quieres.</span>

<span class="kt">int</span> <span class="n">x_hex</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span> <span class="c1">// Puedes asignar hexadecimales a variables</span>

<span class="c1">// El cambio de tipos intentará mantener sus valores numéricos</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x_hex</span><span class="p">);</span> <span class="c1">// =&gt; Muestra 1</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">short</span><span class="p">)</span> <span class="n">x_hex</span><span class="p">);</span> <span class="c1">// =&gt; Muestra 1</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="n">x_hex</span><span class="p">);</span> <span class="c1">// =&gt; Muestra 1</span>

<span class="c1">// Los tipos se desbordan sin aviso</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="mi">257</span><span class="p">);</span> <span class="c1">// =&gt; 1 (El valor máximo de un 'char' es 255)</span>

<span class="c1">// Los tipos enteros puden cambiarse a tipos de coma flotante, y viceversa</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="mi">100</span><span class="p">);</span> <span class="c1">// %f se sustituye por un 'float'</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%lf</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="mi">100</span><span class="p">);</span> <span class="c1">// %lf se sustituye por un 'double'</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mi">100</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Punteros</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// Un puntero es una variable declarada para almacenar una dirección de </span>
<span class="c1">// memoria. Su declaración además nos dirá el tipo de dato al que apunta. </span>
<span class="c1">// Puedes obtener la dirección de memoria de tus variables, y después</span>
<span class="c1">// enlazarlas con ellos.</span>

<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span> <span class="c1">// Usa &amp; para obtener la dirección de una variable.</span>
<span class="c1">// (%p se sustituye por un puntero)</span>
<span class="c1">// =&gt; Muestra alguna dirección de memoria;</span>

<span class="c1">// Los tipos de puntero terminan con * en su declaración</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">px</span><span class="p">;</span> <span class="c1">// px es un puntero a un 'int'</span>
<span class="n">px</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span> <span class="c1">// Almacena la dirección de x en px</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">px</span><span class="p">);</span> <span class="c1">// =&gt; Muestra alguna dirección de memoria</span>

<span class="c1">// Para obtener el valor de la dirección a la que apunta un puntero, pon</span>
<span class="c1">// * delante para desreferenciarle. </span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">px</span><span class="p">);</span> <span class="c1">// =&gt; Muestra 0, el valor de x y de la dirección a la</span>
                     <span class="c1">//    que apunta px</span>

<span class="c1">// También puedes cambiar el valor al que está apuntando el puntero.</span>
<span class="c1">// Tenemos que meter la desreferencia entre paréntesis porque ++ tiene</span>
<span class="c1">// prioridad frente a *.</span>
<span class="p">(</span><span class="o">*</span><span class="n">px</span><span class="p">)</span><span class="o">++</span><span class="p">;</span> <span class="c1">// Incrementa el valor al que apunta px en 1</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">px</span><span class="p">);</span> <span class="c1">// =&gt; Muestra 1</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// =&gt; Muestra 1</span>

<span class="kt">int</span> <span class="n">x_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span> <span class="c1">// Los arrays son una buena manera de distribuir bloques</span>
<span class="kt">int</span> <span class="n">xx</span><span class="p">;</span>          <span class="c1">// continuos de memoria.</span>
<span class="k">for</span> <span class="p">(</span><span class="n">xx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">xx</span><span class="o">&lt;</span><span class="mi">20</span><span class="p">;</span> <span class="n">xx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x_array</span><span class="p">[</span><span class="n">xx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">-</span> <span class="n">xx</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// Inicializa x_array a 20, 19, 18,... 2, 1</span>

<span class="c1">// Declara un puntero de tipo 'int' y lo inicializa para apuntar a x_array</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">x_ptr</span> <span class="o">=</span> <span class="n">x_array</span><span class="p">;</span>
<span class="c1">// x_ptr ahira apunta al primer elemento del 'array' (el entero 20).</span>
<span class="c1">// Esto funciona porque las 'arrays' actualmente son solo punteros a su</span>
<span class="c1">// primer elemento.</span>

<span class="c1">// Los 'arrays' son punteros a su primer elemento.</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">x_ptr</span><span class="p">));</span> <span class="c1">// =&gt; Muestra 20</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// =&gt; Muestra 20</span>

<span class="c1">// Los punteros aumentan y disminuyen en función de su tipo.</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">x_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span> <span class="c1">// =&gt; Muestra 19</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// =&gt; Muestra 19</span>

<span class="c1">// Puedes también asigner dinamicamente bloques contiguos de memoria con</span>
<span class="c1">// la función malloc de la librería estándard, que toma un entero como</span>
<span class="c1">// argumento representando el número de bytes a asignar de la pila.</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">my_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">20</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="n">xx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">xx</span><span class="o">&lt;</span><span class="mi">20</span><span class="p">;</span> <span class="n">xx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="p">(</span><span class="n">my_ptr</span> <span class="o">+</span> <span class="n">xx</span><span class="p">)</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">-</span> <span class="n">xx</span><span class="p">;</span> <span class="c1">// my_ptr[xx] = 20-xx funcionaría también aquí</span>
<span class="p">}</span> <span class="c1">// Inicializa la memoria a 20, 19, 18, 17... 2, 1 (como 'ints')</span>

<span class="c1">// Desreferenciando la memoria que no has asignado te dará resultados</span>
<span class="c1">// impredecibles</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">my_ptr</span> <span class="o">+</span> <span class="mi">21</span><span class="p">));</span> <span class="c1">// =&gt; Prints who-knows-what?</span>

<span class="c1">// Cuando hayas acabado con el bloque de memoría malloc, necesitas </span>
<span class="c1">// liberarlo o sino nadie más podrá usarlo hasta que tu programa se cierre</span>
<span class="n">free</span><span class="p">(</span><span class="n">my_ptr</span><span class="p">);</span>

<span class="c1">// Las cadenas pueden ser 'arrays' de chars, pero normalmente se</span>
<span class="c1">// representan con punteros 'char':</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">my_str</span> <span class="o">=</span> <span class="s">"This is my very own string"</span><span class="p">;</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"%c</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">my_str</span><span class="p">);</span> <span class="c1">// =&gt; 'T'</span>

<span class="n">function_1</span><span class="p">();</span>
<span class="p">}</span> <span class="c1">// fin de la función main</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Funciones</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// Sintexis de la declaración de funciones:</span>
<span class="c1">// &lt;tipo de retorno&gt; &lt;nombre&gt;(&lt;argumentos&gt;)</span>

<span class="kt">int</span> <span class="nf">add_two_ints</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="p">;</span> <span class="c1">// Usa 'return' para dar una salida</span>
<span class="p">}</span>

<span class="cm">/*
Las funciones son de paso por valor, pero puedes hacer tus propias 
referencias con punteros de manera que las funciones puedan cambiar sus 
valores.

Ejemplo: invertidor de cadenas in-situ
*/</span>

<span class="c1">// Una función 'void' no retorna valor</span>
<span class="kt">void</span> <span class="nf">str_reverse</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">str_in</span><span class="p">){</span>
    <span class="kt">char</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ii</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str_in</span><span class="p">);</span> <span class="c1">// Strlen es parte de la librería </span>
    <span class="k">for</span><span class="p">(</span><span class="n">ii</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">ii</span><span class="o">&lt;</span><span class="n">len</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">ii</span><span class="o">++</span><span class="p">){</span>      <span class="c1">// estándard</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">str_in</span><span class="p">[</span><span class="n">ii</span><span class="p">];</span>
        <span class="n">str_in</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">str_in</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">// ii-th último 'char'</span>
        <span class="n">str_in</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*
char c[] = "Esto es una prueba.";
str_reverse(c);
printf("%s\n", c); // =&gt; ".abeurp anu se otsE"
*/</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Definición de tipos y estructuras</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// Los 'Typedefs' pueden ser utilizados para crear alias de tipos.</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">my_type</span><span class="p">;</span>
<span class="n">my_type</span> <span class="n">my_type_var</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// Las estructuras son sólo grupos de datos.</span>
<span class="k">struct</span> <span class="n">rectangle</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">width</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">height</span><span class="p">;</span>
<span class="p">};</span>


<span class="kt">void</span> <span class="nf">function_1</span><span class="p">(){</span>

    <span class="k">struct</span> <span class="n">rectangle</span> <span class="n">my_rec</span><span class="p">;</span>

    <span class="c1">// Utiliza los miembros de una estructura con .</span>
    <span class="n">my_rec</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">my_rec</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

    <span class="c1">// Puedes declarar punteros a estructuras</span>
    <span class="k">struct</span> <span class="n">rectangle</span><span class="o">*</span> <span class="n">my_rec_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_rec</span><span class="p">;</span>

    <span class="c1">// Usa la desreferencia para modificar sus miembros...</span>
    <span class="p">(</span><span class="o">*</span><span class="n">my_rec_ptr</span><span class="p">).</span><span class="n">width</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>

    <span class="c1">// ... o usa la abreviatura -&gt;</span>
    <span class="n">my_rec_ptr</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// Lo mismo que (*my_rec_ptr).height = 10;</span>
<span class="p">}</span>

<span class="c1">// Puedes aplicar un 'typedef' a una estructura por conveniencía.</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">rectangle</span> <span class="n">rect</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">area</span><span class="p">(</span><span class="n">rect</span> <span class="n">r</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">r</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Punteros a Funciones</span>
<span class="c1">///////////////////////////////////////</span>
<span class="cm">/*
En tiempo de ejecución,  las funciones se localizan en unas direcciones de
memoria concretas. Los punteros a funciones son como cualquier otro 
puntero (almacenan una dirección de memoria), pero pueden ser usados para 
utilizar funciones directamente, o para pasar 'handlers' (o funciones 
'callback') por todos lados.
Sin embargo, la sintaxis de definición parecera confusa al principio.

Ejemplo: usar str_reverse desde un puntero
*/</span>
<span class="kt">void</span> <span class="nf">str_reverse_through_pointer</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span> <span class="n">str_in</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Define un puntero a una función, llamado f.</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
    <span class="c1">// La armadura debe coincidir exactamente con al función objetivo.</span>

    <span class="c1">// Assigna la dirección de la función (determinado en tiempo de ejecuión)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">str_reverse</span><span class="p">;</span>

    <span class="c1">// Llamando la función desde el puntero</span>
    <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="n">str_in</span><span class="p">);</span>

    <span class="c1">// Esta es una alternativa para llamarla pero con una sintaxis igual de válida.</span>
    <span class="c1">// f(str_in);</span>
<span class="p">}</span>

<span class="cm">/*
Tanto tiempo como las armaduras de las funciones coincidan, podrás asignar
cualquier función al mismo puntero.
Los punteros a funciones  son normalmente envueltos en 'typedef' para
simplificar su legibilidad, como sigue:
*/</span>

<span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">my_fnp_type</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span>

<span class="c1">// Es usado para declarar la variable puntero actual:</span>
<span class="c1">// ...</span>
<span class="c1">// my_fnp_type f; </span>
</code></pre></div>
<h2>Otras lecturas</h2>

<p>Lo mejor que puedes encontrar es una copia de <a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">K&amp;R, aka &ldquo;The C Programming Language&rdquo;</a>. Es <em>el</em>
libro de C, escrito por Dennis Ritchie, creador de C y Brian Kernighan. Aún así,
se cuidadoso, es antiguo, contiene algunas inexactitudes, y algunas prácticas 
han cambiado.</p>

<p>Otro buen recurso es <a href="http://learncodethehardway.org/c/">Learn C the hard way</a>.</p>

<p>Si tienes una pregunta, lee <a href="http://c-faq.com">compl.lang.c Frequently Asked Questions</a>.</p>

<p>Es muy importante utilizar el espaciado y la sangría apropiados y ser coherente 
con su estilo de codificación en general. El código legible es mejor que el 
código rápido. Para adoptar un buen estilo de codificación, vea el
<a href="https://www.kernel.org/doc/Documentation/CodingStyle">Estilo de codificación del kernel Linux</a>.</p>

<p>Aparte de eso, Google es tu amigo.</p>

    <hr>
    <p>¿Tienes una sugerencia o rectificación? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Abre un issue</a> en el repositorio de Github, o haz un <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/es-es/c-es.html.markdown">pull request</a> tu mismo
    </p>
    <p class="contributed">
    Originalmente contribuido por Adam Bard, y actualizado por <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/es-es/c-es.html.markdown">5 colaborador(es)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://adambard.com/">Adam Bard</a>
    </p>

    <p>
      Translated by:
        <a href="http://flaskbreaker.tumblr.com/">Francisco García</a>
        <a href="https://github.com/heitorPB/">Heitor P. de Bittencourt</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
