<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="en-us" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="en-us" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="en-us" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="en-us" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="en-us">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Haskell in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/haskell/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fhaskell%2F&text=Learn+X+in+Y+minutes%2C+where+X%3DHaskell">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="/">Learn X in Y minutes</a></h1>
  <h2>Where X=Haskell</h2>
    <p class="filelink">
    Get the code:
    <a href="/docs/files/learnhaskell.hs">learnhaskell.hs</a>
    </p>
  <div id="doc">
    <p>Haskell was designed as a practical, purely functional programming
language. It&rsquo;s famous for its monads and its type system, but I keep coming back
to it because of its elegance. Haskell makes coding a real joy for me.</p>
<div class="highlight"><pre><span></span><span class="c1">-- Single line comments start with two dashes.</span>
<span class="cm">{- Multiline comments can be enclosed</span>
<span class="cm">in a block like this.</span>
<span class="cm">-}</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 1. Primitive Datatypes and Operators</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- You have numbers</span>
<span class="mi">3</span><span class="w"> </span><span class="c1">-- 3</span>

<span class="c1">-- Math is what you would expect</span>
<span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">-- 2</span>
<span class="mi">8</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">-- 7</span>
<span class="mi">10</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="c1">-- 20</span>
<span class="mi">35</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="c1">-- 7.0</span>

<span class="c1">-- Division is not integer division by default</span>
<span class="mi">35</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="c1">-- 8.75</span>

<span class="c1">-- integer division</span>
<span class="mi">35</span><span class="w"> </span><span class="p">`</span><span class="n">div</span><span class="p">`</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="c1">-- 8</span>

<span class="c1">-- Boolean values are primitives</span>
<span class="kt">True</span>
<span class="kt">False</span>

<span class="c1">-- Boolean operations</span>
<span class="nf">not</span><span class="w"> </span><span class="kt">True</span><span class="w"> </span><span class="c1">-- False</span>
<span class="nf">not</span><span class="w"> </span><span class="kt">False</span><span class="w"> </span><span class="c1">-- True</span>
<span class="kt">True</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="kt">False</span><span class="w"> </span><span class="c1">-- False</span>
<span class="kt">True</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="kt">False</span><span class="w"> </span><span class="c1">-- True</span>
<span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">-- True</span>
<span class="mi">1</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">-- False</span>
<span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="c1">-- True</span>

<span class="c1">-- In the above examples, `not` is a function that takes one value.</span>
<span class="c1">-- Haskell doesn&#39;t need parentheses for function calls...all the arguments</span>
<span class="c1">-- are just listed after the function. So the general pattern is:</span>
<span class="c1">-- func arg1 arg2 arg3...</span>
<span class="c1">-- See the section on functions for information on how to write your own.</span>

<span class="c1">-- Strings and characters</span>
<span class="s">&quot;This is a string.&quot;</span>
<span class="sc">&#39;a&#39;</span><span class="w"> </span><span class="c1">-- character</span>
<span class="kt">&#39;You</span><span class="w"> </span><span class="n">cant</span><span class="w"> </span><span class="n">use</span><span class="w"> </span><span class="n">single</span><span class="w"> </span><span class="n">quotes</span><span class="w"> </span><span class="n">for</span><span class="w"> </span><span class="n">strings</span><span class="o">.</span><span class="sc">&#39;</span><span class="err"> -- error!</span>

<span class="c1">-- Strings can be concatenated</span>
<span class="s">&quot;Hello &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s">&quot;world!&quot;</span><span class="w"> </span><span class="c1">-- &quot;Hello world!&quot;</span>

<span class="c1">-- A string is a list of characters</span>
<span class="p">[</span><span class="sc">&#39;H&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;e&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;l&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;l&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;o&#39;</span><span class="p">]</span><span class="w"> </span><span class="c1">-- &quot;Hello&quot;</span>

<span class="c1">-- Lists can be indexed with the `!!` operator followed by an index</span>
<span class="s">&quot;This is a string&quot;</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="c1">-- &#39;T&#39;</span>


<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 2. Lists and Tuples</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Every element in a list must have the same type.</span>
<span class="c1">-- These two lists are equal:</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>

<span class="c1">-- Ranges are versatile.</span>
<span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;F&#39;</span><span class="p">]</span><span class="w"> </span><span class="c1">-- &quot;ABCDEF&quot;</span>

<span class="c1">-- You can create a step in a range.</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [0, 2, 4, 6, 8, 10]</span>
<span class="p">[</span><span class="mi">5</span><span class="o">..</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [] (Haskell defaults to incrementing)</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="o">..</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [5, 4, 3, 2, 1]</span>

<span class="c1">-- indexing into a list</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">-- 4 (zero-based indexing)</span>

<span class="c1">-- You can also have infinite lists in Haskell!</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span><span class="w"> </span><span class="c1">-- a list of all the natural numbers</span>

<span class="c1">-- Infinite lists work because Haskell has &quot;lazy evaluation&quot;. This means</span>
<span class="c1">-- that Haskell only evaluates things when it needs to. So you can ask for</span>
<span class="c1">-- the 1000th element of your list and Haskell will give it to you:</span>

<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="mi">999</span><span class="w"> </span><span class="c1">-- 1000</span>

<span class="c1">-- And now Haskell has evaluated elements 1 - 1000 of this list...but the</span>
<span class="c1">-- rest of the elements of this &quot;infinite&quot; list don&#39;t exist yet! Haskell won&#39;t</span>
<span class="c1">-- actually evaluate them until it needs to.</span>

<span class="c1">-- joining two lists</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="mi">6</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>

<span class="c1">-- adding to the head of a list</span>
<span class="mi">0</span><span class="kt">:</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [0, 1, 2, 3, 4, 5]</span>

<span class="c1">-- more list operations</span>
<span class="nf">head</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- 1</span>
<span class="nf">tail</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [2, 3, 4, 5]</span>
<span class="nf">init</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [1, 2, 3, 4]</span>
<span class="nf">last</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- 5</span>

<span class="c1">-- list comprehensions</span>
<span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]]</span><span class="w"> </span><span class="c1">-- [2, 4, 6, 8, 10]</span>

<span class="c1">-- with a conditional</span>
<span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [6, 8, 10]</span>

<span class="c1">-- Every element in a tuple can be a different type, but a tuple has a</span>
<span class="c1">-- fixed length.</span>
<span class="c1">-- A tuple:</span>
<span class="p">(</span><span class="s">&quot;haskell&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="c1">-- accessing elements of a pair (i.e. a tuple of length 2)</span>
<span class="nf">fst</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;haskell&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">-- &quot;haskell&quot;</span>
<span class="nf">snd</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;haskell&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">-- 1</span>

<span class="c1">-- pair element accessing does not work on n-tuples (i.e. triple, quadruple, etc)</span>
<span class="nf">snd</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;snd&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;can&#39;t touch this&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;da na na na&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">-- error! see function below</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 3. Functions</span>
<span class="c1">----------------------------------------------------</span>
<span class="c1">-- A simple function that takes two variables</span>
<span class="nf">add</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span>

<span class="c1">-- Note that if you are using ghci (the Haskell interpreter)</span>
<span class="c1">-- You&#39;ll need to use `let`, i.e.</span>
<span class="c1">-- let add a b = a + b</span>

<span class="c1">-- Using the function</span>
<span class="nf">add</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="c1">-- 3</span>

<span class="c1">-- You can also put the function name between the two arguments</span>
<span class="c1">-- with backticks:</span>
<span class="mi">1</span><span class="w"> </span><span class="p">`</span><span class="n">add</span><span class="p">`</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="c1">-- 3</span>

<span class="c1">-- You can also define functions that have no letters! This lets</span>
<span class="c1">-- you define your own operators! Here&#39;s an operator that does</span>
<span class="c1">-- integer division</span>
<span class="p">(</span><span class="o">//</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">`</span><span class="n">div</span><span class="p">`</span><span class="w"> </span><span class="n">b</span>
<span class="mi">35</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="c1">-- 8</span>

<span class="c1">-- Guards: an easy way to do branching in functions</span>
<span class="nf">fib</span><span class="w"> </span><span class="n">x</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>

<span class="c1">-- Pattern matching is similar. Here we have given three different</span>
<span class="c1">-- equations that define fib. Haskell will automatically use the first</span>
<span class="c1">-- equation whose left hand side pattern matches the value.</span>
<span class="nf">fib</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>
<span class="nf">fib</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span>
<span class="nf">fib</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>

<span class="c1">-- Pattern matching on tuples</span>
<span class="nf">sndOfTriple</span><span class="w"> </span><span class="p">(</span><span class="kr">_</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="c1">-- use a wild card (_) to bypass naming unused value</span>

<span class="c1">-- Pattern matching on lists. Here `x` is the first element</span>
<span class="c1">-- in the list, and `xs` is the rest of the list. We can write</span>
<span class="c1">-- our own map function:</span>
<span class="nf">myMap</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span>
<span class="nf">myMap</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="n">x</span><span class="kt">:</span><span class="p">(</span><span class="n">myMap</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span>

<span class="c1">-- Anonymous functions are created with a backslash followed by</span>
<span class="c1">-- all the arguments.</span>
<span class="nf">myMap</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [3, 4, 5, 6, 7]</span>

<span class="c1">-- using fold (called `inject` in some languages) with an anonymous</span>
<span class="c1">-- function. foldl1 means fold left, and use the first value in the</span>
<span class="c1">-- list as the initial value for the accumulator.</span>
<span class="nf">foldl1</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">acc</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- 15</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 4. More functions</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- partial application: if you don&#39;t pass in all the arguments to a function,</span>
<span class="c1">-- it gets &quot;partially applied&quot;. That means it returns a function that takes the</span>
<span class="c1">-- rest of the arguments.</span>

<span class="nf">add</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="c1">-- foo is now a function that takes a number and adds 10 to it</span>
<span class="nf">foo</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="c1">-- 15</span>

<span class="c1">-- Another way to write the same thing</span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="mi">10</span><span class="o">+</span><span class="p">)</span>
<span class="nf">foo</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="c1">-- 15</span>

<span class="c1">-- function composition</span>
<span class="c1">-- the operator `.` chains functions together.</span>
<span class="c1">-- For example, here foo is a function that takes a value. It adds 10 to it,</span>
<span class="c1">-- multiplies the result of that by 4, and then returns the final value.</span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="mi">10</span><span class="o">+</span><span class="p">)</span>

<span class="c1">-- 4*(10+5) = 60</span>
<span class="nf">foo</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="c1">-- 60</span>

<span class="c1">-- fixing precedence</span>
<span class="c1">-- Haskell has an operator called `$`. This operator applies a function</span>
<span class="c1">-- to a given parameter. In contrast to standard function application, which</span>
<span class="c1">-- has highest possible priority of 10 and is left-associative, the `$` operator</span>
<span class="c1">-- has priority of 0 and is right-associative. Such a low priority means that</span>
<span class="c1">-- the expression on its right is applied as a parameter to the function on its left.</span>

<span class="c1">-- before</span>
<span class="nf">even</span><span class="w"> </span><span class="p">(</span><span class="n">fib</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="c1">-- false</span>

<span class="c1">-- equivalently</span>
<span class="nf">even</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="c1">-- false</span>

<span class="c1">-- composing functions</span>
<span class="nf">even</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="c1">-- false</span>


<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 5. Type signatures</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Haskell has a very strong type system, and every valid expression has a type.</span>

<span class="c1">-- Some basic types:</span>
<span class="mi">5</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span>
<span class="s">&quot;hello&quot;</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">String</span>
<span class="kt">True</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Bool</span>

<span class="c1">-- Functions have types too.</span>
<span class="c1">-- `not` takes a boolean and returns a boolean:</span>
<span class="c1">-- not :: Bool -&gt; Bool</span>

<span class="c1">-- Here&#39;s a function that takes two arguments:</span>
<span class="c1">-- add :: Integer -&gt; Integer -&gt; Integer</span>

<span class="c1">-- When you define a value, it&#39;s good practice to write its type above it:</span>
<span class="nf">double</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span>
<span class="nf">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 6. Control Flow and If Expressions</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- if-expressions</span>
<span class="nf">haskell</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="s">&quot;awesome&quot;</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="s">&quot;awful&quot;</span><span class="w"> </span><span class="c1">-- haskell = &quot;awesome&quot;</span>

<span class="c1">-- if-expressions can be on multiple lines too, indentation is important</span>
<span class="nf">haskell</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span>
<span class="w">            </span><span class="kr">then</span><span class="w"> </span><span class="s">&quot;awesome&quot;</span>
<span class="w">            </span><span class="kr">else</span><span class="w"> </span><span class="s">&quot;awful&quot;</span>

<span class="c1">-- case expressions: Here&#39;s how you could parse command line arguments</span>
<span class="kr">case</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="kr">of</span>
<span class="w">  </span><span class="s">&quot;help&quot;</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">printHelp</span>
<span class="w">  </span><span class="s">&quot;start&quot;</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">startProgram</span>
<span class="w">  </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;bad args&quot;</span>

<span class="c1">-- Haskell doesn&#39;t have loops; it uses recursion instead.</span>
<span class="c1">-- map applies a function over every element in a list</span>

<span class="nf">map</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [2, 4, 6, 8, 10]</span>

<span class="c1">-- you can make a for function using map</span>
<span class="nf">for</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="n">array</span>

<span class="c1">-- and then use it</span>
<span class="nf">for</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="nf">\</span><span class="n">i</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="n">i</span>

<span class="c1">-- we could&#39;ve written that like this too:</span>
<span class="nf">for</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="n">show</span>

<span class="c1">-- You can use foldl or foldr to reduce a list</span>
<span class="c1">-- foldl &lt;fn&gt; &lt;initial value&gt; &lt;list&gt;</span>
<span class="nf">foldl</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="c1">-- 43</span>

<span class="c1">-- This is the same as</span>
<span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>

<span class="c1">-- foldl is left-handed, foldr is right-handed</span>
<span class="nf">foldr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="c1">-- 16</span>

<span class="c1">-- This is now the same as</span>
<span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">)))</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 7. Data Types</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- A data type is declared with a &#39;type constructor&#39; on the left</span>
<span class="c1">-- and one or more &#39;data constructors&#39; on the right, separated by</span>
<span class="c1">-- the pipe | symbol. This is a sum/union type. Each data constructor</span>
<span class="c1">-- is a (possibly nullary) function that creates an object of the type</span>
<span class="c1">-- named by the type constructor.</span>

<span class="c1">-- This is essentially an enum</span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Color</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Red</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Blue</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Green</span>

<span class="c1">-- Now you can use it in a function:</span>

<span class="nf">say</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Color</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span>
<span class="nf">say</span><span class="w"> </span><span class="kt">Red</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;You are Red!&quot;</span>
<span class="nf">say</span><span class="w"> </span><span class="kt">Blue</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;You are Blue!&quot;</span>
<span class="nf">say</span><span class="w"> </span><span class="kt">Green</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;You are Green!&quot;</span>

<span class="c1">-- Note that the type constructor is used in the type signature</span>
<span class="c1">-- and the data constructors are used in the body of the function</span>
<span class="c1">-- Data constructors are primarily pattern-matched against</span>

<span class="c1">-- This next one is a traditional container type holding two fields</span>
<span class="c1">-- In a type declaration, data constructors take types as parameters</span>
<span class="c1">-- Data constructors can have the same name as type constructors</span>
<span class="c1">-- This is common where the type only has a single data constructor</span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Point</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Point</span><span class="w"> </span><span class="kt">Float</span><span class="w"> </span><span class="kt">Float</span>

<span class="c1">-- This can be used in a function like:</span>

<span class="nf">distance</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Point</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Point</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Float</span>
<span class="nf">distance</span><span class="w"> </span><span class="p">(</span><span class="kt">Point</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">Point</span><span class="w"> </span><span class="n">x&#39;</span><span class="w"> </span><span class="n">y&#39;</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">sqrt</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">dx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dy</span>
<span class="w">    </span><span class="kr">where</span><span class="w"> </span><span class="n">dx</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="mi">2</span>
<span class="w">          </span><span class="n">dy</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="mi">2</span>

<span class="c1">-- Types can have multiple data constructors with arguments, too</span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Name</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Mononym</span><span class="w"> </span><span class="kt">String</span>
<span class="w">          </span><span class="o">|</span><span class="w"> </span><span class="kt">FirstLastName</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="kt">String</span>
<span class="w">          </span><span class="o">|</span><span class="w"> </span><span class="kt">FullName</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="kt">String</span>

<span class="c1">-- To make things clearer we can use record syntax</span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Point2D</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">CartesianPoint2D</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Float</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Float</span><span class="w"> </span><span class="p">}</span><span class="w"> </span>
<span class="w">             </span><span class="o">|</span><span class="w"> </span><span class="kt">PolarPoint2D</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Float</span><span class="p">,</span><span class="w"> </span><span class="n">theta</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Float</span><span class="w"> </span><span class="p">}</span>

<span class="nf">myPoint</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">CartesianPoint2D</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mf">7.0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mf">10.0</span><span class="w"> </span><span class="p">}</span>

<span class="c1">-- Using record syntax automatically creates accessor functions</span>
<span class="c1">-- (the name of the field)</span>

<span class="nf">xOfMyPoint</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">myPoint</span>

<span class="c1">-- xOfMyPoint is equal to 7.0</span>

<span class="c1">-- Record syntax also allows a simple form of update</span>

<span class="nf">myPoint&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">myPoint</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mf">9.0</span><span class="w"> </span><span class="p">}</span>

<span class="c1">-- myPoint&#39; is CartesianPoint2D { x = 9.0, y = 10.0 }</span>

<span class="c1">-- Even if a type is defined with record syntax, it can be declared like</span>
<span class="c1">-- a simple data constructor. This is fine:</span>

<span class="nf">myPoint&#39;2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">CartesianPoint2D</span><span class="w"> </span><span class="mf">3.3</span><span class="w"> </span><span class="mf">4.0</span>

<span class="c1">-- It&#39;s also useful to pattern match data constructors in `case` expressions</span>

<span class="nf">distanceFromOrigin</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span>
<span class="w">    </span><span class="kr">case</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">(</span><span class="kt">CartesianPoint2D</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">sqrt</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="mi">2</span>
<span class="w">              </span><span class="p">(</span><span class="kt">PolarPoint2D</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">r</span>

<span class="c1">-- Your data types can have type parameters too:</span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Nothing</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="n">a</span>

<span class="c1">-- These are all of type Maybe</span>
<span class="kt">Just</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="w">    </span><span class="c1">-- of type `Maybe String`</span>
<span class="kt">Just</span><span class="w"> </span><span class="mi">1</span><span class="w">          </span><span class="c1">-- of type `Maybe Int`</span>
<span class="kt">Nothing</span><span class="w">         </span><span class="c1">-- of type `Maybe a` for any `a`</span>

<span class="c1">-- For convenience we can also create type synonyms with the &#39;type&#39; keyword</span>

<span class="kr">type</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="kt">Char</span><span class="p">]</span>

<span class="c1">-- Unlike `data` types, type synonyms need no constructor, and can be used </span>
<span class="c1">-- anywhere a synonymous data type could be used. Say we have the </span>
<span class="c1">-- following type synonyms and items with the following type signatures</span>

<span class="kr">type</span><span class="w"> </span><span class="kt">Weight</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Float</span>
<span class="kr">type</span><span class="w"> </span><span class="kt">Height</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Float</span>
<span class="kr">type</span><span class="w"> </span><span class="kt">Point</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">Float</span><span class="p">,</span><span class="w"> </span><span class="kt">Float</span><span class="p">)</span>
<span class="nf">getMyHeightAndWeight</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Person</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">Height</span><span class="p">,</span><span class="w"> </span><span class="kt">Weight</span><span class="p">)</span>
<span class="nf">findCenter</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Circle</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Point</span>
<span class="nf">somePerson</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Person</span>
<span class="nf">someCircle</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Circle</span>
<span class="nf">distance</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Point</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Point</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Float</span>

<span class="c1">-- The following would compile and run without issue, </span>
<span class="c1">-- even though it does not make sense semantically,</span>
<span class="c1">-- because the type synonyms reduce to the same base types</span>

<span class="nf">distance</span><span class="w"> </span><span class="p">(</span><span class="n">getMyHeightAndWeight</span><span class="w"> </span><span class="n">somePerson</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">findCenter</span><span class="w"> </span><span class="n">someCircle</span><span class="p">)</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 8. Typeclasses</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Typeclasses are one way Haskell does polymorphism</span>
<span class="c1">-- They are similar to interfaces in other languages</span>
<span class="c1">-- A typeclass defines a set of functions that must </span>
<span class="c1">-- work on any type that is in that typeclass.</span>

<span class="c1">-- The Eq typeclass is for types whose instances can </span>
<span class="c1">-- be tested for equality with one another.</span>

<span class="kr">class</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w">  </span>
<span class="w">    </span><span class="p">(</span><span class="o">==</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w">  </span>
<span class="w">    </span><span class="p">(</span><span class="o">/=</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w">  </span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w">  </span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>

<span class="c1">-- This defines a typeclass that requires two functions, (==) and (/=)</span>
<span class="c1">-- It also declares that one function can be declared in terms of another</span>
<span class="c1">-- So it is enough that *either* the (==) function or the (/=) is defined</span>
<span class="c1">-- And the other will be &#39;filled in&#39; based on the typeclass definition</span>

<span class="c1">-- To make a type a member of a type class, the instance keyword is used</span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="kt">TrafficLight</span><span class="w"> </span><span class="kr">where</span><span class="w">  </span>
<span class="w">    </span><span class="kt">Red</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">Red</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span><span class="w">  </span>
<span class="w">    </span><span class="kt">Green</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">Green</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span><span class="w">  </span>
<span class="w">    </span><span class="kt">Yellow</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">Yellow</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span><span class="w">  </span>
<span class="w">    </span><span class="kr">_</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">False</span><span class="w"> </span>

<span class="c1">-- Now we can use (==) and (/=) with TrafficLight objects</span>

<span class="nf">canProceedThrough</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">TrafficLight</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span>
<span class="nf">canProceedThrough</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="kt">Red</span>

<span class="c1">-- You can NOT create an instance definition for a type synonym</span>

<span class="c1">-- Functions can be written to take typeclasses with type parameters, </span>
<span class="c1">-- rather than types, assuming that the function only relies on </span>
<span class="c1">-- features of the typeclass</span>

<span class="nf">isEqual</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span>
<span class="nf">isEqual</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y</span>

<span class="c1">-- Note that x and y MUST be the same type, as they are both defined</span>
<span class="c1">-- as being of type parameter &#39;a&#39;.</span>
<span class="c1">-- A typeclass does not state that different types in the typeclass can </span>
<span class="c1">-- be mixed together.</span>
<span class="c1">-- So `isEqual Red 2` is invalid, even though 2 is an Int which is an </span>
<span class="c1">-- instance of Eq, and Red is a TrafficLight which is also an instance of Eq</span>

<span class="c1">-- Other common typeclasses are:</span>
<span class="c1">-- Ord for types that can be ordered, allowing you to use &gt;, &lt;=, etc.</span>
<span class="c1">-- Read for types that can be created from a string representation</span>
<span class="c1">-- Show for types that can be converted to a string for display</span>
<span class="c1">-- Num, Real, Integral, Fractional for types that can do math</span>
<span class="c1">-- Enum for types that can be stepped through</span>
<span class="c1">-- Bounded for types with a maximum and minimum</span>

<span class="c1">-- Haskell can automatically make types part of Eq, Ord, Read, Show, Enum, </span>
<span class="c1">-- and Bounded with the `deriving` keyword at the end of the type declaration</span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Point</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Point</span><span class="w"> </span><span class="kt">Float</span><span class="w"> </span><span class="kt">Float</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Read</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="p">)</span>

<span class="c1">-- In this case it is NOT necessary to create an &#39;instance&#39; definition</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 9. Haskell IO</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- While IO can&#39;t be explained fully without explaining monads,</span>
<span class="c1">-- it is not hard to explain enough to get going.</span>

<span class="c1">-- When a Haskell program is executed, `main` is</span>
<span class="c1">-- called. It must return a value of type `IO a` for some type `a`. For example:</span>

<span class="nf">main</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span>
<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">putStrLn</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="s">&quot;Hello, sky! &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">(</span><span class="n">say</span><span class="w"> </span><span class="kt">Blue</span><span class="p">)</span>
<span class="c1">-- putStrLn has type String -&gt; IO ()</span>

<span class="c1">-- It is easiest to do IO if you can implement your program as</span>
<span class="c1">-- a function from String to String. The function</span>
<span class="c1">--    interact :: (String -&gt; String) -&gt; IO ()</span>
<span class="c1">-- inputs some text, runs a function on it, and prints out the</span>
<span class="c1">-- output.</span>

<span class="nf">countLines</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span>
<span class="nf">countLines</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">lines</span>

<span class="nf">main&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">interact</span><span class="w"> </span><span class="n">countLines</span>

<span class="c1">-- You can think of a value of type `IO ()` as representing a</span>
<span class="c1">-- sequence of actions for the computer to do, much like a</span>
<span class="c1">-- computer program written in an imperative language. We can use</span>
<span class="c1">-- the `do` notation to chain actions together. For example:</span>

<span class="nf">sayHello</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span>
<span class="nf">sayHello</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span>
<span class="w">   </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;What is your name?&quot;</span>
<span class="w">   </span><span class="n">name</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getLine</span><span class="w"> </span><span class="c1">-- this gets a line and gives it the name &quot;name&quot;</span>
<span class="w">   </span><span class="n">putStrLn</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="s">&quot;Hello, &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">name</span>

<span class="c1">-- Exercise: write your own version of `interact` that only reads</span>
<span class="c1">--           one line of input.</span>

<span class="c1">-- The code in `sayHello` will never be executed, however. The only</span>
<span class="c1">-- action that ever gets executed is the value of `main`.</span>
<span class="c1">-- To run `sayHello` comment out the above definition of `main`</span>
<span class="c1">-- and replace it with:</span>
<span class="c1">--   main = sayHello</span>

<span class="c1">-- Let&#39;s understand better how the function `getLine` we just</span>
<span class="c1">-- used works. Its type is:</span>
<span class="c1">--    getLine :: IO String</span>
<span class="c1">-- You can think of a value of type `IO a` as representing a</span>
<span class="c1">-- computer program that will generate a value of type `a`</span>
<span class="c1">-- when executed (in addition to anything else it does). We can</span>
<span class="c1">-- name and reuse this value using `&lt;-`. We can also</span>
<span class="c1">-- make our own action of type `IO String`:</span>

<span class="nf">action</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">String</span>
<span class="nf">action</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span>
<span class="w">   </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;This is a line. Duh&quot;</span>
<span class="w">   </span><span class="n">input1</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getLine</span>
<span class="w">   </span><span class="n">input2</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getLine</span>
<span class="w">   </span><span class="c1">-- The type of the `do` statement is that of its last line.</span>
<span class="w">   </span><span class="c1">-- `return` is not a keyword, but merely a function</span>
<span class="w">   </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">input1</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">input2</span><span class="p">)</span><span class="w"> </span><span class="c1">-- return :: String -&gt; IO String</span>

<span class="c1">-- We can use this just like we used `getLine`:</span>

<span class="nf">main&#39;&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span>
<span class="w">    </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;I will echo two lines!&quot;</span>
<span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">action</span>
<span class="w">    </span><span class="n">putStrLn</span><span class="w"> </span><span class="n">result</span>
<span class="w">    </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;This was all, folks!&quot;</span>

<span class="c1">-- The type `IO` is an example of a &quot;monad&quot;. The way Haskell uses a monad to</span>
<span class="c1">-- do IO allows it to be a purely functional language. Any function that</span>
<span class="c1">-- interacts with the outside world (i.e. does IO) gets marked as `IO` in its</span>
<span class="c1">-- type signature. This lets us reason about which functions are &quot;pure&quot; (don&#39;t</span>
<span class="c1">-- interact with the outside world or modify state) and which functions aren&#39;t.</span>

<span class="c1">-- This is a powerful feature, because it&#39;s easy to run pure functions</span>
<span class="c1">-- concurrently; so, concurrency in Haskell is very easy.</span>


<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 10. The Haskell REPL</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Start the repl by typing `ghci`.</span>
<span class="c1">-- Now you can type in Haskell code. Any new values</span>
<span class="c1">-- need to be created with `let`:</span>

<span class="kr">let</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">5</span>

<span class="c1">-- You can see the type of any value or expression with `:t`:</span>

<span class="o">&gt;</span><span class="w"> </span><span class="kt">:</span><span class="n">t</span><span class="w"> </span><span class="n">foo</span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span>

<span class="c1">-- Operators, such as `+`, `:` and `$`, are functions.</span>
<span class="c1">-- Their type can be inspected by putting the operator in parentheses:</span>

<span class="o">&gt;</span><span class="w"> </span><span class="kt">:</span><span class="n">t</span><span class="w"> </span><span class="p">(</span><span class="kt">:</span><span class="p">)</span>
<span class="p">(</span><span class="kt">:</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span>

<span class="c1">-- You can get additional information on any `name` using `:i`:</span>

<span class="o">&gt;</span><span class="w"> </span><span class="kt">:</span><span class="n">i</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span>
<span class="kr">class</span><span class="w"> </span><span class="kt">Num</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span>
<span class="w">  </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span>
<span class="w">  </span><span class="o">...</span>
<span class="w">    </span><span class="c1">-- Defined in ‘GHC.Num’</span>
<span class="kr">infixl</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="o">+</span>

<span class="c1">-- You can also run any action of type `IO ()`</span>

<span class="o">&gt;</span><span class="w"> </span><span class="n">sayHello</span>
<span class="kt">What</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">your</span><span class="w"> </span><span class="n">name</span><span class="o">?</span>
<span class="kt">Friend</span><span class="o">!</span>
<span class="kt">Hello</span><span class="p">,</span><span class="w"> </span><span class="kt">Friend</span><span class="o">!</span>
</pre></div>
<p>There&rsquo;s a lot more to Haskell, including typeclasses and monads. These are the
big ideas that make Haskell such fun to code in. I&rsquo;ll leave you with one final
Haskell example: an implementation of a quicksort variant in Haskell:</p>
<div class="highlight"><pre><span></span><span class="nf">qsort</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span>
<span class="nf">qsort</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">qsort</span><span class="w"> </span><span class="n">lesser</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">qsort</span><span class="w"> </span><span class="n">greater</span>
<span class="w">    </span><span class="kr">where</span><span class="w"> </span><span class="n">lesser</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span>
<span class="w">          </span><span class="n">greater</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="o">&gt;=</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span>
</pre></div>
<p>There are two popular ways to install Haskell: The traditional <a href="http://www.haskell.org/platform/">Cabal-based installation</a>, and the newer <a href="https://www.stackage.org/install">Stack-based process</a>.</p>

<p>You can find a much gentler introduction from the excellent
<a href="http://learnyouahaskell.com/">Learn you a Haskell</a> (or <a href="https://learnyouahaskell.github.io/">up-to-date community version</a>),
<a href="http://www.happylearnhaskelltutorial.com/">Happy Learn Haskell Tutorial</a> or
<a href="http://book.realworldhaskell.org/">Real World Haskell</a>.</p>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/haskell.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by Adit Bhargava, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/haskell.html.markdown">33 contributors</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://adit.io">Adit Bhargava</a>,
        <a href="https://stanislav.gq">Stanislav Modrak</a>
    </p>

    <p>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
