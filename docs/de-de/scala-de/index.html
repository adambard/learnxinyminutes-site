<!DOCTYPE html lang="de-de" xml:lang="de-de" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="de-de">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Scala in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/de-de/scala-de/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fde-de%2Fscala-de%2F&text=Lerne+X+in+Y+Minuten%2C+wobei+X%3DScala">
        Teile diese Seite mit anderen
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Thema wählen:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">hell</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dunkel</button>
  </div>
  <h1><a href="/">Lerne X in Y Minuten</a></h1>
  <h2>Wobei X=Scala</h2>
    <p class="filelink">
    Lade den Code herunter:
    <a href="/docs/files/learnscala-de.scala">learnscala-de.scala</a>
    </p>
  <div id="doc">
    <p>Scala ist eine funktionale und objektorientierte Programmiersprache
für die Java Virtual Machine (JVM), um allgemeine Programmieraufgaben
zu erledigen. Scala hat einen akademischen Hintergrund und wurde an
der EPFL (Lausanne / Schweiz) unter der Leitung von Martin Odersky entwickelt.</p>
<div class="highlight"><pre class="highlight scala"><code><span class="cm">/*
Scala-Umgebung einrichten:

1. Scala binaries herunterladen- http://www.scala-lang.org/downloads
2. Unzip/untar in ein Verzeichnis
3. das Unterverzeichnis `bin` der `PATH`-Umgebungsvariable hinzufügen
4. Mit dem Kommando `scala` wird die REPL gestartet und zeigt als Prompt:

scala&gt;

Die REPL (Read-Eval-Print Loop) ist der interaktive Scala Interpreter.
Hier kann man jeden Scala Ausdruck verwenden und das Ergebnis wird direkt
ausgegeben.
Als nächstes beschäftigen wir uns mit ein paar Scala-Grundlagen.
*/</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 1. Grundlagen</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Einzeilige Kommentare beginnen mit zwei Schrägstrichen.</span>

<span class="cm">/*
  Mehrzeilige Kommentare starten mit Schrägstrich und Stern
  und enden mit Stern und Schrägstrich.
*/</span>

<span class="c1">// Einen Wert und eine zusätzliche neue Zeile ausgeben:</span>

<span class="nf">println</span><span class="o">(</span><span class="s">"Hallo Welt!"</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>


<span class="c1">// Einen Wert ohne eine zusätzliche neue Zeile ausgeben:</span>

<span class="nf">print</span><span class="o">(</span><span class="s">"Hallo Welt"</span><span class="o">)</span>

<span class="cm">/*
  Variablen werden entweder mit var oder val deklariert.
  Deklarationen mit val sind immutable, also unveränderlich.
  Deklarationen mit var sind mutable, also veränderlich.
  Immutability ist gut.
*/</span>
<span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="mi">10</span> <span class="c1">// x ist 10</span>
<span class="n">x</span> <span class="k">=</span> <span class="mi">20</span>     <span class="c1">// Error: reassignment to val (Fehler: neue Zuweisung zu einem unveränderlichen Wert)</span>
<span class="k">var</span> <span class="n">y</span> <span class="k">=</span> <span class="mi">10</span>
<span class="n">y</span> <span class="k">=</span> <span class="mi">20</span>     <span class="c1">// y ist jetzt 20</span>

<span class="cm">/*
Scala ist eine statisch getypte Sprache, auch wenn wir in dem o.g. Beispiel
keine Typen an x und y geschrieben haben.
In Scala ist etwas eingebaut, was sich Type Inference nennt. Das heißt, dass der
Scala Compiler in den meisten Fällen erraten kann, von welchem Typ eine Variable ist,
so dass der Typ nicht jedes mal angegeben werden muss.
Einen Typ gibt man bei einer Variablendeklaration wie folgt an:
*/</span>
<span class="k">val</span> <span class="nv">z</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span>
<span class="k">val</span> <span class="nv">a</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">1.0</span>


<span class="c1">// Bei automatischer Umwandlung von Int auf Double wird aus 10 eine 10.0:</span>

<span class="k">val</span> <span class="nv">b</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mi">10</span>


<span class="c1">// Boolean-Werte:</span>

<span class="kc">true</span>
<span class="kc">false</span>


<span class="c1">// Boolean-Operationen:</span>

<span class="o">!</span><span class="kc">true</span>         <span class="c1">// false</span>
<span class="o">!</span><span class="kc">false</span>        <span class="c1">// true</span>
<span class="kc">true</span> <span class="o">==</span> <span class="kc">false</span> <span class="c1">// false</span>
<span class="mi">10</span> <span class="o">&gt;</span> <span class="mi">5</span>        <span class="c1">// true</span>


<span class="c1">// Mathematische Operationen sind wie gewohnt:</span>

<span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>   <span class="c1">// 2</span>
<span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>   <span class="c1">// 1</span>
<span class="mi">5</span> <span class="o">*</span> <span class="mi">3</span>   <span class="c1">// 15</span>
<span class="mi">6</span> <span class="o">/</span> <span class="mi">2</span>   <span class="c1">// 3</span>
<span class="mi">6</span> <span class="o">/</span> <span class="mi">4</span>   <span class="c1">// 1</span>
<span class="mf">6.0</span> <span class="o">/</span> <span class="mi">4</span> <span class="c1">// 1.5</span>


<span class="c1">// Die Auswertung eines Ausdrucks in der REPL gibt den Typ</span>
<span class="c1">// und das Ergebnis zurück:</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">7</span>
  <span class="n">res29</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">8</span>

<span class="cm">/*
Das bedeutet, dass das Resultat der Auswertung von 1 + 7 ein Objekt
von Typ Int ist und einen Wert 8 hat.
"res29" ist ein sequentiell generierter Name, um das Ergebnis des
Ausdrucks zu speichern. Dieser Wert kann bei Dir anders sein...
*/</span>

<span class="s">"Scala strings werden in doppelten Anführungszeichen eingeschlossen"</span>
<span class="sc">'a'</span> <span class="c1">// Ein Scala Char</span>
<span class="c1">// 'Einzeln ge-quotete strings gibt es nicht!' &lt;= Das erzeugt einen Fehler!</span>

<span class="c1">// Für Strings gibt es die üblichen Java-Methoden:</span>

<span class="s">"Hallo Welt"</span><span class="o">.</span><span class="py">length</span>
<span class="s">"Hallo Welt"</span><span class="o">.</span><span class="py">substring</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>
<span class="s">"Hallo Welt"</span><span class="o">.</span><span class="py">replace</span><span class="o">(</span><span class="s">"C"</span><span class="o">,</span> <span class="s">"3"</span><span class="o">)</span>


<span class="c1">// Zusätzlich gibt es noch extra Scala-Methoden</span>
<span class="c1">// siehe: scala.collection.immutable.StringOps</span>

<span class="s">"Hallo Welt"</span><span class="o">.</span><span class="py">take</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="s">"Hallo Welt"</span><span class="o">.</span><span class="py">drop</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>


<span class="c1">// String-Interpolation: prefix "s":</span>

<span class="k">val</span> <span class="nv">n</span> <span class="k">=</span> <span class="mi">45</span>
<span class="n">s</span><span class="s">"Wir haben $n Äpfel"</span> <span class="c1">// =&gt; "Wir haben 45 Äpfel"</span>


<span class="c1">// Ausdrücke im Innern von interpolierten Strings gibt es auch:</span>

<span class="k">val</span> <span class="nv">a</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">11</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>
<span class="n">s</span><span class="s">"Meine zweite Tochter ist ${a(0) - a(2)} Jahre alt."</span>    <span class="c1">// =&gt; "Meine zweite Tochter ist 5 Jahre alt."</span>
<span class="n">s</span><span class="s">"Wir haben das Doppelte von ${n / 2.0} an Äpfeln."</span> <span class="c1">// =&gt; "Wir haben das Doppelte von 22.5 an Äpfeln."</span>
<span class="n">s</span><span class="s">"2 im Quadrat: ${math.pow(2, 2)}"</span>                      <span class="c1">// =&gt; "2 im Quadrat: 4"</span>


<span class="c1">// Formatierung der interpolierten Strings mit dem prefix "f":</span>

<span class="n">f</span><span class="s">"5 im Quadrat: ${math.pow(5, 2)}%1.0f"</span>         <span class="c1">// "5 im Quadrat: 25"</span>
<span class="n">f</span><span class="s">"Quadratwurzel von 122: ${math.sqrt(122)}%1.4f"</span> <span class="c1">// "Quadratwurzel von 122: 11.0454"</span>


<span class="c1">// Raw Strings ignorieren Sonderzeichen:</span>

<span class="n">raw</span><span class="s">"New line feed: \n. Carriage return: \r."</span> <span class="c1">// =&gt; "New line feed: \n. Carriage return: \r."</span>


<span class="c1">// Manche Zeichen müssen "escaped" werden, z.B.</span>
<span class="c1">// ein doppeltes Anführungszeichen im Innern eines Strings:</span>

<span class="s">"Sie standen vor der \"Rose and Crown\""</span> <span class="c1">// =&gt; "Sie standen vor der "Rose and Crown""</span>


<span class="c1">// Dreifache Anführungszeichen erlauben es, dass ein String über mehrere Zeilen geht</span>
<span class="c1">// und Anführungszeichen enthalten kann:</span>

<span class="k">val</span> <span class="nv">html</span> <span class="k">=</span> <span class="s">"""&lt;form id="dieform"&gt;
                &lt;p&gt;Drück belo', Joe&lt;/p&gt;
                &lt;input type="submit"&gt;
              &lt;/form&gt;"""</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 2. Funktionen</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Funktionen werden so definiert:</span>
<span class="c1">//</span>
<span class="c1">//   def functionName(args...): ReturnType = { body... }</span>
<span class="c1">//</span>
<span class="c1">// Beachte: Es wird hier kein Schlüsselwort "return" verwendet.</span>
<span class="c1">// In Scala ist der letzte Ausdruck in einer Funktion der Rückgabewert.</span>

<span class="k">def</span> <span class="nf">sumOfSquares</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">x2</span> <span class="k">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
  <span class="k">val</span> <span class="nv">y2</span> <span class="k">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span>
  <span class="n">x2</span> <span class="o">+</span> <span class="n">y2</span>
<span class="o">}</span>


<span class="c1">// Die geschweiften Klammern können weggelassen werden, wenn</span>
<span class="c1">// die Funktion nur aus einem einzigen Ausdruck besteht:</span>

<span class="k">def</span> <span class="nf">sumOfSquaresShort</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span>


<span class="c1">// Syntax für Funktionsaufrufe:</span>

<span class="nf">sumOfSquares</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>  <span class="c1">// =&gt; 25</span>


<span class="c1">// In den meisten Fällen (mit Ausnahme von rekursiven Funktionen) können</span>
<span class="c1">// Rückgabetypen auch weggelassen werden, da dieselbe Typ-Inferenz, wie bei</span>
<span class="c1">// Variablen, auch bei Funktionen greift:</span>

<span class="k">def</span> <span class="nf">sq</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>  <span class="c1">// Compiler errät, dass der return type Int ist</span>


<span class="c1">// Funktionen können Default-Parameter haben:</span>

<span class="k">def</span> <span class="nf">addWithDefault</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="nf">addWithDefault</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="c1">// =&gt; 3</span>
<span class="nf">addWithDefault</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>    <span class="c1">// =&gt; 6</span>


<span class="c1">// Anonyme Funktionen sehen so aus:</span>

<span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>


<span class="c1">// Im Gegensatz zu def bei normalen Funktionen, kann bei anonymen Funktionen</span>
<span class="c1">// sogar der Eingabetyp weggelassen werden, wenn der Kontext klar ist.</span>
<span class="c1">// Beachte den Typ "Int =&gt; Int", dies beschreibt eine Funktion,</span>
<span class="c1">// welche Int als Parameter erwartet und Int zurückgibt.</span>

<span class="k">val</span> <span class="nv">sq</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>


<span class="c1">// Anonyme Funktionen benutzt man ganz normal:</span>

<span class="nf">sq</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>   <span class="c1">// =&gt; 100</span>


<span class="c1">// Wenn ein Parameter einer anonymen Funktion nur einmal verwendet wird,</span>
<span class="c1">// bietet Scala einen sehr kurzen Weg diesen Parameter zu benutzen,</span>
<span class="c1">// indem die Parameter als Unterstrich "_" in der Parameterreihenfolge</span>
<span class="c1">// verwendet werden. Diese anonymen Funktionen werden sehr häufig</span>
<span class="c1">// verwendet.</span>

<span class="k">val</span> <span class="nv">addOne</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="k">_</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">val</span> <span class="nv">weirdSum</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="k">_</span> <span class="o">*</span> <span class="mi">3</span><span class="o">)</span>
<span class="nf">addOne</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>      <span class="c1">// =&gt; 6</span>
<span class="nf">weirdSum</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span> <span class="c1">// =&gt; 16</span>


<span class="c1">// Es gibt ein Schlüsselwort "return" in Scala. Allerdings ist seine Verwendung</span>
<span class="c1">// nicht immer ratsam und kann fehlerbehaftet sein. "return" gibt nur aus</span>
<span class="c1">// dem innersten def, welches den return Ausdruck umgibt, zurück.</span>
<span class="c1">// "return" hat keinen Effekt in anonymen Funktionen:</span>

<span class="k">def</span> <span class="nf">foo</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">anonFunc</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">{</span> <span class="n">z</span> <span class="k">=&gt;</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">z</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="o">)</span>
      <span class="k">return</span> <span class="n">z</span> <span class="c1">// Zeile macht z zum return Wert von foo</span>
    <span class="k">else</span>
      <span class="n">z</span> <span class="o">+</span> <span class="mi">2</span>    <span class="c1">// Zeile ist der return Wert von anonFunc</span>
  <span class="o">}</span>
  <span class="nf">anonFunc</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>  <span class="c1">// Zeile ist der return Wert von foo</span>
<span class="o">}</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 3. Flusskontrolle</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Wertebereiche und Schleifen:</span>

<span class="mi">1</span> <span class="n">to</span> <span class="mi">5</span>
<span class="k">val</span> <span class="nv">r</span> <span class="k">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">5</span>
<span class="nv">r</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="n">r</span> <span class="n">foreach</span> <span class="nf">println</span>
<span class="o">(</span><span class="mi">5</span> <span class="n">to</span> <span class="mi">1</span> <span class="n">by</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="nf">foreach</span> <span class="o">(</span><span class="n">println</span><span class="o">)</span>

<span class="c1">// Scala ist syntaktisch sehr großzügig; Semikolons am Zeilenende</span>
<span class="c1">// sind optional, beim Aufruf von Methoden können die Punkte</span>
<span class="c1">// und Klammern entfallen und Operatoren sind im Grunde austauschbare Methoden.</span>

<span class="c1">// while Schleife:</span>

<span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
<span class="nf">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"i "</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">}</span>
<span class="n">i</span>    <span class="c1">// i ausgeben, res3: Int = 10</span>


<span class="c1">// Beachte: while ist eine Schleife im klassischen Sinne -</span>
<span class="c1">// Sie läuft sequentiell ab und verändert die loop-Variable.</span>
<span class="c1">// "while" in Scala läuft schneller ab als in Java und die o.g.</span>
<span class="c1">// Kombinatoren und Zusammenlegungen sind einfacher zu verstehen</span>
<span class="c1">// und zu parallelisieren.</span>

<span class="c1">// Ein do while Schleife</span>

<span class="k">do</span> <span class="o">{</span>
  <span class="nf">println</span><span class="o">(</span><span class="s">"x ist immer noch weniger als 10"</span><span class="o">)</span>
  <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="o">}</span> <span class="nf">while</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span>


<span class="c1">// Endrekursionen sind idiomatisch um sich wiederholende</span>
<span class="c1">// Aufgaben in Scala zu lösen. Rekursive Funtionen benötigen explizit einen</span>
<span class="c1">// Rückgabe-Typ, der Compiler kann ihn nicht erraten.</span>
<span class="c1">// Der Rückgabe-Typ in diesem Beispiel ist Unit:</span>

<span class="k">def</span> <span class="nf">showNumbersInRange</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="nf">print</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
  <span class="nf">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">)</span>
    <span class="nf">showNumbersInRange</span><span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
<span class="o">}</span>
<span class="nf">showNumbersInRange</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">14</span><span class="o">)</span>


<span class="c1">// Conditionals</span>

<span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="mi">10</span>
<span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="nf">println</span><span class="o">(</span><span class="s">"yeah"</span><span class="o">)</span>
<span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">10</span><span class="o">)</span> <span class="nf">println</span><span class="o">(</span><span class="s">"yeah"</span><span class="o">)</span>
<span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">11</span><span class="o">)</span> <span class="nf">println</span><span class="o">(</span><span class="s">"yeah"</span><span class="o">)</span>
<span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">11</span><span class="o">)</span> <span class="nf">println</span> <span class="o">(</span><span class="s">"yeah"</span><span class="o">)</span> <span class="k">else</span> <span class="nf">println</span><span class="o">(</span><span class="s">"nay"</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">10</span><span class="o">)</span> <span class="s">"yeah"</span> <span class="k">else</span> <span class="s">"nope"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">text</span> <span class="k">=</span> <span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">10</span><span class="o">)</span> <span class="s">"yeah"</span> <span class="k">else</span> <span class="s">"nope"</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 4. Datenstrukturen (Array, Map, Set, Tupel)</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Array</span>

<span class="k">val</span> <span class="nv">a</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">13</span><span class="o">)</span>
<span class="nf">a</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="nf">a</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="nf">a</span><span class="o">(</span><span class="mi">21</span><span class="o">)</span>    <span class="c1">// Exception</span>


<span class="c1">// Map - Speichert Key-Value-Paare</span>

<span class="k">val</span> <span class="nv">m</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"fork"</span> <span class="o">-&gt;</span> <span class="s">"Gabel"</span><span class="o">,</span> <span class="s">"spoon"</span> <span class="o">-&gt;</span> <span class="s">"Löffel"</span><span class="o">,</span> <span class="s">"knife"</span> <span class="o">-&gt;</span> <span class="s">"Messer"</span><span class="o">)</span>
<span class="nf">m</span><span class="o">(</span><span class="s">"fork"</span><span class="o">)</span>
<span class="nf">m</span><span class="o">(</span><span class="s">"spoon"</span><span class="o">)</span>
<span class="nf">m</span><span class="o">(</span><span class="s">"bottle"</span><span class="o">)</span>       <span class="c1">// Exception</span>
<span class="k">val</span> <span class="nv">safeM</span> <span class="k">=</span> <span class="nv">m</span><span class="o">.</span><span class="py">withDefaultValue</span><span class="o">(</span><span class="s">"unbekannt"</span><span class="o">)</span>
<span class="nf">safeM</span><span class="o">(</span><span class="s">"bottle"</span><span class="o">)</span>

<span class="c1">// Set - Speichert Unikate, unsortiert (sortiert -&gt; SortedSet)</span>

<span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>
<span class="nf">s</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="c1">//false</span>
<span class="nf">s</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="c1">//true</span>
<span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">7</span><span class="o">)</span>
<span class="n">s</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>

<span class="c1">// Tupel - Speichert beliebige Daten und "verbindet" sie miteinander</span>
<span class="c1">// Ein Tupel ist keine Collection.</span>

<span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="s">"three"</span><span class="o">)</span>
<span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="s">"three"</span><span class="o">)</span>


<span class="c1">// Hier ist der Rückgabewert der Funktion ein Tupel</span>
<span class="c1">// Die Funktion gibt das Ergebnis sowie den Rest zurück.</span>

<span class="k">val</span> <span class="nv">divideInts</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="o">%</span> <span class="n">y</span><span class="o">)</span>
<span class="nf">divideInts</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>


<span class="c1">// Um die Elemente eines Tupels anzusprechen, benutzt man diese</span>
<span class="c1">// Notation: _._n wobei n der index des Elements ist (Index startet bei 1)</span>

<span class="k">val</span> <span class="nv">d</span> <span class="k">=</span> <span class="nf">divideInts</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="nv">d</span><span class="o">.</span><span class="py">_1</span>
<span class="nv">d</span><span class="o">.</span><span class="py">_2</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 5. Objektorientierte Programmierung</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="cm">/*
  Bislang waren alle gezeigten Sprachelemente einfache Ausdrücke, welche zwar
  zum Ausprobieren und Lernen in der REPL gut geeignet sind, jedoch in
  einer Scala-Datei selten alleine zu finden sind.
  Die einzigen Top-Level-Konstrukte in Scala sind nämlich:

  - Klassen (classes)
  - Objekte (objects)
  - case classes
  - traits

  Diesen Sprachelemente wenden wir uns jetzt zu.
*/</span>

<span class="c1">// Klassen</span>

<span class="c1">// Zum Erstellen von Objekten benötigt man eine Klasse, wie in vielen</span>
<span class="c1">// anderen Sprachen auch.</span>

<span class="c1">// erzeugt Klasse mit default Konstruktor:</span>

<span class="k">class</span> <span class="nc">Hund</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">t</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Hund</span>
<span class="n">t</span><span class="k">:</span> <span class="kt">Hund</span> <span class="o">=</span> <span class="nc">Hund</span><span class="k">@</span><span class="mi">7103745</span>


<span class="c1">// Der Konstruktor wird direkt hinter dem Klassennamen deklariert.</span>

<span class="k">class</span> <span class="nc">Hund</span><span class="o">(</span><span class="n">sorte</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">t</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Hund</span><span class="o">(</span><span class="s">"Dackel"</span><span class="o">)</span>
<span class="n">t</span><span class="k">:</span> <span class="kt">Hund</span> <span class="o">=</span> <span class="nc">Hund</span><span class="k">@</span><span class="mi">14</span><span class="n">be750c</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">t</span><span class="o">.</span><span class="py">sorte</span> <span class="c1">//error: value sorte is not a member of Hund</span>


<span class="c1">// Per val wird aus dem Attribut ein unveränderliches Feld der Klasse</span>
<span class="c1">// Per var wird aus dem Attribut ein veränderliches Feld der Klasse</span>

<span class="k">class</span> <span class="nc">Hund</span><span class="o">(</span><span class="k">val</span> <span class="nv">sorte</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">t</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Hund</span><span class="o">(</span><span class="s">"Dackel"</span><span class="o">)</span>
<span class="n">t</span><span class="k">:</span> <span class="kt">Hund</span> <span class="o">=</span> <span class="nc">Hund</span><span class="k">@</span><span class="mi">74</span><span class="n">a85515</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">t</span><span class="o">.</span><span class="py">sorte</span>
<span class="n">res18</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Dackel</span>


<span class="c1">// Methoden werden mit def geschrieben</span>

<span class="k">def</span> <span class="nf">bark</span> <span class="k">=</span> <span class="s">"Wuff, wuff!"</span>


<span class="c1">// Felder und Methoden können public, protected und private sein</span>
<span class="c1">// default ist public</span>
<span class="c1">// private ist nur innerhalb des deklarierten Bereichs sichtbar</span>

<span class="k">class</span> <span class="nc">Hund</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">def</span> <span class="nf">x</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="nf">y</span> <span class="k">=</span> <span class="o">...</span>
<span class="o">}</span>


<span class="c1">// protected ist nur innerhalb des deklarierten und aller</span>
<span class="c1">// erbenden Bereiche sichtbar</span>

<span class="k">class</span> <span class="nc">Hund</span> <span class="o">{</span>
  <span class="k">protected</span> <span class="k">def</span> <span class="nf">x</span> <span class="k">=</span> <span class="o">...</span>
<span class="o">}</span>
<span class="k">class</span> <span class="nc">Dackel</span> <span class="k">extends</span> <span class="nc">Hund</span> <span class="o">{</span>
  <span class="c1">// x ist sichtbar</span>
<span class="o">}</span>

<span class="c1">// Object</span>
<span class="c1">// Wird ein Objekt ohne das Schlüsselwort "new" instanziert, wird das sog.</span>
<span class="c1">// "companion object" aufgerufen. Mit dem "object" Schlüsselwort wird so</span>
<span class="c1">// ein Objekt (Typ UND Singleton) erstellt. Damit kann man dann eine Klasse</span>
<span class="c1">// verwenden, ohne ein Objekt instanziieren zu müssen.</span>
<span class="c1">// Ein gültiges companion Objekt einer Klasse ist es aber erst dann, wenn</span>
<span class="c1">// es genauso heißt und in derselben Datei wie die Klasse definiert wurde.</span>

<span class="k">object</span> <span class="nc">Hund</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">alleSorten</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"Pitbull"</span><span class="o">,</span> <span class="s">"Dackel"</span><span class="o">,</span> <span class="s">"Retriever"</span><span class="o">)</span>
  <span class="k">def</span> <span class="nf">createHund</span><span class="o">(</span><span class="n">sorte</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Hund</span><span class="o">(</span><span class="n">sorte</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// Case classes</span>
<span class="c1">// Fallklassen bzw. Case classes sind Klassen, die normale Klassen um</span>
<span class="c1">// zusätzliche Funktionalität erweitern.</span>
<span class="c1">// Mit Case-Klassen bekommt man ein paar</span>
<span class="c1">// Dinge einfach dazu, ohne sich darum kümmern zu müssen. Z.B.</span>
<span class="c1">// ein companion object mit den entsprechenden Methoden,</span>
<span class="c1">// Hilfsmethoden wie toString(), equals() und hashCode() und auch noch</span>
<span class="c1">// Getter für unsere Attribute (das Angeben von val entfällt dadurch)</span>

<span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="k">val</span> <span class="nv">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">class</span> <span class="nc">Hund</span><span class="o">(</span><span class="k">val</span> <span class="nv">sorte</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="k">val</span> <span class="nv">farbe</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="k">val</span> <span class="nv">halter</span><span class="k">:</span> <span class="kt">Person</span><span class="o">)</span>


<span class="c1">// Es genügt, das Schlüsselwort case vor die Klasse zu schreiben:</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Hund</span><span class="o">(</span><span class="n">sorte</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">farbe</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">halter</span><span class="k">:</span> <span class="kt">Person</span><span class="o">)</span>


<span class="c1">// Für neue Instanzen braucht man kein "new":</span>

<span class="k">val</span> <span class="nv">dackel</span> <span class="k">=</span> <span class="nc">Hund</span><span class="o">(</span><span class="s">"dackel"</span><span class="o">,</span> <span class="s">"grau"</span><span class="o">,</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"peter"</span><span class="o">))</span>
<span class="k">val</span> <span class="nv">dogge</span> <span class="k">=</span> <span class="nc">Hund</span><span class="o">(</span><span class="s">"dogge"</span><span class="o">,</span> <span class="s">"grau"</span><span class="o">,</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"peter"</span><span class="o">))</span>


<span class="c1">// getter</span>

<span class="nv">dackel</span><span class="o">.</span><span class="py">halter</span>  <span class="c1">// =&gt; Person = Person(peter)</span>


<span class="c1">// equals</span>

<span class="n">dogge</span> <span class="o">==</span> <span class="n">dackel</span>  <span class="c1">// =&gt; false</span>


<span class="c1">// copy</span>
<span class="c1">// otherGeorge == Person("george", "9876")</span>

<span class="k">val</span> <span class="nv">otherGeorge</span> <span class="k">=</span> <span class="nv">george</span><span class="o">.</span><span class="py">copy</span><span class="o">(</span><span class="n">phoneNumber</span> <span class="k">=</span> <span class="s">"9876"</span><span class="o">)</span>

<span class="c1">// Traits</span>
<span class="c1">// Ähnlich wie Java interfaces, definiert man mit traits einen Objekttyp</span>
<span class="c1">// und Methodensignaturen. Scala erlaubt allerdings das teilweise</span>
<span class="c1">// Implementieren dieser Methoden. Konstruktorparameter sind nicht erlaubt.</span>
<span class="c1">// Traits können von anderen Traits oder Klassen erben, aber nur von</span>
<span class="c1">// parameterlosen.</span>

<span class="k">trait</span> <span class="nc">Hund</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">sorte</span><span class="k">:</span> <span class="kt">String</span>
    <span class="k">def</span> <span class="nf">farbe</span><span class="k">:</span> <span class="kt">String</span>
    <span class="k">def</span> <span class="nf">bellen</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
    <span class="k">def</span> <span class="nf">beissen</span><span class="k">:</span> <span class="kt">Boolean</span>
<span class="o">}</span>
<span class="k">class</span> <span class="nc">Bernhardiner</span> <span class="k">extends</span> <span class="nc">Hund</span><span class="o">{</span>
    <span class="k">val</span> <span class="nv">sorte</span> <span class="k">=</span> <span class="s">"Bernhardiner"</span>
    <span class="k">val</span> <span class="nv">farbe</span> <span class="k">=</span> <span class="s">"braun"</span>
    <span class="k">def</span> <span class="nf">beissen</span> <span class="k">=</span> <span class="kc">false</span>
<span class="o">}</span>



<span class="n">scala</span><span class="o">&gt;</span> <span class="n">b</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Bernhardiner</span> <span class="o">=</span> <span class="nc">Bernhardiner</span><span class="k">@</span><span class="mi">3</span><span class="n">e57cd70</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">b</span><span class="o">.</span><span class="py">sorte</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Bernhardiner</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">b</span><span class="o">.</span><span class="py">bellen</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">b</span><span class="o">.</span><span class="py">beissen</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="c1">// Ein Trait kann auch als Mixin eingebunden werden. Die Klasse erbt vom</span>
<span class="c1">// ersten Trait mit dem Schlüsselwort "extends", während weitere Traits</span>
<span class="c1">// mit "with" verwendet werden können.</span>

<span class="k">trait</span> <span class="nc">Bellen</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">bellen</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"Wuff"</span>
<span class="o">}</span>
<span class="k">trait</span> <span class="nc">Hund</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">sorte</span><span class="k">:</span> <span class="kt">String</span>
    <span class="k">def</span> <span class="nf">farbe</span><span class="k">:</span> <span class="kt">String</span>
<span class="o">}</span>
<span class="k">class</span> <span class="nc">Bernhardiner</span> <span class="k">extends</span> <span class="nc">Hund</span> <span class="k">with</span> <span class="nc">Bellen</span><span class="o">{</span>
    <span class="k">val</span> <span class="nv">sorte</span> <span class="k">=</span> <span class="s">"Bernhardiner"</span>
    <span class="k">val</span> <span class="nv">farbe</span> <span class="k">=</span> <span class="s">"braun"</span>
<span class="o">}</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">b</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Bernhardiner</span>
<span class="n">b</span><span class="k">:</span> <span class="kt">Bernhardiner</span> <span class="o">=</span> <span class="nc">Bernhardiner</span><span class="k">@</span><span class="mi">7</span><span class="n">b69c6ba</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">b</span><span class="o">.</span><span class="py">bellen</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Wuff</span>

<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 6. Mustervergleich (Pattern Matching)</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Pattern matching in Scala ist ein sehr nützliches und wesentlich</span>
<span class="c1">// mächtigeres Feature als Vergleichsfunktionen in Java. In Scala</span>
<span class="c1">// benötigt ein case Statement kein "break", ein fall-through gibt es nicht.</span>
<span class="c1">// Mehrere Überprüfungen können mit einem Statement gemacht werden.</span>
<span class="c1">// Pattern matching wird mit dem Schlüsselwort "match" gemacht.</span>

<span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="o">...</span>
<span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="mi">2</span> <span class="k">=&gt;</span>
  <span class="k">case</span> <span class="mi">3</span> <span class="k">=&gt;</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
<span class="o">}</span>


<span class="c1">// Pattern Matching kann auf beliebige Typen prüfen</span>

<span class="k">val</span> <span class="nv">any</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="o">...</span>
<span class="k">val</span> <span class="nv">gleicht</span> <span class="k">=</span> <span class="n">any</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="mi">2</span> <span class="o">|</span> <span class="mi">3</span> <span class="o">|</span> <span class="mi">5</span> <span class="k">=&gt;</span> <span class="s">"Zahl"</span>
  <span class="k">case</span> <span class="s">"wuff"</span> <span class="k">=&gt;</span> <span class="s">"String"</span>
  <span class="k">case</span> <span class="kc">true</span> <span class="o">|</span> <span class="kc">false</span> <span class="k">=&gt;</span> <span class="s">"Boolean"</span>
  <span class="k">case</span> <span class="mf">45.35</span> <span class="k">=&gt;</span> <span class="s">"Double"</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"Unbekannt"</span>
<span class="o">}</span>


<span class="c1">// und auf Objektgleichheit</span>

<span class="k">def</span> <span class="nf">matchPerson</span><span class="o">(</span><span class="n">person</span><span class="k">:</span> <span class="kt">Person</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">person</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"George"</span><span class="o">,</span> <span class="n">nummer</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"George! Die Nummer ist "</span> <span class="o">+</span> <span class="n">number</span>
  <span class="k">case</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Kate"</span><span class="o">,</span> <span class="n">nummer</span><span class="o">)</span>   <span class="k">=&gt;</span> <span class="s">"Kate! Die Nummer ist "</span> <span class="o">+</span> <span class="n">nummer</span>
  <span class="k">case</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">nummer</span><span class="o">)</span>     <span class="k">=&gt;</span> <span class="s">"Irgendjemand: "</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">", Telefon: "</span> <span class="o">+</span> <span class="n">nummer</span>
<span class="o">}</span>


<span class="c1">// Und viele mehr...</span>

<span class="k">val</span> <span class="nv">email</span> <span class="k">=</span> <span class="s">"(.*)@(.*)"</span><span class="o">.</span><span class="py">r</span>  <span class="c1">// regex</span>
<span class="k">def</span> <span class="nf">matchEverything</span><span class="o">(</span><span class="n">obj</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">obj</span> <span class="k">match</span> <span class="o">{</span>
  <span class="c1">// Werte:</span>
  <span class="k">case</span> <span class="s">"Hallo Welt"</span> <span class="k">=&gt;</span> <span class="s">"string Hallo Welt gefunden"</span>
  <span class="c1">// Typen:</span>
  <span class="k">case</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=&gt;</span> <span class="s">"Double gefunden: "</span> <span class="o">+</span> <span class="n">x</span>
  <span class="c1">// Bedingungen:</span>
  <span class="k">case</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span> <span class="kt">if</span> <span class="kt">x</span> <span class="kt">&gt;</span> <span class="err">10000</span> <span class="o">=&gt;</span> <span class="s">"Ziemlich große Zahl gefunden!"</span>
  <span class="c1">// Case-Klassen:</span>
  <span class="k">case</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">number</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"Kontaktinformationen für $name gefunden!"</span>
  <span class="c1">// RegEx:</span>
  <span class="k">case</span> <span class="nf">email</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">domain</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"E-Mail-Adresse $name@$domain gefunden"</span>
  <span class="c1">// Tupel:</span>
  <span class="nf">case</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">c</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"Tupel gefunden: $a, $b, $c"</span>
  <span class="c1">// Strukturen:</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"Liste aus drei Elementen gefunden, startend mit 1: 1, $b, $c"</span>
  <span class="c1">// Pattern kann man ineinander schachteln:</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="s">"YAY"</span><span class="o">)))</span> <span class="k">=&gt;</span> <span class="s">"Liste von Tupeln gefunden"</span>
<span class="o">}</span>


<span class="c1">// Jedes Objekt mit einer "unapply" Methode kann per Pattern geprüft werden.</span>
<span class="c1">// Ganze Funktionen können Patterns sein:</span>

<span class="k">val</span> <span class="nv">patternFunc</span><span class="k">:</span> <span class="kt">Person</span> <span class="o">=&gt;</span> <span class="nc">String</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"George"</span><span class="o">,</span> <span class="n">number</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"George's number: $number"</span>
  <span class="k">case</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">number</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"Random person's number: $number"</span>
<span class="o">}</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 7. "Higher-order"-Funktionen</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Scala erlaubt, dass Methoden und Funktionen wiederum Funtionen und Methoden</span>
<span class="c1">// als Aufrufparameter oder Rückgabewert verwenden. Diese Methoden heißen</span>
<span class="c1">// higher-order functions.</span>
<span class="c1">// Es gibt zahlreiche higher-order-Funtionen nicht nur für Listen, auch für</span>
<span class="c1">// die meisten anderen Collection-Typen, sowie andere Klassen in Scala.</span>
<span class="c1">// Nennenswerte sind:</span>
<span class="c1">// "filter", "map", "reduce", "foldLeft"/"foldRight", "exists", "forall"</span>

<span class="c1">// List</span>

<span class="k">def</span> <span class="nf">istGleichVier</span><span class="o">(</span><span class="n">a</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">4</span>
<span class="k">val</span> <span class="nv">list</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">resultExists4</span> <span class="k">=</span> <span class="nv">list</span><span class="o">.</span><span class="py">exists</span><span class="o">(</span><span class="n">isEqualToFour</span><span class="o">)</span>


<span class="c1">// map</span>
<span class="c1">// map nimmt eine Funktion und führt sie auf jedem Element aus und erzeugt</span>
<span class="c1">// eine neue Liste</span>

<span class="c1">// Funktion erwartet einen Int und gibt einen Int zurück:</span>

<span class="k">val</span> <span class="nv">add10</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="k">_</span> <span class="o">+</span> <span class="mi">10</span>


<span class="c1">// add10 wird auf jedes Element angewendet:</span>

<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="n">map</span> <span class="n">add10</span> <span class="c1">// =&gt; List(11, 12, 13)</span>


<span class="c1">// Anonyme Funktionen können anstatt definierter Funktionen verwendet werden:</span>

<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">10</span><span class="o">)</span>


<span class="c1">// Der Unterstrich wird anstelle eines Parameters einer anonymen Funktion</span>
<span class="c1">// verwendet. Er wird an die Variable gebunden:</span>

<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">10</span><span class="o">)</span>


<span class="c1">// Wenn der anonyme Block und die Funktion beide EIN Argument erwarten,</span>
<span class="c1">// kann sogar der Unterstrich weggelassen werden.</span>

<span class="nc">List</span><span class="o">(</span><span class="s">"Dom"</span><span class="o">,</span> <span class="s">"Bob"</span><span class="o">,</span> <span class="s">"Natalia"</span><span class="o">)</span> <span class="n">foreach</span> <span class="n">println</span>


<span class="c1">// filter</span>
<span class="c1">// filter nimmt ein Prädikat (eine Funktion von A -&gt; Boolean) und findet</span>
<span class="c1">// alle Elemente, die auf das Prädikat passen:</span>

<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="nf">filter</span> <span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="c1">// =&gt; List(3)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(</span>
  <span class="nc">Person</span><span class="o">(</span><span class="n">name</span> <span class="k">=</span> <span class="s">"Dom"</span><span class="o">,</span> <span class="n">age</span> <span class="k">=</span> <span class="mi">23</span><span class="o">),</span>
  <span class="nc">Person</span><span class="o">(</span><span class="n">name</span> <span class="k">=</span> <span class="s">"Bob"</span><span class="o">,</span> <span class="n">age</span> <span class="k">=</span> <span class="mi">30</span><span class="o">)</span>
<span class="o">).</span><span class="py">filter</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">age</span> <span class="o">&gt;</span> <span class="mi">25</span><span class="o">)</span> <span class="c1">// List(Person("Bob", 30))</span>


<span class="c1">// reduce</span>
<span class="c1">// reduce nimmt zwei Elemente und kombiniert sie zu einem Element,</span>
<span class="c1">// und zwar so lange, bis nur noch ein Element da ist.</span>

<span class="c1">// foreach</span>
<span class="c1">// foreach gibt es für einige Collections</span>

<span class="k">val</span> <span class="nv">aListOfNumbers</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">100</span><span class="o">)</span>
<span class="n">aListOfNumbers</span> <span class="nf">foreach</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
<span class="n">aListOfNumbers</span> <span class="n">foreach</span> <span class="n">println</span>

<span class="c1">// For comprehensions</span>
<span class="c1">// Eine for-comprehension definiert eine Beziehung zwischen zwei Datensets.</span>
<span class="c1">// Dies ist keine for-Schleife.</span>

<span class="k">for</span> <span class="o">{</span> <span class="n">n</span> <span class="k">&lt;-</span> <span class="n">s</span> <span class="o">}</span> <span class="k">yield</span> <span class="nf">sq</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">nSquared2</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span> <span class="n">n</span> <span class="k">&lt;-</span> <span class="n">s</span> <span class="o">}</span> <span class="k">yield</span> <span class="nf">sq</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
<span class="k">for</span> <span class="o">{</span> <span class="n">n</span> <span class="k">&lt;-</span> <span class="n">nSquared2</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">}</span> <span class="k">yield</span> <span class="n">n</span>
<span class="k">for</span> <span class="o">{</span> <span class="n">n</span> <span class="k">&lt;-</span> <span class="n">s</span><span class="o">;</span> <span class="n">nSquared</span> <span class="k">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span> <span class="k">if</span> <span class="n">nSquared</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">}</span> <span class="k">yield</span> <span class="n">nSquared</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 8. Implicits</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// **ACHTUNG:**</span>
<span class="c1">// Implicits sind ein sehr mächtiges Sprachfeature von Scala.</span>
<span class="c1">// Es sehr einfach,</span>
<span class="c1">// sie falsch zu benutzen und Anfänger sollten sie mit Vorsicht oder am</span>
<span class="c1">// besten erst dann benutzen, wenn sie verstehen, wie sie funktionieren.</span>
<span class="c1">// Dieses Tutorial enthält Implicits, da sie in Scala an jeder Stelle</span>
<span class="c1">// vorkommen und man auch mit einer Bibliothek, die Implicits benutzt, sonst</span>
<span class="c1">// nichts sinnvolles machen kann.</span>
<span class="c1">// Hier soll ein Grundverständnis geschaffen werden, wie sie funktionieren.</span>

<span class="c1">// Mit dem Schlüsselwort implicit können Methoden, Werte, Funktion, Objekte</span>
<span class="c1">// zu "implicit Methods" werden.</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">myImplicitInt</span> <span class="k">=</span> <span class="mi">100</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="nf">myImplicitFunction</span><span class="o">(</span><span class="n">sorte</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Hund</span><span class="o">(</span><span class="s">"Golden "</span> <span class="o">+</span> <span class="n">sorte</span><span class="o">)</span>


<span class="c1">// implicit ändert nicht das Verhalten eines Wertes oder einer Funktion</span>

<span class="n">myImplicitInt</span> <span class="o">+</span> <span class="mi">2</span>                   <span class="c1">// =&gt; 102</span>
<span class="nf">myImplicitFunction</span><span class="o">(</span><span class="s">"Pitbull"</span><span class="o">).</span><span class="py">sorte</span> <span class="c1">// =&gt; "Golden Pitbull"</span>


<span class="c1">// Der Unterschied ist, dass diese Werte ausgewählt werden können, wenn ein</span>
<span class="c1">// anderer Codeteil einen implicit Wert benötigt, zum Beispiel innerhalb von</span>
<span class="c1">// implicit Funktionsparametern</span>

<span class="c1">// Diese Funktion hat zwei Parameter: einen normalen und einen implicit</span>

<span class="k">def</span> <span class="nf">sendGreetings</span><span class="o">(</span><span class="n">toWhom</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">howMany</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span>
  <span class="n">s</span><span class="s">"Hallo $toWhom, $howMany Segenswünsche für Sie und Ihre Angehörigen!"</span>


<span class="c1">// Werden beide Parameter gefüllt, verhält sich die Funktion wie erwartet</span>

<span class="nf">sendGreetings</span><span class="o">(</span><span class="s">"John"</span><span class="o">)(</span><span class="mi">1000</span><span class="o">)</span>  <span class="c1">// =&gt; "Hallo John, 1000 Segenswünsche für Sie und Ihre Angehörigen!"</span>


<span class="c1">// Wird der implicit-Parameter jedoch weggelassen, wird ein anderer</span>
<span class="c1">// implicit-Wert vom gleichen Typ genommen. Der Compiler sucht im</span>
<span class="c1">// lexikalischen Scope und im companion object nach einem implicit-Wert,</span>
<span class="c1">// der vom Typ passt, oder nach einer implicit-Methode, mit der er in den</span>
<span class="c1">// geforderten Typ konvertieren kann.</span>

<span class="c1">// Hier also: "myImplicitInt", da ein Int gesucht wird</span>

<span class="nf">sendGreetings</span><span class="o">(</span><span class="s">"Jane"</span><span class="o">)</span>  <span class="c1">// =&gt; "Hallo Jane, 100 Segenswünsche für Sie und Ihre Angehörigen!"</span>


<span class="c1">// bzw. "myImplicitFunction"</span>
<span class="c1">// Der String wird erst mit Hilfe der Funktion in Hund konvertiert,</span>
<span class="c1">// dann wird die Methode aufgerufen:</span>

<span class="s">"Retriever"</span><span class="o">.</span><span class="py">sorte</span> <span class="c1">// =&gt; "Golden Retriever"</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 9. Sonstiges</span>
<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// Importe</span>

<span class="k">import</span> <span class="nn">scala.collection.immutable.List</span>


<span class="c1">// Importiere alle Unterpackages</span>

<span class="k">import</span> <span class="nn">scala.collection.immutable._</span>


<span class="c1">// Importiere verschiedene Klassen mit einem Statement</span>

<span class="k">import</span> <span class="nn">scala.collection.immutable.</span><span class="o">{</span><span class="nc">List</span><span class="o">,</span> <span class="nc">Map</span><span class="o">}</span>


<span class="c1">// Einen Import kann man mit '=&gt;' umbenennen</span>

<span class="k">import</span> <span class="nn">scala.collection.immutable.</span><span class="o">{</span><span class="nc">List</span> <span class="k">=&gt;</span> <span class="nc">ImmutableList</span><span class="o">}</span>


<span class="c1">// Importiere alle Klasses, mit Ausnahem von....</span>
<span class="c1">// Hier ohne: Map and Set:</span>

<span class="k">import</span> <span class="nn">scala.collection.immutable.</span><span class="o">{</span><span class="nc">Map</span> <span class="k">=&gt;</span> <span class="k">_</span><span class="o">,</span> <span class="nc">Set</span> <span class="k">=&gt;</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">}</span>

<span class="c1">// Main</span>

<span class="k">object</span> <span class="nc">Application</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="c1">// Zeugs hier rein.</span>
  <span class="o">}</span>
<span class="o">}</span>


<span class="c1">// I/O</span>
<span class="c1">// Eine Datei Zeile für Zeile lesen</span>

<span class="k">import</span> <span class="nn">scala.io.Source</span>
<span class="nf">for</span><span class="o">(</span><span class="n">line</span> <span class="k">&lt;-</span> <span class="nv">Source</span><span class="o">.</span><span class="py">fromFile</span><span class="o">(</span><span class="s">"myfile.txt"</span><span class="o">).</span><span class="py">getLines</span><span class="o">())</span>
  <span class="nf">println</span><span class="o">(</span><span class="n">line</span><span class="o">)</span>


<span class="c1">// Eine Datei schreiben</span>

<span class="k">val</span> <span class="nv">writer</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PrintWriter</span><span class="o">(</span><span class="s">"myfile.txt"</span><span class="o">)</span>
<span class="nv">writer</span><span class="o">.</span><span class="py">write</span><span class="o">(</span><span class="s">"Schreibe Zeile"</span> <span class="o">+</span> <span class="nv">util</span><span class="o">.</span><span class="py">Properties</span><span class="o">.</span><span class="py">lineSeparator</span><span class="o">)</span>
<span class="nv">writer</span><span class="o">.</span><span class="py">write</span><span class="o">(</span><span class="s">"Und noch eine Zeile"</span> <span class="o">+</span> <span class="nv">util</span><span class="o">.</span><span class="py">Properties</span><span class="o">.</span><span class="py">lineSeparator</span><span class="o">)</span>
<span class="nv">writer</span><span class="o">.</span><span class="py">close</span><span class="o">()</span>
</code></pre></div>
<h2>Weiterführende Hinweise</h2>

<h3>DE</h3>

<ul>
<li><a href="https://scalatutorial.wordpress.com">Scala Tutorial</a></li>
<li><a href="http://scalatutorial.de">Scala Tutorial</a></li>
</ul>

<h3>EN</h3>

<ul>
<li><a href="http://horstmann.com/scala/">Scala for the impatient</a></li>
<li><a href="http://twitter.github.io/scala_school/">Twitter Scala school</a></li>
<li><a href="http://docs.scala-lang.org/">The scala documentation</a></li>
<li><a href="http://scalatutorials.com/tour/">Try Scala in your browser</a></li>
<li><a href="http://danielwestheide.com/scala/neophytes.html">Neophytes Guide to Scala</a></li>
<li>Join the <a href="https://groups.google.com/forum/#!forum/scala-user">Scala user group</a></li>
</ul>

    <hr>
    <p>Du hast einen Verbesserungsvorschlag oder einen Fehler gefunden? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Erstelle ein Ticket</a> im offiziellen Github Repo, oder du erstellst einfach gleich einen <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/de-de/scala-de.html.markdown">pull request</a>!
    </p>
    <p class="contributed">
    Originalversion von George Petrov, mit Updates von <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/de-de/scala-de.html.markdown">8 contributor(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://github.com/petrovg">George Petrov</a>,
        <a href="http://dbousamra.github.com">Dominic Bou-Samra</a>,
        <a href="http://geoffliu.me">Geoff Liu</a>,
        <a href="http://reference-error.org">Ha-Duong Nguyen</a>,
        <a href="github.com/denniskeller">Dennis Keller</a>
    </p>

    <p>
      Translated by:
        <a href="https://github.com/coastalchief">Christian Albrecht</a>
        <a href="https://github.com/exic">Jonas Grote</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
