<!DOCTYPE html lang="de-de" xml:lang="de-de" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="de-de">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn swift in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/de-de/swift-de/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fde-de%2Fswift-de%2F&text=Lerne+X+in+Y+Minuten%2C+wobei+X%3Dswift">
        Teile diese Seite mit anderen
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Thema wählen:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">hell</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dunkel</button>
  </div>
  <h1><a href="/">Lerne X in Y Minuten</a></h1>
  <h2>Wobei X=swift</h2>
    <p class="filelink">
    Lade den Code herunter:
    <a href="/docs/files/learnswift-de.swift">learnswift-de.swift</a>
    </p>
  <div id="doc">
    <p>Swift ist eine Programmiersprache von Apple für die Entwicklung von iOS und macOS Applikationen. Swift wurde 2014 zu Apples WWDC Entwicklerkonferenz vorgestellt und wurde mit dem Ziel entwickelt, fehlerträchtigen Code zu vermeiden sowie mit Objective-C zu koexistieren. Es wird mit dem LLVM Compiler gebaut und ist ab Xcode 6+ verfügbar.</p>

<p>Das offizielle <a href="https://itunes.apple.com/us/book/swift-programming-language/id881256329">Swift Programming Language</a> Buch von Apple ist kostenlos via Apple Books verfügbar.</p>

<p>Außerdem hilfreich ist Apples <a href="https://developer.apple.com/library/prerelease/ios/referencelibrary/GettingStarted/RoadMapiOS/index.html">Getting Started Guide</a>, ein guter Einstiegspunkt mit komplettem Swift-Tutorial.</p>
<div class="highlight"><pre class="highlight swift"><code><span class="c1">// importiere ein Modul</span>
<span class="kd">import</span> <span class="kt">UIKit</span>

<span class="c1">//</span>
<span class="c1">// MARK: Grundlagen</span>
<span class="c1">//</span>

<span class="c1">// Xcode unterstützt "Landmarks" um Code zu gliedern, sie werden in der Jump Bar aufgelistet</span>
<span class="c1">// MARK: Abschnitts-Markierung</span>
<span class="c1">// TODO: Zu erledigen</span>
<span class="c1">// FIXME: Zu beheben</span>

<span class="c1">// In Swift 2 wurden println und print zusammengefasst in eine print-Methode. Es wird automatisch ein Zeilenumbruch angehängt.</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">)</span> <span class="c1">// println ist jetzt print</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">,</span> <span class="nv">appendNewLine</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span> <span class="c1">// printen ohne Zeilenumbruch am Ende</span>

<span class="c1">// Variablen (var) können nach der Initialisierung verändert werden </span>
<span class="c1">// Konstanten (let) können nach der Initialisierung NICHT verändert werden </span>

<span class="k">var</span> <span class="nv">myVariable</span> <span class="o">=</span> <span class="mi">42</span>
<span class="k">let</span> <span class="nv">øπΩ</span> <span class="o">=</span> <span class="s">"value"</span> <span class="c1">// Unicode-Variablennamen</span>
<span class="k">let</span> <span class="nv">π</span> <span class="o">=</span> <span class="mf">3.1415926</span>
<span class="k">let</span> <span class="nv">convenience</span> <span class="o">=</span> <span class="s">"keyword"</span> <span class="c1">// Kontext-abhängiger Variablenname</span>
<span class="k">let</span> <span class="nv">weak</span> <span class="o">=</span> <span class="s">"keyword"</span><span class="p">;</span> <span class="k">let</span> <span class="nv">override</span> <span class="o">=</span> <span class="s">"another keyword"</span> <span class="c1">// Instruktionen können durch ein Semikolon aufgeteilt werden</span>
<span class="kd">let</span> <span class="p">`</span><span class="nv">class</span><span class="p">`</span> <span class="o">=</span> <span class="s">"keyword"</span> <span class="c1">// Nutze "Backticks" um Schlüsselwörter als Variablennamen zu verwenden</span>
<span class="k">let</span> <span class="nv">explicitDouble</span><span class="p">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mi">70</span> <span class="c1">// Typ explizit festgelegt</span>
<span class="k">let</span> <span class="nv">intValue</span> <span class="o">=</span> <span class="mo">0007</span> <span class="c1">// 7</span>
<span class="k">let</span> <span class="nv">largeIntValue</span> <span class="o">=</span> <span class="mi">77_000</span> <span class="c1">// 77000</span>
<span class="k">let</span> <span class="nv">label</span> <span class="o">=</span> <span class="s">"some text "</span> <span class="o">+</span> <span class="kt">String</span><span class="p">(</span><span class="n">myVariable</span><span class="p">)</span> <span class="c1">// Casting</span>
<span class="k">let</span> <span class="nv">piText</span> <span class="o">=</span> <span class="s">"Pi = </span><span class="se">\(</span><span class="n">π</span><span class="se">)</span><span class="s">, Pi 2 = </span><span class="se">\(</span><span class="n">π</span> <span class="o">*</span> <span class="mi">2</span><span class="se">)</span><span class="s">"</span> <span class="c1">// String Interpolation</span>

<span class="c1">// Build-spezifische Werte</span>
<span class="c1">// benutzt -D build configuration</span>
<span class="cp">#if false</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"not printed"</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">buildValue</span> <span class="o">=</span> <span class="mi">3</span>
<span class="cp">#else</span>
    <span class="k">let</span> <span class="nv">buildValue</span> <span class="o">=</span> <span class="mi">7</span>
<span class="cp">#endif</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Build value: </span><span class="se">\(</span><span class="n">buildValue</span><span class="se">)</span><span class="s">"</span><span class="p">)</span> <span class="c1">// Build value: 7</span>

<span class="cm">/*
    Optionals ist ein Swift-Feature, welches ermöglicht, dass eine Variable entweder einen (`Some`) oder keinen (`None`) Wert hat

    Da Swift von jeder property einen Wert erwartet, muss sogar nil explizit als Optional festgelegt werden.

    Optional&lt;T&gt; ist ein Enum.
*/</span>
<span class="k">var</span> <span class="nv">someOptionalString</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span> <span class="o">=</span> <span class="s">"optional"</span> <span class="c1">// Kann nil sein</span>
<span class="c1">// Genau wie oben, aber ? ist ein postfix operator (Syntax Candy)</span>
<span class="k">var</span> <span class="nv">someOptionalString2</span><span class="p">:</span> <span class="kt">Optional</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="s">"optional"</span>

<span class="k">if</span> <span class="n">someOptionalString</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="c1">// Ich bin nicht nil</span>
    <span class="k">if</span> <span class="n">someOptionalString</span><span class="o">!.</span><span class="nf">hasPrefix</span><span class="p">(</span><span class="s">"opt"</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"has the prefix"</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="nv">empty</span> <span class="o">=</span> <span class="n">someOptionalString</span><span class="p">?</span><span class="o">.</span><span class="n">isEmpty</span>
<span class="p">}</span>
<span class="n">someOptionalString</span> <span class="o">=</span> <span class="kc">nil</span>

<span class="c1">// Implizit entpackter Optionalwert</span>
<span class="k">var</span> <span class="nv">unwrappedString</span><span class="p">:</span> <span class="kt">String</span><span class="o">!</span> <span class="o">=</span> <span class="s">"Value is expected."</span>
<span class="c1">// Genau wie oben, aber ! ist ein postfix operator (noch mehr Syntax Candy)</span>
<span class="k">var</span> <span class="nv">unwrappedString2</span><span class="p">:</span> <span class="kt">ImplicitlyUnwrappedOptional</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="s">"Value is expected."</span>

<span class="k">if</span> <span class="k">let</span> <span class="nv">someOptionalStringConstant</span> <span class="o">=</span> <span class="n">someOptionalString</span> <span class="p">{</span>
    <span class="c1">// hat einen (`Some`) Wert, nicht nil</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">someOptionalStringConstant</span><span class="o">.</span><span class="nf">hasPrefix</span><span class="p">(</span><span class="s">"ok"</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// hat keinen "ok"-Prefix</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Swift unterstützt das festlegen von Werten eines beliebigen Typens</span>
<span class="c1">// AnyObject == id</span>
<span class="c1">// Im Gegensatz zum Objective-C `id`, funktioniert AnyObject mit jeglichen Werten (Class, Int, struct, etc)</span>
<span class="k">var</span> <span class="nv">anyObjectVar</span><span class="p">:</span> <span class="kt">AnyObject</span> <span class="o">=</span> <span class="mi">7</span>
<span class="n">anyObjectVar</span> <span class="o">=</span> <span class="s">"Changed value to a string, not good practice, but possible."</span>

<span class="cm">/*
    Ein Kommentar

    /*
        Verschachtelte Kommentare sind ebenfalls unterstützt
    */
*/</span>

<span class="c1">//</span>
<span class="c1">// MARK: Collections</span>
<span class="c1">//</span>

<span class="cm">/*
    Array und Dictionary-Typen sind structs. 
    Deswegen implizieren `let` und `var` bei der Initialisierung auch ob sie änderbar (var) oder unveränderlich (let) sind.
*/</span>

<span class="c1">// Array</span>
<span class="k">var</span> <span class="nv">shoppingList</span> <span class="o">=</span> <span class="p">[</span><span class="s">"catfish"</span><span class="p">,</span> <span class="s">"water"</span><span class="p">,</span> <span class="s">"lemons"</span><span class="p">]</span>
<span class="n">shoppingList</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">"bottle of water"</span>
<span class="k">let</span> <span class="nv">emptyArray</span> <span class="o">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">]()</span> <span class="c1">// let == unveränderlich</span>
<span class="k">let</span> <span class="nv">emptyArray2</span> <span class="o">=</span> <span class="kt">Array</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span><span class="p">()</span> <span class="c1">// genau wie oben</span>
<span class="k">var</span> <span class="nv">emptyMutableArray</span> <span class="o">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">]()</span> <span class="c1">// var == änderbar</span>


<span class="c1">// Dictionary</span>
<span class="k">var</span> <span class="nv">occupations</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">"Malcolm"</span><span class="p">:</span> <span class="s">"Captain"</span><span class="p">,</span>
    <span class="s">"kaylee"</span><span class="p">:</span> <span class="s">"Mechanic"</span>
<span class="p">]</span>
<span class="n">occupations</span><span class="p">[</span><span class="s">"Jayne"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Public Relations"</span>
<span class="k">let</span> <span class="nv">emptyDictionary</span> <span class="o">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">Float</span><span class="p">]()</span> <span class="c1">// let == unveränderlich</span>
<span class="k">let</span> <span class="nv">emptyDictionary2</span> <span class="o">=</span> <span class="kt">Dictionary</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Float</span><span class="o">&gt;</span><span class="p">()</span> <span class="c1">// genau wie oben</span>
<span class="k">var</span> <span class="nv">emptyMutableDictionary</span> <span class="o">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">Float</span><span class="p">]()</span> <span class="c1">// var == änderbar</span>


<span class="c1">//</span>
<span class="c1">// MARK: Kontrollstruktur</span>
<span class="c1">//</span>

<span class="c1">// for-Schleife (array)</span>
<span class="k">let</span> <span class="nv">myArray</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="k">for</span> <span class="n">value</span> <span class="k">in</span> <span class="n">myArray</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"One!"</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Not one!"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// for-Schleife mit Indizes (array)</span>
<span class="k">for</span> <span class="n">index</span> <span class="k">in</span> <span class="n">myArray</span><span class="o">.</span><span class="n">indices</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Value with index </span><span class="se">\(</span><span class="n">index</span><span class="se">)</span><span class="s"> is </span><span class="se">\(</span><span class="n">myArray</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// for-Schleife (dictionary)</span>
<span class="k">var</span> <span class="nv">dict</span> <span class="o">=</span> <span class="p">[</span><span class="s">"one"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">"two"</span><span class="p">:</span> <span class="mi">2</span><span class="p">]</span>
<span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">in</span> <span class="n">dict</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">key</span><span class="se">)</span><span class="s">: </span><span class="se">\(</span><span class="n">value</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// for-Schleife (range)</span>
<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="o">-</span><span class="mi">1</span><span class="o">...</span><span class="n">shoppingList</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">shoppingList</span><span class="p">[</span><span class="mi">1</span><span class="o">...</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s">"steak"</span><span class="p">,</span> <span class="s">"peacons"</span><span class="p">]</span>
<span class="c1">// ..&lt; schließt letzte Nummer aus</span>

<span class="c1">// while-Schleife</span>
<span class="k">var</span> <span class="nv">i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">*=</span> <span class="mi">2</span>
<span class="p">}</span>

<span class="c1">// do-while-Schleife</span>
<span class="k">do</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"hello"</span><span class="p">)</span>
<span class="p">}</span> <span class="k">while</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">2</span>

<span class="c1">// Switch</span>
<span class="c1">// Sehr mächtig, wie `if` statement mit Syntax Candy</span>
<span class="c1">// Unterstützt Strings, Objekt-Instanzen und primitive Typen (Int, Double, etc)</span>
<span class="k">let</span> <span class="nv">vegetable</span> <span class="o">=</span> <span class="s">"red pepper"</span>
<span class="k">switch</span> <span class="n">vegetable</span> <span class="p">{</span>
<span class="k">case</span> <span class="s">"celery"</span><span class="p">:</span>
    <span class="k">let</span> <span class="nv">vegetableComment</span> <span class="o">=</span> <span class="s">"Add some raisins and make ants on a log."</span>
<span class="k">case</span> <span class="s">"cucumber"</span><span class="p">,</span> <span class="s">"watercress"</span><span class="p">:</span>
    <span class="k">let</span> <span class="nv">vegetableComment</span> <span class="o">=</span> <span class="s">"That would make a good tea sandwich."</span>
<span class="k">case</span> <span class="k">let</span> <span class="nv">localScopeValue</span> <span class="k">where</span> <span class="n">localScopeValue</span><span class="o">.</span><span class="nf">hasSuffix</span><span class="p">(</span><span class="s">"pepper"</span><span class="p">):</span>
    <span class="k">let</span> <span class="nv">vegetableComment</span> <span class="o">=</span> <span class="s">"Is it a spicy </span><span class="se">\(</span><span class="n">localScopeValue</span><span class="se">)</span><span class="s">?"</span>
<span class="k">default</span><span class="p">:</span> <span class="c1">// notwendig (um alle möglichen Eingaben zu verarbeiten)</span>
    <span class="k">let</span> <span class="nv">vegetableComment</span> <span class="o">=</span> <span class="s">"Everything tastes good in soup."</span>
<span class="p">}</span>


<span class="c1">//</span>
<span class="c1">// MARK: Funktionen</span>
<span class="c1">//</span>

<span class="c1">// Funktionen sind ein sogenannter "first-class" Typ, was bedeutet, dass sie</span>
<span class="c1">// in Funktionen geschachtelt werden und "herumgereicht" werden können</span>

<span class="c1">// Funktion mit Swift header Dokumentation</span>

<span class="cm">/**
    Eine Grüß-Funktion

    - Ein Aufzählungspunkt
    - Ein weiterer Aufzählungspunkt in der Dokumentation

    :param: name Ein Name
    :param: day Ein Tag
    :returns: Ein String, der Name und Tag beinhält.
*/</span>
<span class="kd">func</span> <span class="nf">greet</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="nv">day</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">"Hello </span><span class="se">\(</span><span class="n">name</span><span class="se">)</span><span class="s">, today is </span><span class="se">\(</span><span class="n">day</span><span class="se">)</span><span class="s">."</span>
<span class="p">}</span>
<span class="nf">greet</span><span class="p">(</span><span class="s">"Bob"</span><span class="p">,</span> <span class="s">"Tuesday"</span><span class="p">)</span>

<span class="c1">// Ähnlich wie oben, bloß anderes Funktions-Parameter-Verhalten</span>
<span class="kd">func</span> <span class="nf">greet2</span><span class="p">(</span><span class="nv">#requiredName</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">externalParamName</span> <span class="nv">localParamName</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">"Hello </span><span class="se">\(</span><span class="n">requiredName</span><span class="se">)</span><span class="s">, the day is </span><span class="se">\(</span><span class="n">localParamName</span><span class="se">)</span><span class="s">"</span>
<span class="p">}</span>
<span class="nf">greet2</span><span class="p">(</span><span class="nv">requiredName</span><span class="p">:</span><span class="s">"John"</span><span class="p">,</span> <span class="nv">externalParamName</span><span class="p">:</span> <span class="s">"Sunday"</span><span class="p">)</span>


<span class="c1">// Funktion, welche mehrere Werte in einem Tupel zurückgibt</span>
<span class="kd">func</span> <span class="nf">getGasPrices</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Double</span><span class="p">,</span> <span class="kt">Double</span><span class="p">,</span> <span class="kt">Double</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">return</span> <span class="p">(</span><span class="mf">3.59</span><span class="p">,</span> <span class="mf">3.69</span><span class="p">,</span> <span class="mf">3.79</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">pricesTuple</span> <span class="o">=</span> <span class="nf">getGasPrices</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">price</span> <span class="o">=</span> <span class="n">pricesTuple</span><span class="o">.</span><span class="mi">2</span> <span class="c1">// 3.79</span>
<span class="c1">// Ignoriere Tupel-(oder andere)Werte mit _ (Unterstrich)</span>
<span class="k">let</span> <span class="p">(</span><span class="nv">_</span><span class="p">,</span> <span class="nv">price1</span><span class="p">,</span> <span class="nv">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">pricesTuple</span> <span class="c1">// price1 == 3.69</span>
<span class="nf">print</span><span class="p">(</span><span class="n">price1</span> <span class="o">==</span> <span class="n">pricesTuple</span><span class="o">.</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Gas price: </span><span class="se">\(</span><span class="n">price</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>

<span class="c1">// Variierende Argumente..</span>
<span class="kd">func</span> <span class="nf">setup</span><span class="p">(</span><span class="nv">numbers</span><span class="p">:</span> <span class="kt">Int</span><span class="o">...</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// .. liegen als Array vor</span>
    <span class="k">let</span> <span class="nv">number</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">let</span> <span class="nv">argCount</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="n">count</span>
<span class="p">}</span>

<span class="c1">// Funktionen übergeben und zurückgeben</span>
<span class="kd">func</span> <span class="nf">makeIncrementer</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">addOne</span><span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">number</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">addOne</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">increment</span> <span class="o">=</span> <span class="nf">makeIncrementer</span><span class="p">()</span>
<span class="nf">increment</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>

<span class="c1">// Übergabe via Referenz ("Pass by reference")</span>
<span class="kd">func</span> <span class="nf">swapTwoInts</span><span class="p">(</span><span class="k">inout</span> <span class="nv">a</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="k">inout</span> <span class="nv">b</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">tempA</span> <span class="o">=</span> <span class="n">a</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">tempA</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">someIntA</span> <span class="o">=</span> <span class="mi">7</span>
<span class="k">var</span> <span class="nv">someIntB</span> <span class="o">=</span> <span class="mi">3</span>
<span class="nf">swapTwoInts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">someIntA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">someIntB</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">someIntB</span><span class="p">)</span> <span class="c1">// 7</span>


<span class="c1">//</span>
<span class="c1">// MARK: Closures</span>
<span class="c1">//</span>
<span class="k">var</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>

<span class="c1">// Funktionen sind besondere Closures ({})</span>

<span class="c1">// Closure Beispiel</span>
<span class="c1">// `-&gt;` teilt Parameter und Rückgabe-Typ</span>
<span class="c1">// `in` teilt den Closure Header vom Body</span>
<span class="n">numbers</span><span class="o">.</span><span class="nf">map</span><span class="p">({</span>
    <span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="k">in</span>
    <span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">number</span>
    <span class="k">return</span> <span class="n">result</span>
<span class="p">})</span>


<span class="c1">// Wenn der Typ bekannt ist, wie oben, kann folgendes getan werden</span>
<span class="n">numbers</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="nf">map</span><span class="p">({</span> <span class="n">number</span> <span class="k">in</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">number</span> <span class="p">})</span>
<span class="c1">// oder sogar dies</span>
<span class="c1">//numbers = numbers.map({ $0 * 3 })</span>

<span class="nf">print</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="c1">// [3, 6, 18]</span>

<span class="c1">// "Schleppende Closure" (Trailing Closure)</span>
<span class="n">numbers</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&gt;</span> <span class="nv">$1</span> <span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="c1">// [18, 6, 3]</span>

<span class="c1">// Sehr verkürzt, da sich der Typ durch den &lt; Operator ableiten lässt</span>

<span class="n">numbers</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="o">&lt;</span> <span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="c1">// [3, 6, 18]</span>

<span class="c1">//</span>
<span class="c1">// MARK: Strukturen</span>
<span class="c1">// (häufig einfach structs)</span>
<span class="c1">//</span>

<span class="c1">// Structures und Klassen haben sehr ähnliche Fähigkeiten</span>
<span class="kd">struct</span> <span class="kt">NamesTable</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">names</span> <span class="o">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">]()</span>

    <span class="c1">// Eigendefiniertes subscript</span>
    <span class="nf">subscript</span><span class="p">(</span><span class="nv">index</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">names</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c1">// Strukturen haben eine automatisch generierte, designierte Initialisierungsfunktion</span>
<span class="k">let</span> <span class="nv">namesTable</span> <span class="o">=</span> <span class="kt">NamesTable</span><span class="p">(</span><span class="nv">names</span><span class="p">:</span> <span class="p">[</span><span class="s">"Me"</span><span class="p">,</span> <span class="s">"Them"</span><span class="p">])</span>
<span class="k">let</span> <span class="nv">name</span> <span class="o">=</span> <span class="n">namesTable</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Name is </span><span class="se">\(</span><span class="n">name</span><span class="se">)</span><span class="s">"</span><span class="p">)</span> <span class="c1">// Name is Them</span>

<span class="c1">//</span>
<span class="c1">// MARK: Klassen</span>
<span class="c1">//</span>

<span class="c1">// Klassen, Strukturen und deren Member haben drei Ebenen der Zugriffskontrolle</span>
<span class="c1">// Es gibt: internal (default), public, private</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="kt">Shape</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">getArea</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Alle Methoden und Properties einer Klasse sind public</span>
<span class="c1">// Wenn das einfache Ziel ist, Daten in einem strukturierten Objekt zu halten,</span>
<span class="c1">// sollte ein `struct` verwendet werden</span>

<span class="kd">internal</span> <span class="kd">class</span> <span class="kt">Rect</span><span class="p">:</span> <span class="kt">Shape</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">sideLength</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1">// Eigendefinierte Getter und Setter für die Property</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">perimeter</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">sideLength</span>
        <span class="p">}</span>
        <span class="k">set</span> <span class="p">{</span>
            <span class="c1">// `newValue` ist eine implizite Variable, welche in Settern verfügbar ist</span>
            <span class="n">sideLength</span> <span class="o">=</span> <span class="n">newValue</span> <span class="o">/</span> <span class="mi">4</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// "Lazy" (faules) Laden einer Property, sie bleibt uninitialisiert (nil),</span>
    <span class="c1">// bis sie aufgerufen wird</span>
    <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">subShape</span> <span class="o">=</span> <span class="kt">Rect</span><span class="p">(</span><span class="nv">sideLength</span><span class="p">:</span> <span class="mi">4</span><span class="p">)</span>

    <span class="c1">// Wenn kein eigendefinierter Getter/Setter notwendig ist,</span>
    <span class="c1">// aber trotzdem Code vor und nach dem Setzen eines Variablenwertes laufen soll,</span>
    <span class="c1">// kann "willSet" und "didSet" benutzt werden</span>
    <span class="k">var</span> <span class="nv">identifier</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"defaultID"</span> <span class="p">{</span>
        <span class="c1">// der `willSet` Parameter wird der Variablenname für den neuen Wert sein </span>
        <span class="nf">willSet</span><span class="p">(</span><span class="n">someIdentifier</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="n">someIdentifier</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">sideLength</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">sideLength</span> <span class="o">=</span> <span class="n">sideLength</span>
        <span class="c1">// super.init muss immer aufgerufen werden, wenn eigene Properties initialisiert werden</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">shrink</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">sideLength</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">sideLength</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">override</span> <span class="kd">func</span> <span class="nf">getArea</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">sideLength</span> <span class="o">*</span> <span class="n">sideLength</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Eine simple `Square`-Klasse erbt von/erweitert `Rect`</span>
<span class="kd">class</span> <span class="kt">Square</span><span class="p">:</span> <span class="kt">Rect</span> <span class="p">{</span>
    <span class="kd">convenience</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">sideLength</span><span class="p">:</span> <span class="mi">5</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">mySquare</span> <span class="o">=</span> <span class="kt">Square</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="n">mySquare</span><span class="o">.</span><span class="nf">getArea</span><span class="p">())</span> <span class="c1">// 25</span>
<span class="n">mySquare</span><span class="o">.</span><span class="nf">shrink</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="n">mySquare</span><span class="o">.</span><span class="n">sideLength</span><span class="p">)</span> <span class="c1">// 4</span>

<span class="c1">// Casten der Instanz</span>
<span class="k">let</span> <span class="nv">aShape</span> <span class="o">=</span> <span class="n">mySquare</span> <span class="k">as</span> <span class="kt">Shape</span>

<span class="c1">// Vergleiche Instanzen, nicht äquivalent zum == , welches Objekte vergleicht ("equal to") </span>
<span class="k">if</span> <span class="n">mySquare</span> <span class="o">===</span> <span class="n">mySquare</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Yep, it's mySquare"</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Optionale Initialisierung</span>
<span class="kd">class</span> <span class="kt">Circle</span><span class="p">:</span> <span class="kt">Shape</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">radius</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">getArea</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">radius</span>
    <span class="p">}</span>

    <span class="c1">// Ein Fragezeichen nach `init` ist eine optionale Initialisierung,</span>
    <span class="c1">// welche nil zurückgeben kann</span>
    <span class="nf">init</span><span class="p">?(</span><span class="nv">radius</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">radius</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">myCircle</span> <span class="o">=</span> <span class="kt">Circle</span><span class="p">(</span><span class="nv">radius</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">myCircle</span><span class="p">?</span><span class="o">.</span><span class="nf">getArea</span><span class="p">())</span>    <span class="c1">// Optional(3)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">myCircle</span><span class="o">!.</span><span class="nf">getArea</span><span class="p">())</span>    <span class="c1">// 3</span>
<span class="k">var</span> <span class="nv">myEmptyCircle</span> <span class="o">=</span> <span class="kt">Circle</span><span class="p">(</span><span class="nv">radius</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">myEmptyCircle</span><span class="p">?</span><span class="o">.</span><span class="nf">getArea</span><span class="p">())</span>    <span class="c1">// "nil"</span>
<span class="k">if</span> <span class="k">let</span> <span class="nv">circle</span> <span class="o">=</span> <span class="n">myEmptyCircle</span> <span class="p">{</span>
    <span class="c1">// wird nicht ausgeführt, da myEmptyCircle nil ist</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"circle is not nil"</span><span class="p">)</span>
<span class="p">}</span>


<span class="c1">//</span>
<span class="c1">// MARK: Enums</span>
<span class="c1">//</span>

<span class="c1">// Enums können optional einen eigenen Typen haben</span>
<span class="c1">// Wie Klassen auch können sie Methoden haben</span>

<span class="kd">enum</span> <span class="kt">Suit</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">spades</span><span class="p">,</span> <span class="n">hearts</span><span class="p">,</span> <span class="n">diamonds</span><span class="p">,</span> <span class="n">clubs</span>
    <span class="kd">func</span> <span class="nf">getIcon</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="k">self</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">spades</span><span class="p">:</span> <span class="k">return</span> <span class="s">"♤"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">hearts</span><span class="p">:</span> <span class="k">return</span> <span class="s">"♡"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">diamonds</span><span class="p">:</span> <span class="k">return</span> <span class="s">"♢"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">clubs</span><span class="p">:</span> <span class="k">return</span> <span class="s">"♧"</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c1">// Enum-Werte können vereinfacht geschrieben werden, es muss nicht der Enum-Typ</span>
<span class="c1">// genannt werden, wenn die Variable explizit deklariert wurde</span>

<span class="k">var</span> <span class="nv">suitValue</span><span class="p">:</span> <span class="kt">Suit</span> <span class="o">=</span> <span class="o">.</span><span class="n">hearts</span>

<span class="c1">// Nicht-Integer-Enums brauchen direkt zugewiesene "Rohwerte"</span>
<span class="kd">enum</span> <span class="kt">BookName</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">john</span> <span class="o">=</span> <span class="s">"John"</span>
    <span class="k">case</span> <span class="n">luke</span> <span class="o">=</span> <span class="s">"Luke"</span>
<span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Name: </span><span class="se">\(</span><span class="kt">BookName</span><span class="o">.</span><span class="n">john</span><span class="o">.</span><span class="n">rawValue</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>

<span class="c1">// Enum mit assoziierten Werten</span>
<span class="kd">enum</span> <span class="kt">Furniture</span> <span class="p">{</span>
    <span class="c1">// mit Int assoziiert</span>
    <span class="k">case</span> <span class="nf">desk</span><span class="p">(</span><span class="nv">height</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>
    <span class="c1">// mit String und Int assoziiert</span>
    <span class="k">case</span> <span class="nf">chair</span><span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span>

    <span class="kd">func</span> <span class="nf">description</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="k">self</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nf">desk</span><span class="p">(</span><span class="k">let</span> <span class="nv">height</span><span class="p">):</span>
            <span class="k">return</span> <span class="s">"Desk with </span><span class="se">\(</span><span class="n">height</span><span class="se">)</span><span class="s"> cm"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nf">chair</span><span class="p">(</span><span class="k">let</span> <span class="nv">brand</span><span class="p">,</span> <span class="k">let</span> <span class="nv">height</span><span class="p">):</span>
            <span class="k">return</span> <span class="s">"Chair of </span><span class="se">\(</span><span class="n">brand</span><span class="se">)</span><span class="s"> with </span><span class="se">\(</span><span class="n">height</span><span class="se">)</span><span class="s"> cm"</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">desk</span><span class="p">:</span> <span class="kt">Furniture</span> <span class="o">=</span> <span class="o">.</span><span class="nf">desk</span><span class="p">(</span><span class="nv">height</span><span class="p">:</span> <span class="mi">80</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">desk</span><span class="o">.</span><span class="nf">description</span><span class="p">())</span>     <span class="c1">// "Desk with 80 cm"</span>
<span class="k">var</span> <span class="nv">chair</span> <span class="o">=</span> <span class="kt">Furniture</span><span class="o">.</span><span class="nf">chair</span><span class="p">(</span><span class="s">"Foo"</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">chair</span><span class="o">.</span><span class="nf">description</span><span class="p">())</span>    <span class="c1">// "Chair of Foo with 40 cm"</span>


<span class="c1">//</span>
<span class="c1">// MARK: Protokolle</span>
<span class="c1">//</span>

<span class="c1">// Protokolle (`protocol`s) können verlangen, dass entsprechende</span>
<span class="c1">// Typen spezifische Instanz-Properties, Instanz/Klassen-Methoden,</span>
<span class="c1">// Operatoren oder Subscripts implementieren/haben</span>

<span class="kd">protocol</span> <span class="kt">ShapeGenerator</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">enabled</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span> <span class="k">get</span> <span class="k">set</span> <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">buildShape</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Shape</span>
<span class="p">}</span>

<span class="c1">// Protocols mit @objc deklariert ermöglichen optionale Funktionen,</span>
<span class="c1">// welche es ermöglichen, abzufragen ob ein Typ einem Protokoll entspricht</span>
<span class="kd">@objc</span> <span class="kd">protocol</span> <span class="kt">TransformShape</span> <span class="p">{</span>
    <span class="kd">optional</span> <span class="kd">func</span> <span class="nf">reshaped</span><span class="p">()</span>
    <span class="kd">optional</span> <span class="kd">func</span> <span class="nf">canReshape</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">MyShape</span><span class="p">:</span> <span class="kt">Rect</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">delegate</span><span class="p">:</span> <span class="kt">TransformShape</span><span class="p">?</span>

    <span class="kd">func</span> <span class="nf">grow</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">sideLength</span> <span class="o">+=</span> <span class="mi">2</span>

        <span class="c1">// Ein Fragezeichen nach einer optionalen Property, Methode oder Subscript</span>
        <span class="c1">// ignoriert elegant Nil-Werte und geben nil zurück, anstatt einen Laufzeitfehler zu werfen</span>
        <span class="c1">// Dies wird "optional Chaining" (optionale Verkettung) genannt</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nv">allow</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">delegate</span><span class="p">?</span><span class="o">.</span><span class="nf">canReshape</span><span class="p">?()</span> <span class="p">{</span>
            <span class="c1">// frage erst nach delegate, dann nach Methode</span>
            <span class="k">self</span><span class="o">.</span><span class="n">delegate</span><span class="p">?</span><span class="o">.</span><span class="nf">reshaped</span><span class="p">?()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c1">//</span>
<span class="c1">// MARK: Sonstiges</span>
<span class="c1">//</span>

<span class="c1">// `extension`s: (Erweiterungen), erweitere Typen um zusätzliche Funktionalität</span>

<span class="c1">// Square entspricht jetzt dem `Printable` Protokoll</span>
<span class="kd">extension</span> <span class="kt">Square</span><span class="p">:</span> <span class="kt">Printable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">description</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">"Area: </span><span class="se">\(</span><span class="k">self</span><span class="o">.</span><span class="nf">getArea</span><span class="p">()</span><span class="se">)</span><span class="s"> - ID: </span><span class="se">\(</span><span class="k">self</span><span class="o">.</span><span class="n">identifier</span><span class="se">)</span><span class="s">"</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Square: </span><span class="se">\(</span><span class="n">mySquare</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>

<span class="c1">// Standardtypen können ebenfalls erweitert werden</span>
<span class="kd">extension</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">customProperty</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">"This is </span><span class="se">\(</span><span class="k">self</span><span class="se">)</span><span class="s">"</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">multiplyBy</span><span class="p">(</span><span class="nv">num</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">num</span> <span class="o">*</span> <span class="k">self</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="mi">7</span><span class="o">.</span><span class="n">customProperty</span><span class="p">)</span> <span class="c1">// "This is 7"</span>
<span class="nf">print</span><span class="p">(</span><span class="mi">14</span><span class="o">.</span><span class="nf">multiplyBy</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="c1">// 42</span>


<span class="c1">//Generics: Ähnlich zu Java und C#. Nutze das `where` keyword um die Bedingung</span>
<span class="c1">// des Generics festzulegen</span>

<span class="kd">func</span> <span class="n">findIndex</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">Equatable</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">array</span><span class="p">:</span> <span class="p">[</span><span class="kt">T</span><span class="p">],</span> <span class="nv">valueToFind</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="n">valueToFind</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">index</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">foundAtIndex</span> <span class="o">=</span> <span class="nf">findIndex</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">foundAtIndex</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// true</span>

<span class="c1">// Operatoren:</span>
<span class="c1">// Eigendefinierte Operatoren können mit diesen Zeichen beginnen:</span>
<span class="c1">//      / = - + * % &lt; &gt; ! &amp; | ^ . ~</span>
<span class="c1">// oder</span>
<span class="c1">// Unicode Mathematik, Symbole, Pfeile, Dingbat, und Linien/Box - Zeichen</span>
<span class="k">prefix</span> <span class="k">operator</span> <span class="o">!!!</span> <span class="p">{}</span>


<span class="c1">// Ein Prefix-Operator, welcher die Seitenlänge verdreifacht</span>
<span class="k">prefix</span> <span class="kd">func</span> <span class="o">!!!</span> <span class="p">(</span><span class="k">inout</span> <span class="nv">shape</span><span class="p">:</span> <span class="kt">Square</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Square</span> <span class="p">{</span>
    <span class="n">shape</span><span class="o">.</span><span class="n">sideLength</span> <span class="o">*=</span> <span class="mi">3</span>
    <span class="k">return</span> <span class="n">shape</span>
<span class="p">}</span>

<span class="c1">// Aktueller Wert</span>
<span class="nf">print</span><span class="p">(</span><span class="n">mySquare</span><span class="o">.</span><span class="n">sideLength</span><span class="p">)</span> <span class="c1">// 4</span>

<span class="c1">// Wert nach verwendung des eigenen Operators</span>
<span class="o">!!!</span><span class="n">mySquare</span>
<span class="nf">print</span><span class="p">(</span><span class="n">mySquare</span><span class="o">.</span><span class="n">sideLength</span><span class="p">)</span> <span class="c1">// 12</span>
</code></pre></div>
    <hr>
    <p>Du hast einen Verbesserungsvorschlag oder einen Fehler gefunden? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Erstelle ein Ticket</a> im offiziellen Github Repo, oder du erstellst einfach gleich einen <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/de-de/swift-de.html.markdown">pull request</a>!
    </p>
    <p class="contributed">
    Originalversion von Grant Timmerman, mit Updates von <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/de-de/swift-de.html.markdown">8 contributor(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://github.com/grant">Grant Timmerman</a>,
        <a href="http://github.com/cbess">Christopher Bess</a>,
        <a href="http://github.com/kamidox">Joey Huang</a>,
        <a href="http://github.com/anthonyn60">Anthony Nguyen</a>
    </p>

    <p>
      Translated by:
        <a href="http://vfuc.co">Jonas Wippermann</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
