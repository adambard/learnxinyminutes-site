<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="de-de" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="de-de" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="de-de" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="de-de" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="de-de">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Tcl in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/de-de/tcl-de/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fde-de%2Ftcl-de%2F&text=Lerne+X+in+Y+Minuten%2C+wobei+X%3DTcl">
        Teile diese Seite mit anderen
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Thema wählen:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">hell</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dunkel</button>
  </div>
  <h1><a href="/">Lerne X in Y Minuten</a></h1>
  <h2>Wobei X=Tcl</h2>
    <p class="filelink">
    Lade den Code herunter:
    <a href="/docs/files/learntcl-de.tcl">learntcl-de.tcl</a>
    </p>
  <div id="doc">
    <p>Tcl wurde kreiert von <a href="http://wiki.tcl.tk/John%20Ousterout">John Ousterhout</a> als
eine wiederverwendbare Script-Sprache für Chip-Design Werkzeuge die er kreiert
hat. Im Jahre 1997 wurde er mit dem <a href="http://en.wikipedia.org/wiki/ACM_Software_System_Award">ACM Software System
Award</a> für Tcl
ausgezeichnet. Tcl kann sowohl als eingebettete Scipt-Sprache als auch als
allgemeine Programmier-Sprache verwendet werden. Tcl kann auch als portable
C-Bibliothek verwendet werden. Sogar in Fällen in denen die Script-Fähigkeiten
nicht nötig sind. Denn Tcl stellt Daten-Strukturen wie dynamische Zeichenketten,
Listen und Hash-Tabellen bereit. Die C-Bilbiothek stellt auch portable
Funktionen zur Verfügung: Laden von dynamischen Bibliotheken, Zeichenketten
formatierung und Code Konversion, Dateisystem Operationen, Netzwerk Operationen
und mehr.</p>

<p>Verschiedenste herausragende Fähigkeiten von Tcl:</p>

<ul>
<li><p>Praktische Cross-Platform Netzwerk-API</p></li>
<li><p>Vollständig virtualisiertes Dateisystem</p></li>
<li><p>Stapelbare I/O Kanäle</p></li>
<li><p>Asynchron bis zum Kern</p></li>
<li><p>Vollständige Ko-Routinen</p></li>
<li><p>Robustes und einfach zu verwendendes Thread-Modell</p></li>
</ul>

<p>Wenn Lisp ein Listen-Prozessor ist, dann ist TCl ein Zeichenketten-Prozessor.
Alle Werte sind Zeichenketten. Eine Liste ist ein Zeichenketten-Format. Eine
Prozedur-Definition ist ein Zeichenketten-Format. Um leistungsfähig zu sein,
werden Tcl-intern diese Zeichenketten in Strukutierter-Form gepuffert. Ein
Beispiel: Der &ldquo;list&rdquo; Befehl arbeitet mit diesen internen gepufferten 
Repräsentationen. Tcl kümmert sich selbständig darum die String-Repräsentationen
zu aktualisieren, falls dies im Skript benötigt werden sollten. Das Kopieren-
beim-Schreiben-Design von Tcl erlaubt es Skript-Authoren mit großen Daten-
Strukturen zu arbeiten ohne zuätzlichen Speicher-Overhead. Prozeduren werden
automatisch byte-kompiliert außer sie verwenden dynamsiche Befehle wie zum
Beispiel &ldquo;uplevel&rdquo;, &ldquo;upvar und &quot;trace&rdquo;.</p>

<p>Es ist eine freude in Tcl zu programmieren. Hacker-Typen werden gefallen daran
finden, wenn sie Lisp, Forth oder Smalltalk interessant finden. Tcl wird auch
Ingenieuren und Wissenshaftlern gefallen die nur den Job erledigen wollen,
und zwar mit Werkzeugen die sich ihrem Willen anpassen. Bei Tcl ist jegliche
funktionalität in Befehlen ausgeführt, selbst Dinge wie Schleifen und
Mathematische-Funktionen die bei anderen Sprachen normalerweise Teil der Syntax
sind. Das erlaubt Tcl in den Hintergrund von Domänen spezischen Sprachen zu
treten die das jeweilige Projekt gerade benötigt. Die Tcl-Syntax ist sehr
leichtgewichtig. Sie ist selbst leichtgewichtiger als die Syntax von Lisp.
Tcl steht dir einfach nicht im Weg.</p>
<div class="highlight"><pre><span></span><span class="c">#! /bin/env tclsh</span>

<span class="c">################################################################################</span>
<span class="c">## 1. Richtlinien </span>
<span class="c">################################################################################</span>

<span class="c"># Tcl ist nicht Bash oder C! Das muss gesagt werden, denn standard Shell-Quoting</span>
<span class="c"># funktioniert fast mit Tcl. Daher glauben viele sie können diese Syntax für</span>
<span class="c"># Tcl übernehmen. Am Beginn funktioniert das meist, führt aber schnell zu </span>
<span class="c"># Frustrationen wenn die Skripte komplexer werden.</span>

<span class="c"># Eckige-Klammern sind nur Quoting-Mechanismen, keine Code-Block-Konstruktoren</span>
<span class="c"># und auch keine Listen-Konstruktoren. In Tcl gibt es diese beiden Dinge nicht.</span>
<span class="c"># Eckige-Klammern werden verwendet um Spezial-Zeichen in Prozeduren zu escapen</span>
<span class="c"># und in Zeichenketten die als Listen formattiert sind.</span>

<span class="c">################################################################################</span>
<span class="c">## 2. Syntax </span>
<span class="c">################################################################################</span>

<span class="c"># Jede Zeile ist ein Befehl. Das erste Wort ist der Name des Befehls, jedes</span>
<span class="c"># weitere Wort ist ein Argument des Befehls. Wörter sind begrenzt durch</span>
<span class="c"># Leerzeichen. Da jedes Wort auch ein String ist, sind keine speziellen</span>
<span class="c"># auszeichnungen wie Anführungs-Zeichen, Klammern oder Backslashes nötig.</span>
<span class="c"># Selbst wenn Anführungs-Zeichen verwendet werden, denn sie sind ja keine</span>
<span class="c"># String-Konstruktoren, sondern nur Escape-Zeichen.</span>

<span class="k">set</span><span class="w"> </span>greeting1<span class="w"> </span>Sal<span class="w"> </span>
set<span class="w"> </span>greeting2<span class="w"> </span>ut
<span class="k">set</span><span class="w"> </span>greeting3<span class="w"> </span>ations


<span class="c"># Strichpunkte begrenzen auch Befehle</span>
<span class="k">set</span><span class="w"> </span>greeting1<span class="w"> </span>Sal<span class="k">;</span><span class="w"> </span><span class="k">set</span><span class="w"> </span>greeting2<span class="w"> </span>ut<span class="k">;</span><span class="w"> </span><span class="k">set</span><span class="w"> </span>greeting3<span class="w"> </span>ations<span class="w"> </span>


<span class="err">#</span><span class="w"> </span>Das<span class="w"> </span>Dollar-Zeichen<span class="w"> </span>zeigt<span class="w"> </span>eine<span class="w"> </span>Variablen-Substitution<span class="w"> </span>an.
<span class="k">set</span><span class="w"> </span>greeting<span class="w"> </span><span class="nv">$greeting1$greeting2$greeting3</span>


<span class="c"># Eckige-Klammern zeigen Befehls-Substitionen an. Das Ergebnis des Befehls wird an</span>
<span class="c"># Stelle des Klammern-Ausdrucks eingefügt. Wenn man dem &quot;set&quot; Befehl nur den</span>
<span class="c"># Namen einer Variablen übergibt, gibt er den Wert der Variablen zurück.</span>
<span class="k">set</span><span class="w"> </span>greeting<span class="w"> </span><span class="nv">$greeting1$greeting2</span><span class="k">[set</span><span class="w"> </span>greeting3<span class="k">]</span>


<span class="c"># Befehls-Substitution sollte eigentlich Script-Substitution heißen, denn ein</span>
<span class="c"># komplettes Script, und nicht nur ein Befehl, kann zwischen die Eckigen-Klammern</span>
<span class="c"># geschrieben werden. Der &quot;incr&quot; Befehl erhöht den Wert einer Variable um 1</span>
<span class="c"># und gibt den neuen Wert der Variable zurück.</span>
<span class="k">set</span><span class="w"> </span>greeting<span class="w"> </span><span class="nv">$greeting</span><span class="k">[</span>
<span class="w">    </span><span class="nb">incr</span><span class="w"> </span>i
<span class="w">    </span><span class="nb">incr</span><span class="w"> </span>i
<span class="w">    </span><span class="nb">incr</span><span class="w"> </span>i
<span class="k">]</span>


<span class="c"># Der Backslash unterdrück die Bedeutung von Sonderzeichen</span>
<span class="k">set</span><span class="w"> </span>amount<span class="w"> </span><span class="err">\</span><span class="nv">$16.42</span>


<span class="c"># Der Backslash macht bestimmte Zeichen zu Sonderzeichen</span>
<span class="nb">puts</span><span class="w"> </span>lots<span class="err">\</span>nof<span class="err">\</span>n<span class="err">\</span>n<span class="err">\</span>n<span class="err">\</span>n<span class="err">\</span>n<span class="err">\</span>nnewlines

<span class="c"># Ein Wort das in geschweiften Klammern eingeschlossen wurde ist von jeglichen</span>
<span class="c"># speziellen Interpretationen ausgeschlossen. Eine Ausnahme bilden Backslashes</span>
<span class="c"># vor geschweiften Klammern, hiermit wird die geschweifte Klammer von der Suche</span>
<span class="c"># nach der schließenden geschweiften Klammer ausgeschlossen.</span>
<span class="k">set</span><span class="w"> </span>somevar<span class="w"> </span><span class="k">{</span>
<span class="w">    </span><span class="nv">Das</span><span class="w"> </span>ist<span class="w"> </span>ein<span class="w"> </span>literales<span class="w"> </span><span class="err">$</span><span class="w"> </span>Zeichen,<span class="w"> </span>diese<span class="w"> </span>geschweifte<span class="w"> </span>Klammer<span class="w"> </span><span class="err">\</span><span class="k">}</span><span class="w"> </span>wird<span class="w"> </span>nicht
<span class="w">    </span><span class="nv">als</span><span class="w"> </span>Ende<span class="w"> </span>interpretiert.
<span class="k">}</span><span class="w"> </span>


<span class="c"># Bei einem Wort das in doppelten Anführungszeichen steht verlieren Leerzeichen</span>
<span class="c"># ihre spezielle Bedeutung.</span>
<span class="k">set</span><span class="w"> </span>name<span class="w"> </span>Neo
<span class="k">set</span><span class="w"> </span>greeting<span class="w"> </span><span class="s2">&quot;Hallo, $name&quot;</span>


<span class="c">#Variablen-Namen können irgend eine Zeichenkette sein.</span>
<span class="k">set</span><span class="w"> </span><span class="k">{</span><span class="nv">first</span><span class="w"> </span>name<span class="k">}</span><span class="w"> </span>New


<span class="c"># Die Geschweifte-Klammern-Form der Variablen-Substitution kann sehr komplexe</span>
<span class="c"># Variblen-Namen handhaben.</span>
<span class="k">set</span><span class="w"> </span>greeting<span class="w"> </span><span class="s2">&quot;Hello, ${first name}&quot;</span>


<span class="c"># Der &quot;set&quot; Befehl kann immer anstatt einer Variablen-Substition verwendet</span>
<span class="c"># werden.</span>
<span class="k">set</span><span class="w"> </span>greeting<span class="w"> </span><span class="s2">&quot;Hello, [set {first name}]&quot;</span>


<span class="c"># Mit dem Expansions-Operator &quot;{*}&quot; werden Wörter innerhalb eines Wortes wieder</span>
<span class="c"># individuell als Teile des aktuellen Befehls behandelt.</span>
<span class="k">set</span><span class="w"> </span><span class="k">{</span><span class="o">*</span><span class="k">}{</span><span class="nv">name</span><span class="w"> </span>Neo<span class="k">}</span>

<span class="c"># Ist Äquivalent zu</span>
<span class="k">set</span><span class="w"> </span>name<span class="w"> </span>Neo


<span class="c"># Ein Array ist eine spezielle Varible die also Kontainer für andere Variablen</span>
<span class="c"># dient.</span>
<span class="k">set</span><span class="w"> </span>person<span class="k">(</span><span class="nv">name</span><span class="k">)</span><span class="w"> </span>Neo
<span class="k">set</span><span class="w"> </span>person<span class="k">(</span><span class="nv">gender</span><span class="k">)</span><span class="w"> </span>male
<span class="k">set</span><span class="w"> </span>greeting<span class="w"> </span><span class="s2">&quot;Hello, $person(name)&quot;</span>


<span class="c"># Ein Namensraum enthält Befehle und Variablen</span>
<span class="k">namespace</span><span class="w"> </span>eval<span class="w"> </span>people<span class="w"> </span><span class="k">{</span>
<span class="w">    </span><span class="k">namespace</span><span class="w"> </span>eval<span class="w"> </span>person1<span class="w"> </span><span class="k">{</span>
<span class="w">        </span><span class="k">variable</span><span class="w"> </span>name<span class="w"> </span>Neo
<span class="w">    </span><span class="k">}</span>
<span class="k">}</span>


<span class="c">#Der volle Name einer Variablen beihaltet den/die umschließenden</span>
<span class="c"># Namensraum/Namensräume begrenzt durch zwei Doppelpunkte.</span>
<span class="k">set</span><span class="w"> </span>greeting<span class="w"> </span><span class="s2">&quot;Hello $people::person1::name&quot;</span>
</pre></div><div class="highlight"><pre><span></span><span class="c">################################################################################</span>
<span class="c">## 3. Einige Notizen </span>
<span class="c">################################################################################</span>

<span class="c"># Jede weitere Funktion ist über Befehle implementiert. Von nun an kommt keine</span>
<span class="c"># neue Syntax hinzu. Alles weitere das es über Tcl zu lernen gibt ist das</span>
<span class="c"># Verhalten individueller Befehle und die bedeutung ihrer Argumente.</span>


<span class="c"># Um einen Interpreter zu bekommen mit dem man nichts mehr machen kann, lösche</span>
<span class="c"># einfach den globalen Namensraum. Das ist nicht sehr sinnvoll, zeigt aber die</span>
<span class="c"># Natur von Tcl.</span>
<span class="k">namespace</span><span class="w"> </span>delete<span class="w"> </span><span class="o">::</span>


<span class="c"># Wegen des Verhaltens der Namens-Auflösung ist es sicherer den &quot;variable&quot;</span>
<span class="c"># Befehl zu verwenden um in einem Namensraum einen Wert zu deklarieren oder</span>
<span class="c"># zuzuweisen. Wenn eine Variable mit dem namen &quot;name&quot; bereits im globalen</span>
<span class="c"># Namensraum existiert, bewirkt der &quot;set&quot; Befehl das der globalen Variable ein</span>
<span class="c"># Wert zugewiesen wird, anstatt eine Variable im lokalen Namensraum zu erzeugen</span>
<span class="k">namespace</span><span class="w"> </span>eval<span class="w"> </span>people<span class="w"> </span><span class="k">{</span>
<span class="w">    </span><span class="k">namespace</span><span class="w"> </span>eval<span class="w"> </span>person1<span class="w"> </span><span class="k">{</span>
<span class="w">        </span><span class="k">variable</span><span class="w"> </span>name<span class="w"> </span>Neo
<span class="w">    </span><span class="k">}</span>
<span class="k">}</span>


<span class="c"># Es kann immer der vollständige Name einer Variable verwendet werden, falls</span>
<span class="c"># gewünscht.</span>
<span class="k">set</span><span class="w"> </span>people::person1::name<span class="w"> </span>Neo



<span class="c">################################################################################</span>
<span class="c">## 4. Befehle </span>
<span class="c">################################################################################</span>

<span class="c"># Berechnungen werde mit dem &quot;expr&quot; Befehl durchgeführt.</span>
<span class="k">set</span><span class="w"> </span>a<span class="w"> </span><span class="mi">3</span>
<span class="k">set</span><span class="w"> </span>b<span class="w"> </span><span class="mi">4</span>
<span class="k">set</span><span class="w"> </span>c<span class="w"> </span><span class="k">[expr</span><span class="w"> </span><span class="k">{</span><span class="nv">$a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">$b</span><span class="k">}]</span>

<span class="c"># Since &quot;expr&quot; performs variable substitution on its own, brace the expression</span>
<span class="c"># to prevent Tcl from performing variable substitution first.  See</span>

<span class="c"># Da der &quot;expr&quot; Befehl eigene Variablen-Substitutionen durchführt, setze den</span>
<span class="c"># zu berechnenden Ausdruck in Eckige-Klammern. Das hindert Tcl daran Variablen-</span>
<span class="c"># Substitutionen durchzuführen. Für Details siehe:</span>
<span class="c"># &quot;http://wiki.tcl.tk/Brace%20your%20#%20expr-essions&quot;</span>


<span class="c"># Der &quot;expr&quot; Befehl versteht Variablen- und Befehls-Substitutionen</span>
<span class="k">set</span><span class="w"> </span>c<span class="w"> </span><span class="k">[expr</span><span class="w"> </span><span class="k">{</span><span class="nv">$a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">[set</span><span class="w"> </span>b<span class="k">]}]</span>


<span class="c"># Der &quot;expr&quot; Befehl stellt Mathematische-Funktionen zur Verfügung.</span>
<span class="k">set</span><span class="w"> </span>c<span class="w"> </span><span class="k">[expr</span><span class="w"> </span><span class="k">{</span><span class="nv">pow</span><span class="k">(</span><span class="nv">$a</span>,<span class="nv">$b</span><span class="k">)}]</span>


<span class="c"># Mathematische Operatoren sind als Befehle auch im Namensraum </span>
<span class="c"># ::tcl::mathop verfügbar.</span>
<span class="o">::</span><span class="nv">tcl</span><span class="o">::</span>mathop::<span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">3</span>

<span class="c"># Befehle können aus anderen Namensräumen importiert werden.</span>
<span class="k">namespace</span><span class="w"> </span>import<span class="w"> </span><span class="o">::</span>tcl::mathop::<span class="o">+</span>
<span class="k">set</span><span class="w"> </span>result<span class="w"> </span><span class="k">[</span><span class="o">+</span><span class="w"> </span><span class="nv">5</span><span class="w"> </span><span class="mi">3</span><span class="k">]</span>


<span class="c"># Neu Befehle werden mit dem &quot;proc&quot; Befehl gebildet.</span>
<span class="k">proc</span><span class="w"> </span>greet<span class="w"> </span>name<span class="w"> </span><span class="k">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="s2">&quot;Hello, $name!&quot;</span>
<span class="k">}</span>

<span class="c">#Es können mehrere Parameter spezifiziert werden.</span>
<span class="k">proc</span><span class="w"> </span>greet<span class="w"> </span><span class="k">{</span><span class="nv">greeting</span><span class="w"> </span>name<span class="k">}</span><span class="w"> </span><span class="k">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="s2">&quot;$greeting, $name!&quot;</span>
<span class="k">}</span>


<span class="c"># Wie bereits erwähnt, geschwungene Klammern erzeugen keinen Code-Block.</span>
<span class="c"># Jeder Wert, sogar das dritte Argument für den &quot;proc&quot; Befehl ist eine</span>
<span class="c"># Zeichenkette. Der vorherige Befehl kann daher auch ohne</span>
<span class="c"># geschwungene Klammern geschrieben werden:</span>
<span class="k">proc</span><span class="w"> </span>greet<span class="w"> </span>greeting<span class="err">\</span><span class="w"> </span>name<span class="w"> </span>return<span class="err">\</span><span class="w"> </span><span class="err">\</span><span class="s2">&quot;Hello,\ \$name!</span>



<span class="s2"># Wenn der letzte Parameter der literale Wert &quot;</span>args<span class="s2">&quot; ist, sammelt dieser Wert</span>
<span class="s2"># alle übrigen Argumente des Befehls ein wenn dieser aufgerufen wird.</span>
<span class="s2">proc fold {cmd args} {</span>
<span class="s2">    set res 0</span>
<span class="s2">    foreach arg $args {</span>
<span class="s2">        set res [$cmd $res $arg]</span>
<span class="s2">    }</span>
<span class="s2">}</span>
<span class="s2">fold ::tcl::mathop::* 5 3 3 ;# -&gt;  45</span>


<span class="s2"># Bedingte Ausführung ist auch als Befehl implementiert</span>
<span class="s2">if {3 &gt; 4} {</span>
<span class="s2">    puts {This will never happen}</span>
<span class="s2">} elseif {4 &gt; 4} {</span>
<span class="s2">    puts {This will also never happen}</span>
<span class="s2">} else {</span>
<span class="s2">    puts {This will always happen}</span>
<span class="s2">}</span>


<span class="s2"># Auch Schleifen sind Befehle. Das erste, zweite und dritte Argument des &quot;</span>for<span class="s2">&quot;</span>
<span class="s2"># Befehls wird als mathematischer Ausdruck behandelt.</span>
<span class="s2">for {set i 0} {$i &lt; 10} {incr i} {</span>
<span class="s2">    set res [expr {$res + $i}]</span>
<span class="s2">}</span>


<span class="s2"># Das erste Argument des &quot;</span>while<span class="s2">&quot; Befehls wird auch als mathematischer Ausdruck</span>
<span class="s2"># behandelt.</span>
<span class="s2">set i 0</span>
<span class="s2">while {$i &lt; 10} {</span>
<span class="s2">    incr i 2</span>
<span class="s2">}</span>


<span class="s2"># Eine Liste ist eine speziell formatierte Zeichenkette. Im einfachsten Fall</span>
<span class="s2"># genügen Leerzeichen als Trennzeichen zwischen den einzelnen Werten.</span>
<span class="s2">set amounts 10\ 33\ 18 </span>
<span class="s2">set amount [lindex $amounts 1]</span>


<span class="s2"># Geschwungene Klammern und Backslashes können verwendet werden um komplexe</span>
<span class="s2"># Werte in einer Liste zu formatieren. Eine Liste sieht aus wie ein Skript,</span>
<span class="s2"># allerdings verlieren verlieren Zeilenumbrüche und Doppelüunkte ihre </span>
<span class="s2"># besondere Bedeutung. Diese Funktionalität macht Tcl homoikonisch. Die</span>
<span class="s2"># folgende Liste enhtält drei Elemente.</span>
<span class="s2">set values {</span>

<span class="s2">    one\ two</span>

<span class="s2">    {three four}</span>

<span class="s2">    five\{six</span>

<span class="s2">}</span>


<span class="s2"># Da Listen auch Zeichenketten sind, kann man Zeichenketten-Operationen auf</span>
<span class="s2"># ihnen anwenden. Allerdings mit dem Risiko die Formatierung der Liste zu</span>
<span class="s2"># beschädigen.</span>
<span class="s2">set values {one two three four}</span>
<span class="s2">set values [string map {two \{} $values] ;# $values is no-longer a \</span>
<span class="s2">    properly-formatted listwell-formed list</span>


<span class="s2"># Der sicherste Weg korrekt formatierte Liste zu erzeugen, ist den &quot;</span>list<span class="s2">&quot;</span>
<span class="s2"># Befehl zu verwenden.</span>
<span class="s2">set values [list one \{ three four]</span>
<span class="s2">lappend values { } ;# Ein Leerzeichen als Element der Liste hinzufügen</span>


<span class="s2"># Mit &quot;</span>eval<span class="s2">&quot; können Werte als Skripts evaluiert weden.</span>
<span class="s2">eval {</span>
<span class="s2">    set name Neo</span>
<span class="s2">    set greeting &quot;</span>Hello,<span class="w"> </span><span class="nv">$name</span><span class="s2">&quot;</span>
<span class="s2">}</span>


<span class="s2"># Eine Liste kann immer an &quot;</span>eval<span class="s2">&quot; übergeben werden, solange die Liste einen</span>
<span class="s2"># einzigen Befehl entält.</span>
<span class="s2">eval {set name Neo}</span>
<span class="s2">eval [list set greeting &quot;Hello, $name&quot;]</span>


<span class="s2"># Daher: Wenn &quot;</span>eval<span class="s2">&quot; verwendet wird, verwende [list] um den gewünschten Befehl</span>
<span class="s2"># aufzubauen.</span>
<span class="s2">set command {set name}</span>
<span class="s2">lappend command {Archibald Sorbisol}</span>
<span class="s2">eval $command</span>


<span class="s2"># Es ist ein häufiger Fehler die Listen funktionen beim Aufbauen von Listen</span>
<span class="s2"># nicht zu verwenden.</span>
<span class="s2">set command {set name}</span>
<span class="s2">append command { Archibald Sorbisol}</span>
<span class="s2">eval $command ;# Hier passiert eine Fehler, denn der &quot;</span>set<span class="s2">&quot; Befehl hat nun zu \</span>
<span class="s2">    viele Argumente {set name Archibald Sorbisol}</span>


<span class="s2"># Dieser Fehler kann auch leicht beim &quot;</span>subst<span class="s2">&quot; Befehl passieren.</span>
<span class="s2">set replacement {Archibald Sorbisol}</span>
<span class="s2">set command {set name $replacement}</span>
<span class="s2">set command [subst $command] </span>
<span class="s2">eval $command ;# The same error as before: too many arguments to &quot;</span>set<span class="s2">&quot; in \</span>
<span class="s2">    {set name Archibald Sorbisol}</span>


<span class="s2"># Die korrekte Vorgangsweise ist es den substituierten Wert mit dem &quot;</span>list<span class="s2">&quot;</span>
<span class="s2"># Befehl zu formatieren.</span>
<span class="s2">set replacement [list {Archibald Sorbisol}]</span>
<span class="s2">set command {set name $replacement}</span>
<span class="s2">set command [subst $command] </span>
<span class="s2">eval $command</span>


<span class="s2"># Der &quot;</span>list<span class="s2">&quot; Befehl wird sehr häufig verwendet um Werte zu formatieren die</span>
<span class="s2"># in Tcl Skript Vorlagen substituiert werden. Es gibt dazu viele Beispiele,</span>
<span class="s2"># siehe unterhalb.</span>


<span class="s2"># Der &quot;</span>apply<span class="s2">&quot; Befehl evaluiert eine Zeichenkette als Befehl.</span>
<span class="s2">set cmd {{greeting name} {</span>
<span class="s2">    return &quot;</span><span class="nv">$greeting</span>,<span class="w"> </span><span class="nv">$name</span><span class="o">!</span><span class="s2">&quot;</span>
<span class="s2">}}</span>
<span class="s2">apply $cmd Whaddup Neo</span>


<span class="s2"># Der &quot;</span>uplevel<span class="s2">&quot; Befehl evaluiert ein Skript in einem höher liegenden</span>
<span class="s2">Gültigkeitsbereich.</span>
<span class="s2">proc greet {} {</span>
<span class="s2">    uplevel {puts &quot;</span><span class="nv">$greeting</span>,<span class="w"> </span><span class="nv">$name</span><span class="s2">&quot;}</span>
<span class="s2">}</span>

<span class="s2">proc set_double {varname value} {</span>
<span class="s2">    if {[string is double $value]} {</span>
<span class="s2">        uplevel [list variable $varname $value]</span>
<span class="s2">    } else {</span>
<span class="s2">        error [list {not a double} $value]</span>
<span class="s2">    }</span>
<span class="s2">}</span>


<span class="s2"># Der &quot;</span>upvar<span class="s2">&quot; Befehl verknüpft eine Variable im aktuellen Gültigkeitsbereich</span>
<span class="s2"># mit einer Variable in einem höher liegenden Gültigkeitsbereich.</span>
<span class="s2">proc set_double {varname value} {</span>
<span class="s2">    if {[string is double $value]} {</span>
<span class="s2">        upvar 1 $varname var</span>
<span class="s2">        set var $value</span>
<span class="s2">    } else {</span>
<span class="s2">        error [list {not a double} $value]</span>
<span class="s2">    }</span>
<span class="s2">}</span>


<span class="s2"># Werde den eingebauten &quot;</span>while<span class="s2">&quot; Befehl los.</span>
<span class="s2">rename ::while {}</span>


<span class="s2"># Definieren einen neuen &quot;</span>while<span class="s2">&quot; Befehl mit hilfe des &quot;</span>proc<span class="s2">&quot; Befehls.</span>
<span class="s2"># Ausführlichere Fehler-Behandlung wird dem Leser als Übung überlassen.</span>
<span class="s2">proc while {condition script} {</span>
<span class="s2">    if {[uplevel 1 [list expr $condition]]} {</span>
<span class="s2">        uplevel 1 $script</span>
<span class="s2">        tailcall [namespace which while] $condition $script</span>
<span class="s2">    }</span>
<span class="s2">}</span>


<span class="s2"># Der &quot;</span>coroutine<span class="s2">&quot; Befehl erzeugt einen separaten Call-Stack, zusammen mit einem</span>
<span class="s2"># Befehl um diesem Call-Stack zu verwenden. Der &quot;</span>yield<span class="s2">&quot; Befehl unterbricht</span>
<span class="s2"># die Ausführung des aktuellen Call-Stacks.</span>
<span class="s2">proc countdown {} {</span>
<span class="s2">    #send something back to the initial &quot;</span>coroutine<span class="s2">&quot; command</span>
<span class="s2">    yield</span>

<span class="s2">    set count 3 </span>
<span class="s2">    while {$count &gt; 1} {</span>
<span class="s2">        yield [incr count -1]</span>
<span class="s2">    }</span>
<span class="s2">    return 0</span>
<span class="s2">}</span>
<span class="s2">coroutine countdown1 countdown</span>
<span class="s2">coroutine countdown2 countdown</span>
<span class="s2">puts [countdown 1] ;# -&gt; 2 </span>
<span class="s2">puts [countdown 2] ;# -&gt; 2 </span>
<span class="s2">puts [countdown 1] ;# -&gt; 1 </span>
<span class="s2">puts [countdown 1] ;# -&gt; 0 </span>
<span class="s2">puts [coundown 1] ;# -&gt; invalid command name &quot;</span>countdown1<span class="s2">&quot;</span>
<span class="s2">puts [countdown 2] ;# -&gt; 1 </span>
</pre></div>
<h2>Referenzen</h2>

<p><a href="http://www.tcl.tk/man/tcl/">Official Tcl Documentation</a></p>

<p><a href="http://wiki.tcl.tk">Tcl Wiki</a></p>

<p><a href="http://www.reddit.com/r/Tcl">Tcl Subreddit</a></p>

    <hr>
    <p>Du hast einen Verbesserungsvorschlag oder einen Fehler gefunden? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Erstelle ein Ticket</a> im offiziellen Github Repo, oder du erstellst einfach gleich einen <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/de-de/tcl-de.html.markdown">pull request</a>!
    </p>
    <p class="contributed">
    Originalversion von Poor Yorick, mit Updates von <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/de-de/tcl-de.html.markdown">0 contributor(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://pooryorick.com/">Poor Yorick</a>
    </p>

    <p>
      Translated by:
        <a href="https://github.com/Git-Jiro">Martin Schimandl</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
