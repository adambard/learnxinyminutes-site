<!DOCTYPE html lang="de-de" xml:lang="de-de" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="de-de">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Haskell in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/de-de/haskell-de/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fde-de%2Fhaskell-de%2F&text=Lerne+X+in+Y+Minuten%2C+wobei+X%3DHaskell">
        Teile diese Seite mit anderen
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Thema wählen:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">hell</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dunkel</button>
  </div>
  <h1><a href="/">Lerne X in Y Minuten</a></h1>
  <h2>Wobei X=Haskell</h2>
    <p class="filelink">
    Lade den Code herunter:
    <a href="/docs/files/haskell-de.hs">haskell-de.hs</a>
    </p>
  <div id="doc">
    <p>Haskell wurde als praktische und funktionale Sprache entworfen.
Es ist berühmt für das Schema der Monaden und des Typsystems, aber
es sticht vor allem die Einfachheit und Eleganz hervor.</p>
<div class="highlight"><pre class="highlight haskell"><code><span class="c1">-- Einfache Kommentare beginnen mit 2 Bindestriche.</span>
<span class="cm">{- So wird ein Kommentar
über mehrere Zeilen angelegt.
-}</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 1. Primitive Datentypen und Operatoren</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Normale Zahlen.</span>
<span class="mi">3</span> <span class="c1">-- 3</span>

<span class="c1">-- Einfache Rechenoperationen.</span>
<span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">-- 2</span>
<span class="mi">8</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">-- 7</span>
<span class="mi">10</span> <span class="o">*</span> <span class="mi">2</span> <span class="c1">-- 20</span>
<span class="mi">35</span> <span class="o">/</span> <span class="mi">5</span> <span class="c1">-- 7.0</span>

<span class="c1">-- Die Division ist per se auf Fließkommazahlen.</span>
<span class="mi">35</span> <span class="o">/</span> <span class="mi">4</span> <span class="c1">-- 8.75</span>

<span class="c1">-- Ganzzahlige Division</span>
<span class="mi">35</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">4</span> <span class="c1">-- 8</span>

<span class="c1">-- Boolesche Werte sind Primitiven.</span>
<span class="kt">True</span>
<span class="kt">False</span>

<span class="c1">-- Logik Operationen</span>
<span class="n">not</span> <span class="kt">True</span> <span class="c1">-- False</span>
<span class="n">not</span> <span class="kt">False</span> <span class="c1">-- True</span>
<span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="c1">-- True</span>
<span class="mi">1</span> <span class="o">/=</span> <span class="mi">1</span> <span class="c1">-- False</span>
<span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="c1">-- True</span>

<span class="c1">-- `not` ist eine Funktion die ein Argument entgegenimmt.</span>
<span class="c1">-- Haskell benötigt keine Klammern um Argumente.</span>
<span class="c1">-- Sie werden einfach aufgelistet: func arg1 arg2 arg3...</span>
<span class="c1">-- Wie man Funktionen definiert kommt weiter unten.</span>


<span class="c1">-- Strings und Zeichen</span>
<span class="s">"Das ist ein String."</span>
<span class="sc">'a'</span> <span class="c1">-- Zeichen</span>
<span class="kt">'Einfache</span> <span class="kt">Anf</span><span class="err">ü</span><span class="n">hrungszeichen</span> <span class="n">gehen</span> <span class="n">nicht</span><span class="o">.</span><span class="n">'</span> <span class="c1">-- error!</span>

<span class="c1">-- Strings können konkateniert werden.</span>
<span class="s">"Hello "</span> <span class="o">++</span> <span class="s">"world!"</span> <span class="c1">-- "Hello world!"</span>

<span class="c1">-- Ein String ist eine Liste von Zeichen.</span>
<span class="p">[</span><span class="sc">'H'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="sc">'l'</span><span class="p">,</span> <span class="sc">'l'</span><span class="p">,</span> <span class="sc">'o'</span><span class="p">,</span> <span class="sc">'!'</span><span class="p">]</span> <span class="c1">-- "Hallo!"</span>
<span class="s">"Das ist eine String"</span> <span class="o">!!</span> <span class="mi">0</span> <span class="c1">-- 'D'</span>


<span class="c1">----------------------------------------------------</span>
<span class="c1">-- Listen und Tupel</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Jedes Element einer Liste muss vom gleichen Typ sein.</span>
<span class="c1">-- Zwei gleiche Listen</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>

<span class="c1">-- Die zweite Variante nennt sich die "range"-Syntax.</span>
<span class="c1">-- Ranges sind recht flexibel:</span>
<span class="p">[</span><span class="sc">'A'</span><span class="o">..</span><span class="sc">'F'</span><span class="p">]</span> <span class="c1">-- "ABCDEF"</span>

<span class="c1">-- Es ist möglich eine Schrittweite anzugeben:</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="c1">-- [0,2,4,6,8,10]</span>
<span class="p">[</span><span class="mi">5</span><span class="o">..</span><span class="mi">1</span><span class="p">]</span> <span class="c1">-- [], da Haskell standardmässig inkrementiert.</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="o">..</span><span class="mi">1</span><span class="p">]</span> <span class="c1">-- [5,4,3,2,1]</span>

<span class="c1">-- Der "!!"-Operator extrahiert das Element an einem bestimmten Index:</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="o">!!</span> <span class="mi">3</span> <span class="c1">-- 4</span>

<span class="c1">-- Haskell unterstützt unendliche Listen!</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span> <span class="c1">-- Die Liste aller natürlichen Zahlen</span>

<span class="c1">-- Unendliche Listen funktionieren in Haskell, da es "lazy evaluation"</span>
<span class="c1">-- unterstützt. Haskell evaluiert erst etwas, wenn es benötigt wird.</span>
<span class="c1">-- Somit kannst du nach dem 1000. Element fragen und Haskell gibt es dir:</span>

<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span> <span class="o">!!</span> <span class="mi">999</span> <span class="c1">-- 1000</span>

<span class="c1">-- Haskell evaluiert nun die ersten 1 - 1000 Elemente, aber der Rest der Liste</span>
<span class="c1">-- bleibt unangetastet. Haskell wird sie solange nicht weiterevaluieren</span>
<span class="c1">-- bis es muss.</span>

<span class="c1">-- Zwei Listen konkatenieren</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="mi">6</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>

<span class="c1">-- Ein Element als Head hinzufügen</span>
<span class="mi">0</span><span class="o">:</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- [0, 1, 2, 3, 4, 5]</span>

<span class="c1">-- Weitere Listenoperationen</span>
<span class="n">head</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- 1</span>
<span class="n">tail</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- [2, 3, 4, 5]</span>
<span class="n">init</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- [1, 2, 3, 4]</span>
<span class="n">last</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- 5</span>

<span class="c1">-- Listen erschaffen ("list comprehensions")</span>
<span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]]</span> <span class="c1">-- [2, 4, 6, 8, 10]</span>

<span class="c1">-- Mit Bedingungen</span>
<span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">],</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">]</span> <span class="c1">-- [6, 8, 10]</span>

<span class="c1">-- Tupel haben eine feste Länge, jedes Element darf aber ein anderen Typ haben.</span>
<span class="c1">-- Ein Tupel:</span>
<span class="p">(</span><span class="s">"haskell"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1">-- Ein Paar (Pair) ist ein Tupel mit 2 Elementen, auf die man wie folgt</span>
<span class="c1">-- zugreifen kann:</span>
<span class="n">fst</span> <span class="p">(</span><span class="s">"haskell"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">-- "haskell"</span>
<span class="n">snd</span> <span class="p">(</span><span class="s">"haskell"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">-- 1</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 3. Funktionen</span>
<span class="c1">----------------------------------------------------</span>
<span class="c1">-- Eine einfache Funktion die zwei Argumente hat.</span>
<span class="n">add</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="c1">-- Wenn man ghci (den Haskell Interpreter) benutzt, muss ein `let` davor.</span>
<span class="c1">-- let add a b = a + b</span>

<span class="c1">-- Eine Funktion aufrufen</span>
<span class="n">add</span> <span class="mi">1</span> <span class="mi">2</span> <span class="c1">-- 3</span>

<span class="c1">-- Man kann eine Funktion auch Infix verwenden,</span>
<span class="c1">-- wenn man sie mit backticks umgibt</span>
<span class="mi">1</span> <span class="p">`</span><span class="n">add</span><span class="p">`</span> <span class="mi">2</span> <span class="c1">-- 3</span>

<span class="c1">-- So sieht die Definition eines eigenen Operators aus.</span>
<span class="c1">-- Also einer Funktion deren Name aus Symbolen besteht.</span>
<span class="c1">-- Die Integer Division:</span>
<span class="p">(</span><span class="o">//</span><span class="p">)</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="n">b</span>
<span class="mi">35</span> <span class="o">//</span> <span class="mi">4</span> <span class="c1">-- 8</span>

<span class="c1">-- Guards sind eine einfache Möglichkeit für Fallunterscheidungen.</span>
<span class="n">fib</span> <span class="n">x</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="n">fib</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1">-- Pattern Matching funktioniert ähnlich.</span>
<span class="c1">-- Hier sind drei Definitionen von fib. Haskell wird automatisch</span>
<span class="c1">-- die erste Funktionen nehmen die dem Pattern der Eingabe entspricht.</span>
<span class="n">fib</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">fib</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">fib</span> <span class="n">x</span> <span class="o">=</span> <span class="n">fib</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1">-- Pattern matching auf Tupeln:</span>
<span class="n">foo</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1">-- Pattern matching auf Listen.</span>
<span class="c1">-- `x` ist das erste Element der Liste und `xs` der Rest der Liste.</span>
<span class="c1">-- Damit können wir unsere eigene map Funktion bauen:</span>
<span class="n">myMap</span> <span class="n">func</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">myMap</span> <span class="n">func</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">func</span> <span class="n">x</span><span class="o">:</span><span class="p">(</span><span class="n">myMap</span> <span class="n">func</span> <span class="n">xs</span><span class="p">)</span>

<span class="c1">-- Anonyme Funktionen (Lambda-Funktionen) werden mit einem</span>
<span class="c1">-- Backslash eingeleitet, gefolgt von allen Argumenten.</span>
<span class="n">myMap</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- [3, 4, 5, 6, 7]</span>

<span class="c1">-- Fold (`inject` in einigen Sprachen)</span>
<span class="c1">-- Foldl1 bedeutet: fold von links nach rechts und nehme den ersten</span>
<span class="c1">-- Wert der Liste als Basiswert für den Akkumulator.</span>
<span class="n">foldl1</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- 15</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 4. Mehr Funktionen</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- currying: Wenn man nicht alle Argumente an eine Funktion übergibt,</span>
<span class="c1">-- so wird sie eine neue Funktion gebildet ("curried").</span>
<span class="c1">-- Es findet eine partielle Applikation statt und die neue Funktion</span>
<span class="c1">-- nimmt die fehlenden Argumente auf.</span>

<span class="n">add</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">add</span> <span class="mi">10</span> <span class="c1">-- foo ist nun Funktion die ein Argument nimmt und 10 addiert</span>
<span class="n">foo</span> <span class="mi">5</span> <span class="c1">-- 15</span>

<span class="c1">-- Ein alternativer Weg</span>
<span class="n">foo</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="mi">10</span><span class="p">)</span>
<span class="n">foo</span> <span class="mi">5</span> <span class="c1">-- 15</span>

<span class="c1">-- Funktionskomposition</span>
<span class="c1">-- Die (.) Funktion verkettet Funktionen.</span>
<span class="c1">-- Zum Beispiel, die Funktion Foo nimmt ein Argument, addiert 10 dazu und</span>
<span class="c1">-- multipliziert dieses Ergebnis mit 4.</span>
<span class="n">foo</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="o">+</span><span class="mi">10</span><span class="p">)</span>

<span class="c1">-- (5 + 10) * 4 = 60</span>
<span class="n">foo</span> <span class="mi">5</span> <span class="c1">-- 60</span>


<span class="c1">-- Haskell hat einen Operator `$`, welcher Funktionsapplikation durchführt.</span>
<span class="c1">-- Im Gegenzug zu der Standard-Funktionsapplikation, welche linksassoziativ ist</span>
<span class="c1">-- und die höchstmögliche Priorität von "10" hat, ist der `$`-Operator</span>
<span class="c1">-- rechtsassoziativ und hat die Priorität 0. Dieses hat (i.d.R.) den Effekt,</span>
<span class="c1">-- dass der `komplette` Ausdruck auf der rechten Seite als Parameter für die</span>
<span class="c1">-- Funktion auf der linken Seite verwendet wird.</span>
<span class="c1">-- Mit `.` und `$` kann man sich so viele Klammern ersparen.</span>

<span class="p">(</span><span class="n">even</span> <span class="p">(</span><span class="n">fib</span> <span class="mi">7</span><span class="p">))</span> <span class="c1">-- false</span>

<span class="c1">-- Äquivalent:</span>
<span class="n">even</span> <span class="o">$</span> <span class="n">fib</span> <span class="mi">7</span> <span class="c1">-- false</span>

<span class="c1">-- Funktionskomposition:</span>
<span class="n">even</span> <span class="o">.</span> <span class="n">fib</span> <span class="o">$</span> <span class="mi">7</span> <span class="c1">-- false</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 5. Typensystem</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Haskell hat ein sehr starkes Typsystem.</span>
<span class="c1">-- Alles hat einen Typ und eine Typsignatur.</span>

<span class="c1">-- Einige grundlegende Typen:</span>
<span class="mi">5</span> <span class="o">::</span> <span class="kt">Integer</span>
<span class="s">"hello"</span> <span class="o">::</span> <span class="kt">String</span>
<span class="kt">True</span> <span class="o">::</span> <span class="kt">Bool</span>

<span class="c1">-- Funktionen haben genauso Typen.</span>
<span class="c1">-- `not` ist Funktion die ein Bool annimmt und ein Bool zurückgibt:</span>
<span class="c1">-- not :: Bool -&gt; Bool</span>

<span class="c1">-- Eine Funktion die zwei Integer Argumente annimmt:</span>
<span class="c1">-- add :: Integer -&gt; Integer -&gt; Integer</span>

<span class="c1">-- Es ist guter Stil zu jeder Funktionsdefinition eine</span>
<span class="c1">-- Typdefinition darüber zu schreiben:</span>
<span class="n">double</span> <span class="o">::</span> <span class="kt">Integer</span> <span class="o">-&gt;</span> <span class="kt">Integer</span>
<span class="n">double</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 6. If-Ausdrücke und Kontrollstrukturen</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- If-Ausdruck:</span>
<span class="n">haskell</span> <span class="o">=</span> <span class="kr">if</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="kr">then</span> <span class="s">"awesome"</span> <span class="kr">else</span> <span class="s">"awful"</span> <span class="c1">-- haskell = "awesome"</span>

<span class="c1">-- If-Ausdrücke können auch über mehrere Zeilen verteilt sein.</span>
<span class="c1">-- Die Einrückung ist dabei wichtig.</span>
<span class="n">haskell</span> <span class="o">=</span> <span class="kr">if</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="kr">then</span> <span class="s">"awesome"</span>
            <span class="kr">else</span> <span class="s">"awful"</span>

<span class="c1">-- Case-Ausdruck: Am Beispiel vom Parsen von "commandline"-Argumenten.</span>
<span class="kr">case</span> <span class="n">args</span> <span class="kr">of</span>
  <span class="s">"help"</span> <span class="o">-&gt;</span> <span class="n">printHelp</span>
  <span class="s">"start"</span> <span class="o">-&gt;</span> <span class="n">startProgram</span>
  <span class="kr">_</span> <span class="o">-&gt;</span> <span class="n">putStrLn</span> <span class="s">"bad args"</span>

<span class="c1">-- Haskell nutzt Rekursion anstatt Schleifen.</span>
<span class="c1">-- map wendet eine Funktion auf jedes Element einer Liste an.</span>

<span class="n">map</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- [2, 4, 6, 8, 10]</span>

<span class="c1">-- So kann man auch eine for-Funktion kreieren.</span>
<span class="n">for</span> <span class="n">array</span> <span class="n">func</span> <span class="o">=</span> <span class="n">map</span> <span class="n">func</span> <span class="n">array</span>

<span class="c1">-- und so benutzt man sie:</span>
<span class="n">for</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="o">$</span> <span class="nf">\</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">show</span> <span class="n">i</span>

<span class="c1">-- wir hätten sie auch so benutzen können:</span>
<span class="n">for</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="n">show</span>

<span class="c1">-- foldl oder foldr reduziren Listen auf einen Wert.</span>
<span class="c1">-- foldl &lt;Funktion&gt; &lt;initialer Wert&gt; &lt;Liste&gt;</span>
<span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="mi">4</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="c1">-- 43</span>

<span class="c1">-- die Abarbeitung sieht so aus:</span>
<span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>

<span class="c1">-- foldl ist linksseitig und foldr rechtsseitig.</span>
<span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="mi">4</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="c1">-- 16</span>

<span class="c1">-- die Abarbeitung sieht so aus:</span>
<span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)))</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 7. Datentypen</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- So kann man seine eigenen Datentypen in Haskell anlegen:</span>

<span class="kr">data</span> <span class="kt">Color</span> <span class="o">=</span> <span class="kt">Red</span> <span class="o">|</span> <span class="kt">Blue</span> <span class="o">|</span> <span class="kt">Green</span>

<span class="c1">-- Nun können wir sie in einer Funktion benutzen.</span>

<span class="n">say</span> <span class="o">::</span> <span class="kt">Color</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">say</span> <span class="kt">Red</span> <span class="o">=</span> <span class="s">"You are Red!"</span>
<span class="n">say</span> <span class="kt">Blue</span> <span class="o">=</span> <span class="s">"You are Blue!"</span>
<span class="n">say</span> <span class="kt">Green</span> <span class="o">=</span>  <span class="s">"You are Green!"</span>

<span class="c1">-- Datentypen können auch Parameter aufnehmen:</span>

<span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Nothing</span> <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>

<span class="c1">-- Diese sind alle vom Typ Maybe:</span>
<span class="kt">Just</span> <span class="s">"hello"</span>    <span class="c1">-- vom Typ `Maybe String`</span>
<span class="kt">Just</span> <span class="mi">1</span>          <span class="c1">-- vom Typ `Maybe Int`</span>
<span class="kt">Nothing</span>         <span class="c1">-- vom Typ `Maybe a` für jedes `a`</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 8. Haskell IO</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- IO kann nicht völlig erklärt werden ohne Monaden zu erklären,</span>
<span class="c1">-- aber man kann die grundlegenden Dinge erklären.</span>

<span class="c1">-- Wenn eine Haskell Programm ausgeführt wird, so wird `main` aufgerufen.</span>
<span class="c1">-- Diese muss etwas vom Typ `IO ()` zurückgeben. Zum Beispiel:</span>

<span class="n">main</span> <span class="o">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">main</span> <span class="o">=</span> <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">"Hello, sky! "</span> <span class="o">++</span> <span class="p">(</span><span class="n">say</span> <span class="kt">Blue</span><span class="p">)</span>
<span class="c1">-- putStrLn hat den Typ String -&gt; IO ()</span>

<span class="c1">-- Es ist am einfachsten, wenn man sein Programm als Funktion von</span>
<span class="c1">-- String nach String implementiert.</span>
<span class="c1">-- Zum Beispiel die Funktion interact :: (String -&gt; String) -&gt; IO ()</span>
<span class="c1">-- nimmt einen Text, tut etwas damit und gibt diesen wieder aus.</span>

<span class="n">countLines</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">countLines</span> <span class="o">=</span> <span class="n">show</span> <span class="o">.</span> <span class="n">length</span> <span class="o">.</span> <span class="n">lines</span>

<span class="n">main'</span> <span class="o">=</span> <span class="n">interact</span> <span class="n">countLines</span>

<span class="c1">-- Man kann den Typ `IO ()` als Repräsentation einer Sequenz von</span>
<span class="c1">-- Aktionen sehen, die der Computer abarbeiten muss.</span>
<span class="c1">-- Wie bei einem Programm das in einer Imperativen Sprache geschreiben wurde.</span>
<span class="c1">-- Mit der `do` Notation können Aktionen verbunden werden.</span>

<span class="n">sayHello</span> <span class="o">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">sayHello</span> <span class="o">=</span> <span class="kr">do</span>
   <span class="n">putStrLn</span> <span class="s">"What is your name?"</span>
   <span class="n">name</span> <span class="o">&lt;-</span> <span class="n">getLine</span> <span class="c1">-- eine Zeile wird geholt und</span>
                   <span class="c1">-- an die Variable "name" gebunden</span>
   <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">"Hello, "</span> <span class="o">++</span> <span class="n">name</span>

<span class="c1">-- Übung: Schreibe deine eigene Version von `interact`,</span>
<span class="c1">-- die nur eine Zeile einliest.</span>

<span class="c1">-- `sayHello` wird niemals ausgeführt, nur `main` wird ausgeführt.</span>
<span class="c1">-- Um `sayHello` laufen zulassen kommentiere die Definition von `main`</span>
<span class="c1">-- aus und ersetze sie mit:</span>
<span class="c1">--     main = sayHello</span>

<span class="c1">-- Lass uns untersuchen wie `getLine` arbeitet.</span>
<span class="c1">-- Der Typ ist: getLine :: IO String</span>
<span class="c1">-- Man kann sich vorstellen das der Wert vom Typ `IO a` ein</span>
<span class="c1">-- Programm repräsentiert das etwas vom Typ `a` generiert.</span>
<span class="c1">-- Der Wert wird mit `&lt;-` gespeichert und kann wieder benutzt werden.</span>
<span class="c1">-- Wir könne auch eigene Funktionen vom Typ `IO String` definieren:</span>

<span class="n">action</span> <span class="o">::</span> <span class="kt">IO</span> <span class="kt">String</span>
<span class="n">action</span> <span class="o">=</span> <span class="kr">do</span>
   <span class="n">putStrLn</span> <span class="s">"This is a line. Duh"</span>
   <span class="n">input1</span> <span class="o">&lt;-</span> <span class="n">getLine</span>
   <span class="n">input2</span> <span class="o">&lt;-</span> <span class="n">getLine</span>
   <span class="c1">-- Der Typ von `do` ergibt sich aus der letzten Zeile.</span>
   <span class="c1">-- `return` ist eine Funktion und keine Schlüsselwort</span>
   <span class="n">return</span> <span class="p">(</span><span class="n">input1</span> <span class="o">++</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span> <span class="o">++</span> <span class="n">input2</span><span class="p">)</span> <span class="c1">-- return :: String -&gt; IO String</span>

<span class="c1">-- Nun können wir `action` wie `getLine` benutzen:</span>

<span class="n">main''</span> <span class="o">=</span> <span class="kr">do</span>
    <span class="n">putStrLn</span> <span class="s">"I will echo two lines!"</span>
    <span class="n">result</span> <span class="o">&lt;-</span> <span class="n">action</span>
    <span class="n">putStrLn</span> <span class="n">result</span>
    <span class="n">putStrLn</span> <span class="s">"This was all, folks!"</span>

<span class="c1">-- Der Typ `IO` ist ein Beispiel für eine Monade.</span>
<span class="c1">-- Haskell benutzt Monaden Seiteneffekte zu kapseln und somit</span>
<span class="c1">-- eine rein funktional Sprache zu sein.</span>
<span class="c1">-- Jede Funktion die mit der Außenwelt interagiert (z.B. IO)</span>
<span class="c1">-- hat den Typ `IO` in seiner Signatur.</span>
<span class="c1">-- Damit kann man zwischen "reinen" Funktionen (interagieren nicht</span>
<span class="c1">-- mit der Außenwelt oder ändern ihren Zustand) und Anderen unterscheiden.</span>

<span class="c1">-- Nebenläufigkeit ist in Haskell sehr einfach, da reine Funktionen</span>
<span class="c1">-- leicht nebenläufig arbeiten können.</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 9. Die Haskell REPL</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Starte die REPL mit dem Befehl `ghci`</span>
<span class="c1">-- Nun kann man Haskell Code eingeben.</span>
<span class="c1">-- Alle neuen Werte müssen mit `let` gebunden werden:</span>

<span class="kr">let</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">5</span>

<span class="c1">-- `:t` zeigt den Typen von jedem Wert an:</span>

<span class="o">&gt;:</span><span class="n">t</span> <span class="n">foo</span>
<span class="n">foo</span> <span class="o">::</span> <span class="kt">Integer</span>

<span class="c1">-- Auch jede `IO ()` Funktion kann ausgeführt werden.</span>

<span class="o">&gt;</span> <span class="n">sayHello</span>
<span class="kt">What</span> <span class="n">is</span> <span class="n">your</span> <span class="n">name</span><span class="o">?</span>
<span class="kt">Friend</span><span class="o">!</span>
<span class="kt">Hello</span><span class="p">,</span> <span class="kt">Friend</span><span class="o">!</span>
</code></pre></div>
<p>Es gibt noch viel mehr in Haskell, wie zum Beispiel Typklassen und Monaden.
Dies sind die Ideen durch die Haskell Programmierung zum Spaß wird.
Mit dem folgenden kleinen Beispiel werde ich euch verlassen:
Quicksort in Haskell:</p>
<div class="highlight"><pre class="highlight haskell"><code><span class="n">qsort</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">qsort</span> <span class="p">(</span><span class="n">p</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">qsort</span> <span class="n">lesser</span> <span class="o">++</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">++</span> <span class="n">qsort</span> <span class="n">greater</span>
    <span class="kr">where</span> <span class="n">lesser</span>  <span class="o">=</span> <span class="n">filter</span> <span class="p">(</span><span class="o">&lt;</span> <span class="n">p</span><span class="p">)</span> <span class="n">xs</span>
          <span class="n">greater</span> <span class="o">=</span> <span class="n">filter</span> <span class="p">(</span><span class="o">&gt;=</span> <span class="n">p</span><span class="p">)</span> <span class="n">xs</span>
</code></pre></div>
<p>Haskell ist sehr einfach zu installieren.
Hol es dir von <a href="http://www.haskell.org/platform/">hier</a>.</p>

<p>Eine sehr viele langsamere Einführung findest du unter:
<a href="http://learnyouahaskell.com/">Learn you a Haskell</a> oder
<a href="http://book.realworldhaskell.org/">Real World Haskell</a>.</p>

    <hr>
    <p>Du hast einen Verbesserungsvorschlag oder einen Fehler gefunden? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Erstelle ein Ticket</a> im offiziellen Github Repo, oder du erstellst einfach gleich einen <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/de-de/haskell-de.html.markdown">pull request</a>!
    </p>
    <p class="contributed">
    Originalversion von Adit Bhargava, mit Updates von <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/de-de/haskell-de.html.markdown">3 contributor(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://adit.io">Adit Bhargava</a>
    </p>

    <p>
      Translated by:
        <a href="https://github.com/santifa">Henrik Jürges</a>
        <a href="http://weh.hamburg">Nikolai Weh</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
