<!DOCTYPE html lang="en-us" xml:lang="en-us" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="en-us">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn haxe in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/haxe/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fhaxe%2F&text=Learn+X+in+Y+minutes%2C+where+X%3Dhaxe">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="/">Learn X in Y minutes</a></h1>
  <h2>Where X=haxe</h2>
    <p class="filelink">
    Get the code:
    <a href="/docs/files/LearnHaxe3.hx">LearnHaxe3.hx</a>
    </p>
  <div id="doc">
    <p><a href="https://haxe.org/">Haxe</a> is a general-purpose language that provides platform support for C++, C#,
Swf/ActionScript, JavaScript, Java, PHP, Python, Lua, HashLink, and Neko bytecode
(the latter two being also written by the Haxe author). Note that this guide is for
Haxe version 3.  Some of the guide may be applicable to older versions, but it is
recommended to use other references.</p>
<div class="highlight"><pre class="highlight csharp"><code><span class="cm">/*
   Welcome to Learn Haxe 3 in 15 minutes.  http://www.haxe.org
   This is an executable tutorial.  You can compile and run it using the haxe
   compiler, while in the same directory as LearnHaxe.hx:

       $ haxe -main LearnHaxe3 --interp

   Look for the slash-star marks surrounding these paragraphs.  We are inside
   a "Multiline comment".  We can leave some notes here that will get ignored
   by the compiler.

   Multiline comments are also used to generate javadoc-style documentation for
   haxedoc.  They will be used for haxedoc if they immediately precede a class,
   class function, or class variable.
 */</span>

<span class="c1">// Double slashes like this will give a single-line comment.</span>

<span class="cm">/*
   This is your first actual haxe code coming up, it's declaring an empty
   package.  A package isn't necessary, but it's useful if you want to create
   a namespace for your code (e.g. org.yourapp.ClassName).

   Omitting package declaration is the same as declaring an empty package.
 */</span>
<span class="n">package</span><span class="p">;</span> <span class="c1">// empty package, no namespace.</span>

<span class="cm">/*
   Packages are directories that contain modules. Each module is a .hx file
   that contains types defined in a package. Package names (e.g. org.yourapp)
   must be lower case while module names are capitalized. A module contain one
   or more types whose names are also capitalized.

   E.g, the class "org.yourapp.Foo" should have the folder structure
   org/module/Foo.hx, as accessible from the compiler's working directory or
   class path.

   If you import code from other files, it must be declared before the rest of
   the code.  Haxe provides a lot of common default classes to get you started:
 */</span>
<span class="n">import</span> <span class="n">haxe</span><span class="p">.</span><span class="n">ds</span><span class="p">.</span><span class="n">ArraySort</span><span class="p">;</span>

<span class="c1">// you can import many classes/modules at once with "*"</span>
<span class="n">import</span> <span class="n">haxe</span><span class="p">.</span><span class="n">ds</span><span class="p">.*;</span>

<span class="c1">// you can import static fields</span>
<span class="n">import</span> <span class="n">Lambda</span><span class="p">.</span><span class="n">array</span><span class="p">;</span>

<span class="c1">// you can also use "*" to import all static fields</span>
<span class="n">import</span> <span class="n">Math</span><span class="p">.*;</span>

<span class="c1">// You can also import classes in a special way, enabling them to extend the</span>
<span class="c1">// functionality of other classes like a "mixin".  More on 'using' later.</span>
<span class="k">using</span> <span class="nn">StringTools</span><span class="p">;</span>

<span class="c1">// Typedefs are like variables... for types.  They must be declared before any</span>
<span class="c1">// code.  More on this later.</span>
<span class="n">typedef</span> <span class="n">FooString</span> <span class="p">=</span> <span class="n">String</span><span class="p">;</span>

<span class="c1">// Typedefs can also reference "structural" types, more on that later as well.</span>
<span class="n">typedef</span> <span class="n">FooObject</span> <span class="p">=</span> <span class="p">{</span> <span class="n">foo</span><span class="p">:</span> <span class="n">String</span> <span class="p">};</span>

<span class="c1">// Here's the class definition.  It's the main class for the file, since it has</span>
<span class="c1">// the same name (LearnHaxe3).</span>
<span class="k">class</span> <span class="nc">LearnHaxe3</span> <span class="p">{</span>
    <span class="cm">/*
       If you want certain code to run automatically, you need to put it in
       a static main function, and specify the class in the compiler arguments.
       In this case, we've specified the "LearnHaxe3" class in the compiler
       arguments above.
     */</span>
    <span class="k">static</span> <span class="n">function</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="cm">/*
           Trace is the default method of printing haxe expressions to the
           screen.  Different targets will have different methods of
           accomplishing this.  E.g., java, c++, c#, etc. will print to std
           out.  Javascript will print to console.log, and flash will print to
           an embedded TextField.  All traces come with a default newline.
           Finally, It's possible to prevent traces from showing by using the
           "--no-traces" argument on the compiler.
         */</span>
        <span class="nf">trace</span><span class="p">(</span><span class="s">"Hello World, with trace()!"</span><span class="p">);</span>

        <span class="c1">// Trace can handle any type of value or object.  It will try to print</span>
        <span class="c1">// a representation of the expression as best it can.  You can also</span>
        <span class="c1">// concatenate strings with the "+" operator:</span>
        <span class="nf">trace</span><span class="p">(</span><span class="s">"Integer: "</span> <span class="p">+</span> <span class="m">10</span> <span class="p">+</span> <span class="s">" Float: "</span> <span class="p">+</span> <span class="m">3.14</span> <span class="p">+</span> <span class="s">" Boolean: "</span> <span class="p">+</span> <span class="k">true</span><span class="p">);</span>

        <span class="c1">// In Haxe, it's required to separate expressions in the same block with</span>
        <span class="c1">// semicolons.  But, you can put two expressions on one line:</span>
        <span class="nf">trace</span><span class="p">(</span><span class="err">'</span><span class="n">two</span> <span class="n">expressions</span><span class="p">..</span><span class="err">'</span><span class="p">);</span> <span class="nf">trace</span><span class="p">(</span><span class="err">'</span><span class="n">one</span> <span class="n">line</span><span class="err">'</span><span class="p">);</span>


        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="c1">// Types &amp; Variables</span>
        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="nf">trace</span><span class="p">(</span><span class="s">"***Types &amp; Variables***"</span><span class="p">);</span>

        <span class="c1">// You can save values and references to data structures using the</span>
        <span class="c1">// "var" keyword:</span>
        <span class="kt">var</span> <span class="n">an_integer</span><span class="p">:</span><span class="n">Int</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">an_integer</span> <span class="p">+</span> <span class="s">" is the value for an_integer"</span><span class="p">);</span>

        <span class="cm">/*
           Haxe is statically typed, so "an_integer" is declared to have an
           "Int" type, and the rest of the expression assigns the value "1" to
           it.  It's not necessary to declare the type in many cases.  Here,
           the haxe compiler is inferring that the type of another_integer
           should be "Int".
         */</span>
        <span class="kt">var</span> <span class="n">another_integer</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">another_integer</span> <span class="p">+</span> <span class="s">" is the value for another_integer"</span><span class="p">);</span>

        <span class="c1">// The $type() method prints the type that the compiler assigns:</span>
        <span class="err">$</span><span class="nf">type</span><span class="p">(</span><span class="n">another_integer</span><span class="p">);</span>

        <span class="c1">// You can also represent integers with hexadecimal:</span>
        <span class="kt">var</span> <span class="n">hex_integer</span> <span class="p">=</span> <span class="m">0xffffff</span><span class="p">;</span>

        <span class="cm">/*
           Haxe uses platform precision for Int and Float sizes.  It also
           uses the platform behavior for overflow.
           (Other numeric types and behavior are possible using special
           libraries.)

           In addition to simple values like Integers, Floats, and Booleans,
           Haxe provides standard library implementations for common data
           structures like strings, arrays, lists, and maps:
         */</span>

        <span class="c1">// Strings can have double or single quotes.</span>
        <span class="kt">var</span> <span class="n">a_string</span> <span class="p">=</span> <span class="s">"some"</span> <span class="p">+</span> <span class="err">'</span><span class="kt">string</span><span class="err">'</span><span class="p">;</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">a_string</span> <span class="p">+</span> <span class="s">" is the value for a_string"</span><span class="p">);</span>

        <span class="c1">// Strings can be "interpolated" by inserting variables into specific</span>
        <span class="c1">// positions.  The string must be single quoted, and the variable must</span>
        <span class="c1">// be preceded with "$".  Expressions can be enclosed in ${...}.</span>
        <span class="kt">var</span> <span class="n">x</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
        <span class="kt">var</span> <span class="n">an_interpolated_string</span> <span class="p">=</span> <span class="err">'</span><span class="n">the</span> <span class="k">value</span> <span class="n">of</span> <span class="n">x</span> <span class="k">is</span> <span class="err">$</span><span class="n">x</span><span class="err">'</span><span class="p">;</span>
        <span class="kt">var</span> <span class="n">another_interpolated_string</span> <span class="p">=</span> <span class="err">'</span><span class="n">the</span> <span class="k">value</span> <span class="n">of</span> <span class="n">x</span> <span class="p">+</span> <span class="m">1</span> <span class="k">is</span> <span class="err">$</span><span class="p">{</span><span class="n">x</span> <span class="p">+</span> <span class="m">1</span><span class="p">}</span><span class="err">'</span><span class="p">;</span>

        <span class="c1">// Strings are immutable, instance methods will return a copy of</span>
        <span class="c1">// parts or all of the string. (See also the StringBuf class).</span>
        <span class="kt">var</span> <span class="n">a_sub_string</span> <span class="p">=</span> <span class="n">a_string</span><span class="p">.</span><span class="nf">substr</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">4</span><span class="p">);</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">a_sub_string</span> <span class="p">+</span> <span class="s">" is the value for a_sub_string"</span><span class="p">);</span>

        <span class="c1">// Regexes are also supported, but there's not enough space here to go</span>
        <span class="c1">// into much detail.</span>
        <span class="kt">var</span> <span class="n">re</span> <span class="p">=</span> <span class="p">~/</span><span class="n">foobar</span><span class="p">/;</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="err">'</span><span class="n">foo</span><span class="err">'</span><span class="p">)</span> <span class="p">+</span> <span class="s">" is the value for (~/foobar/.match('foo')))"</span><span class="p">);</span>

        <span class="c1">// Arrays are zero-indexed, dynamic, and mutable.  Missing values are</span>
        <span class="c1">// defined as null.</span>
        <span class="kt">var</span> <span class="n">a</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;();</span> <span class="c1">// an array that contains Strings</span>
        <span class="n">a</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="err">'</span><span class="n">foo</span><span class="err">'</span><span class="p">;</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">length</span> <span class="p">+</span> <span class="s">" is the value for a.length"</span><span class="p">);</span>
        <span class="n">a</span><span class="p">[</span><span class="m">9</span><span class="p">]</span> <span class="p">=</span> <span class="err">'</span><span class="n">bar</span><span class="err">'</span><span class="p">;</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">length</span> <span class="p">+</span> <span class="s">" is the value for a.length (after modification)"</span><span class="p">);</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="m">3</span><span class="p">]</span> <span class="p">+</span> <span class="s">" is the value for a[3]"</span><span class="p">);</span> <span class="c1">//null</span>

        <span class="c1">// Arrays are *generic*, so you can indicate which values they contain</span>
        <span class="c1">// with a type parameter:</span>
        <span class="kt">var</span> <span class="n">a2</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;();</span> <span class="c1">// an array of Ints</span>
        <span class="kt">var</span> <span class="n">a3</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;&gt;();</span> <span class="c1">// an Array of Arrays (of Strings).</span>

        <span class="c1">// Maps are simple key/value data structures.  The key and the value</span>
        <span class="c1">// can be of any type.</span>
        <span class="c1">// Here, the keys are strings, and the values are Ints:</span>
        <span class="kt">var</span> <span class="n">m</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Map</span><span class="p">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Int</span><span class="p">&gt;();</span>
        <span class="n">m</span><span class="p">.</span><span class="k">set</span><span class="p">(</span><span class="err">'</span><span class="n">foo</span><span class="err">'</span><span class="p">,</span> <span class="m">4</span><span class="p">);</span>
        <span class="c1">// You can also use array notation:</span>
        <span class="n">m</span><span class="p">[</span><span class="err">'</span><span class="n">bar</span><span class="err">'</span><span class="p">]</span> <span class="p">=</span> <span class="m">5</span><span class="p">;</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="nf">exists</span><span class="p">(</span><span class="err">'</span><span class="n">bar</span><span class="err">'</span><span class="p">)</span> <span class="p">+</span> <span class="s">" is the value for m.exists('bar')"</span><span class="p">);</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="err">'</span><span class="n">bar</span><span class="err">'</span><span class="p">)</span> <span class="p">+</span> <span class="s">" is the value for m.get('bar')"</span><span class="p">);</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="err">'</span><span class="n">bar</span><span class="err">'</span><span class="p">]</span> <span class="p">+</span> <span class="s">" is the value for m['bar']"</span><span class="p">);</span>

        <span class="kt">var</span> <span class="n">m2</span> <span class="p">=</span> <span class="p">[</span><span class="err">'</span><span class="n">foo</span><span class="err">'</span> <span class="p">=&gt;</span> <span class="m">4</span><span class="p">,</span> <span class="err">'</span><span class="n">baz</span><span class="err">'</span> <span class="p">=&gt;</span> <span class="m">6</span><span class="p">];</span> <span class="c1">// Alternative map syntax</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">m2</span> <span class="p">+</span> <span class="s">" is the value for m2"</span><span class="p">);</span>

        <span class="c1">// Remember, you can use type inference.  The Haxe compiler will</span>
        <span class="c1">// decide the type of the variable the first time you pass an</span>
        <span class="c1">// argument that sets a type parameter.</span>
        <span class="kt">var</span> <span class="n">m3</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Map</span><span class="p">();</span>
        <span class="n">m3</span><span class="p">.</span><span class="k">set</span><span class="p">(</span><span class="m">6</span><span class="p">,</span> <span class="err">'</span><span class="n">baz</span><span class="err">'</span><span class="p">);</span> <span class="c1">// m3 is now a Map&lt;Int,String&gt;</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">m3</span> <span class="p">+</span> <span class="s">" is the value for m3"</span><span class="p">);</span>

        <span class="c1">// Haxe has some more common datastructures in the haxe.ds module, such</span>
        <span class="c1">// as List, Stack, and BalancedTree.</span>


        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="c1">// Operators</span>
        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="nf">trace</span><span class="p">(</span><span class="s">"***OPERATORS***"</span><span class="p">);</span>

        <span class="c1">// basic arithmetic</span>
        <span class="nf">trace</span><span class="p">((</span><span class="m">4</span> <span class="p">+</span> <span class="m">3</span><span class="p">)</span> <span class="p">+</span> <span class="s">" is the value for (4 + 3)"</span><span class="p">);</span>
        <span class="nf">trace</span><span class="p">((</span><span class="m">5</span> <span class="p">-</span> <span class="m">1</span><span class="p">)</span> <span class="p">+</span> <span class="s">" is the value for (5 - 1)"</span><span class="p">);</span>
        <span class="nf">trace</span><span class="p">((</span><span class="m">2</span> <span class="p">*</span> <span class="m">4</span><span class="p">)</span> <span class="p">+</span> <span class="s">" is the value for (2 * 4)"</span><span class="p">);</span>
        <span class="c1">// Division always produces Floats.</span>
        <span class="nf">trace</span><span class="p">((</span><span class="m">8</span> <span class="p">/</span> <span class="m">3</span><span class="p">)</span> <span class="p">+</span> <span class="s">" is the value for (8 / 3) (a Float)"</span><span class="p">);</span>
        <span class="nf">trace</span><span class="p">((</span><span class="m">12</span> <span class="p">%</span> <span class="m">4</span><span class="p">)</span> <span class="p">+</span> <span class="s">" is the value for (12 % 4)"</span><span class="p">);</span>

        <span class="c1">// basic comparison</span>
        <span class="nf">trace</span><span class="p">((</span><span class="m">3</span> <span class="p">==</span> <span class="m">2</span><span class="p">)</span> <span class="p">+</span> <span class="s">" is the value for 3 == 2"</span><span class="p">);</span>
        <span class="nf">trace</span><span class="p">((</span><span class="m">3</span> <span class="p">!=</span> <span class="m">2</span><span class="p">)</span> <span class="p">+</span> <span class="s">" is the value for 3 != 2"</span><span class="p">);</span>
        <span class="nf">trace</span><span class="p">((</span><span class="m">3</span> <span class="p">&gt;</span>  <span class="m">2</span><span class="p">)</span> <span class="p">+</span> <span class="s">" is the value for 3 &gt; 2"</span><span class="p">);</span>
        <span class="nf">trace</span><span class="p">((</span><span class="m">3</span> <span class="p">&lt;</span>  <span class="m">2</span><span class="p">)</span> <span class="p">+</span> <span class="s">" is the value for 3 &lt; 2"</span><span class="p">);</span>
        <span class="nf">trace</span><span class="p">((</span><span class="m">3</span> <span class="p">&gt;=</span> <span class="m">2</span><span class="p">)</span> <span class="p">+</span> <span class="s">" is the value for 3 &gt;= 2"</span><span class="p">);</span>
        <span class="nf">trace</span><span class="p">((</span><span class="m">3</span> <span class="p">&lt;=</span> <span class="m">2</span><span class="p">)</span> <span class="p">+</span> <span class="s">" is the value for 3 &lt;= 2"</span><span class="p">);</span>

        <span class="c1">// standard bitwise operators</span>
        <span class="cm">/*
            ~       Unary bitwise complement
            &lt;&lt;      Signed left shift
            &gt;&gt;      Signed right shift
            &gt;&gt;&gt;     Unsigned right shift
            &amp;       Bitwise AND
            ^       Bitwise exclusive OR
            |       Bitwise inclusive OR
        */</span>

        <span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="nf">trace</span><span class="p">(</span><span class="s">"Pre-/Post- Increments and Decrements"</span><span class="p">);</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">i</span><span class="p">++);</span> <span class="c1">// i = 1. Post-Increment</span>
        <span class="nf">trace</span><span class="p">(++</span><span class="n">i</span><span class="p">);</span> <span class="c1">// i = 2. Pre-Increment</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">i</span><span class="p">--);</span> <span class="c1">// i = 1. Post-Decrement</span>
        <span class="nf">trace</span><span class="p">(--</span><span class="n">i</span><span class="p">);</span> <span class="c1">// i = 0. Pre-Decrement</span>


        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="c1">// Control Structures</span>
        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="nf">trace</span><span class="p">(</span><span class="s">"***CONTROL STRUCTURES***"</span><span class="p">);</span>

        <span class="c1">// if statements</span>
        <span class="kt">var</span> <span class="n">j</span> <span class="p">=</span> <span class="m">10</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="p">==</span> <span class="m">10</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">trace</span><span class="p">(</span><span class="s">"this is printed"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="p">&gt;</span> <span class="m">10</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">trace</span><span class="p">(</span><span class="s">"not greater than 10, so not printed"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">trace</span><span class="p">(</span><span class="s">"also not printed."</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// there is also a "ternary" if:</span>
        <span class="p">(</span><span class="n">j</span> <span class="p">==</span> <span class="m">10</span><span class="p">)</span> <span class="p">?</span> <span class="nf">trace</span><span class="p">(</span><span class="s">"equals 10"</span><span class="p">)</span> <span class="p">:</span> <span class="nf">trace</span><span class="p">(</span><span class="s">"not equals 10"</span><span class="p">);</span>

        <span class="c1">// Finally, there is another form of control structure that operates</span>
        <span class="c1">// at compile time:  conditional compilation.</span>
<span class="cp">#if neko
</span>        <span class="nf">trace</span><span class="p">(</span><span class="err">'</span><span class="n">hello</span> <span class="k">from</span> <span class="n">neko</span><span class="err">'</span><span class="p">);</span>
<span class="err">#</span><span class="n">elseif</span> <span class="n">js</span>
        <span class="nf">trace</span><span class="p">(</span><span class="err">'</span><span class="n">hello</span> <span class="k">from</span> <span class="n">js</span><span class="err">'</span><span class="p">);</span>
<span class="cp">#else
</span>        <span class="nf">trace</span><span class="p">(</span><span class="err">'</span><span class="n">hello</span> <span class="k">from</span> <span class="n">another</span> <span class="n">platform</span><span class="p">!</span><span class="err">'</span><span class="p">);</span>
<span class="err">#</span><span class="n">end</span>

        <span class="c1">// The compiled code will change depending on the platform target.</span>
        <span class="c1">// Since we're compiling for neko (-x or -neko), we only get the neko</span>
        <span class="c1">// greeting.</span>


        <span class="nf">trace</span><span class="p">(</span><span class="s">"Looping and Iteration"</span><span class="p">);</span>

        <span class="c1">// while loop</span>
        <span class="kt">var</span> <span class="n">k</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="p">&lt;</span> <span class="m">100</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// trace(counter); // will print out numbers 0-99</span>
            <span class="n">k</span><span class="p">++;</span>
        <span class="p">}</span>

        <span class="c1">// do-while loop</span>
        <span class="kt">var</span> <span class="n">l</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="k">do</span> <span class="p">{</span>
            <span class="nf">trace</span><span class="p">(</span><span class="s">"do statement always runs at least once"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">);</span>

        <span class="c1">// for loop</span>
        <span class="c1">// There is no c-style for loop in Haxe, because they are prone</span>
        <span class="c1">// to error, and not necessary.  Instead, Haxe has a much simpler</span>
        <span class="c1">// and safer version that uses Iterators (more on those later).</span>
        <span class="kt">var</span> <span class="n">m</span> <span class="p">=</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">val</span> <span class="k">in</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">trace</span><span class="p">(</span><span class="n">val</span> <span class="p">+</span> <span class="s">" is the value for val in the m array"</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Note that you can iterate on an index using a range</span>
        <span class="c1">// (more on ranges later as well)</span>
        <span class="kt">var</span> <span class="n">n</span> <span class="p">=</span> <span class="p">[</span><span class="err">'</span><span class="n">foo</span><span class="err">'</span><span class="p">,</span> <span class="err">'</span><span class="n">bar</span><span class="err">'</span><span class="p">,</span> <span class="err">'</span><span class="n">baz</span><span class="err">'</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">val</span> <span class="k">in</span> <span class="m">0.</span><span class="p">..</span><span class="n">n</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">trace</span><span class="p">(</span><span class="n">val</span> <span class="p">+</span> <span class="s">" is the value for val (an index for n)"</span><span class="p">);</span>
        <span class="p">}</span>


        <span class="nf">trace</span><span class="p">(</span><span class="s">"Array Comprehensions"</span><span class="p">);</span>

        <span class="c1">// Array comprehensions give you the ability to iterate over arrays</span>
        <span class="c1">// while also creating filters and modifications.</span>
        <span class="kt">var</span> <span class="n">filtered_n</span> <span class="p">=</span> <span class="p">[</span><span class="k">for</span> <span class="p">(</span><span class="n">val</span> <span class="k">in</span> <span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="p">!=</span> <span class="s">"foo"</span><span class="p">)</span> <span class="n">val</span><span class="p">];</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">filtered_n</span> <span class="p">+</span> <span class="s">" is the value for filtered_n"</span><span class="p">);</span>

        <span class="kt">var</span> <span class="n">modified_n</span> <span class="p">=</span> <span class="p">[</span><span class="k">for</span> <span class="p">(</span><span class="n">val</span> <span class="k">in</span> <span class="n">n</span><span class="p">)</span> <span class="n">val</span> <span class="p">+=</span> <span class="sc">'!'</span><span class="p">];</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">modified_n</span> <span class="p">+</span> <span class="s">" is the value for modified_n"</span><span class="p">);</span>

        <span class="kt">var</span> <span class="n">filtered_and_modified_n</span>
            <span class="p">=</span> <span class="p">[</span><span class="k">for</span> <span class="p">(</span><span class="n">val</span> <span class="k">in</span> <span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="p">!=</span> <span class="s">"foo"</span><span class="p">)</span> <span class="n">val</span> <span class="p">+=</span> <span class="s">"!"</span><span class="p">];</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">filtered_and_modified_n</span>
                <span class="p">+</span> <span class="s">" is the value for filtered_and_modified_n"</span><span class="p">);</span>


        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="c1">// Switch Statements (Value Type)</span>
        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="nf">trace</span><span class="p">(</span><span class="s">"***SWITCH STATEMENTS (VALUE TYPES)***"</span><span class="p">);</span>

        <span class="cm">/*
           Switch statements in Haxe are very powerful.  In addition to working
           on basic values like strings and ints, they can also work on the
           generalized algebraic data types in enums (more on enums later).
           Here are some basic value examples for now:
         */</span>
        <span class="kt">var</span> <span class="n">my_dog_name</span> <span class="p">=</span> <span class="s">"fido"</span><span class="p">;</span>
        <span class="kt">var</span> <span class="n">favorite_thing</span>  <span class="p">=</span> <span class="s">""</span><span class="p">;</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">my_dog_name</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="s">"fido"</span> <span class="p">:</span> <span class="n">favorite_thing</span> <span class="p">=</span> <span class="s">"bone"</span><span class="p">;</span>
            <span class="k">case</span> <span class="s">"rex"</span>  <span class="p">:</span> <span class="n">favorite_thing</span> <span class="p">=</span> <span class="s">"shoe"</span><span class="p">;</span>
            <span class="k">case</span> <span class="s">"spot"</span> <span class="p">:</span> <span class="n">favorite_thing</span> <span class="p">=</span> <span class="s">"tennis ball"</span><span class="p">;</span>
            <span class="k">default</span>     <span class="p">:</span> <span class="n">favorite_thing</span> <span class="p">=</span> <span class="s">"some unknown treat"</span><span class="p">;</span>
            <span class="c1">// same as default:</span>
            <span class="c1">// case _   : favorite_thing = "some unknown treat";</span>
        <span class="p">}</span>
        <span class="c1">// The "_" case above is a "wildcard" value that will match anything.</span>

        <span class="nf">trace</span><span class="p">(</span><span class="s">"My dog's name is "</span> <span class="p">+</span> <span class="n">my_dog_name</span>
                <span class="p">+</span> <span class="s">", and his favorite thing is a: "</span>
                <span class="p">+</span> <span class="n">favorite_thing</span><span class="p">);</span>


        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="c1">// Expression Statements</span>
        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="nf">trace</span><span class="p">(</span><span class="s">"***EXPRESSION STATEMENTS***"</span><span class="p">);</span>

        <span class="c1">// Haxe control statements are very powerful because every statement</span>
        <span class="c1">// is also an expression, consider:</span>

        <span class="c1">// if statements</span>
        <span class="kt">var</span> <span class="n">k</span> <span class="p">=</span> <span class="k">if</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="m">10</span> <span class="k">else</span> <span class="m">20</span><span class="p">;</span>

        <span class="nf">trace</span><span class="p">(</span><span class="s">"k equals "</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span> <span class="c1">// outputs 10</span>

        <span class="kt">var</span> <span class="n">other_favorite_thing</span> <span class="p">=</span> <span class="k">switch</span> <span class="p">(</span><span class="n">my_dog_name</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="s">"fido"</span> <span class="p">:</span> <span class="s">"teddy"</span><span class="p">;</span>
            <span class="k">case</span> <span class="s">"rex"</span>  <span class="p">:</span> <span class="s">"stick"</span><span class="p">;</span>
            <span class="k">case</span> <span class="s">"spot"</span> <span class="p">:</span> <span class="s">"football"</span><span class="p">;</span>
            <span class="k">default</span>     <span class="p">:</span> <span class="s">"some unknown treat"</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nf">trace</span><span class="p">(</span><span class="s">"My dog's name is "</span> <span class="p">+</span> <span class="n">my_dog_name</span>
                <span class="p">+</span> <span class="s">", and his other favorite thing is a: "</span>
                <span class="p">+</span> <span class="n">other_favorite_thing</span><span class="p">);</span>


        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="c1">// Converting Value Types</span>
        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="nf">trace</span><span class="p">(</span><span class="s">"***CONVERTING VALUE TYPES***"</span><span class="p">);</span>

        <span class="c1">// You can convert strings to ints fairly easily.</span>

        <span class="c1">// string to integer</span>
        <span class="n">Std</span><span class="p">.</span><span class="nf">parseInt</span><span class="p">(</span><span class="s">"0"</span><span class="p">);</span>     <span class="c1">// returns 0</span>
        <span class="n">Std</span><span class="p">.</span><span class="nf">parseFloat</span><span class="p">(</span><span class="s">"0.4"</span><span class="p">);</span> <span class="c1">// returns 0.4</span>

        <span class="c1">// integer to string</span>
        <span class="n">Std</span><span class="p">.</span><span class="kt">string</span><span class="p">(</span><span class="m">0</span><span class="p">);</span> <span class="c1">// returns "0"</span>
        <span class="c1">// concatenation with strings will auto-convert to string.</span>
        <span class="m">0</span> <span class="p">+</span> <span class="s">""</span><span class="p">;</span>    <span class="c1">// returns "0"</span>
        <span class="k">true</span> <span class="p">+</span> <span class="s">""</span><span class="p">;</span> <span class="c1">// returns "true"</span>
        <span class="c1">// See documentation for parsing in Std for more details.</span>


        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="c1">// Dealing with Types</span>
        <span class="c1">//////////////////////////////////////////////////////////////////</span>

        <span class="cm">/*
           As mentioned before, Haxe is a statically typed language.  All in
           all, static typing is a wonderful thing.  It enables
           precise autocompletions, and can be used to thoroughly check the
           correctness of a program.  Plus, the Haxe compiler is super fast.

           *HOWEVER*, there are times when you just wish the compiler would
           let something slide, and not throw a type error in a given case.

           To do this, Haxe has two separate keywords.  The first is the
           "Dynamic" type:
         */</span>
        <span class="kt">var</span> <span class="n">dyn</span><span class="p">:</span> <span class="n">Dynamic</span> <span class="p">=</span> <span class="s">"any type of variable, such as this string"</span><span class="p">;</span>

        <span class="cm">/*
           All that you know for certain with a Dynamic variable is that the
           compiler will no longer worry about what type it is. It is like a
           wildcard variable:  You can pass it instead of any variable type,
           and you can assign any variable type you want.

           The other more extreme option is the "untyped" keyword:
         */</span>
        <span class="n">untyped</span> <span class="p">{</span>
            <span class="kt">var</span> <span class="n">x</span><span class="p">:</span><span class="n">Int</span> <span class="p">=</span> <span class="err">'</span><span class="n">foo</span><span class="err">'</span><span class="p">;</span> <span class="c1">// This can't be right!</span>
            <span class="kt">var</span> <span class="n">y</span><span class="p">:</span><span class="n">String</span> <span class="p">=</span> <span class="m">4</span><span class="p">;</span>  <span class="c1">// Madness!</span>
        <span class="p">}</span>

        <span class="cm">/*
           The untyped keyword operates on entire *blocks* of code, skipping
           any type checks that might be otherwise required. This keyword should
           be used very sparingly, such as in limited conditionally-compiled
           situations where type checking is a hindrance.

           In general, skipping type checks is *not* recommended.  Use the
           enum, inheritance, or structural type models in order to help ensure
           the correctness of your program.  Only when you're certain that none
           of the type models work should you resort to "Dynamic" or "untyped".
         */</span>


        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="c1">// Basic Object Oriented Programming</span>
        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="nf">trace</span><span class="p">(</span><span class="s">"***BASIC OBJECT ORIENTED PROGRAMMING***"</span><span class="p">);</span>

        <span class="c1">// Create an instance of FooClass.  The classes for this are at the</span>
        <span class="c1">// end of the file.</span>
        <span class="kt">var</span> <span class="n">foo_instance</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">FooClass</span><span class="p">(</span><span class="m">3</span><span class="p">);</span>

        <span class="c1">// read the public variable normally</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">foo_instance</span><span class="p">.</span><span class="n">public_any</span>
                <span class="p">+</span> <span class="s">" is the value for foo_instance.public_any"</span><span class="p">);</span>

        <span class="c1">// we can read this variable</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">foo_instance</span><span class="p">.</span><span class="n">public_read</span>
                <span class="p">+</span> <span class="s">" is the value for foo_instance.public_read"</span><span class="p">);</span>
        <span class="c1">// but not write it; this will throw an error if uncommented:</span>
        <span class="c1">// foo_instance.public_read = 4;</span>
        <span class="c1">// trace(foo_instance.public_write); // as will this.</span>

        <span class="c1">// Calls the toString method:</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">foo_instance</span> <span class="p">+</span> <span class="s">" is the value for foo_instance"</span><span class="p">);</span>
        <span class="c1">// same thing:</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">foo_instance</span><span class="p">.</span><span class="nf">toString</span><span class="p">()</span>
                <span class="p">+</span> <span class="s">" is the value for foo_instance.toString()"</span><span class="p">);</span>

        <span class="c1">// The foo_instance has the "FooClass" type, while acceptBarInstance</span>
        <span class="c1">// has the BarClass type.  However, since FooClass extends BarClass, it</span>
        <span class="c1">// is accepted.</span>
        <span class="n">BarClass</span><span class="p">.</span><span class="nf">acceptBarInstance</span><span class="p">(</span><span class="n">foo_instance</span><span class="p">);</span>

        <span class="c1">// The classes below have some more advanced examples, the "example()"</span>
        <span class="c1">// method will just run them here.</span>
        <span class="n">SimpleEnumTest</span><span class="p">.</span><span class="nf">example</span><span class="p">();</span>
        <span class="n">ComplexEnumTest</span><span class="p">.</span><span class="nf">example</span><span class="p">();</span>
        <span class="n">TypedefsAndStructuralTypes</span><span class="p">.</span><span class="nf">example</span><span class="p">();</span>
        <span class="n">UsingExample</span><span class="p">.</span><span class="nf">example</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// This is the "child class" of the main LearnHaxe3 Class.</span>
<span class="k">class</span> <span class="nc">FooClass</span> <span class="n">extends</span> <span class="n">BarClass</span> <span class="n">implements</span> <span class="n">BarInterface</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">var</span> <span class="n">public_any</span><span class="p">:</span><span class="n">Int</span><span class="p">;</span> <span class="c1">// public variables are accessible anywhere</span>
    <span class="k">public</span> <span class="kt">var</span> <span class="nf">public_read</span> <span class="p">(</span><span class="k">default</span><span class="p">,</span> <span class="k">null</span><span class="p">):</span> <span class="n">Int</span><span class="p">;</span> <span class="c1">// enable only public read</span>
    <span class="k">public</span> <span class="kt">var</span> <span class="nf">public_write</span> <span class="p">(</span><span class="k">null</span><span class="p">,</span> <span class="k">default</span><span class="p">):</span> <span class="n">Int</span><span class="p">;</span> <span class="c1">// or only public write</span>
    <span class="c1">// Use this style to enable getters/setters:</span>
    <span class="k">public</span> <span class="kt">var</span> <span class="nf">property</span> <span class="p">(</span><span class="k">get</span><span class="p">,</span> <span class="k">set</span><span class="p">):</span> <span class="n">Int</span><span class="p">;</span>

    <span class="c1">// private variables are not available outside the class.</span>
    <span class="c1">// see @:allow for ways around this.</span>
    <span class="kt">var</span> <span class="n">_private</span><span class="p">:</span><span class="n">Int</span><span class="p">;</span> <span class="c1">// variables are private if they are not marked public</span>

    <span class="c1">// a public constructor</span>
    <span class="k">public</span> <span class="n">function</span> <span class="k">new</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span><span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// call the constructor of the parent object, since we extended BarClass:</span>
        <span class="nf">super</span><span class="p">();</span>

        <span class="k">this</span><span class="p">.</span><span class="n">public_any</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">_private</span> <span class="p">=</span> <span class="n">arg</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// getter for _private</span>
    <span class="n">function</span> <span class="nf">get_property</span><span class="p">()</span> <span class="p">:</span> <span class="n">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">_private</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// setter for _private</span>
    <span class="n">function</span> <span class="nf">set_property</span><span class="p">(</span><span class="n">val</span><span class="p">:</span><span class="n">Int</span><span class="p">)</span> <span class="p">:</span> <span class="n">Int</span> <span class="p">{</span>
        <span class="n">_private</span> <span class="p">=</span> <span class="n">val</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">val</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Special function that is called whenever an instance is cast to a string.</span>
    <span class="k">public</span> <span class="n">function</span> <span class="nf">toString</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">_private</span> <span class="p">+</span> <span class="s">" with toString() method!"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// this class needs to have this function defined, since it implements</span>
    <span class="c1">// the BarInterface interface.</span>
    <span class="k">public</span> <span class="n">function</span> <span class="nf">baseFunction</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">:</span> <span class="n">String</span> <span class="p">{</span>
        <span class="c1">// convert the int to string automatically</span>
        <span class="k">return</span> <span class="n">x</span> <span class="p">+</span> <span class="s">" was passed into baseFunction!"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// A simple class to extend.</span>
<span class="k">class</span> <span class="nc">BarClass</span> <span class="p">{</span>
    <span class="kt">var</span> <span class="n">base_variable</span><span class="p">:</span><span class="n">Int</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">function</span> <span class="k">new</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">base_variable</span> <span class="p">=</span> <span class="m">4</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">function</span> <span class="nf">acceptBarInstance</span><span class="p">(</span><span class="n">b</span><span class="p">:</span><span class="n">BarClass</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// A simple interface to implement</span>
<span class="k">interface</span> <span class="nc">BarInterface</span> <span class="p">{</span>
    <span class="k">public</span> <span class="n">function</span> <span class="nf">baseFunction</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="n">Int</span><span class="p">):</span><span class="n">String</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">//////////////////////////////////////////////////////////////////</span>
<span class="c1">// Enums and Switch Statements</span>
<span class="c1">//////////////////////////////////////////////////////////////////</span>

<span class="c1">// Enums in Haxe are very powerful.  In their simplest form, enums</span>
<span class="c1">// are a type with a limited number of states:</span>
<span class="k">enum</span> <span class="n">SimpleEnum</span> <span class="p">{</span>
    <span class="n">Foo</span><span class="p">;</span>
    <span class="n">Bar</span><span class="p">;</span>
    <span class="n">Baz</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//   Here's a class that uses it:</span>
<span class="k">class</span> <span class="nc">SimpleEnumTest</span> <span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">function</span> <span class="nf">example</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// You can specify the "full" name,</span>
        <span class="kt">var</span> <span class="n">e_explicit</span><span class="p">:</span><span class="n">SimpleEnum</span> <span class="p">=</span> <span class="n">SimpleEnum</span><span class="p">.</span><span class="n">Foo</span><span class="p">;</span>
        <span class="kt">var</span> <span class="n">e</span> <span class="p">=</span> <span class="n">Foo</span><span class="p">;</span> <span class="c1">// but inference will work as well.</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="n">Foo</span><span class="p">:</span> <span class="nf">trace</span><span class="p">(</span><span class="s">"e was Foo"</span><span class="p">);</span>
            <span class="k">case</span> <span class="n">Bar</span><span class="p">:</span> <span class="nf">trace</span><span class="p">(</span><span class="s">"e was Bar"</span><span class="p">);</span>
            <span class="k">case</span> <span class="n">Baz</span><span class="p">:</span> <span class="nf">trace</span><span class="p">(</span><span class="s">"e was Baz"</span><span class="p">);</span> <span class="c1">// comment this line to throw an error.</span>
        <span class="p">}</span>

        <span class="cm">/*
           This doesn't seem so different from simple value switches on strings.
           However, if we don't include *all* of the states, the compiler will
           complain.  You can try it by commenting out a line above.

           You can also specify a default for enum switches as well:
         */</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="n">Foo</span><span class="p">:</span> <span class="nf">trace</span><span class="p">(</span><span class="s">"e was Foo again"</span><span class="p">);</span>
            <span class="k">default</span> <span class="p">:</span> <span class="nf">trace</span><span class="p">(</span><span class="s">"default works here too"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Enums go much further than simple states, we can also enumerate</span>
<span class="c1">// *constructors*, but we'll need a more complex enum example.</span>
<span class="k">enum</span> <span class="n">ComplexEnum</span> <span class="p">{</span>
    <span class="nf">IntEnum</span><span class="p">(</span><span class="n">i</span><span class="p">:</span><span class="n">Int</span><span class="p">);</span>
    <span class="nf">MultiEnum</span><span class="p">(</span><span class="n">i</span><span class="p">:</span><span class="n">Int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span><span class="n">String</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span><span class="n">Float</span><span class="p">);</span>
    <span class="nf">SimpleEnumEnum</span><span class="p">(</span><span class="n">s</span><span class="p">:</span><span class="n">SimpleEnum</span><span class="p">);</span>
    <span class="nf">ComplexEnumEnum</span><span class="p">(</span><span class="n">c</span><span class="p">:</span><span class="n">ComplexEnum</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// Note: The enum above can include *other* enums as well, including itself!</span>
<span class="c1">// Note: This is what's called *Algebraic data type* in some other languages.</span>

<span class="k">class</span> <span class="nc">ComplexEnumTest</span> <span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">function</span> <span class="nf">example</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">var</span> <span class="n">e1</span><span class="p">:</span><span class="n">ComplexEnum</span> <span class="p">=</span> <span class="nf">IntEnum</span><span class="p">(</span><span class="m">4</span><span class="p">);</span> <span class="c1">// specifying the enum parameter</span>
        <span class="c1">// Now we can switch on the enum, as well as extract any parameters</span>
        <span class="c1">// it might have had.</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">e1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="nf">IntEnum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">:</span> <span class="nf">trace</span><span class="p">(</span><span class="err">'$</span><span class="n">x</span> <span class="n">was</span> <span class="n">the</span> <span class="n">parameter</span> <span class="n">passed</span> <span class="n">to</span> <span class="n">e1</span><span class="err">'</span><span class="p">);</span>
            <span class="k">default</span><span class="p">:</span> <span class="nf">trace</span><span class="p">(</span><span class="s">"Shouldn't be printed"</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// another parameter here that is itself an enum... an enum enum?</span>
        <span class="kt">var</span> <span class="n">e2</span> <span class="p">=</span> <span class="nf">SimpleEnumEnum</span><span class="p">(</span><span class="n">Foo</span><span class="p">);</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">e2</span><span class="p">){</span>
            <span class="k">case</span> <span class="nf">SimpleEnumEnum</span><span class="p">(</span><span class="n">s</span><span class="p">):</span> <span class="nf">trace</span><span class="p">(</span><span class="err">'$</span><span class="n">s</span> <span class="n">was</span> <span class="n">the</span> <span class="n">parameter</span> <span class="n">passed</span> <span class="n">to</span> <span class="n">e2</span><span class="err">'</span><span class="p">);</span>
            <span class="k">default</span><span class="p">:</span> <span class="nf">trace</span><span class="p">(</span><span class="s">"Shouldn't be printed"</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// enums all the way down</span>
        <span class="kt">var</span> <span class="n">e3</span> <span class="p">=</span> <span class="nf">ComplexEnumEnum</span><span class="p">(</span><span class="nf">ComplexEnumEnum</span><span class="p">(</span><span class="nf">MultiEnum</span><span class="p">(</span><span class="m">4</span><span class="p">,</span> <span class="err">'</span><span class="n">hi</span><span class="err">'</span><span class="p">,</span> <span class="m">4.3</span><span class="p">)));</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">e3</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// You can look for certain nested enums by specifying them</span>
            <span class="c1">//  explicitly:</span>
            <span class="k">case</span> <span class="nf">ComplexEnumEnum</span><span class="p">(</span><span class="nf">ComplexEnumEnum</span><span class="p">(</span><span class="nf">MultiEnum</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)))</span> <span class="p">:</span> <span class="p">{</span>
                <span class="nf">trace</span><span class="p">(</span><span class="err">'$</span><span class="n">i</span><span class="p">,</span> <span class="err">$</span><span class="n">j</span><span class="p">,</span> <span class="n">and</span> <span class="err">$</span><span class="n">k</span> <span class="n">were</span> <span class="n">passed</span> <span class="k">into</span> <span class="k">this</span> <span class="n">nested</span> <span class="n">monster</span><span class="err">'</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">default</span><span class="p">:</span> <span class="nf">trace</span><span class="p">(</span><span class="s">"Shouldn't be printed"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// Check out "generalized algebraic data types" (GADT) for more details</span>
        <span class="c1">// on why these are so great.</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">TypedefsAndStructuralTypes</span> <span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">function</span> <span class="nf">example</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Here we're going to use typedef types, instead of base types.</span>
        <span class="c1">// At the top we've declared the type "FooString" to mean a "String" type.</span>
        <span class="kt">var</span> <span class="n">t1</span><span class="p">:</span><span class="n">FooString</span> <span class="p">=</span> <span class="s">"some string"</span><span class="p">;</span>

        <span class="c1">// We can use typedefs for "structural types" as well.  These types are</span>
        <span class="c1">// defined by their field structure, not by class inheritance.  Here's</span>
        <span class="c1">// an anonymous object with a String field named "foo":</span>
        <span class="kt">var</span> <span class="n">anon_obj</span> <span class="p">=</span> <span class="p">{</span> <span class="n">foo</span><span class="p">:</span> <span class="err">'</span><span class="n">hi</span><span class="err">'</span> <span class="p">};</span>

        <span class="cm">/*
           The anon_obj variable doesn't have a type declared, and is an
           anonymous object according to the compiler.  However, remember back at
           the top where we declared the FooObj typedef?  Since anon_obj matches
           that structure, we can use it anywhere that a "FooObject" type is
           expected.
         */</span>
        <span class="kt">var</span> <span class="n">f</span> <span class="p">=</span> <span class="nf">function</span><span class="p">(</span><span class="n">fo</span><span class="p">:</span><span class="n">FooObject</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">trace</span><span class="p">(</span><span class="err">'$</span><span class="n">fo</span> <span class="n">was</span> <span class="n">passed</span> <span class="k">in</span> <span class="n">to</span> <span class="k">this</span> <span class="n">function</span><span class="err">'</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nf">f</span><span class="p">(</span><span class="n">anon_obj</span><span class="p">);</span> <span class="c1">// call the FooObject signature function with anon_obj.</span>

        <span class="cm">/*
           Note that typedefs can have optional fields as well, marked with "?"

           typedef OptionalFooObj = {
                ?optionalString: String,
                requiredInt: Int
           }

           Typedefs work well with conditional compilation.  For instance,
           we could have included this at the top of the file:

#if( js )
        typedef Surface = js.html.CanvasRenderingContext2D;
#elseif( nme )
        typedef Surface = nme.display.Graphics;
#elseif( !flash9 )
        typedef Surface = flash8.MovieClip;
#elseif( java )
        typedef Surface = java.awt.geom.GeneralPath;
#end

           That would give us a single "Surface" type to work with across
           all of those platforms.
         */</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">UsingExample</span> <span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">function</span> <span class="nf">example</span><span class="p">()</span> <span class="p">{</span>
        <span class="cm">/*
           The "using" import keyword is a special type of class import that
           alters the behavior of any static methods in the class.

           In this file, we've applied "using" to "StringTools", which contains
           a number of static methods for dealing with String types.
         */</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">StringTools</span><span class="p">.</span><span class="nf">endsWith</span><span class="p">(</span><span class="s">"foobar"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">)</span> <span class="p">+</span> <span class="s">" should be true!"</span><span class="p">);</span>

        <span class="cm">/*
           With a "using" import, the first argument type is extended with the
           method.  What does that mean?  Well, since "endsWith" has a first
           argument type of "String", that means all String types now have the
           "endsWith" method:
         */</span>
        <span class="nf">trace</span><span class="p">(</span><span class="s">"foobar"</span><span class="p">.</span><span class="nf">endsWith</span><span class="p">(</span><span class="s">"bar"</span><span class="p">)</span> <span class="p">+</span> <span class="s">" should be true!"</span><span class="p">);</span>

        <span class="cm">/*
           This technique enables a good deal of expression for certain types,
           while limiting the scope of modifications to a single file.

           Note that the String instance is *not* modified in the run time.
           The newly attached method is not really part of the attached
           instance, and the compiler still generates code equivalent to a
           static method.
         */</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>We&rsquo;re still only scratching the surface here of what Haxe can do.  For a formal
overview of all Haxe features, see the <a href="https://haxe.org/manual">manual</a> and
the <a href="https://api.haxe.org/">API docs</a>. For a comprehensive directory of available
third-party Haxe libraries, see <a href="https://lib.haxe.org/">Haxelib</a>.</p>

<p>For more advanced topics, consider checking out:</p>

<ul>
<li><a href="https://haxe.org/manual/types-abstract.html">Abstract types</a></li>
<li><a href="https://haxe.org/manual/macro.html">Macros</a></li>
<li><a href="https://haxe.org/manual/cr-features.html">Compiler Features</a></li>
</ul>

<p>Finally, please join us on <a href="https://community.haxe.org/">the Haxe forum</a>,
on IRC <a href="http://webchat.freenode.net/">#haxe on
freenode</a>, or on the
<a href="https://gitter.im/HaxeFoundation/haxe">Haxe Gitter chat</a>.</p>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/haxe.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by Justin Donaldson, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/haxe.html.markdown">9 contributor(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="https://github.com/jdonaldson/">Justin Donaldson</a>,
        <a href="https://github.com/nadako/">Dan Korostelev</a>
    </p>

    <p>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
