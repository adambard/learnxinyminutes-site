<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="sv-se" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="sv-se" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="sv-se" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="sv-se" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="sv-se">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Haskell in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/sv-se/haskell-sv/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fsv-se%2Fhaskell-sv%2F&text=Learn+X+in+Y+minutes%2C+where+X%3DHaskell">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="/">Learn X in Y minutes</a></h1>
  <h2>Where X=Haskell</h2>
    <p class="filelink">
    Get the code:
    <a href="/docs/files/learnhaskell-sv.hs">learnhaskell-sv.hs</a>
    </p>
  <div id="doc">
    <p>Haskell skapades för att vara ett praktiskt, rent, funktionellt
programmeringsspråk. Det är känt för sin använding av monader och dess
härledande typsystem men anledningen till att jag ständigt återbesöker språket
är på grund av dess elegans. Haskell gör programmering till ett rent nöje.</p>
<div class="highlight"><pre><span></span><span class="c1">-- Radkommenterar börjar med två bindestreck.</span>
<span class="cm">{- Flerradskommentarer innesluts av vänster/höger måsvinge bindestreck</span>
<span class="cm">block på detta vis.</span>
<span class="cm">-}</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 1. Fördefinierade datatyper och operatorer</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Du har siffror</span>
<span class="mi">3</span><span class="w"> </span><span class="c1">-- 3</span>

<span class="c1">-- Matte fungerar som förväntat</span>
<span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">-- 2</span>
<span class="mi">8</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">-- 7</span>
<span class="mi">10</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="c1">-- 20</span>
<span class="mi">35</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="c1">-- 7.0</span>

<span class="c1">-- Division är normalt inte heltalsdivision</span>
<span class="mi">35</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="c1">-- 8.75</span>

<span class="c1">-- Heltalsdivision, här infix div</span>
<span class="mi">35</span><span class="w"> </span><span class="p">`</span><span class="n">div</span><span class="p">`</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="c1">-- 8</span>

<span class="c1">-- Boolar (Sant och Falskt) är fördefinierade</span>
<span class="kt">True</span>
<span class="kt">False</span>

<span class="c1">-- Samt dess operationer</span>
<span class="nf">not</span><span class="w"> </span><span class="kt">True</span><span class="w"> </span><span class="c1">-- False</span>
<span class="nf">not</span><span class="w"> </span><span class="kt">False</span><span class="w"> </span><span class="c1">-- True</span>
<span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">-- True</span>
<span class="mi">1</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">-- False</span>
<span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="c1">-- True</span>

<span class="c1">-- I ovanstående exempel är `not` en funktion vilken bara tar ett argument.</span>
<span class="c1">-- Haskell behöver inte paranteser för sina funktionsanrop... alla argument</span>
<span class="c1">-- ges mellanslagsseparerade direkt efter funktionen. Det övergripande mönstret</span>
<span class="c1">-- är:</span>
<span class="c1">-- func arg1 arg2 arg3...</span>
<span class="c1">-- Se sektionen om funktioner för information om hur du skriver dina egna.</span>

<span class="c1">-- Strängar och bokstäver</span>
<span class="s">&quot;Detta är en sträng&quot;</span>
<span class="sc">&#39;a&#39;</span><span class="w"> </span><span class="c1">-- bokstav</span>
<span class="kt">&#39;Du</span><span class="w"> </span><span class="n">kan</span><span class="w"> </span><span class="n">inte</span><span class="w"> </span><span class="n">använda</span><span class="w"> </span><span class="n">enkelfnutt</span><span class="w"> </span><span class="n">för</span><span class="w"> </span><span class="n">strängar</span><span class="o">.</span><span class="sc">&#39;</span><span class="err"> -- fel!</span>

<span class="c1">-- Strängar kan konkateneras</span>
<span class="s">&quot;Hej &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s">&quot;världen!&quot;</span><span class="w"> </span><span class="c1">-- &quot;Hej världen!&quot;</span>

<span class="c1">-- En sträng är en lista av bokstäver</span>
<span class="p">[</span><span class="sc">&#39;H&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;e&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;j&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;s&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;n&#39;</span><span class="p">]</span><span class="w"> </span><span class="c1">-- &quot;Hejsan&quot;</span>
<span class="s">&quot;Detta är en sträng&quot;</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="c1">-- &#39;D&#39;</span>


<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 2. Listor och Tupler</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Varje element i en lista måste ha samma typ.</span>
<span class="c1">-- Dessa listor är ekvivalenta:</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>

<span class="c1">-- Intervall är mångsidiga.</span>
<span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;F&#39;</span><span class="p">]</span><span class="w"> </span><span class="c1">-- &quot;ABCDEF&quot;</span>

<span class="c1">-- Man kan stega intervall.</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [0, 2, 4, 6, 8, 10]</span>
<span class="p">[</span><span class="mi">5</span><span class="o">..</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [] (Haskell förutsätter normalt inkrement)</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="o">..</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [5, 4, 3, 2, 1]</span>

<span class="c1">-- Indexering in i en lista</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">-- 4 (nollindexerat)</span>

<span class="c1">-- Man kan ha oändliga listor i Haskell!</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span><span class="w"> </span><span class="c1">-- listan över alla naturliga tal</span>

<span class="c1">-- Oändliga listor fungerar enbart för att Haskell har &quot;lat evaluering&quot;.</span>
<span class="c1">-- Det betyder att Haskell bara evaluerar de uttryck den måste. Du kan alltså</span>
<span class="c1">-- fråga efter det 1000:e elementet i en oändlig lista och Haskell kommer då ge</span>
<span class="c1">-- dig det:</span>

<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="mi">999</span><span class="w"> </span><span class="c1">-- 1000</span>

<span class="c1">-- Nu har Haskell evaluerat element 1 till 1000 i denna lista... men resten</span>
<span class="c1">-- av medlemmarna i denna oändliga lista existerar inte ännu! Haskell kommer</span>
<span class="c1">-- faktiskt inte utvärdera element den inte måste.</span>

<span class="c1">-- Sammanslagning av två listor</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="mi">6</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>

<span class="c1">-- Lägg till 0 vid listhuvudet</span>
<span class="mi">0</span><span class="kt">:</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [0, 1, 2, 3, 4, 5]</span>

<span class="c1">-- fler listoperationer som huvud, svans, initiella samt sista</span>
<span class="nf">head</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- 1</span>
<span class="nf">tail</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [2, 3, 4, 5]</span>
<span class="nf">init</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [1, 2, 3, 4]</span>
<span class="nf">last</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- 5</span>

<span class="c1">-- listomfattningar</span>
<span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]]</span><span class="w"> </span><span class="c1">-- [2, 4, 6, 8, 10]</span>

<span class="c1">-- med bivilkor</span>
<span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [6, 8, 10]</span>

<span class="c1">-- Varje element i en tupel kan ha olika typ men en tupel kan bara ha en</span>
<span class="c1">-- fixerad, eller statisk, längd.</span>
<span class="c1">-- En tupel:</span>
<span class="p">(</span><span class="s">&quot;haskell&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="c1">-- För att komma åt element i ett par, alltså en 2-tupel, finns</span>
<span class="c1">-- de fördefinierade funktionerna:</span>
<span class="nf">fst</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;haskell&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">-- &quot;haskell&quot;</span>
<span class="nf">snd</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;haskell&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">-- 1</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 3. Funktioner</span>
<span class="c1">----------------------------------------------------</span>
<span class="c1">-- En enkel funktion med två parametrar</span>
<span class="nf">add</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span>

<span class="c1">-- Notera även att om du använder ghci (Haskellinterpretatorn) kommer du behöva</span>
<span class="c1">-- använda `let` namnbindning för att synliggöra din funktionsdeklaration,</span>
<span class="c1">-- alltså</span>
<span class="kr">let</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span>

<span class="c1">-- För att använda funktionen</span>
<span class="nf">add</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="c1">-- 3</span>

<span class="c1">-- Man kan även göra funktionsanropet infix, alltså mellan parametersättningen,</span>
<span class="c1">-- med hjälp av bakåtfnuttar:</span>
<span class="mi">1</span><span class="w"> </span><span class="p">`</span><span class="n">add</span><span class="p">`</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="c1">-- 3</span>

<span class="c1">-- Du kan även definiera funktioner vars funktionsnamn avsaknar bokstäver!</span>
<span class="c1">-- Med hjälp av parenteser kan du därmed definiera operatorer (normalt infix)!</span>
<span class="c1">-- Följande är en operator för heltalsdivision, vilken förlitar sig på div:</span>
<span class="p">(</span><span class="o">//</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">`</span><span class="n">div</span><span class="p">`</span><span class="w"> </span><span class="n">b</span>
<span class="mi">35</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="c1">-- 8</span>

<span class="c1">-- Funktionsvakter: ett enkelt sätt att grena ut dina funktioner</span>
<span class="nf">fib</span><span class="w"> </span><span class="n">x</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>

<span class="c1">-- Mönstermatchning fungerar på liknande vis. Här ger vi tre olika</span>
<span class="c1">-- parametermatchningar för vårat fib-resulat. Haskell kommer automatiskt följa</span>
<span class="c1">-- första bästa träff, uppifrån ned, vars vänstra sida om likhetstecknet matchar</span>
<span class="c1">-- anroparens parametervärde.</span>
<span class="nf">fib</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>
<span class="nf">fib</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span>
<span class="nf">fib</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>

<span class="c1">-- Mönstermatchning på tupler:</span>
<span class="nf">foo</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>

<span class="c1">-- Mönstermatchning på listor. Här är `x` det första elementet i listan och `xs`</span>
<span class="c1">-- är resten av listan. Nu kan vi skriva våran egen map-funktion</span>
<span class="nf">minMap</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span>
<span class="nf">minMap</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="n">x</span><span class="kt">:</span><span class="p">(</span><span class="n">minMap</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span>

<span class="c1">-- Anonyma funktioner, eller lambdauttryck, skapas med hjälp av omvänt</span>
<span class="c1">-- snedstreck, följt av parametrarna</span>
<span class="nf">minMap</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [3, 4, 5, 6, 7]</span>

<span class="c1">-- Användning av fold (även kallad `inject`, `reduce`, osv.) tillsammans med en</span>
<span class="c1">-- anonym funktion. `fold1` är en vänstervikande funktion och använder första</span>
<span class="c1">-- värdet i listan som det initiella värdet för ackumulatorn.</span>
<span class="nf">foldl1</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">acc</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- 15</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 4. Mer funktioner</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Partiell applikation:</span>
<span class="c1">-- Om du inte anropar funktionen med alla sina argument</span>
<span class="c1">-- blir den partiellt applicerad. Det betyder att du erhåller en funktion där en</span>
<span class="c1">-- delmängd av parametrarna blivit värdesatta men några är fortfarande fria.</span>
<span class="nf">add</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="c1">-- foo är nu en funktion som tar ett nummer och lägger till 10 till</span>
<span class="w">             </span><span class="c1">-- det</span>
<span class="nf">foo</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="c1">-- 15</span>

<span class="c1">-- Ett annat sätt att skriva samma sak</span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="mi">10</span><span class="o">+</span><span class="p">)</span>
<span class="nf">foo</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="c1">-- 15</span>

<span class="c1">-- Funktionskomposition:</span>
<span class="c1">-- Operatorn `.` kedjar ihop funktioner</span>
<span class="c1">-- Till exempel, nedan är `foo` en funktion som tar ett värde, den adderar 10</span>
<span class="c1">-- till det, multiplicerar det resultatet med 4 och sen ersätts med det värdet.</span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="mi">10</span><span class="o">+</span><span class="p">)</span>

<span class="c1">-- 4*(10+5) = 60</span>
<span class="nf">foo</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="c1">-- 60</span>

<span class="c1">-- Precedensordning:</span>
<span class="c1">-- Haskell har en operator `$`. Denna operator applicerar en funktion till en</span>
<span class="c1">-- given parameter med dess precedens. I kontrast mot vanlig</span>
<span class="c1">-- funktionsapplikation, vilket har den högsta utvärderingsprioriteten 10 och</span>
<span class="c1">-- associerar till vänster, har denna prioritetsordning 0 och är</span>
<span class="c1">-- högerassociativ. Denna låga prioritet medför att parameteruttrycket till</span>
<span class="c1">-- höger om operatorn får det reducerat innan det appliceras till sin vänster.</span>

<span class="c1">-- före</span>
<span class="nf">even</span><span class="w"> </span><span class="p">(</span><span class="n">fib</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="c1">-- falskt</span>

<span class="c1">-- ekvivalent</span>
<span class="nf">even</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="c1">-- falskt</span>

<span class="c1">-- med funktionskomposition</span>
<span class="nf">even</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="c1">-- falskt</span>


<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 5. Typsignaturer</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Haskell har ett väldigt starkt typsystem, alla giltiga uttryck har en typ.</span>

<span class="c1">-- Några grundläggande typer:</span>
<span class="mi">5</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span>
<span class="s">&quot;hello&quot;</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">String</span>
<span class="kt">True</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Bool</span>

<span class="c1">-- Funktioner har också typer,</span>
<span class="c1">-- `not` tar en bool och returnerar en bool:</span>
<span class="c1">-- not :: Bool -&gt; Bool</span>

<span class="c1">-- Här är ett exempel på en funktionssignatur vilken beskriver en funktion som</span>
<span class="c1">-- reducerar två heltal till ett:</span>
<span class="c1">-- add :: Integer -&gt; Integer -&gt; Integer</span>

<span class="c1">-- Trots att Haskell härleder typen på icke typsatta uttryck är det bra form att</span>
<span class="c1">-- explicit ange dessa för ens deklarerade funktioner:</span>
<span class="nf">double</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span>
<span class="nf">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 6. Kontrollflöde och Ifsatser</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- if-sats</span>
<span class="nf">haskell</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="s">&quot;awesome&quot;</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="s">&quot;awful&quot;</span><span class="w"> </span><span class="c1">-- haskell = &quot;awesome&quot;</span>

<span class="c1">-- if-statser kan spridas över rader men indentering har betydelse</span>
<span class="nf">haskell</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span>
<span class="w">            </span><span class="kr">then</span><span class="w"> </span><span class="s">&quot;awesome&quot;</span>
<span class="w">            </span><span class="kr">else</span><span class="w"> </span><span class="s">&quot;awful&quot;</span>

<span class="c1">-- case uttryck: följande är ett exempel på kommandoradsparsning</span>
<span class="kr">case</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="kr">of</span>
<span class="w">  </span><span class="s">&quot;help&quot;</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">printHelp</span>
<span class="w">  </span><span class="s">&quot;start&quot;</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">startProgram</span>
<span class="w">  </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;bad args&quot;</span>

<span class="c1">-- Haskell har inte loopar istället används recursion.</span>
<span class="c1">-- map applicerar en funktion över varje element i en lista</span>

<span class="nf">map</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [2, 4, 6, 8, 10]</span>

<span class="c1">-- man kan deklarera en for funktion genom att använda map</span>
<span class="nf">for</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="n">array</span>

<span class="c1">-- och därefter använda den tillsammans med en anonym funktion för att</span>
<span class="c1">-- efterlikna en loop</span>
<span class="nf">for</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="nf">\</span><span class="n">i</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="n">i</span>

<span class="c1">-- men vi kunde även ha skrivit på följande vis:</span>
<span class="nf">for</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="n">show</span>

<span class="c1">-- Du kan använda foldl eller foldr för att reducera en lista</span>
<span class="c1">-- foldl &lt;fn&gt; &lt;initial value&gt; &lt;list&gt;</span>
<span class="nf">foldl</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="c1">-- 43</span>

<span class="c1">-- Vilket är samma sak som</span>
<span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>

<span class="c1">-- foldl viker från vänster, foldr från höger</span>
<span class="nf">foldr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="c1">-- 16</span>

<span class="c1">-- Vilket alltså är samma sak som</span>
<span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">)))</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 7. Datatyper</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Såhär definierar du din egen datatyp i Haskell</span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Color</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Red</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Blue</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Green</span>

<span class="c1">-- När du gjort det kan du använda den i funktionssignaturer och uttryck</span>
<span class="nf">say</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Color</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span>
<span class="nf">say</span><span class="w"> </span><span class="kt">Red</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Du är Rö!&quot;</span>
<span class="nf">say</span><span class="w"> </span><span class="kt">Blue</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Du är Blå!&quot;</span>
<span class="nf">say</span><span class="w"> </span><span class="kt">Green</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Du är Grön!&quot;</span>

<span class="c1">-- Dina datatyper kan även ta parametrar</span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Nothing</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="n">a</span>

<span class="c1">-- Följande uttryck är alla specialiseringar av typen Maybe</span>
<span class="kt">Just</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="w">    </span><span class="c1">-- har typen `Maybe String`</span>
<span class="kt">Just</span><span class="w"> </span><span class="mi">1</span><span class="w">          </span><span class="c1">-- har typen `Maybe Int`</span>
<span class="kt">Nothing</span><span class="w">         </span><span class="c1">-- har typen `Maybe a` för alla `a`</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 8. Haskell IO</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Även om IO inte kan förstås fullt ut utan att först förklara monader är det</span>
<span class="c1">-- inte svårt att lära sig tillräckligt för att komma igång</span>

<span class="c1">-- När ett Haskellprogram körs är det topnivåns main som körs. Main måste</span>
<span class="c1">-- returnerna ett värde av typen `IO a`, för någon typ `a`. Till exempel:</span>

<span class="nf">main</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span>
<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">putStrLn</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="s">&quot;Hej, himmelen! &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">(</span><span class="n">say</span><span class="w"> </span><span class="kt">Blue</span><span class="p">)</span>
<span class="c1">-- putStrLn har typen type String -&gt; IO ()</span>

<span class="c1">-- Det är enkelt att göra IO om du kan implementera ditt program som en funktion</span>
<span class="c1">-- från String till String. Funktionen</span>
<span class="c1">--    interact :: (String -&gt; String) -&gt; IO ()</span>
<span class="c1">-- tar denna funktion och matar den med strängdata från stdin och skriver ut</span>
<span class="c1">-- resultatet som en sträng på stdout</span>

<span class="nf">countLines</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span>
<span class="nf">countLines</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">lines</span>

<span class="nf">main&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">interact</span><span class="w"> </span><span class="n">countLines</span>

<span class="c1">-- Du kan tänka på värden av typen `IO ()` som att representera</span>
<span class="c1">-- händelsesekvenser du vill att din dator skall utföra, likt imperativa språk.</span>
<span class="c1">-- För att kedja ihop händelsesekvenser använder man ett syntaktiskt socker</span>
<span class="c1">-- kallat do-notation. Som exempel:</span>

<span class="nf">sägHej</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span>
<span class="nf">sägHej</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span>
<span class="w">   </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;Vad heter du?&quot;</span>
<span class="w">   </span><span class="n">namn</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getLine</span><span class="w"> </span><span class="c1">-- denna raden läser en rad från stdin och vi binder den till</span>
<span class="w">                  </span><span class="c1">-- funktionsnamnet `namn`</span>
<span class="w">   </span><span class="n">putStrLn</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="s">&quot;Hejsan, &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">namn</span>

<span class="c1">-- Övning: Skriv din egen version av interageringsfunktionen `interact` som bara</span>
<span class="c1">-- läser en rad från stdin, vanliga `interact` läser till EOF.</span>

<span class="c1">-- Koden i sägHej kommer dock aldrig exekveras. Den enda handlingen som blir det</span>
<span class="c1">-- är som bekant utvärderingen av `main`.</span>
<span class="c1">-- För att köra `sägHej` kommentera ut definition av `main` ovan och</span>
<span class="c1">-- avkommentera nedanstående version:</span>
<span class="c1">--   main = sayHello</span>

<span class="c1">-- Låt oss bättre förstå hur funktionen `getLine` vi just använde fungerar. Dess</span>
<span class="c1">-- typsignatur är:</span>
<span class="c1">--    getLine :: IO String</span>
<span class="c1">-- Du kan tänka på typen `IO a` som att representeras av ett datorprogram vilken</span>
<span class="c1">-- kommer generera ett värde av typen `a` när det exekveras (utöver allt annat</span>
<span class="c1">-- det kan tänkas göra). Vi kan därtill binda detta värde till ett namn för</span>
<span class="c1">-- återanvändning genom att använda `&lt;-`. Vi kan även skapa våran egen handling</span>
<span class="c1">-- av typen `IO String`:</span>

<span class="nf">handling</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">String</span>
<span class="nf">handling</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span>
<span class="w">   </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;Detta är en rad, tihi&quot;</span>
<span class="w">   </span><span class="n">input1</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getLine</span>
<span class="w">   </span><span class="n">input2</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getLine</span>
<span class="w">   </span><span class="c1">-- Typen av hela `do` blocket är vad som står på sista raden. Här är även</span>
<span class="w">   </span><span class="c1">-- `return` inte ett nyckelord i språket utan en funktion med en typsignatur</span>
<span class="w">   </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">input1</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">input2</span><span class="p">)</span><span class="w"> </span><span class="c1">-- return :: String -&gt; IO String</span>

<span class="c1">-- Vi kan använda `return` på samma sätt som vi använde `getLine`:</span>

<span class="nf">main&#39;&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span>
<span class="w">    </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;Jag kommer eka två rader!&quot;</span>
<span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">handling</span>
<span class="w">    </span><span class="n">putStrLn</span><span class="w"> </span><span class="n">result</span>
<span class="w">    </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;Tack och hej leverpastej!&quot;</span>

<span class="c1">-- Typen `IO` är ett exempel på en monad. Sättet Haskell utnyttjar monader på är</span>
<span class="c1">-- anledningen till hur språket kan bibehålla sin renhet. En funktion vilken</span>
<span class="c1">-- interagerar med omvärlden (alltså gör IO) blir markerad med `IO` i sin</span>
<span class="c1">-- typsignatur. Detta låter oss enkelt upptäcka vilka funktioner som är &quot;rena&quot;</span>
<span class="c1">-- (inte interagerar med omvärlden eller är tillståndsoberoende) and vilka</span>
<span class="c1">-- funktioner som inte är det.</span>

<span class="c1">-- Detta är ett mäktigt särdrag eftersom det är enkelt att köra rena funktioner</span>
<span class="c1">-- sammanlöpande; Samtidig programmering är enkel att göra i Haskell.</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 9. Haskell REPL (kodtolk)</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Efter installation av GHC kan vi starta tolken genom att skriva `ghci`.</span>
<span class="c1">-- Nu kan du mata in Haskellkod direkt i den. Nya värden måste introduceras med</span>
<span class="c1">-- `let` bindning:</span>

<span class="kr">let</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">5</span>

<span class="c1">-- Du kan även se typen av namnbindningen med `:t`</span>

<span class="o">&gt;</span><span class="w"> </span><span class="kt">:</span><span class="n">t</span><span class="w"> </span><span class="n">foo</span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span>

<span class="c1">-- Operatorer, som `+`, `:` och `$` är funktioner. Deras typ kan inspekteras</span>
<span class="c1">-- genom att skriva operatorn mellan parenteser:</span>

<span class="o">&gt;</span><span class="w"> </span><span class="kt">:</span><span class="n">t</span><span class="w"> </span><span class="p">(</span><span class="kt">:</span><span class="p">)</span>
<span class="p">(</span><span class="kt">:</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span>

<span class="c1">-- Du kan få ytterliggare information om något namn genom att använda `:i`</span>

<span class="o">&gt;</span><span class="w"> </span><span class="kt">:</span><span class="n">i</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span>
<span class="kr">class</span><span class="w"> </span><span class="kt">Num</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span>
<span class="w">  </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span>
<span class="w">  </span><span class="o">...</span>
<span class="w">    </span><span class="c1">-- Defined in ‘GHC.Num’</span>
<span class="kr">infixl</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="o">+</span>

<span class="c1">-- Du kan även köra alla handlingar av typen `IO ()` direkt i tolken</span>

<span class="o">&gt;</span><span class="w"> </span><span class="n">sägHej</span>
<span class="kt">Vad</span><span class="w"> </span><span class="n">är</span><span class="w"> </span><span class="n">ditt</span><span class="w"> </span><span class="n">namn</span><span class="o">?</span>
<span class="kt">Kompis</span><span class="o">!</span>
<span class="kt">Hello</span><span class="p">,</span><span class="w"> </span><span class="kt">Kompis</span><span class="o">!</span>
</pre></div>
<p>Det finns mycket mer att upptäcka med Haskell, inklusive typklasser och monader.
Vilka är de stora idéerna som gör Haskell till det roliga programmeringsspråket
det är. Jag lämar dig med ett sista exempel; En implementation av quicksort:</p>
<div class="highlight"><pre><span></span><span class="nf">qsort</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span>
<span class="nf">qsort</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">qsort</span><span class="w"> </span><span class="n">mindre</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">qsort</span><span class="w"> </span><span class="n">större</span>
<span class="w">    </span><span class="kr">where</span><span class="w"> </span><span class="n">mindre</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span>
<span class="w">          </span><span class="n">större</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="o">&gt;=</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span>
</pre></div>
<p>Det finns två populära sätt att installera Haskell på: Den traditionella <a href="http://www.haskell.org/platform/">Cabal sättet</a>, eller det nyare <a href="https://www.stackage.org/install">Stack sättet</a>.</p>

<p>Du kan finna vänligare och/eller djupare introduktioner till Haskell på engelska
från:
<a href="http://learnyouahaskell.com/">Learn you a Haskell</a>,
<a href="http://www.happylearnhaskelltutorial.com/">Happy Learn Haskell Tutorial</a> eller
<a href="http://book.realworldhaskell.org/">Real World Haskell</a>.</p>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/sv-se/haskell-sv.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by Adit Bhargava, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/sv-se/haskell-sv.html.markdown">1 contributor</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://adit.io">Adit Bhargava</a>
    </p>

    <p>
      Translated by:
        <a href="http://edwtjo.me">Edward Tjörnhammar</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
