<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="sv-se" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="sv-se" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="sv-se" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="sv-se" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="sv-se">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn nix in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/sv-se/nix-sv/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fsv-se%2Fnix-sv%2F&text=Learn+X+in+Y+minutes%2C+where+X%3Dnix">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="/">Learn X in Y minutes</a></h1>
  <h2>Where X=nix</h2>
    <p class="filelink">
    Get the code:
    <a href="/docs/files/learn-sv.nix">learn-sv.nix</a>
    </p>
  <div id="doc">
    <p>Nix är ett enkelt funktionelt språk utvecklat för
<a href="https://nixos.org/nix/">Nix pakethanteraren</a> och
<a href="https://nixos.org/">NixOS</a> linuxdistributionen.</p>

<p>Du kan utvärdera Nix uttryck genom att använda
<a href="https://nixos.org/nix/manual/#sec-nix-instantiate">nix-instantiate</a>
eller <a href="https://github.com/edolstra/nix-repl"><code>nix-repl</code></a>.</p>
<div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">builtins</span><span class="p">;</span> <span class="p">[</span>

  <span class="c1">#  Kommentarer</span>
  <span class="c1">#=========================================</span>

  <span class="c1"># Inlinekommentarer ser ut såhär.</span>

  <span class="cm">/* Flerradskommentarer ser ut</span>
<span class="cm">     såhär. */</span>


  <span class="c1">#  Booleaner</span>
  <span class="c1">#=========================================</span>

  <span class="p">(</span><span class="no">true</span> <span class="o">&amp;&amp;</span> <span class="no">false</span><span class="p">)</span>               <span class="c1"># Och</span>
  <span class="c1">#=&gt; false</span>

  <span class="p">(</span><span class="no">true</span> <span class="o">||</span> <span class="no">false</span><span class="p">)</span>               <span class="c1"># Eller</span>
  <span class="c1">#=&gt; true</span>

  <span class="p">(</span><span class="k">if</span> <span class="mi">3</span> <span class="err">&lt;</span> <span class="mi">4</span> <span class="k">then</span> <span class="s2">&quot;a&quot;</span> <span class="k">else</span> <span class="s2">&quot;b&quot;</span><span class="p">)</span>  <span class="c1"># Villkorlig</span>
  <span class="c1">#=&gt; &quot;a&quot;</span>


  <span class="c1">#  Heltal</span>
  <span class="c1">#=========================================</span>

  <span class="c1"># Heltal är den enda numeriska typen.</span>

  <span class="mi">1</span> <span class="mi">0</span> <span class="mi">42</span> <span class="p">(</span><span class="err">-</span><span class="mi">3</span><span class="p">)</span>       <span class="c1"># Några heltal</span>

  <span class="p">(</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">6</span> <span class="o">+</span> <span class="mi">12</span> <span class="err">-</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Addition</span>
  <span class="c1">#=&gt; 20</span>

  <span class="p">(</span><span class="mi">7</span> <span class="err">/</span> <span class="mi">2</span><span class="p">)</span>           <span class="c1"># Division</span>
  <span class="c1">#=&gt; 3</span>


  <span class="c1">#  Strängar</span>
  <span class="c1">#=========================================</span>

  <span class="s2">&quot;Stränglitteraler omgärdas av raka citationstecken.&quot;</span>

  <span class="s2">&quot;</span>
<span class="s2">    Stränglitteraler kan sträcka sig</span>
<span class="s2">    över flera rader.</span>
<span class="s2">  &quot;</span>

  <span class="s1">&#39;&#39;</span>
<span class="s1">    Detta kallas för en indenterad strängliteral, omgärdad av dubbla apostrofer</span>
<span class="s1">    Den plockar intelligent bort ledande blanktecken.</span>
<span class="s1">  </span><span class="se">&#39;&#39;</span>

<span class="s1">  </span><span class="se">&#39;&#39;</span>
<span class="s1">    a</span>
<span class="s1">      b</span>
<span class="s1">  </span><span class="se">&#39;&#39;</span>
<span class="s1">  #=&gt; &quot;a\n  b&quot;</span>

<span class="s1">  (&quot;ab&quot; + &quot;cd&quot;)   # Strängkonkatenering</span>
<span class="s1">  #=&gt; &quot;abcd&quot;</span>

<span class="s1">  # Antikvotering låter dig bädda in språkvärden i strängar.</span>
<span class="s1">  (&quot;Din hemkatalog är </span><span class="si">${</span>getEnv <span class="s2">&quot;HOME&quot;</span><span class="si">}</span><span class="s1">&quot;)</span>
<span class="s1">  #=&gt; &quot;Din hemkatalog är /home/alice&quot;</span>


<span class="s1">  #  Sökvägar</span>
<span class="s1">  #=========================================</span>

<span class="s1">  # Nix har en primitiv, inbyggd, typ för sökvägar.</span>
<span class="s1">  /tmp/tutorials/learn.nix</span>

<span class="s1">  # Relativa sökvägar förenas med sökvägen till dess definerande fils sökväg</span>
<span class="s1">  # vid tolkningstillfället för att skapa dess absoluta sökväg.</span>

<span class="s1">  tutorials/learn.nix</span>
<span class="s1">  #=&gt; /the-base-path/tutorials/learn.nix</span>

<span class="s1">  # En sökväg måste innehålla åtminstonde ett snedstreck, så en relativ sökväg</span>
<span class="s1">  # till en fil i samma katalog måste ges ett &quot;./&quot; prefix</span>

<span class="s1">  ./learn.nix</span>
<span class="s1">  #=&gt; /the-base-path/learn.nix</span>

<span class="s1">  # Divisionsoperatorn / måste omges av blanksteg om man vill att det skall</span>
<span class="s1">  # tolkas som heltalsdivision</span>

<span class="s1">  7/2        # Detta är en sökväg</span>
<span class="s1">  (7 / 2)    # Detta är heltalsdivision</span>


<span class="s1">  #  Importer</span>
<span class="s1">  #=========================================</span>

<span class="s1">  # En nix fil innehåller ett enstaka topnivåuttryck utan fria variabler.</span>
<span class="s1">  # Ett importuttryck evalueras till värdet på filen som den importerar.</span>
<span class="s1">  (import /tmp/foo.nix)</span>

<span class="s1">  # Importer kan också specificeras med hjälp av strängar.</span>
<span class="s1">  (import &quot;/tmp/foo.nix&quot;)</span>

<span class="s1">  # Importsökvägar måste vara absoluta. Sökvägslitteraler härleds vid</span>
<span class="s1">  # tolkningstillfället så följande är ok.</span>
<span class="s1">  (import ./foo.nix)</span>

<span class="s1">  # Men detta är inte något som sker med strängar.</span>
<span class="s1">  (import &quot;./foo.nix&quot;)</span>
<span class="s1">  #=&gt; error: string ‘foo.nix’ doesn&#39;t represent an absolute path</span>


<span class="s1">  #  Let</span>
<span class="s1">  #=========================================</span>

<span class="s1">  # `let` block tillåter oss att binda värden till namn.</span>
<span class="s1">  (let x = &quot;a&quot;; in</span>
<span class="s1">    x + x + x)</span>
<span class="s1">  #=&gt; &quot;aaa&quot;</span>

<span class="s1">  # Bindingar kan referera till varandra och deras ordning sinsemellan spelar</span>
<span class="s1">  # ingen roll.</span>
<span class="s1">  (let y = x + &quot;b&quot;;</span>
<span class="s1">       x = &quot;a&quot;; in</span>
<span class="s1">    y + &quot;c&quot;)</span>
<span class="s1">  #=&gt; &quot;abc&quot;</span>

<span class="s1">  # Innre bindningar skuggar utanpåliggande bindingar.</span>
<span class="s1">  (let a = 1; in</span>
<span class="s1">    let a = 2; in</span>
<span class="s1">      a)</span>
<span class="s1">  #=&gt; 2</span>


<span class="s1">  #  Funktioner</span>
<span class="s1">  #=========================================</span>

<span class="s1">  (n: n + 1)      # En lambdafunktion som lägger till 1</span>

<span class="s1">  ((n: n + 1) 5)  # Samma funktion applicerad på 5</span>
<span class="s1">  #=&gt; 6</span>

<span class="s1">  # Det finns ingen syntax för direkt namngivna funktioner, istället binder man</span>
<span class="s1">  # dessa med `let` block som andra värden.</span>
<span class="s1">  (let succ = (n: n + 1); in succ 5)</span>
<span class="s1">  #=&gt; 6</span>

<span class="s1">  # En funktion är en lambda med en parameter. Flera parameterar kan ges med</span>
<span class="s1">  # hjälp av currying.</span>
<span class="s1">  ((x: y: x + &quot;-&quot; + y) &quot;a&quot; &quot;b&quot;)</span>
<span class="s1">  #=&gt; &quot;a-b&quot;</span>

<span class="s1">  # Vi kan också ha namngivna funktionsparametrar, vilket vi kommer komma till</span>
<span class="s1">  # senare, efter att vi introducerat attributset.</span>

<span class="s1">  #  Listor</span>
<span class="s1">  #=========================================</span>

<span class="s1">  # Listor noteras med hakparenteser.</span>

<span class="s1">  (length [1 2 3 &quot;x&quot;])</span>
<span class="s1">  #=&gt; 4</span>

<span class="s1">  ([1 2 3] ++ [4 5])</span>
<span class="s1">  #=&gt; [1 2 3 4 5]</span>

<span class="s1">  (concatLists [[1 2] [3 4] [5]])</span>
<span class="s1">  #=&gt; [1 2 3 4 5]</span>

<span class="s1">  (head [1 2 3])</span>
<span class="s1">  #=&gt; 1</span>
<span class="s1">  (tail [1 2 3])</span>
<span class="s1">  #=&gt; [2 3]</span>

<span class="s1">  (elemAt [&quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot;] 2)</span>
<span class="s1">  #=&gt; &quot;c&quot;</span>

<span class="s1">  (elem 2 [1 2 3])</span>
<span class="s1">  #=&gt; true</span>
<span class="s1">  (elem 5 [1 2 3])</span>
<span class="s1">  #=&gt; false</span>

<span class="s1">  (filter (n: n &lt; 3) [1 2 3 4])</span>
<span class="s1">  #=&gt; [ 1 2 ]</span>


<span class="s1">  #  Mängder</span>
<span class="s1">  #=========================================</span>

<span class="s1">  # Ett attributset är en oordnad mappning av strängnycklar och värden.</span>
<span class="s1">  { foo = [1 2]; bar = &quot;x&quot;; }</span>

<span class="s1">  # Punktoperatorn . väljer ett värde från attributset:et</span>
<span class="s1">  { a = 1; b = 2; }.a</span>
<span class="s1">  #=&gt; 1</span>

<span class="s1">  # Frågeoperatorn ? testar om en nyckel är närvarande i ett attributset</span>
<span class="s1">  ({ a = 1; b = 2; } ? a)</span>
<span class="s1">  #=&gt; true</span>
<span class="s1">  ({ a = 1; b = 2; } ? c)</span>
<span class="s1">  #=&gt; false</span>

<span class="s1">  # Snedstrecksoperatorn // slår ihop två attributset:ar.</span>
<span class="s1">  ({ a = 1; } // { b = 2; })</span>
<span class="s1">  #=&gt; { a = 1; b = 2; }</span>

<span class="s1">  # Värden på höger skriver över värden till vänster.</span>
<span class="s1">  ({ a = 1; b = 2; } // { a = 3; c = 4; })</span>
<span class="s1">  #=&gt; { a = 3; b = 2; c = 4; }</span>

<span class="s1">  # Recursionsnyckelordet rec noterar ett rekursivt attributset (en fixpunkt)</span>
<span class="s1">  # i vilket attributen kan referera till varandra.</span>
<span class="s1">  (let a = 1; in     { a = 2; b = a; }.b)</span>
<span class="s1">  #=&gt; 1</span>
<span class="s1">  (let a = 1; in rec { a = 2; b = a; }.b)</span>
<span class="s1">  #=&gt; 2</span>

<span class="s1">  # Nästlade attributset:ar kan definieras bit för bit.</span>
<span class="s1">  {</span>
<span class="s1">    a.b   = 1;</span>
<span class="s1">    a.c.d = 2;</span>
<span class="s1">    a.c.e = 3;</span>
<span class="s1">  }.a.c</span>
<span class="s1">  #=&gt; { d = 2; e = 3; }</span>

<span class="s1">  # Ett attributsets barn kan inte tilldelas på detta vis om attributsetet</span>
<span class="s1">  # självt blivit direkt tilldelat.</span>
<span class="s1">  {</span>
<span class="s1">    a = { b = 1; };</span>
<span class="s1">    a.c = 2;</span>
<span class="s1">  }</span>
<span class="s1">  #=&gt; error: attribute ‘a’ already defined</span>


<span class="s1">  #  Bindningsintroduktion, `with`</span>
<span class="s1">  #=========================================</span>

<span class="s1">  # Det attributset vilket återfinns i ett `with` uttryck kommer få sina</span>
<span class="s1">  # värdebindningar introducerade i efterkommande uttryck.</span>
<span class="s1">  (with { a = 1; b = 2; };</span>
<span class="s1">    a + b)</span>
<span class="s1">  # =&gt; 3</span>

<span class="s1">  # Innre bindningar skuggar yttre bindningar.</span>
<span class="s1">  (with { a = 1; b = 2; };</span>
<span class="s1">    (with { a = 5; };</span>
<span class="s1">      a + b))</span>
<span class="s1">  #=&gt; 7</span>

<span class="s1">  # Första raden av detta exempel börjar med &quot;with builtins;&quot; eftersom builtins</span>
<span class="s1">  # är ett attributset innehållande alla inbyggda hjälpfunktioner såsom</span>
<span class="s1">  # (length, head, tail, filter, etc.). Detta sparar oss från att hela tiden</span>
<span class="s1">  # referera in i det attributset:et , alltså du kan använda bara &quot;length&quot;</span>
<span class="s1">  # istället för &quot;builtins.length&quot;.</span>


<span class="s1">  #  Attributsetmönster</span>
<span class="s1">  #=========================================</span>

<span class="s1">  # Attributset är användbara när vi skall skicka med flera värden till en</span>
<span class="s1">  # funktion.</span>
<span class="s1">  (args: args.x + &quot;-&quot; + args.y) { x = &quot;a&quot;; y = &quot;b&quot;; }</span>
<span class="s1">  #=&gt; &quot;a-b&quot;</span>

<span class="s1">  # Man kan använda attributsetmönster för ökad tydlighet.</span>
<span class="s1">  ({x, y}: x + &quot;-&quot; + y) { x = &quot;a&quot;; y = &quot;b&quot;; }</span>
<span class="s1">  #=&gt; &quot;a-b&quot;</span>

<span class="s1">  # Attributmönster misslyckas dock om det medskickade attributmönstret</span>
<span class="s1">  # innehåller extra nycklar.</span>
<span class="s1">  ({x, y}: x + &quot;-&quot; + y) { x = &quot;a&quot;; y = &quot;b&quot;; z = &quot;c&quot;; }</span>
<span class="s1">  #=&gt; error: anonymous function called with unexpected argument ‘z’</span>

<span class="s1">  # Genom att lägga till &quot;, ...&quot; kan vi ignorera ytterliggare nycklar.</span>
<span class="s1">  ({x, y, ...}: x + &quot;-&quot; + y) { x = &quot;a&quot;; y = &quot;b&quot;; z = &quot;c&quot;; }</span>
<span class="s1">  #=&gt; &quot;a-b&quot;</span>


<span class="s1">  #  Felmeddelanden</span>
<span class="s1">  #=========================================</span>

<span class="s1">  # `throw` gör att programtolken gör abort med dess tillhörande felmeddelande</span>
<span class="s1">  causes evaluation to abort with an error message.</span>
<span class="s1">  (2 + (throw &quot;foo&quot;))</span>
<span class="s1">  #=&gt; error: foo</span>

<span class="s1">  # `tryEval` fångar kastade fel `throw`.</span>
<span class="s1">  (tryEval 42)</span>
<span class="s1">  #=&gt; { success = true; value = 42; }</span>
<span class="s1">  (tryEval (2 + (throw &quot;foo&quot;)))</span>
<span class="s1">  #=&gt; { success = false; value = false; }</span>

<span class="s1">  # `abort` fungerar som `throw`, men är kritiskt och kan inte fångas.</span>
<span class="s1">  (tryEval (abort &quot;foo&quot;))</span>
<span class="s1">  #=&gt; error: evaluation aborted with the following error message: ‘foo’</span>

<span class="s1">  # `assert` utvärderas till det givna värdet om dess predikat är sant.</span>
<span class="s1">  # annars skickar den ett fångbart fel.</span>
<span class="s1">  (assert 1 &lt; 2; 42)</span>
<span class="s1">  #=&gt; 42</span>
<span class="s1">  (assert 1 &gt; 2; 42)</span>
<span class="s1">  #=&gt; error: assertion failed at (string):1:1</span>
<span class="s1">  (tryEval (assert 1 &gt; 2; 42))</span>
<span class="s1">  #=&gt; { success = false; value = false; }</span>


<span class="s1">  #  Orenhet</span>
<span class="s1">  #=========================================</span>

<span class="s1">  # Eftersom repeterbarhet för byggen är en kritisk egenskap för</span>
<span class="s1">  # Nix-pakethanteraren betonas funktionell renhet i Nix-programmeringsspråket.</span>
<span class="s1">  # Men med det sagt existerar det källor till orenhet</span>

<span class="s1">  # Man kan referera till miljövariabler.</span>
<span class="s1">  (getEnv &quot;HOME&quot;)</span>
<span class="s1">  #=&gt; &quot;/home/alice&quot;</span>

<span class="s1">  # `trace` funktionen används för att debugga. Den skriver ut första argumentet</span>
<span class="s1">  # till stderr och reduceras samtidigt till det andra argumentet.</span>
<span class="s1">  (trace 1 2)</span>
<span class="s1">  #=&gt; trace: 1</span>
<span class="s1">  #=&gt; 2</span>

<span class="s1">  # Man kan skriva filer till Nix-store, lagringsplatsen för alla Nix-uttryck.</span>
<span class="s1">  # Även om detta är orent beteende är det hyfsat säkert eftersom filens</span>
<span class="s1">  # lagringsplats är härledd från dess innehåll och beroenden. Man kan läsa</span>
<span class="s1">  # filer från precis överallt. I nedanstående exempel skriver vi en fil till</span>
<span class="s1">  # Nix-store och sedan läser tillbaka den.</span>

<span class="s1">  (let filename = toFile &quot;foo.txt&quot; &quot;hello!&quot;; in</span>
<span class="s1">    [filename (builtins.readFile filename)])</span>
<span class="s1">  #=&gt; [ &quot;/nix/store/ayh05aay2anx135prqp0cy34h891247x-foo.txt&quot; &quot;hello!&quot; ]</span>

<span class="s1">  # Vi kan också ladda ned filer till Nix-store.</span>
<span class="s1">  (fetchurl &quot;https://example.com/package-1.2.3.tgz&quot;)</span>
<span class="s1">  #=&gt; &quot;/nix/store/2drvlh8r57f19s9il42zg89rdr33m2rm-package-1.2.3.tgz&quot;</span>

<span class="s1">]</span>
</pre></div>
<h3>Vidare Läsning (eng)</h3>

<ul>
<li><p><a href="https://nixos.org/nix/manual/#ch-expression-language">Nix Manual - Nix expression language</a></p></li>
<li><p><a href="https://medium.com/@MrJamesFisher/nix-by-example-a0063a1a4c55">James Fisher - Nix by example - Part 1: The Nix expression language</a></p></li>
<li><p><a href="https://ops.functionalalgebra.com/nix-by-example/">Susan Potter - Nix Cookbook - Nix By Example</a></p></li>
<li><p><a href="https://zero-to-nix.com/">Zero to Nix - Nix Tutorial</a></p></li>
<li><p><a href="https://web.archive.org/web/20210121042658/https://ebzzry.io/en/nix/#nix">Rommel Martinez - A Gentle Introduction to the Nix Family</a></p></li>
</ul>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/sv-se/nix-sv.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by Chris Martin, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/sv-se/nix-sv.html.markdown">4 contributors</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://chris-martin.org/">Chris Martin</a>
    </p>

    <p>
      Translated by:
        <a href="http://edwtjo.me">Edward Tjörnhammar</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
