<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="uk-ua" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="uk-ua" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="uk-ua" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="uk-ua" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="uk-ua">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn C in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/uk-ua/c-ua/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }
                el.className = theme === "dark" ? "dark" : "light";
                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (!theme) {
                theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"
              }
              set_theme(theme)
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.onload = function(){
              load_theme();
            };

            // Listen for system preference change
            window
              .matchMedia("(prefers-color-scheme: dark)")
              .addEventListener("change", ({matches:isDark}) => {
                set_theme(isDark ? "dark" : "light")
              })
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fuk-ua%2Fc-ua%2F&text=%D0%92%D0%B8%D0%B2%D1%87%D1%96%D1%82%D1%8C+X+%D0%B7%D0%B0+Y+%D1%85%D0%B2%D0%B8%D0%BB%D0%B8%D0%BD%2C+%D0%B4%D0%B5+X%3DC">
        Поділитися сторінкою
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Виберіть тему:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">світла</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">темна</button>
  </div>
  <h1><a href="/">Вивчіть X за Y хвилин</a></h1>
  <h2>Де X=C</h2>
    <p class="filelink">
    Отримати вихідний код:
    <a href="/docs/files/learnc-ua.c">learnc-ua.c</a>
    </p>
  <div id="doc">
    <p>О, C! Досі мова для сучасних обчислень у високопродуктивних продуктах.</p>

<p>C це імовірно найбільш низькорівнева мова, яку будуть використовувати більшість програмістів. Проте, вона компенсує це не тільки швидкістю виконання. Як тільки ви оціните її можливість ручного управління пам&#39;яттю, С зможе відвести саме в ті місця, в які вам потрібно було потрапити.</p>

<blockquote>
<p><strong>Дещо про прапори компілятора</strong></p>

<p>За замовчуванням, gcc та clang досить тихо інформують про попередження та помилки
при компіляції, хоч це і може бути дуже корисною інформацією. Тому рекомендується
використовувати більш вимогливий компілятор. Ось кілька рекомендацій:</p>

<p><code>-Wall -Wextra -Werror -O2 -std=c99 -pedantic</code></p>

<p>За інформацією про ці та інші прапори зверніться до головної сторінки man вашого 
компілятора C (наприклад, <code>man 1 gcc</code>) або ж просто заґуґліть.</p>
</blockquote>
<div class="highlight"><pre><span></span><span class="c1">// Однорядкові коментарі починаються з //</span>
<span class="c1">// Проте вони з&#39;явились тільки після С99.</span>

<span class="cm">/*</span>
<span class="cm">Багаторядкові коментарі мають такий вигляд. І працюють в C89.</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">Багаторядкові коментарі не можуть вкладатись один в одний. </span>
<span class="cm">/* Будьте обережними */</span><span class="w"> </span><span class="c1">// коментар закінчується на цьому рядку...</span>
<span class="o">*/</span><span class="w"> </span><span class="c1">// ...а не на цьому!</span>

<span class="c1">// Константа: #define &lt;keyword&gt;</span>
<span class="c1">// Назви констант, як правило, пишуться великими літерами, проте це не вимога</span>
<span class="cp">#define DAYS_IN_YEAR 365</span>

<span class="c1">// Ще одним способом оголосити константи є перелічення констант.</span>
<span class="c1">// До речі, всі вирази мають закінчуватись крапкою з комою.</span>
<span class="k">enum</span><span class="w"> </span><span class="n">days</span><span class="w"> </span><span class="p">{</span><span class="n">SUN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">MON</span><span class="p">,</span><span class="w"> </span><span class="n">TUE</span><span class="p">,</span><span class="w"> </span><span class="n">WED</span><span class="p">,</span><span class="w"> </span><span class="n">THU</span><span class="p">,</span><span class="w"> </span><span class="n">FRI</span><span class="p">,</span><span class="w"> </span><span class="n">SAT</span><span class="p">};</span>
<span class="c1">// MON отримає значення 2 автоматично, TUE дорівнюватиме 3 і т.д.</span>

<span class="c1">// Імпортувати заголовки можна за допомогою #include</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>

<span class="c1">// (Заголовки із стандартної бібліотеки С вказуються між &lt;кутовими дужками&gt;.)</span>
<span class="c1">// Щоб додати власні заголовки, потрібно використовувати &quot;подвійні лапки&quot; </span>
<span class="c1">// замість кутових:</span>
<span class="c1">//#include &quot;my_header.h&quot;</span>

<span class="c1">// Сигнатури функцій попередньо оголошуються в .h файлах або на початку .с файлів.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">function_1</span><span class="p">();</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">function_2</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="c1">// Потрібно оголосити &#39;прототип функції&#39; перед main(), реалізація функцій </span>
<span class="c1">// відбувається після функції main().</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">add_two_ints</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x2</span><span class="p">);</span><span class="w"> </span><span class="c1">// прототип функції</span>
<span class="c1">// Варіант `int add_two_ints(int, int);` теж правильний (не потрібно називати </span>
<span class="c1">// аргументи). Рекомендується також називати аргументи в прототипі для </span>
<span class="c1">// кращого розуміння.</span>

<span class="c1">// Вхідною точкою програми є функція під назвою main. Вона повертає чисельний тип.</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// реалізація програми</span>
<span class="p">}</span>

<span class="c1">// Аргументи командного рядка, вказані при запуску програми, також передаються</span>
<span class="c1">// у функцію main.</span>
<span class="c1">// argc - це кількість переданих аргументів</span>
<span class="c1">// argv — це масив масивів символів, що містить самі аргументи</span>
<span class="c1">// argv[0] - назва програми, argv[1] - перший аргумент, і т.д.</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// printf дозволяє вивести на екран значення, вивід - це форматований рядок, </span>
<span class="w">  </span><span class="c1">// в даному випадку %d позначає чисельне значення, \n — це новий рядок</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Виводить 0</span>

<span class="w">  </span><span class="c1">///////////////////////////////////////</span>
<span class="w">  </span><span class="c1">// Типи</span>
<span class="w">  </span><span class="c1">///////////////////////////////////////</span>

<span class="w">  </span><span class="c1">// Всі змінні повинні бути оголошені на початку поточного блоку області видимості.</span>
<span class="w">  </span><span class="c1">// В цьому коді вони оголошуються динамічно. С99-сумісні компілятори</span>
<span class="w">  </span><span class="c1">// дозволяють оголошення близько до місця, де значення використовується.</span>

<span class="w">  </span><span class="c1">// int (цілочисельний знаковий тип) зазвичай займає 4 байти</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x_int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// short (цілочисельний знаковий тип) зазвичай займає 2 байти</span>
<span class="w">  </span><span class="c1">// </span>
<span class="w">  </span><span class="kt">short</span><span class="w"> </span><span class="n">x_short</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Символьний тип char гарантовано займає 1 байт</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">x_char</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">y_char</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;y&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Символьні літерали позначаються &#39;&#39;</span>

<span class="w">  </span><span class="c1">// long (цілочисельний знаковий тип) має розмір від 4 до 8 байтів; великі значення  </span>
<span class="w">  </span><span class="c1">// типу long гарантовано займають 8 байтів</span>
<span class="w">  </span><span class="kt">long</span><span class="w"> </span><span class="n">x_long</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x_long_long</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Тип float - це зазвичай 32-бітове число з плаваючою крапкою</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">x_float</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span><span class="w"> </span><span class="c1">// Суфікс &#39;f&#39; позначає літерал з плаваючою крапкою</span>

<span class="w">  </span><span class="c1">// Тип double - це зазвийчай 64-бітове число з плаваючою крапкою</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">x_double</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"> </span><span class="c1">// дійсне число без суфіксів має тип double</span>

<span class="w">  </span><span class="c1">// Цілочисельні типи можуть не мати знаку (бути більше, або ж рівними нулю)</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">ux_short</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ux_int</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">ux_long_long</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Char всередині одинарних лапок інтерпретуються як числа в наборі </span>
<span class="w">  </span><span class="c1">// символів комп&#39;ютера.</span>
<span class="w">  </span><span class="sc">&#39;0&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 48 в таблиці ASCII.</span>
<span class="w">  </span><span class="sc">&#39;A&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 65 в таблиці ASCII.</span>

<span class="w">  </span><span class="c1">// sizeof(T) повертає розмір змінної типу Т в байтах</span>
<span class="w">  </span><span class="c1">// sizeof(obj) віддає розмір виразу (змінна, літерал, і т.п.)</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"> </span><span class="c1">// =&gt; 4 (на більшості пристроїв з 4-байтним словом)</span>

<span class="w">  </span><span class="c1">// Якщо аргумент оператора `sizeof` — це вираз, тоді його аргументи не оцінюються</span>
<span class="w">  </span><span class="c1">// (крім масивів, розмір яких залежить від змінної).</span>
<span class="w">  </span><span class="c1">// Значення, що повертається в цьому випадку, - це константа часу компіляції.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// size_t - беззнаковий чисельний тип розміром щонайменше 2 байти, який</span>
<span class="w">  </span><span class="c1">// використовується для відображення розміру об&#39;єкта.</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="o">++</span><span class="p">);</span><span class="w"> </span><span class="c1">// a++ не оцінюється</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(a++) = %zu where a = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// Виводить &quot;sizeof(a++) = 4 where a = 1&quot; (на 32-бітній архітектурі)</span>

<span class="w">  </span><span class="c1">// Масиви повинні бути проініціалізовані з конкретним розміром.</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">my_char_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span><span class="w"> </span><span class="c1">// Цей масив займає 1 * 20 = 20 байтів</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">my_int_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span><span class="w"> </span><span class="c1">// Цей масив займає 4 * 20 = 80 байтів</span>
<span class="w">  </span><span class="c1">// (припускаючи 4-байтні числа)</span>

<span class="w">  </span><span class="c1">// Таким чином можна проініціалізувати масив нулем:</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">my_array</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="w">  </span><span class="c1">// де &quot;{0}&quot; називається &quot;ініціалізатором масиву&quot;.</span>

<span class="w">  </span><span class="c1">// Зазначте, можна явно не оголошувати розмір масиву, ЯКЩО ви проініціалізуєте </span>
<span class="w">  </span><span class="c1">// масив у тому ж рядку. Тому, наступне оголошення еквівалентне:</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">my_array</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="w">  </span><span class="c1">// АЛЕ, потрібно визначити розмір масиву під час виконання, як тут:</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">my_array_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">my_array</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">my_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="w">  </span><span class="c1">// ПОПЕРЕДЖЕННЯ якщо ви вирішили використовувати даний підхід, потрібно </span>
<span class="w">  </span><span class="c1">// визначити розмір **перед тим**, як ви почнете передавати масив у функцію</span>
<span class="w">  </span><span class="c1">// (побачите дискусію пізніше). Масиви перетворюються на вказівники при</span>
<span class="w">  </span><span class="c1">// передачі як аргументи у функцію, тому попереднє твердження буде видавати</span>
<span class="w">  </span><span class="c1">// хибний результат всередині функції.</span>

<span class="w">  </span><span class="c1">// Індексація по масиву така ж сама, як і в інших мовах програмування або,</span>
<span class="w">  </span><span class="c1">// скоріше, як у інших с-подібних мовах.</span>
<span class="w">  </span><span class="n">my_array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="c1">// =&gt; 0</span>

<span class="w">  </span><span class="c1">// Масиви незмінні, це просто частина пам&#39;яті!</span>
<span class="w">  </span><span class="n">my_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">my_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"> </span><span class="c1">// =&gt; 2</span>

<span class="w">  </span><span class="c1">// Масиви, розмір яких залежить від змінної, в С99 (та в С11 як вибірковий </span>
<span class="w">  </span><span class="c1">// функціонал) можуть бути оголошені також. Розмір такого масиву не має бути</span>
<span class="w">  </span><span class="c1">// константою під час компіляції:</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Enter the array size: &quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// спитати користувача розмір масиву</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">array_size</span><span class="p">;</span>
<span class="w">  </span><span class="n">fscanf</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">array_size</span><span class="p">);</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">var_length_array</span><span class="p">[</span><span class="n">array_size</span><span class="p">];</span><span class="w"> </span><span class="c1">// оголосити масив</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof array = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="n">var_length_array</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Приклад:</span>
<span class="w">  </span><span class="c1">// &gt; Enter the array size: 10</span>
<span class="w">  </span><span class="c1">// &gt; sizeof array = 40</span>

<span class="w">  </span><span class="c1">// Рядки - це просто масиви символьних літералів (char), що закінчуються NULL </span>
<span class="w">  </span><span class="c1">// (0x00) байтом, представленим у рядках як спеціальний символ &#39;\0&#39;.</span>
<span class="w">  </span><span class="c1">// (Не потрібно включати байт NULL в рядкові літерали; компілятор сам вставляє</span>
<span class="w">  </span><span class="c1">// його наприкінці масиву.)</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">a_string</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;This is a string&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a_string</span><span class="p">);</span><span class="w"> </span><span class="c1">// %s форматує рядок</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a_string</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span><span class="w"> </span><span class="c1">// =&gt; 0</span>
<span class="w">  </span><span class="c1">// тобто, байт #17 - це 0 (так само, як і 18-ий, 19-ий, та 20-ий)</span>

<span class="w">  </span><span class="c1">// Якщо між одинарними лапками є букви, тоді це символьний літерал.</span>
<span class="w">  </span><span class="c1">// Він має тип `int`, а не `char` (так історично склалось).</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">cha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// добре</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">chb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// також добре (неявне перетворення з int на char)</span>

<span class="w">  </span><span class="c1">// Багатовимірні масиви:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">multi_array</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>
<span class="w">  </span><span class="c1">// Доступ до елементів:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">array_int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">multi_array</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="c1">// =&gt; 3</span>

<span class="w">  </span><span class="c1">///////////////////////////////////////</span>
<span class="w">  </span><span class="c1">// Оператори</span>
<span class="w">  </span><span class="c1">///////////////////////////////////////</span>

<span class="w">  </span><span class="c1">// Скорочення для багатьох оголошень:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">i2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="n">f2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">  </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Арифметичні операції</span>
<span class="w">  </span><span class="n">i1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 3</span>
<span class="w">  </span><span class="n">i2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">i1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>
<span class="w">  </span><span class="n">i2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 2</span>
<span class="w">  </span><span class="n">i1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">i2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0 (0.5 округлено до 0)</span>

<span class="w">  </span><span class="c1">// Потрібно перетворити хоча б одну з цілочисельних змінних на float, щоб </span>
<span class="w">  </span><span class="c1">// отримати результат з плаваючою крапкою</span>
<span class="w">  </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">i1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">i2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0.5f</span>
<span class="w">  </span><span class="n">i1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">i2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0.5 // Так само і для типу double</span>
<span class="w">  </span><span class="n">f1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0.5, з певною точністю</span>
<span class="w">  </span><span class="c1">// Такі обчислення не є точними</span>

<span class="w">  </span><span class="c1">// Ділення за модулем також є</span>
<span class="w">  </span><span class="mi">11</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 2, остача від ділення</span>

<span class="w">  </span><span class="c1">// Оператори порівняння ймовірно схожі, проте в С немає логічного типу.</span>
<span class="w">  </span><span class="c1">// Натомість використовується int.</span>
<span class="w">  </span><span class="c1">// (Або _Bool або bool в C99.)</span>
<span class="w">  </span><span class="c1">// 0 - хибно (false), всі інші значення - правда (true). Оператори</span>
<span class="w">  </span><span class="c1">// порівняння завжди повертають 0 або 1.</span>
<span class="w">  </span><span class="mi">3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0 (false)</span>
<span class="w">  </span><span class="mi">3</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1 (true)</span>
<span class="w">  </span><span class="mi">3</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>
<span class="w">  </span><span class="mi">3</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0</span>
<span class="w">  </span><span class="mi">2</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>
<span class="w">  </span><span class="mi">2</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>

<span class="w">  </span><span class="c1">// C - це не Python, порівняння не утворюють ланцюги.</span>
<span class="w">  </span><span class="c1">// Попередження: Рядок нижче скомпілюється, але він означає `(0 &lt; a) &lt; 2`.</span>
<span class="w">  </span><span class="c1">// В даному випадку, це 1, тому що (0 &lt; 1).</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">between_0_and_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Натомість потрібно використати:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">between_0_and_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Логічні оператори з числами</span>
<span class="w">  </span><span class="o">!</span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0 (Логічне НЕ)</span>
<span class="w">  </span><span class="o">!</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>
<span class="w">  </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1 (Логічне І)</span>
<span class="w">  </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0</span>
<span class="w">  </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1 (Логічне АБО)</span>
<span class="w">  </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0</span>

<span class="w">  </span><span class="c1">// Тернарний вираз з умовою ( ? : )</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="w">  </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 10 &quot;if e &gt; f return e, else return f.&quot;</span>

<span class="w">  </span><span class="c1">// Оператори збільшення та зменшення на 1:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">// Повернути j ПОТІМ збільшити j. (s = 0, j = 1)</span>
<span class="w">  </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">;</span><span class="w"> </span><span class="c1">// Збільшити j ПОТІМ повернути j. (s = 2, j = 2)</span>
<span class="w">  </span><span class="c1">// так само і для j-- та --j</span>

<span class="w">  </span><span class="c1">// Побітові операції!</span>
<span class="w">  </span><span class="o">~</span><span class="mh">0x0F</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0xFFFFFFF0 (побітове заперечення, &quot;перше доповнення&quot;, результат </span>
<span class="w">  </span><span class="c1">// для 32-бітного int)</span>
<span class="w">  </span><span class="mh">0x0F</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xF0</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0x00 (побітове І)</span>
<span class="w">  </span><span class="mh">0x0F</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0xF0</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0xFF (побітове АБО)</span>
<span class="w">  </span><span class="mh">0x04</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="mh">0x0F</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0x0B (побітове XOR)</span>
<span class="w">  </span><span class="mh">0x01</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0x02 (побітовий зсув вліво (на 1))</span>
<span class="w">  </span><span class="mh">0x02</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0x01 (побітовий зсув вправо (на 1))</span>

<span class="w">  </span><span class="c1">// Будьте обережними при зсуві цілочисельних значень зі знаком.  </span>
<span class="w">  </span><span class="c1">// Наступні дії дають невизначений результат:</span>
<span class="w">  </span><span class="c1">// - зсув на біт, що зберігає знак числа (int a = 1 &lt;&lt; 31)</span>
<span class="w">  </span><span class="c1">// - зсув вліво на від&#39;ємне число (int a = -1 &lt;&lt; 2)</span>
<span class="w">  </span><span class="c1">// - зсув на число, що більше за ширину типу </span>
<span class="w">  </span><span class="c1">// TODO: LHS</span>
<span class="w">  </span><span class="c1">// - зсув на зміщення, що &gt;= ширині типу в лівій частині виразу:</span>
<span class="w">  </span><span class="c1">//   int a = 1 &lt;&lt; 32; // Невизначена поведінка, якщо ширина int 32 біти.</span>

<span class="w">  </span><span class="c1">///////////////////////////////////////</span>
<span class="w">  </span><span class="c1">// Структури розгалуження</span>
<span class="w">  </span><span class="c1">///////////////////////////////////////</span>

<span class="w">  </span><span class="c1">// Оператор умови</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;I am never run</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// ніколи не буде виконано</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;I am also never run</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// теж ніколи не буде виконано</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;I print</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w">    </span><span class="c1">// це буде надруковано</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Цикл з передумовою</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">ii</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// БУДЬ-ЯКЕ значення, що менше 10 - правда.</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ii</span><span class="o">++</span><span class="p">);</span><span class="w"> </span><span class="c1">// ii++ збільшує ii на 1 ПІСЛЯ передачі поточного значення.</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="c1">// =&gt; надрукує &quot;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Цикл з післяумовою</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">kk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">kk</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">++</span><span class="n">kk</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="c1">// ++kk збільшує kk на 1 ПЕРЕД передачою поточного значення.</span>
<span class="w">  </span><span class="c1">// =&gt; надрукує &quot;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Цикл з лічильником</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">jj</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">jj</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">jj</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">jj</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">jj</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="c1">// =&gt; виводить &quot;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// *****Додатково*****:</span>
<span class="w">  </span><span class="c1">// Цикли та функції обов&#39;язково повинні мати тіло. Якщо тіло не потрібно:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">;</span><span class="w"> </span><span class="c1">// використовуйте крапку з комою, щоб симулювати тіло (пусте твердження)</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Або</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Розгалуження з множинним вибором: switch()</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span><span class="w"> </span><span class="c1">// значення повинні бути *константними* виразами і мати вбудований тип</span>
<span class="w">          </span><span class="c1">//(наприклад, перелічення)</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hey, &#39;a&#39; equals 0!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"> </span><span class="c1">// якщо не використати break, то управління буде передано наступному блоку</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Huh, &#39;a&#39; equals 1!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Будьте обережними, виконання продовжиться до тих пір, поки</span>
<span class="w">    </span><span class="c1">// не зустрінеться наступний &quot;break&quot;.</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">3</span><span class="p">:</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">4</span><span class="p">:</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Look at that.. &#39;a&#39; is either 3, or 4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="k">default</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// якщо вираз a не співпадає з описаними значеннями, то виконується </span>
<span class="w">    </span><span class="c1">// блок default</span>
<span class="w">    </span><span class="n">fputs</span><span class="p">(</span><span class="s">&quot;Error!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">stderr</span><span class="p">);</span>
<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="mi">-1</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="cm">/*</span>
<span class="cm">  Використання &quot;goto&quot; в С</span>
<span class="cm">  */</span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kt">bool</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// вводимо таке перелічення, оскільки С не має логічного типу до С99</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">disaster</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="p">((</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">150</span><span class="p">)</span>
<span class="w">        </span><span class="n">disaster</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">disaster</span><span class="p">)</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">error</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nl">error</span><span class="w"> </span><span class="p">:</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Error occurred at i = %d &amp; j = %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">);</span>
<span class="w">  </span><span class="cm">/*</span>
<span class="cm">  https://ideone.com/GuPhd6</span>
<span class="cm">  Даний приклад виведе &quot;Error occurred at i = 51 &amp; j = 99.&quot;</span>
<span class="cm">  */</span>

<span class="w">  </span><span class="c1">///////////////////////////////////////</span>
<span class="w">  </span><span class="c1">// Приведення до типів</span>
<span class="w">  </span><span class="c1">///////////////////////////////////////</span>

<span class="w">  </span><span class="c1">// Кожне значенння в С має тип, але можна перевести значення з одного типу в </span>
<span class="w">  </span><span class="c1">// інший, якщо потрібно (із деякими обмеженнями).</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x_hex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x01</span><span class="p">;</span><span class="w"> </span><span class="c1">// Змінним можна присвоювати літерали в шістнадцятковій </span>
<span class="w">                    </span><span class="c1">// системі числення</span>

<span class="w">  </span><span class="c1">// Приведення до типу призведе до спроби зберегти чисельне значення</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x_hex</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Виводить 1</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">short</span><span class="p">)</span><span class="w"> </span><span class="n">x_hex</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Виводить 1</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="n">x_hex</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Виводить 1</span>

<span class="w">  </span><span class="c1">// В данному випадку попередження не виникатиме, якщо значення виходить за межі </span>
<span class="w">  </span><span class="c1">// значення типу</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="mi">257</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; 1 (максимальне значення char = 255, </span>
<span class="w">  </span><span class="c1">// якщо char має довжину 8 біт)</span>

<span class="w">  </span><span class="c1">// Для того, щоб дізнатись максимальний розмір `char`, `signed char` або ж </span>
<span class="w">  </span><span class="c1">// `unsigned char`, потрібно використати макроси CHAR_MAX, SCHAR_MAX та UCHAR_MAX</span>
<span class="w">  </span><span class="c1">// відповідно з &lt;limits.h&gt;. </span>

<span class="w">  </span><span class="c1">// Вбудовані типи можуть бути приведені до типу із плаваючою крапкою і навпаки.</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span><span class="w"> </span><span class="c1">// %f завжди перетворює число на double...</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w">  </span><span class="mi">100</span><span class="p">);</span><span class="w"> </span><span class="c1">// ...навіть, якщо це float.</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mf">100.0</span><span class="p">);</span>

<span class="w">  </span><span class="c1">///////////////////////////////////////</span>
<span class="w">  </span><span class="c1">// Вказівники</span>
<span class="w">  </span><span class="c1">///////////////////////////////////////</span>

<span class="w">  </span><span class="c1">// Вказівник - це змінна, що зберігає адресу у пам&#39;яті. Оголошення вказівника </span>
<span class="w">  </span><span class="c1">// також потребує інформації про тип об&#39;єкта, на який він вказує. Можна </span>
<span class="w">  </span><span class="c1">// отримати адресу пам&#39;яті будь-якої змінної, а потім працювати з нею.</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// Оператор &amp; повертає адресу змінної у пам&#39;яті</span>
<span class="w">  </span><span class="c1">// (%p форматує об&#39;єкт вказівника типу void *)</span>
<span class="w">  </span><span class="c1">// =&gt; Виводить деяку адресу в пам&#39;яті</span>

<span class="w">  </span><span class="c1">// Для оголошення вказівника потрібно поставити * перед його назвою.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">px</span><span class="p">,</span><span class="w"> </span><span class="n">not_a_pointer</span><span class="p">;</span><span class="w"> </span><span class="c1">// px - це вказівник на цілочисельне значення (int)</span>
<span class="w">  </span><span class="n">px</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// Зберігає адресу змінної x в px</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">px</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Виводить адресу в пам&#39;яті</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%zu, %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">px</span><span class="p">),</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">not_a_pointer</span><span class="p">));</span>
<span class="w">  </span><span class="c1">// =&gt; Виводить &quot;8, 4&quot; на звичайній 64-бітній системі</span>

<span class="w">  </span><span class="c1">// Щоб прочитати значення, яке зберігається за адресою, на яку вказує вказівник,</span>
<span class="w">  </span><span class="c1">// потрібно поставити знак * перед назвою змінної. </span>
<span class="w">  </span><span class="c1">// Так, * використовується одночасно і для оголошення вказівника, і для отримання </span>
<span class="w">  </span><span class="c1">// значення за адресою. Звучить заплутано, проте тільки спочатку.</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">px</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Виводить 0, значення x</span>

<span class="w">  </span><span class="c1">// Можна також змінити значення, на яке посилається вказівник.</span>
<span class="w">  </span><span class="c1">// Тут звернення до адреси обернене у круглі дужки, тому що </span>
<span class="w">  </span><span class="c1">// ++ має вищий пріоритет виконання, ніж *.</span>
<span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">px</span><span class="p">)</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">// Збільшити значення, на яке вказує px, на 1</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">px</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Виводить 1</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Виводить 1</span>

<span class="w">  </span><span class="c1">// Масиви зручно використовувати для виділення неперервного блоку пам&#39;яті.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span><span class="w"> </span><span class="c1">// оголошує масив з 20 елементів (розмір можна задати лише один раз)</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">xx</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">xx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">xx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"> </span><span class="n">xx</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x_array</span><span class="p">[</span><span class="n">xx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">xx</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="c1">// Ініціалізує x_array значеннями 20, 19, 18,... 2, 1</span>

<span class="w">  </span><span class="c1">// Оголосити вказівник типу int, який посилається на масив x_array</span>
<span class="w">  </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">x_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x_array</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// x_ptr тепер вказує на перший елемент масиву (число 20).</span>
<span class="w">  </span><span class="c1">//  </span>
<span class="w">  </span><span class="c1">// Це працює, тому що при зверненні до імені масиву повертається вказівник </span>
<span class="w">  </span><span class="c1">// на перший елемент. Наприклад, коли масив передається у функцію або присвоюється</span>
<span class="w">  </span><span class="c1">// вказівнику, він неявно приводиться до вказівника.</span>
<span class="w">  </span><span class="c1">// Виключення: </span>
<span class="w">  </span><span class="c1">// - коли вказівник передається як аргумент із оператором `&amp;`:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">ptr_to_arr</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arr</span><span class="p">;</span><span class="w"> </span><span class="c1">// &amp;arr НЕ має тип `int *`!</span>
<span class="w">  </span><span class="c1">// Він має тип &quot;вказівник на масив&quot; (з 10 чисел).</span>
<span class="w">  </span><span class="c1">// - коли масив - це рядковий літерал, що використовується для ініціалізації</span>
<span class="w">  </span><span class="c1">// масив символів:</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">otherarr</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foobarbazquirk&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// - коли масив - це аргумент операторів `sizeof` або `alignof`:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">arraythethird</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arraythethird</span><span class="p">;</span><span class="w"> </span><span class="c1">// те ж саме, що з int *ptr = &amp;arr[0];</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%zu, %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">arraythethird</span><span class="p">),</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">ptr</span><span class="p">));</span>
<span class="w">  </span><span class="c1">// Ймовірно, виводить &quot;40, 4&quot; або &quot;40, 8&quot;</span>

<span class="w">  </span><span class="c1">// Інкрементація та декрементація вказівника залежить від його типу.</span>
<span class="w">  </span><span class="c1">// (так звана арифметика вказівників)</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">x_ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w"> </span><span class="c1">// =&gt; Виводить 19</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"> </span><span class="c1">// =&gt; Виводить 19</span>

<span class="w">  </span><span class="c1">// Можна також динамічно виділити послідовні блоки в пам&#39;яті за допомогою</span>
<span class="w">  </span><span class="c1">// функції malloc зі стандартної бібліотеки. malloc приймає один аргумент типу</span>
<span class="w">  </span><span class="c1">// size_t, що описує кількість байтів для виділення (зазвичай із купи, проте це</span>
<span class="w">  </span><span class="c1">// може бути неправдою на вбудованих системах - стандарт С нічого про це не повідомляє).</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">my_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">my_ptr</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">20</span><span class="p">);</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">xx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">xx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"> </span><span class="n">xx</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">*</span><span class="p">(</span><span class="n">my_ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">xx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">xx</span><span class="p">;</span><span class="w"> </span><span class="c1">// my_ptr[xx] = 20-xx</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="c1">// Проініціалізувати пам&#39;ять значеннями 20, 19, 18, 17... 2, 1 (як int)</span>

<span class="w">  </span><span class="c1">// Будьте обережними із передачею значень, що надаються користувачем, в malloc!</span>
<span class="w">  </span><span class="c1">// Про всяк випадок, використовуйте calloc в таких ситуаціях (який, на відміну від </span>
<span class="w">  </span><span class="c1">// malloc, також заповнює пам&#39;ять нулями).</span>
<span class="w">  </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">my_other_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calloc</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// Немає стандартного способу визначити розмір динамічно виділеного масиву в С.</span>
<span class="w">  </span><span class="c1">// Через це, якщо масиви будуть часто передаватись в програмі, потрібна інша змінна,</span>
<span class="w">  </span><span class="c1">// яка буде відслідковувати кількість елементів в масиві. Детальніше в розділі </span>
<span class="w">  </span><span class="c1">// про функції.</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">my_arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="w">  </span><span class="c1">// Додати елемент до масиву.</span>
<span class="w">  </span><span class="n">size</span><span class="o">++</span><span class="p">;</span>
<span class="w">  </span><span class="n">my_arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">realloc</span><span class="p">(</span><span class="n">my_arr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">my_arr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Не забувайте перевіряти результат виконання realloc на помилки!</span>
<span class="w">    </span><span class="k">return</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">my_arr</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Робота з вказівниками може призводити до неочікуваних і непрогнозованих </span>
<span class="w">  </span><span class="c1">// результатів, якщо звернутись до пам&#39;яті, що не була виділена вами.</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">my_ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">21</span><span class="p">));</span><span class="w"> </span><span class="c1">// =&gt; Хто зна, що буде виведено. </span>
<span class="w">                                    </span><span class="c1">// Може навіть вилетіти з помилкою.</span>

<span class="w">  </span><span class="c1">// Після закінчення роботи із виділеною за допомогою malloc пам&#39;яттю, її обов&#39;язково</span>
<span class="w">  </span><span class="c1">// потрібно звільнити. Інакше ніхто не зможе нею скористатися, аж поки програма не</span>
<span class="w">  </span><span class="c1">// завершить свою роботу (така ситуація називається &quot;витоком пам&#39;яті&quot;).</span>
<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">my_ptr</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Рядки - це масиви символів, проте вони найчастіше представлені як </span>
<span class="w">  </span><span class="c1">// вказівник на символ (тобто, вказівник на перший елемент масиву). Вважається</span>
<span class="w">  </span><span class="c1">// хорошим підходом використовувати `const char *&#39;, посилаючись на об&#39;єкт</span>
<span class="w">  </span><span class="c1">// рядка, оскільки його не можна змінити (&quot;foo&quot;[0] = &#39;a&#39; ЗАБОРОНЕНО).</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">my_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;This is my very own string literal&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">my_str</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; &#39;T&#39;</span>

<span class="w">  </span><span class="c1">// Це не працюватиме, якщо рядок - це масив (потенційно створений за допомогою </span>
<span class="w">  </span><span class="c1">// рядкового літерала), що зберігається у частині пам&#39;яті, яку можна перезаписувати:</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">foo</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foo&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">foo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Дозволяється, foo тепер містить &quot;aoo&quot;</span>

<span class="w">  </span><span class="n">function_1</span><span class="p">();</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// Кінець функції main</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Функції</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// Синтаксис оголошення функції:</span>
<span class="c1">// &lt;тип повернення&gt; &lt;назва функції&gt;(&lt;аргументи&gt;)</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">add_two_ints</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x2</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x2</span><span class="p">;</span><span class="w"> </span><span class="c1">// Використовуйте return, щоб повернути значення</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">Дані у функцію передають за значенням. Коли функція викликається, аргументи, що</span>
<span class="cm">передаються у функцію, копіюються з оригіналів (окрім масивів). Всі зміни над </span>
<span class="cm">значенням аргументів всередині функції не впливають на значення оригіналів.</span>

<span class="cm">Використовуйте вказівники, якщо потрібно редагувати безпосередньо оригінальні </span>
<span class="cm">значення аргументів.</span>

<span class="cm">Приклад: замінити рядок на обернений.</span>
<span class="cm">*/</span>

<span class="c1">// void означає, що функція нічого не повертає</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">str_reverse</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str_in</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">str_in</span><span class="p">);</span><span class="w"> </span><span class="c1">// `strlen()` це частина стандартної бібліотеки С</span>
<span class="w">                               </span><span class="c1">// Зауважте: довжина, яку повертає `strlen`, не включає</span>
<span class="w">                               </span><span class="c1">//           термінальний NULL байт (&#39;\0&#39;)</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">ii</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// в C99 можна напряму оголошувати тип `ii` в циклі</span>
<span class="w">    </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str_in</span><span class="p">[</span><span class="n">ii</span><span class="p">];</span>
<span class="w">    </span><span class="n">str_in</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str_in</span><span class="p">[</span><span class="n">len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="c1">// ii-й символ з кінця</span>
<span class="w">    </span><span class="n">str_in</span><span class="p">[</span><span class="n">len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">// Зауважте: для використання strlen() потрібно завантажити файл заголовку string.h</span>

<span class="cm">/*</span>
<span class="cm">char c[] = &quot;This is a test.&quot;;</span>
<span class="cm">str_reverse(c);</span>
<span class="cm">printf(&quot;%s\n&quot;, c); // =&gt; &quot;.tset a si sihT&quot;</span>
<span class="cm">*/</span>
<span class="cm">/*</span>
<span class="cm">Оскільки можна повертати тільки одну змінну, для зміни значення більшої </span>
<span class="cm">кількості змінних можна використовувати виклик за посиланням</span>
<span class="cm">*/</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">swapTwoNumbers</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm">int first = 10;</span>
<span class="cm">int second = 20;</span>
<span class="cm">printf(&quot;first: %d\nsecond: %d\n&quot;, first, second);</span>
<span class="cm">swapTwoNumbers(&amp;first, &amp;second);</span>
<span class="cm">printf(&quot;first: %d\nsecond: %d\n&quot;, first, second);</span>
<span class="cm">// змінні обмінюються значеннями</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">Масиви завжди передаються у функції як вказівники, не зважаючи на тип масиву </span>
<span class="cm">(статичний чи динамічний). Тому всередині функція не знає про розмір масиву.</span>
<span class="cm">*/</span>
<span class="c1">// Розмір масиву завжди має передаватись разом із масивом!</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">printIntArray</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;arr[%d] is: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm">int my_arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</span>
<span class="cm">int size = 10;</span>
<span class="cm">printIntArray(my_arr, size);</span>
<span class="cm">// виведе &quot;arr[0] is: 1&quot; і т.д.</span>
<span class="cm">*/</span>

<span class="c1">// Ключове слово extern використовується, якщо всередині функції потрібно звернутись</span>
<span class="c1">// до змінної, що була оголошена поза функцією.</span>
<span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">testFunc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">extern</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="c1">// використовуємо зовнішню змінну i</span>
<span class="p">}</span>

<span class="c1">// Зробити зовнішню змінну приватною у вихідному файлі за допомогою static:</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// інші файли, що використовують testFunc2(), </span>
<span class="w">                  </span><span class="c1">// не матимуть доступу до змінної j</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">testFunc2</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">extern</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// Ключове слово static робить змінну недоступною для коду поза даною одиницею </span>
<span class="c1">// компіляції. (На більшості систем, одиниця компіляції - це файл). </span>
<span class="c1">// static можна використовувати до глобальних змінних, функцій, локальних</span>
<span class="c1">// змінних у функціях. Локальні змінні, проініціалізовані static, поводять</span>
<span class="c1">// себе як глобальні змінні, проте тільки в межах даного файлу. Статичні</span>
<span class="c1">// змінні ініціалізуються 0, якщо інше значення не було вказане.</span>
<span class="c1">// **Як варіант, функції можна зробити приватними оголосивши їх як static**</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Користувацькі типи та структури</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// Ключове слово typedef використовується, щоб створити псевдонім типу</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">my_type</span><span class="p">;</span>
<span class="n">my_type</span><span class="w"> </span><span class="n">my_type_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// Структури - це такі собі колекції з даними. Пам&#39;ять для полів виділяється </span>
<span class="c1">// послідовно, в порядку їх написання:</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">height</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Проте це не означає, що </span>
<span class="c1">// sizeof(struct rectangle) == sizeof(int) + sizeof(int)</span>
<span class="c1">// в зв&#39;язку з вирівнюванням пам&#39;яті [1]</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">function_1</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="n">my_rec</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Доступ до полів структури відбувається через .</span>
<span class="w">  </span><span class="n">my_rec</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">  </span><span class="n">my_rec</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Можна створити вказівники на структуру</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="o">*</span><span class="n">my_rec_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">my_rec</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Звернення до структури через вказівник та зміна значень поля:</span>
<span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">my_rec_ptr</span><span class="p">).</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Але є й альтернативний спосіб звернутись до поля через вказівник, використовуючи </span>
<span class="w">  </span><span class="c1">// оператор -&gt; (краще читається)</span>
<span class="w">  </span><span class="n">my_rec_ptr</span><span class="o">-&gt;</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="c1">// Те ж саме, що (*my_rec_ptr).height = 10;</span>
<span class="p">}</span>

<span class="c1">// Можна використати typedef перед struct</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="n">rect</span><span class="p">;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">area</span><span class="p">(</span><span class="n">rect</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Якщо ваша структура доволі громіздка, можна звертатись до неї через вказівник, </span>
<span class="c1">// щоб уникнути копіювання всієї структури:</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">areaptr</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">rect</span><span class="w"> </span><span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Вказівники на функції</span>
<span class="c1">///////////////////////////////////////</span>
<span class="cm">/*</span>
<span class="cm">Під час виконання функції знаходяться за відомими адресами в пам&#39;яті. Вказівники </span>
<span class="cm">на функції - це ті ж самі вказівники, що зберігають адресу у пам&#39;яті, проте можуть</span>
<span class="cm">використовуватись, щоб викликати функції напряму і передавати обробники (або функції зі </span>
<span class="cm">зворотнім зв&#39;язком). Хоча, синтаксис спочатку може бути доволі незрозумілим.</span>

<span class="cm">Приклад: use str_reverse from a pointer</span>
<span class="cm">*/</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">str_reverse_through_pointer</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str_in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Оголосити вказівник на функцію під назвою f.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"> </span><span class="c1">// Сигнатура повинна точно співпадати із цільовою функцією.</span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">str_reverse</span><span class="p">;</span><span class="w"> </span><span class="c1">// Присвойте адресу певної функції (визначається під час виконання)</span>
<span class="w">  </span><span class="c1">// f = str_reverse; повинно працювати також</span>
<span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="n">str_in</span><span class="p">);</span><span class="w"> </span><span class="c1">// Виклик функції через вказівник</span>
<span class="w">  </span><span class="c1">// f(str_in); // Це альтернативний, але теж вірний синтаксис виклику функції.</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">Якщо сигнатури функцій співпадають, можна присвоїти будь-яку функцію тому ж </span>
<span class="cm">самому вказівнику. Вказівники на функції зазвичай використовуються як псевдоніми </span>
<span class="cm">для спрощення та покращення читабельності коду. Приклад:</span>
<span class="cm">*/</span>

<span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">my_fnp_type</span><span class="p">)(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>

<span class="c1">// Використання при оголошенні змінної вказівника:</span>
<span class="c1">// ...</span>
<span class="c1">// my_fnp_type f;</span>


<span class="c1">// Спеціальні символи:</span>
<span class="cm">/*</span>
<span class="cm">&#39;\a&#39;; // символ попередження (дзвінок)</span>
<span class="cm">&#39;\n&#39;; // символ нового рядка</span>
<span class="cm">&#39;\t&#39;; // символ табуляції (вирівнювання по лівому краю)</span>
<span class="cm">&#39;\v&#39;; // вертикальна табуляція</span>
<span class="cm">&#39;\f&#39;; // нова сторінка</span>
<span class="cm">&#39;\r&#39;; // повернення каретки</span>
<span class="cm">&#39;\b&#39;; // стирання останнього символу</span>
<span class="cm">&#39;\0&#39;; // нульовий символ. Зазвичай розташовується в кінці рядка.</span>
<span class="cm">//   hello\n\0. \0 використовується для позначення кінця рядка.</span>
<span class="cm">&#39;\\&#39;; // зворотній слеш</span>
<span class="cm">&#39;\?&#39;; // знак питання</span>
<span class="cm">&#39;\&#39;&#39;; // одинарні лапки</span>
<span class="cm">&#39;\&quot;&#39;; // подвійні лапки</span>
<span class="cm">&#39;\xhh&#39;; // шістнадцяткове число. Наприклад: &#39;\xb&#39; = символ вертикальної табуляції</span>
<span class="cm">&#39;\0oo&#39;; // вісімкове число. Наприклад: &#39;\013&#39; = символ вертикальної табуляції</span>

<span class="cm">// форматування виводу:</span>
<span class="cm">&quot;%d&quot;;    // ціле число (int)</span>
<span class="cm">&quot;%3d&quot;;   // ціле число, щонайменше 3 символи (вирівнювання по правому краю)</span>
<span class="cm">&quot;%s&quot;;    // рядок</span>
<span class="cm">&quot;%f&quot;;    // число з плаваючою крапкою (float)</span>
<span class="cm">&quot;%ld&quot;;   // велике ціле число (long)</span>
<span class="cm">&quot;%3.2f&quot;; // число з плаваючою крапкою, щонайменше 3 цифри зліва і 2 цифри справа </span>
<span class="cm">&quot;%7.4s&quot;; // (аналогічно для рядків)</span>
<span class="cm">&quot;%c&quot;;    // символ</span>
<span class="cm">&quot;%p&quot;;    // вказівник. Зазначте: потребує перетворення типу на (void *) перед </span>
<span class="cm">         //                      використанням у `printf`.</span>
<span class="cm">&quot;%x&quot;;    // шістнадцяткове число</span>
<span class="cm">&quot;%o&quot;;    // вісімкове число</span>
<span class="cm">&quot;%%&quot;;    // друкує %</span>
<span class="cm">*/</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Порядок виконання</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">//---------------------------------------------------//</span>
<span class="c1">//        Оператори                  | Асоціативність//</span>
<span class="c1">//---------------------------------------------------//</span>
<span class="c1">// () [] -&gt; .                        | зліва направо //</span>
<span class="c1">// ! ~ ++ -- + = *(type)sizeof       | справа наліво //</span>
<span class="c1">// * / %                             | зліва направо //</span>
<span class="c1">// + -                               | зліва направо //</span>
<span class="c1">// &lt;&lt; &gt;&gt;                             | зліва направо //</span>
<span class="c1">// &lt; &lt;= &gt; &gt;=                         | зліва направо //</span>
<span class="c1">// == !=                             | зліва направо //</span>
<span class="c1">// &amp;                                 | зліва направо //</span>
<span class="c1">// ^                                 | зліва направо //</span>
<span class="c1">// |                                 | зліва направо //</span>
<span class="c1">// &amp;&amp;                                | зліва направо //</span>
<span class="c1">// ||                                | зліва направо //</span>
<span class="c1">// ?:                                | справа наліво //</span>
<span class="c1">// = += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;= | справа наліво //</span>
<span class="c1">// ,                                 | зліва направо //</span>
<span class="c1">//---------------------------------------------------//</span>

<span class="cm">/****************************** Файли заголовків *********************************</span>

<span class="cm">Файли заголовків важливі в С. Вони розділяють вихідний код та визначення на різні </span>
<span class="cm">файли, що робить їх кращими для розуміння. </span>

<span class="cm">Файли заголовків синтаксично подібні до вихідних файлів С, проте описуються у&quot;.h&quot;</span>
<span class="cm">файлах. Їх можна додати в код за допомогою директиви #include &quot;example.h&quot;, якщо</span>
<span class="cm">example.h існує в тому ж каталозі, що і файл С.</span>
<span class="cm">*/</span>

<span class="cm">/* </span>
<span class="cm">Так можна запобігти тому, що заголовок буде оголошений кілька разів. Така ситуація</span>
<span class="cm">виникає у випадку циклічної залежності, тобто коли вміст заголовку вже було</span>
<span class="cm">оголошено.                                                         </span>
<span class="cm">*/</span>
<span class="cp">#ifndef EXAMPLE_H </span><span class="cm">/* якщо EXAMPLE_H ще не оголошено. */</span>
<span class="cp">#define EXAMPLE_H </span><span class="cm">/* Визначити макрос EXAMPLE_H. */</span>

<span class="cm">/* </span>
<span class="cm">Заголовки можна додавати в інші заголовки, таким чином вони разом додаються</span>
<span class="cm">у подальшому.                      </span>
<span class="cm">*/</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>

<span class="cm">/* </span>
<span class="cm">Макроси можуть бути визначені також у заголовку та використовуватись у файлах,</span>
<span class="cm">що містять цей заголовок. </span>
<span class="cm">*/</span>
<span class="cp">#define EXAMPLE_NAME &quot;Dennis Ritchie&quot;</span>

<span class="cm">/* Макроси функції також можна визначити.  */</span>
<span class="cp">#define ADD(a, b) ((a) + (b))</span>
<span class="cm">/*</span>
<span class="cm">Зверніть увагу на круглі дужки навколо аргументів! Важливо переконатись, що </span>
<span class="cm">a та b не можна проінтерпретувати інакше. Наприклад:</span>
<span class="cm">MUL(x, y) (x * y); </span>
<span class="cm">MUL(1 + 2, 3) -&gt; (1 + 2 * 3), що є помилкою</span>
<span class="cm">*/</span>

<span class="cm">/* Struct та typedef можуть використовуватись для узгодженості між файлами. */</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Node</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Node</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">Node</span><span class="p">;</span>

<span class="cm">/* Так само і перелічення. */</span>
<span class="k">enum</span><span class="w"> </span><span class="n">traffic_light_state</span><span class="w"> </span><span class="p">{</span><span class="n">GREEN</span><span class="p">,</span><span class="w"> </span><span class="n">YELLOW</span><span class="p">,</span><span class="w"> </span><span class="n">RED</span><span class="p">};</span>

<span class="cm">/* </span>
<span class="cm">Прототипи функцій також можна оголосити так, щоб використовувати у кількох </span>
<span class="cm">файлах. Але так робити не варто. Краще оголосити їх у С файлі.</span>
<span class="cm">*/</span>
<span class="n">Node</span><span class="w"> </span><span class="nf">createLinkedList</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">vals</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Окрім вище згаданих випадків, всі інші визначення мають описуватись у С файлах.</span>
<span class="cm">*/</span>

<span class="cp">#endif </span><span class="cm">/* Кінець директиви передкомпіляції if. */</span>
</pre></div>
<h2>Додаткові матеріали</h2>

<p>Кращим посібником для вивчення С буде книга авторства Деніса Рітчі (творець С) та Браяна Кернігана, 
<a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">K&amp;R, aka &ldquo;The C Programming Language&rdquo;</a>.
Але обережно з нею, книга старезна і містить неточності (ідеї, що вже вважаються не надто прийнятними).</p>

<p>Ще одним хорошим ресурсом є книга &ldquo;Learn C The Hard Way&rdquo; (наявна тільки англійською).</p>

<p>На деякі часті запитання дасть відповідь англомовний ресурс <a href="http://c-faq.com">compl.lang.c Frequently Asked Questions</a>.</p>

<p>Нагадаю, що важливо використовувати правильні інтервали, відступи та загалом мати узгоджений стиль коду.
Зручний для читання код краще, ніж складний код або зроблений нашвидкоруч. За прикладом можна звернутись до
<a href="https://www.kernel.org/doc/Documentation/process/coding-style.rst">Linux kernel coding style</a>.</p>

<p>Щодо всього іншого, Ґуґл на допомогу!</p>

<p>[1] <a href="http://stackoverflow.com/questions/119123/why-isnt-sizeof-for-a-struct-equal-to-the-sum-of-sizeof-of-each-member">Чому розмір структури не дорівнює сумі розмірів її полів? (англ.)</a></p>

    <hr>
    <p>Маєте пораду? А може, виправлення? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Відкрийте Issue</a> у GitHub-репозиторії або зробіть <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/uk-ua/c-ua.html.markdown">pull request</a> самостійно!
    </p>
    <p class="contributed">
    Автор початкової версії Adam Bard, оновлено <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/uk-ua/c-ua.html.markdown">9 авторами</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://adambard.com/">Adam Bard</a>,
        <a href="http://twitter.com/H2CO3_iOS">Árpád Goretity</a>,
        <a href="http://cbs.stgn.pl">Jakub Trzebiatowski</a>,
        <a href="https://marcoms.github.io">Marco Scannadinari</a>,
        <a href="https://github.io/zfergus2">Zachary Ferguson</a>,
        <a href="https://github.com/himanshu81494">himanshu</a>,
        <a href="https://github.com/JoshuaRLi">Joshua Li</a>,
        <a href="https://github.com/dchirila">Dragos B. Chirila</a>
    </p>

    <p>
      Translated by:
        <a href="https://github.com/AstiaSun">AstiaSun</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
