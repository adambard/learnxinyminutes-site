<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="en-us" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="en-us" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="en-us" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="en-us" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="en-us">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn sorbet in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/sorbet/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fsorbet%2F&text=Learn+X+in+Y+minutes%2C+where+X%3Dsorbet">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="/">Learn X in Y minutes</a></h1>
  <h2>Where X=sorbet</h2>
    <p class="filelink">
    Get the code:
    <a href="/docs/files/learnsorbet.rb">learnsorbet.rb</a>
    </p>
  <div id="doc">
    <p>Sorbet is a type checker for Ruby. It adds syntax for method signatures that
enable both static and runtime type checking.</p>

<p>The easiest way to see it in action is in the playground at
<a href="https://sorbet.run">sorbet.run</a>.</p>

<p>Try copying in one of the sections below! Each top-level <code>class</code> or <code>module</code>
is independent from the others.</p>
<div class="highlight"><pre><span></span><span class="c1"># Every file should have a &quot;typed sigil&quot; that tells Sorbet how strict to be</span>
<span class="c1"># during static type checking.</span>
<span class="c1">#</span>
<span class="c1"># Strictness levels (lax to strict):</span>
<span class="c1">#</span>
<span class="c1"># ignore: Sorbet won&#39;t even read the file. This means its contents are not</span>
<span class="c1"># visible during type checking. Avoid this.</span>
<span class="c1">#</span>
<span class="c1"># false: Sorbet will only report errors related to constant resolution. This is</span>
<span class="c1"># the default if no sigil is included.</span>
<span class="c1">#</span>
<span class="c1"># true: Sorbet will report all static type errors. This is the sweet spot of</span>
<span class="c1"># safety for effort.</span>
<span class="c1">#</span>
<span class="c1"># strict: Sorbet will require that all methods, constants, and instance</span>
<span class="c1"># variables have static types.</span>
<span class="c1">#</span>
<span class="c1"># strong: Sorbet will no longer allow anything to be T.untyped, even</span>
<span class="c1"># explicitly. Almost nothing satisfies this.</span>

<span class="c1"># typed: true</span>

<span class="c1"># Include the runtime type-checking library. This lets you write inline sigs</span>
<span class="c1"># and have them checked at runtime (instead of running Sorbet as RBI-only).</span>
<span class="c1"># These runtime checks happen even for files with `ignore` or `false` sigils.</span>
<span class="nb">require</span><span class="w"> </span><span class="s1">&#39;sorbet-runtime&#39;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">BasicSigs</span>
<span class="w">  </span><span class="c1"># Bring in the type definition helpers. You&#39;ll almost always need this.</span>
<span class="w">  </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Sig</span>

<span class="w">  </span><span class="c1"># Sigs are defined with `sig` and a block. Define the return value type with</span>
<span class="w">  </span><span class="c1"># `returns`.</span>
<span class="w">  </span><span class="c1">#</span>
<span class="w">  </span><span class="c1"># This method returns a value whose class is `String`. These are the most</span>
<span class="w">  </span><span class="c1"># common types, and Sorbet calls them &quot;class types&quot;.</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">returns</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">greet</span>
<span class="w">    </span><span class="s1">&#39;Hello, World!&#39;</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># Define parameter value types with `params`.</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">n</span><span class="p">:</span><span class="w"> </span><span class="nb">Integer</span><span class="p">)</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">greet_repeat</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">greet</span><span class="w"> </span><span class="p">}</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># Define keyword parameters the same way.</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">n</span><span class="p">:</span><span class="w"> </span><span class="nb">Integer</span><span class="p">,</span><span class="w"> </span><span class="ss">sep</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">greet_repeat_2</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="ss">sep</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">greet</span><span class="w"> </span><span class="p">}</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># Notice that positional/keyword and required/optional make no difference</span>
<span class="w">  </span><span class="c1"># here. They&#39;re all defined the same way in `params`.</span>

<span class="w">  </span><span class="c1"># For lots of parameters, it&#39;s nicer to use do..end and a multiline block</span>
<span class="w">  </span><span class="c1"># instead of curly braces.</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="n">params</span><span class="p">(</span>
<span class="w">      </span><span class="ss">str</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">,</span>
<span class="w">      </span><span class="ss">num</span><span class="p">:</span><span class="w"> </span><span class="nb">Integer</span><span class="p">,</span>
<span class="w">      </span><span class="ss">sym</span><span class="p">:</span><span class="w"> </span><span class="no">Symbol</span><span class="p">,</span>
<span class="w">    </span><span class="p">)</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span>
<span class="w">  </span><span class="k">end</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">uhh</span><span class="p">(</span><span class="ss">str</span><span class="p">:,</span><span class="w"> </span><span class="ss">num</span><span class="p">:,</span><span class="w"> </span><span class="ss">sym</span><span class="p">:)</span>
<span class="w">    </span><span class="s1">&#39;What would you even do with these?&#39;</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># For a method whose return value is useless, use `void`.</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="o">.</span><span class="n">void</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">say_hello</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
<span class="w">    </span><span class="nb">puts</span><span class="w"> </span><span class="s2">&quot;Hello, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">!&quot;</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># Splats! Also known as &quot;rest parameters&quot;, &quot;*args&quot;, &quot;**kwargs&quot;, and others.</span>
<span class="w">  </span><span class="c1">#</span>
<span class="w">  </span><span class="c1"># Type the value that a _member_ of `args` or `kwargs` will have, not `args`</span>
<span class="w">  </span><span class="c1"># or `kwargs` itself.</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">args</span><span class="p">:</span><span class="w"> </span><span class="nb">Integer</span><span class="p">,</span><span class="w"> </span><span class="ss">kwargs</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="o">.</span><span class="n">void</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">no_op</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">kwargs</span><span class="o">[</span><span class="ss">:op</span><span class="o">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s1">&#39;minus&#39;</span>
<span class="w">      </span><span class="n">args</span><span class="o">.</span><span class="n">each</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">|</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="nb">puts</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">      </span><span class="n">args</span><span class="o">.</span><span class="n">each</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">|</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="nb">puts</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># Most initializers should be `void`.</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="o">.</span><span class="n">void</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">initialize</span><span class="p">(</span><span class="nb">name</span><span class="p">:)</span>
<span class="w">    </span><span class="c1"># Instance variables must have annotated types to participate in static</span>
<span class="w">    </span><span class="c1"># type checking.</span>

<span class="w">    </span><span class="c1"># The value in `T.let` is checked statically and at runtime.</span>
<span class="w">    </span><span class="vi">@upname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">let</span><span class="p">(</span><span class="nb">name</span><span class="o">.</span><span class="n">upcase</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span>

<span class="w">    </span><span class="c1"># Sorbet can infer this one!</span>
<span class="w">    </span><span class="vi">@name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">name</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># Constants also need annotated types.</span>
<span class="w">  </span><span class="no">SORBET</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">let</span><span class="p">(</span><span class="s1">&#39;A delicious frozen treat&#39;</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span>

<span class="w">  </span><span class="c1"># Class variables too.</span>
<span class="w">  </span><span class="vc">@@the_answer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">let</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="nb">Integer</span><span class="p">)</span>

<span class="w">  </span><span class="c1"># Sorbet knows about the `attr_*` family.</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">returns</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="kp">attr_reader</span><span class="w"> </span><span class="ss">:upname</span>

<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">write_only</span><span class="p">:</span><span class="w"> </span><span class="nb">Integer</span><span class="p">)</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="nb">Integer</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="kp">attr_writer</span><span class="w"> </span><span class="ss">:write_only</span>

<span class="w">  </span><span class="c1"># You say the reader part and Sorbet will say the writer part.</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">returns</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="kp">attr_accessor</span><span class="w"> </span><span class="ss">:name</span>
<span class="k">end</span>

<span class="k">module</span><span class="w"> </span><span class="nn">Debugging</span>
<span class="w">  </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Sig</span>

<span class="w">  </span><span class="c1"># Sometimes it&#39;s helpful to know what type Sorbet has inferred for an</span>
<span class="w">  </span><span class="c1"># expression. Use `T.reveal_type` to make type-checking show a special error</span>
<span class="w">  </span><span class="c1"># with that information.</span>
<span class="w">  </span><span class="c1">#</span>
<span class="w">  </span><span class="c1"># This is most useful if you have Sorbet integrated into your editor so you</span>
<span class="w">  </span><span class="c1"># can see the result as soon as you save the file.</span>

<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">obj</span><span class="p">:</span><span class="w"> </span><span class="no">Object</span><span class="p">)</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">debug</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="w">    </span><span class="n">T</span><span class="o">.</span><span class="n">reveal_type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="w"> </span><span class="c1"># Revealed type: Object</span>
<span class="w">    </span><span class="n">repr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obj</span><span class="o">.</span><span class="n">inspect</span>

<span class="w">    </span><span class="c1"># Remember that Ruby methods can be called without arguments, so you can</span>
<span class="w">    </span><span class="c1"># save a couple characters!</span>
<span class="w">    </span><span class="n">T</span><span class="o">.</span><span class="n">reveal_type</span><span class="w"> </span><span class="n">repr</span><span class="w"> </span><span class="c1"># Revealed type: String</span>

<span class="w">    </span><span class="s2">&quot;DEBUG: &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">repr</span>
<span class="w">  </span><span class="k">end</span>
<span class="k">end</span>

<span class="k">module</span><span class="w"> </span><span class="nn">StandardLibrary</span>
<span class="w">  </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Sig</span>
<span class="w">  </span><span class="c1"># Sorbet provides some helpers for typing the Ruby standard library.</span>

<span class="w">  </span><span class="c1"># Use T::Boolean to catch both `true` and `false`.</span>
<span class="w">  </span><span class="c1">#</span>
<span class="w">  </span><span class="c1"># For the curious, this is equivalent to</span>
<span class="w">  </span><span class="c1">#</span>
<span class="w">  </span><span class="c1">#     T.type_alias { T.any(TrueClass, FalseClass) }</span>
<span class="w">  </span><span class="c1">#</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">str</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="n">T</span><span class="o">::</span><span class="no">Boolean</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">confirmed?</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
<span class="w">    </span><span class="n">str</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s1">&#39;yes&#39;</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># Remember that the value `nil` is an instance of NilClass.</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">val</span><span class="p">:</span><span class="w"> </span><span class="no">NilClass</span><span class="p">)</span><span class="o">.</span><span class="n">void</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">only_nil</span><span class="p">(</span><span class="ss">val</span><span class="p">:);</span><span class="w"> </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># To avoid modifying standard library classes, Sorbet provides wrappers to</span>
<span class="w">  </span><span class="c1"># support common generics.</span>
<span class="w">  </span><span class="c1">#</span>
<span class="w">  </span><span class="c1"># Here&#39;s the full list:</span>
<span class="w">  </span><span class="c1"># * T::Array</span>
<span class="w">  </span><span class="c1"># * T::Enumerable</span>
<span class="w">  </span><span class="c1"># * T::Enumerator</span>
<span class="w">  </span><span class="c1"># * T::Hash</span>
<span class="w">  </span><span class="c1"># * T::Range</span>
<span class="w">  </span><span class="c1"># * T::Set</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">config</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Hash</span><span class="o">[</span><span class="no">Symbol</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="o">]</span><span class="p">)</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="n">T</span><span class="o">::</span><span class="nb">Array</span><span class="o">[</span><span class="nb">String</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">merge_values</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
<span class="w">    </span><span class="n">keyset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="ss">:old_key</span><span class="p">,</span><span class="w"> </span><span class="ss">:new_key</span><span class="o">]</span>
<span class="w">    </span><span class="n">config</span><span class="o">.</span><span class="n">each_pair</span><span class="o">.</span><span class="n">flat_map</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="o">|</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="o">|</span>
<span class="w">      </span><span class="n">keyset</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">?</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;sensible default&#39;</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># Sometimes (usually dependency injection), a method will accept a reference</span>
<span class="w">  </span><span class="c1"># to a class rather than an instance of the class. Use `T.class_of(Dep)` to</span>
<span class="w">  </span><span class="c1"># accept the `Dep` class itself (or something that inherits from it).</span>
<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">Dep</span><span class="p">;</span><span class="w"> </span><span class="k">end</span>

<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">dep</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">class_of</span><span class="p">(</span><span class="no">Dep</span><span class="p">))</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="no">Dep</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">dependency_injection</span><span class="p">(</span><span class="ss">dep</span><span class="p">:)</span>
<span class="w">    </span><span class="n">dep</span><span class="o">.</span><span class="n">new</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># Blocks, procs, and lambdas, oh my! All of these are typed with `T.proc`.</span>
<span class="w">  </span><span class="c1">#</span>
<span class="w">  </span><span class="c1"># Limitations:</span>
<span class="w">  </span><span class="c1"># 1. All parameters are assumed to be required positional parameters.</span>
<span class="w">  </span><span class="c1"># 2. The only runtime check is that the value is a `Proc`. The argument types</span>
<span class="w">  </span><span class="c1">#    are only checked statically.</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="n">params</span><span class="p">(</span>
<span class="w">      </span><span class="ss">data</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="nb">Array</span><span class="o">[</span><span class="nb">String</span><span class="o">]</span><span class="p">,</span>
<span class="w">      </span><span class="ss">blk</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">proc</span><span class="o">.</span><span class="n">params</span><span class="p">(</span><span class="ss">val</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="nb">Integer</span><span class="p">),</span>
<span class="w">    </span><span class="p">)</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="nb">Integer</span><span class="p">)</span>
<span class="w">  </span><span class="k">end</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">count</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">blk</span><span class="p">)</span>
<span class="w">    </span><span class="n">data</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blk</span><span class="p">)</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">returns</span><span class="p">(</span><span class="nb">Integer</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">count_usage</span>
<span class="w">    </span><span class="n">count</span><span class="p">(</span><span class="o">[</span><span class="s2">&quot;one&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;two&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;three&quot;</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">|</span><span class="n">word</span><span class="o">|</span><span class="w"> </span><span class="n">word</span><span class="o">.</span><span class="n">length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># If the method takes an implicit block, Sorbet will infer `T.untyped` for</span>
<span class="w">  </span><span class="c1"># it. Use the explicit block syntax if the types are important.</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">str</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">untyped</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">implicit_block</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
<span class="w">    </span><span class="k">yield</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># If you&#39;re writing a DSL and will execute the block in a different context,</span>
<span class="w">  </span><span class="c1"># use `bind`.</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">num</span><span class="p">:</span><span class="w"> </span><span class="nb">Integer</span><span class="p">,</span><span class="w"> </span><span class="ss">blk</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">proc</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="nb">Integer</span><span class="p">)</span><span class="o">.</span><span class="n">void</span><span class="p">)</span><span class="o">.</span><span class="n">void</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">number_fun</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">blk</span><span class="p">)</span>
<span class="w">    </span><span class="n">num</span><span class="o">.</span><span class="n">instance_eval</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blk</span><span class="p">)</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">num</span><span class="p">:</span><span class="w"> </span><span class="nb">Integer</span><span class="p">)</span><span class="o">.</span><span class="n">void</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">number_fun_usage</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
<span class="w">    </span><span class="n">number_fun</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">puts</span><span class="w"> </span><span class="n">digits</span><span class="o">.</span><span class="n">join</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># If the block doesn&#39;t take any parameters, don&#39;t include `params`.</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">blk</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">proc</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="nb">Integer</span><span class="p">))</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="nb">Integer</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">doubled_block</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blk</span><span class="p">)</span>
<span class="w">    </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blk</span><span class="o">.</span><span class="n">call</span>
<span class="w">  </span><span class="k">end</span>
<span class="k">end</span>

<span class="k">module</span><span class="w"> </span><span class="nn">Combinators</span>
<span class="w">  </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Sig</span>
<span class="w">  </span><span class="c1"># These methods let you define new types from existing types.</span>

<span class="w">  </span><span class="c1"># Use `T.any` when you have a value that can be one of many types. These are</span>
<span class="w">  </span><span class="c1"># sometimes known as &quot;union types&quot; or &quot;sum types&quot;.</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">num</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="nb">Integer</span><span class="p">,</span><span class="w"> </span><span class="nb">Float</span><span class="p">))</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="no">Rational</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">hundreds</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
<span class="w">    </span><span class="n">num</span><span class="o">.</span><span class="n">rationalize</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># `T.nilable(Type)` is a convenient alias for `T.any(Type, NilClass)`.</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">val</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">nilable</span><span class="p">(</span><span class="nb">String</span><span class="p">))</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="nb">Integer</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">strlen</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
<span class="w">    </span><span class="n">val</span><span class="o">.</span><span class="n">nil?</span><span class="w"> </span><span class="p">?</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">val</span><span class="o">.</span><span class="n">length</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># Use `T.all` when you have a value that must satisfy multiple types. These</span>
<span class="w">  </span><span class="c1"># are sometimes known as &quot;intersection types&quot;. They&#39;re most useful for</span>
<span class="w">  </span><span class="c1"># interfaces (described later), but can also describe helper modules.</span>

<span class="w">  </span><span class="k">module</span><span class="w"> </span><span class="nn">Reversible</span>
<span class="w">    </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Sig</span>
<span class="w">    </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">reverse</span>
<span class="w">      </span><span class="c1"># Pretend this is actually implemented</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="k">module</span><span class="w"> </span><span class="nn">Sortable</span>
<span class="w">    </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Sig</span>
<span class="w">    </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">sort</span>
<span class="w">      </span><span class="c1"># Pretend this is actually implemented</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">List</span>
<span class="w">    </span><span class="kp">include</span><span class="w"> </span><span class="no">Reversible</span>
<span class="w">    </span><span class="kp">include</span><span class="w"> </span><span class="no">Sortable</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">list</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="no">Reversible</span><span class="p">,</span><span class="w"> </span><span class="no">Sortable</span><span class="p">))</span><span class="o">.</span><span class="n">void</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">rev_sort</span><span class="p">(</span><span class="n">list</span><span class="p">)</span>
<span class="w">    </span><span class="c1"># reverse from Reversible</span>
<span class="w">    </span><span class="n">list</span><span class="o">.</span><span class="n">reverse</span>
<span class="w">    </span><span class="c1"># sort from Sortable</span>
<span class="w">    </span><span class="n">list</span><span class="o">.</span><span class="n">sort</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">rev_sort_usage</span>
<span class="w">    </span><span class="n">rev_sort</span><span class="p">(</span><span class="no">List</span><span class="o">.</span><span class="n">new</span><span class="p">)</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># Sometimes, actually spelling out the type every time becomes more confusing</span>
<span class="w">  </span><span class="c1"># than helpful. Use type aliases to make them easier to work with.</span>
<span class="w">  </span><span class="no">JSONLiteral</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">type_alias</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="nb">Float</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Boolean</span><span class="p">,</span><span class="w"> </span><span class="no">NilClass</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">val</span><span class="p">:</span><span class="w"> </span><span class="no">JSONLiteral</span><span class="p">)</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">stringify</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
<span class="w">    </span><span class="n">val</span><span class="o">.</span><span class="n">to_s</span>
<span class="w">  </span><span class="k">end</span>
<span class="k">end</span>

<span class="k">module</span><span class="w"> </span><span class="nn">DataClasses</span>
<span class="w">  </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Sig</span>
<span class="w">  </span><span class="c1"># Use `T::Struct` to create a new class with type-checked fields. It combines</span>
<span class="w">  </span><span class="c1"># the best parts of the standard Struct and OpenStruct, and then adds static</span>
<span class="w">  </span><span class="c1"># typing on top.</span>
<span class="w">  </span><span class="c1">#</span>
<span class="w">  </span><span class="c1"># Types constructed this way are sometimes known as &quot;product types&quot;.</span>

<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">Matcher</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Struct</span>
<span class="w">    </span><span class="c1"># Use `prop` to define a field with both a reader and writer.</span>
<span class="w">    </span><span class="n">prop</span><span class="w"> </span><span class="ss">:count</span><span class="p">,</span><span class="w"> </span><span class="nb">Integer</span>
<span class="w">    </span><span class="c1"># Use `const` to only define the reader and skip the writer.</span>
<span class="w">    </span><span class="n">const</span><span class="w"> </span><span class="ss">:pattern</span><span class="p">,</span><span class="w"> </span><span class="no">Regexp</span>
<span class="w">    </span><span class="c1"># You can still set a default value with `default`.</span>
<span class="w">    </span><span class="n">const</span><span class="w"> </span><span class="ss">:message</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="ss">default</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;Found one!&#39;</span>

<span class="w">    </span><span class="c1"># This is otherwise a normal class, so you can still define methods.</span>

<span class="w">    </span><span class="c1"># You&#39;ll still need to bring `sig` in if you want to use it though.</span>
<span class="w">    </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Sig</span>

<span class="w">    </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">reset</span>
<span class="w">      </span><span class="nb">self</span><span class="o">.</span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">text</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="ss">matchers</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="nb">Array</span><span class="o">[</span><span class="no">Matcher</span><span class="o">]</span><span class="p">)</span><span class="o">.</span><span class="n">void</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">awk</span><span class="p">(</span><span class="n">text</span><span class="p">,</span><span class="w"> </span><span class="n">matchers</span><span class="p">)</span>
<span class="w">    </span><span class="n">matchers</span><span class="o">.</span><span class="n">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:reset</span><span class="p">)</span>
<span class="w">    </span><span class="n">text</span><span class="o">.</span><span class="n">lines</span><span class="o">.</span><span class="n">each</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="o">|</span><span class="n">line</span><span class="o">|</span>
<span class="w">      </span><span class="n">matchers</span><span class="o">.</span><span class="n">each</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="o">|</span><span class="n">matcher</span><span class="o">|</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">matcher</span><span class="o">.</span><span class="n">pattern</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="n">line</span>
<span class="w">          </span><span class="no">Kernel</span><span class="o">.</span><span class="n">puts</span><span class="w"> </span><span class="n">matcher</span><span class="o">.</span><span class="n">message</span>
<span class="w">          </span><span class="n">matcher</span><span class="o">.</span><span class="n">count</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">        </span><span class="k">end</span>
<span class="w">      </span><span class="k">end</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># Gotchas and limitations</span>

<span class="w">  </span><span class="c1"># 1. `const` fields are not truly immutable. They don&#39;t have a writer method,</span>
<span class="w">  </span><span class="c1">#    but may be changed in other ways.</span>
<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">ChangeMe</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Struct</span>
<span class="w">    </span><span class="n">const</span><span class="w"> </span><span class="ss">:list</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="nb">Array</span><span class="o">[</span><span class="nb">Integer</span><span class="o">]</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">change_me</span><span class="p">:</span><span class="w"> </span><span class="no">ChangeMe</span><span class="p">)</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="n">T</span><span class="o">::</span><span class="no">Boolean</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">whoops!</span><span class="p">(</span><span class="n">change_me</span><span class="p">)</span>
<span class="w">    </span><span class="n">change_me</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">ChangeMe</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">list</span><span class="p">:</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="o">]</span><span class="p">)</span>
<span class="w">    </span><span class="n">change_me</span><span class="o">.</span><span class="n">list</span><span class="o">.</span><span class="n">reverse!</span>
<span class="w">    </span><span class="n">change_me</span><span class="o">.</span><span class="n">list</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">]</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># 2. `T::Struct` inherits its equality method from `BasicObject`, which uses</span>
<span class="w">  </span><span class="c1">#    identity equality (also known as &quot;reference equality&quot;).</span>
<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">Coordinate</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Struct</span>
<span class="w">    </span><span class="n">const</span><span class="w"> </span><span class="ss">:row</span><span class="p">,</span><span class="w"> </span><span class="nb">Integer</span>
<span class="w">    </span><span class="n">const</span><span class="w"> </span><span class="ss">:col</span><span class="p">,</span><span class="w"> </span><span class="nb">Integer</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">returns</span><span class="p">(</span><span class="n">T</span><span class="o">::</span><span class="no">Boolean</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">never_equal!</span>
<span class="w">    </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">Coordinate</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">row</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">col</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">    </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">Coordinate</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">row</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">col</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">    </span><span class="n">p1</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">p2</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># Define your own `#==` method to check the fields, if that&#39;s what you want.</span>
<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">Position</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Struct</span>
<span class="w">    </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Sig</span>

<span class="w">    </span><span class="n">const</span><span class="w"> </span><span class="ss">:x</span><span class="p">,</span><span class="w"> </span><span class="nb">Integer</span>
<span class="w">    </span><span class="n">const</span><span class="w"> </span><span class="ss">:y</span><span class="p">,</span><span class="w"> </span><span class="nb">Integer</span>

<span class="w">    </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">other</span><span class="p">:</span><span class="w"> </span><span class="no">Object</span><span class="p">)</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="n">T</span><span class="o">::</span><span class="no">Boolean</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">==</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
<span class="w">      </span><span class="c1"># There&#39;s a real implementation here:</span>
<span class="w">      </span><span class="c1"># https://github.com/tricycle/sorbet-struct-comparable</span>
<span class="w">      </span><span class="kp">true</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># Use `T::Enum` to define a fixed set of values that are easy to reference.</span>
<span class="w">  </span><span class="c1"># This is especially useful when you don&#39;t care what the values _are_ as much</span>
<span class="w">  </span><span class="c1"># as you care that the set of possibilities is closed and static.</span>
<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">Crayon</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Enum</span>
<span class="w">    </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Sig</span>

<span class="w">    </span><span class="c1"># Initialize members with `enums`.</span>
<span class="w">    </span><span class="n">enums</span><span class="w"> </span><span class="k">do</span>
<span class="w">      </span><span class="c1"># Define each member with `new`. Each of these is an instance of the</span>
<span class="w">      </span><span class="c1"># `Crayon` class.</span>
<span class="w">      </span><span class="no">Red</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kp">new</span>
<span class="w">      </span><span class="no">Orange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kp">new</span>
<span class="w">      </span><span class="no">Yellow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kp">new</span>
<span class="w">      </span><span class="no">Green</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kp">new</span>
<span class="w">      </span><span class="no">Blue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kp">new</span>
<span class="w">      </span><span class="no">Violet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kp">new</span>
<span class="w">      </span><span class="no">Brown</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kp">new</span>
<span class="w">      </span><span class="no">Black</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kp">new</span>
<span class="w">      </span><span class="c1"># The default value of the enum is its name in all-lowercase. To change</span>
<span class="w">      </span><span class="c1"># that, pass a value to `new`.</span>
<span class="w">      </span><span class="no">Gray90</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kp">new</span><span class="p">(</span><span class="s1">&#39;light-gray&#39;</span><span class="p">)</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">returns</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">to_hex</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="nb">self</span>
<span class="w">      </span><span class="k">when</span><span class="w"> </span><span class="no">Red</span><span class="w">   </span><span class="k">then</span><span class="w"> </span><span class="s1">&#39;#ff0000&#39;</span>
<span class="w">      </span><span class="k">when</span><span class="w"> </span><span class="no">Green</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="s1">&#39;#00ff00&#39;</span>
<span class="w">      </span><span class="c1"># ...</span>
<span class="w">      </span><span class="k">else</span><span class="w">            </span><span class="s1">&#39;#ffffff&#39;</span>
<span class="w">      </span><span class="k">end</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">crayon</span><span class="p">:</span><span class="w"> </span><span class="no">Crayon</span><span class="p">,</span><span class="w"> </span><span class="ss">path</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="nb">Array</span><span class="o">[</span><span class="no">Position</span><span class="o">]</span><span class="p">)</span><span class="o">.</span><span class="n">void</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">draw</span><span class="p">(</span><span class="ss">crayon</span><span class="p">:,</span><span class="w"> </span><span class="ss">path</span><span class="p">:)</span>
<span class="w">    </span><span class="n">path</span><span class="o">.</span><span class="n">each</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="o">|</span><span class="n">pos</span><span class="o">|</span>
<span class="w">      </span><span class="no">Kernel</span><span class="o">.</span><span class="n">puts</span><span class="w"> </span><span class="s2">&quot;(</span><span class="si">#{</span><span class="n">pos</span><span class="o">.</span><span class="n">x</span><span class="si">}</span><span class="s2">, </span><span class="si">#{</span><span class="n">pos</span><span class="o">.</span><span class="n">y</span><span class="si">}</span><span class="s2">) = &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">crayon</span><span class="o">.</span><span class="n">to_hex</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># To get all the values in the enum, use `.values`. For convenience there&#39;s</span>
<span class="w">  </span><span class="c1"># already a `#serialize` to get the enum string value.</span>

<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">returns</span><span class="p">(</span><span class="n">T</span><span class="o">::</span><span class="nb">Array</span><span class="o">[</span><span class="nb">String</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">crayon_names</span>
<span class="w">    </span><span class="no">Crayon</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:serialize</span><span class="p">)</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># Use the &quot;deserialize&quot; family to go from string to enum value.</span>

<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">nilable</span><span class="p">(</span><span class="no">Crayon</span><span class="p">))</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">crayon_from_name</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="no">Crayon</span><span class="o">.</span><span class="n">has_serialized?</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
<span class="w">      </span><span class="c1"># If the value is not found, this will raise a `KeyError`.</span>
<span class="w">      </span><span class="no">Crayon</span><span class="o">.</span><span class="n">deserialize</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c1"># If the value is not found, this will return `nil`.</span>
<span class="w">    </span><span class="no">Crayon</span><span class="o">.</span><span class="n">try_deserialize</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
<span class="w">  </span><span class="k">end</span>
<span class="k">end</span>

<span class="k">module</span><span class="w"> </span><span class="nn">FlowSensitivity</span>
<span class="w">  </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Sig</span>
<span class="w">  </span><span class="c1"># Sorbet understands Ruby&#39;s control flow constructs and uses that information</span>
<span class="w">  </span><span class="c1"># to get more accurate types when your code branches.</span>

<span class="w">  </span><span class="c1"># You&#39;ll see this most often when doing nil checks.</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">nilable</span><span class="p">(</span><span class="nb">String</span><span class="p">))</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">greet_loudly</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nb">name</span><span class="o">.</span><span class="n">nil?</span>
<span class="w">      </span><span class="s1">&#39;HELLO, YOU!&#39;</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">      </span><span class="c1"># Sorbet knows that `name` must be a String here, so it&#39;s safe to call</span>
<span class="w">      </span><span class="c1"># `#upcase`.</span>
<span class="w">      </span><span class="s2">&quot;HELLO, </span><span class="si">#{</span><span class="nb">name</span><span class="o">.</span><span class="n">upcase</span><span class="si">}</span><span class="s2">!&quot;</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># The nils are a special case of refining `T.any`.</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="nb">Integer</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="nb">Array</span><span class="o">[</span><span class="nb">Integer</span><span class="o">]</span><span class="p">))</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="n">T</span><span class="o">::</span><span class="nb">Array</span><span class="o">[</span><span class="nb">String</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">database_lookup</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nb">id</span><span class="o">.</span><span class="n">is_a?</span><span class="p">(</span><span class="nb">Integer</span><span class="p">)</span>
<span class="w">      </span><span class="c1"># `ids` must be an Integer here.</span>
<span class="w">      </span><span class="o">[</span><span class="nb">id</span><span class="o">.</span><span class="n">to_s</span><span class="o">]</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">      </span><span class="c1"># `ids` must be a T::Array[Integer] here.</span>
<span class="w">      </span><span class="nb">id</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:to_s</span><span class="p">)</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># Sorbet recognizes these methods that narrow type definitions:</span>
<span class="w">  </span><span class="c1"># * is_a?</span>
<span class="w">  </span><span class="c1"># * kind_of?</span>
<span class="w">  </span><span class="c1"># * nil?</span>
<span class="w">  </span><span class="c1"># * Class#===</span>
<span class="w">  </span><span class="c1"># * Class#&lt;</span>
<span class="w">  </span><span class="c1"># * block_given?</span>
<span class="w">  </span><span class="c1">#</span>
<span class="w">  </span><span class="c1"># Because they&#39;re so common, it also recognizes these Rails extensions:</span>
<span class="w">  </span><span class="c1"># * blank?</span>
<span class="w">  </span><span class="c1"># * present?</span>
<span class="w">  </span><span class="c1">#</span>
<span class="w">  </span><span class="c1"># Be careful to maintain Sorbet assumptions if you redefine these methods!</span>

<span class="w">  </span><span class="c1"># Have you ever written this line of code?</span>
<span class="w">  </span><span class="c1">#</span>
<span class="w">  </span><span class="c1">#     raise StandardError, &quot;Can&#39;t happen&quot;</span>
<span class="w">  </span><span class="c1">#</span>
<span class="w">  </span><span class="c1"># Sorbet can help you prove that statically (this is known as</span>
<span class="w">  </span><span class="c1"># &quot;exhaustiveness&quot;) with `T.absurd`.  It&#39;s extra cool when combined with</span>
<span class="w">  </span><span class="c1"># `T::Enum`!</span>

<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">Size</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Enum</span>
<span class="w">    </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Sig</span>

<span class="w">    </span><span class="n">enums</span><span class="w"> </span><span class="k">do</span>
<span class="w">      </span><span class="no">Byte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kp">new</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
<span class="w">      </span><span class="no">Kibibyte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kp">new</span><span class="p">(</span><span class="s1">&#39;KiB&#39;</span><span class="p">)</span>
<span class="w">      </span><span class="no">Mebibyte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kp">new</span><span class="p">(</span><span class="s1">&#39;MiB&#39;</span><span class="p">)</span>
<span class="w">      </span><span class="c1"># &quot;640K ought to be enough for anybody&quot;</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">returns</span><span class="p">(</span><span class="nb">Integer</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">bytes</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="nb">self</span>
<span class="w">        </span><span class="k">when</span><span class="w"> </span><span class="no">Byte</span><span class="w">     </span><span class="k">then</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w">  </span><span class="mi">0</span>
<span class="w">        </span><span class="k">when</span><span class="w"> </span><span class="no">Kibibyte</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">10</span>
<span class="w">        </span><span class="k">when</span><span class="w"> </span><span class="no">Mebibyte</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">20</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">          </span><span class="c1"># Sorbet knows you&#39;ve checked all the cases, so there&#39;s no possible</span>
<span class="w">          </span><span class="c1"># value that `self` could have here.</span>
<span class="w">          </span><span class="c1">#</span>
<span class="w">          </span><span class="c1"># But if you _do_ get here somehow, this will raise at runtime.</span>
<span class="w">          </span><span class="n">T</span><span class="o">.</span><span class="n">absurd</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>

<span class="w">          </span><span class="c1"># If you&#39;re missing a case, Sorbet can even tell you which one it is!</span>
<span class="w">      </span><span class="k">end</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># We&#39;re gonna need `puts` and `raise` for this next part.</span>
<span class="w">  </span><span class="kp">include</span><span class="w"> </span><span class="no">Kernel</span>

<span class="w">  </span><span class="c1"># Sorbet knows that no code can execute after a `raise` statement because it</span>
<span class="w">  </span><span class="c1"># &quot;never returns&quot;.</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">num</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">nilable</span><span class="p">(</span><span class="nb">Integer</span><span class="p">))</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="nb">Integer</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">decrement</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
<span class="w">    </span><span class="k">raise</span><span class="w"> </span><span class="no">ArgumentError</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;¯\_(ツ)_/¯&#39;</span><span class="w"> </span><span class="k">unless</span><span class="w"> </span><span class="n">num</span>

<span class="w">    </span><span class="n">num</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">CustomError</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="no">StandardError</span><span class="p">;</span><span class="w"> </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># You can annotate your own error-raising methods with `T.noreturn`.</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">message</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">noreturn</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">oh_no</span><span class="p">(</span><span class="n">message</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;A bad thing happened&#39;</span><span class="p">)</span>
<span class="w">    </span><span class="nb">puts</span><span class="w"> </span><span class="n">message</span>
<span class="w">    </span><span class="k">raise</span><span class="w"> </span><span class="no">CustomError</span><span class="p">,</span><span class="w"> </span><span class="n">message</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># Infinite loops also don&#39;t return.</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">returns</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">noreturn</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">loading</span>
<span class="w">    </span><span class="kp">loop</span><span class="w"> </span><span class="k">do</span>
<span class="w">      </span><span class="sx">%q(-\|/)</span><span class="o">.</span><span class="n">each_char</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="o">|</span><span class="n">c</span><span class="o">|</span>
<span class="w">        </span><span class="nb">print</span><span class="w"> </span><span class="s2">&quot;</span><span class="se">\r</span><span class="si">#{</span><span class="n">c</span><span class="si">}</span><span class="s2"> reticulating splines...&quot;</span>
<span class="w">        </span><span class="nb">sleep</span><span class="w"> </span><span class="mi">1</span>
<span class="w">      </span><span class="k">end</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># You may run into a situation where Sorbet &quot;loses&quot; your type refinement.</span>
<span class="w">  </span><span class="c1"># Remember that almost everything you do in Ruby is a method call that could</span>
<span class="w">  </span><span class="c1"># return a different value next time you call it. Sorbet doesn&#39;t assume that</span>
<span class="w">  </span><span class="c1"># any methods are pure (even those from `attr_reader` and `attr_accessor`).</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">returns</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">nilable</span><span class="p">(</span><span class="nb">Integer</span><span class="p">))</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">answer</span>
<span class="w">    </span><span class="nb">rand</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="o">.</span><span class="mi">5</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kp">nil</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">bad_typecheck</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">answer</span><span class="o">.</span><span class="n">nil?</span>
<span class="w">      </span><span class="mi">0</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">      </span><span class="c1"># But answer might return `nil` if we call it again!</span>
<span class="w">      </span><span class="n">answer</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">      </span><span class="c1"># ^ Method + does not exist on NilClass component of T.nilable(Integer)</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">good_typecheck</span>
<span class="w">    </span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">answer</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">ans</span><span class="o">.</span><span class="n">nil?</span>
<span class="w">      </span><span class="mi">0</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">      </span><span class="c1"># This time, Sorbet knows that `ans` is non-nil.</span>
<span class="w">      </span><span class="n">ans</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>
<span class="k">end</span>

<span class="k">module</span><span class="w"> </span><span class="nn">InheritancePatterns</span>
<span class="w">  </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Sig</span>

<span class="w">  </span><span class="c1"># If you have a method that always returns the type of its receiver, use</span>
<span class="w">  </span><span class="c1"># `T.self_type`. This is common in fluent interfaces and DSLs.</span>
<span class="w">  </span><span class="c1">#</span>
<span class="w">  </span><span class="c1"># Warning: This feature is still experimental!</span>
<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">Logging</span>
<span class="w">    </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Sig</span>

<span class="w">    </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">returns</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">self_type</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">log</span>
<span class="w">      </span><span class="n">pp</span><span class="w"> </span><span class="nb">self</span>
<span class="w">      </span><span class="nb">self</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">Data</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="no">Logging</span>
<span class="w">    </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Sig</span>

<span class="w">    </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">x</span><span class="p">:</span><span class="w"> </span><span class="nb">Integer</span><span class="p">,</span><span class="w"> </span><span class="ss">y</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="o">.</span><span class="n">void</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">initialize</span><span class="p">(</span><span class="ss">x</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="ss">y</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="w">      </span><span class="vi">@x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span>
<span class="w">      </span><span class="vi">@y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c1"># You don&#39;t _have_ to use `T.self_type` if there&#39;s only one relevant class.</span>
<span class="w">    </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">x</span><span class="p">:</span><span class="w"> </span><span class="nb">Integer</span><span class="p">)</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="no">Data</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">setX</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">      </span><span class="vi">@x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span>
<span class="w">      </span><span class="nb">self</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">y</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="no">Data</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">setY</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="w">      </span><span class="vi">@y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span>
<span class="w">      </span><span class="nb">self</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># Ta-da!</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">data</span><span class="p">:</span><span class="w"> </span><span class="no">Data</span><span class="p">)</span><span class="o">.</span><span class="n">void</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">chaining</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="w">    </span><span class="n">data</span><span class="o">.</span><span class="n">setX</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">setY</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># If it&#39;s a class method (a.k.a. singleton method), use `T.attached_class`.</span>
<span class="w">  </span><span class="c1">#</span>
<span class="w">  </span><span class="c1"># No warning here. This one is stable!</span>
<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">Box</span>
<span class="w">    </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Sig</span>

<span class="w">    </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">contents</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="ss">weight</span><span class="p">:</span><span class="w"> </span><span class="nb">Integer</span><span class="p">)</span><span class="o">.</span><span class="n">void</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">initialize</span><span class="p">(</span><span class="n">contents</span><span class="p">,</span><span class="w"> </span><span class="n">weight</span><span class="p">)</span>
<span class="w">      </span><span class="vi">@contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">contents</span>
<span class="w">      </span><span class="vi">@weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">weight</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">contents</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">attached_class</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nc">self</span><span class="o">.</span><span class="nf">pack</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
<span class="w">      </span><span class="kp">new</span><span class="p">(</span><span class="n">contents</span><span class="p">,</span><span class="w"> </span><span class="n">contents</span><span class="o">.</span><span class="n">chars</span><span class="o">.</span><span class="n">uniq</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">CompanionCube</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="no">Box</span>
<span class="w">    </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Sig</span>

<span class="w">    </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">returns</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">pick_up</span>
<span class="w">      </span><span class="s2">&quot;♥</span><span class="si">#{</span><span class="vi">@contents</span><span class="si">}</span><span class="s2">🤍&quot;</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">returns</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">befriend</span>
<span class="w">    </span><span class="no">CompanionCube</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">pick_up</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># Sorbet has support for abstract classes and interfaces. It can check that</span>
<span class="w">  </span><span class="c1"># all the concrete classes and implementations actually define the required</span>
<span class="w">  </span><span class="c1"># methods with compatible signatures.</span>

<span class="w">  </span><span class="c1"># Here&#39;s an abstract class:</span>

<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">WorkflowStep</span>
<span class="w">    </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Sig</span>

<span class="w">    </span><span class="c1"># Bring in the inheritance helpers.</span>
<span class="w">    </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Helpers</span>

<span class="w">    </span><span class="c1"># Mark this class as abstract. This means it cannot be instantiated with</span>
<span class="w">    </span><span class="c1"># `.new`, but it can still be subclassed.</span>
<span class="w">    </span><span class="n">abstract!</span>

<span class="w">    </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">args</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="nb">Array</span><span class="o">[</span><span class="nb">String</span><span class="o">]</span><span class="p">)</span><span class="o">.</span><span class="n">void</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="w">      </span><span class="n">pre_hook</span>
<span class="w">      </span><span class="n">execute</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="w">      </span><span class="n">post_hook</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c1"># This is an abstract method, which means it _must_ be implemented by</span>
<span class="w">    </span><span class="c1"># subclasses. Add a signature with `abstract` to an empty method to tell</span>
<span class="w">    </span><span class="c1"># Sorbet about it.</span>
<span class="w">    </span><span class="c1">#</span>
<span class="w">    </span><span class="c1"># If this implementation of the method actually gets called at runtime, it</span>
<span class="w">    </span><span class="c1"># will raise `NotImplementedError`.</span>
<span class="w">    </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">abstract</span><span class="o">.</span><span class="n">params</span><span class="p">(</span><span class="ss">args</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="nb">Array</span><span class="o">[</span><span class="nb">String</span><span class="o">]</span><span class="p">)</span><span class="o">.</span><span class="n">void</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="n">args</span><span class="p">);</span><span class="w"> </span><span class="k">end</span>

<span class="w">    </span><span class="c1"># The following non-abstract methods _can_ be implemented by subclasses,</span>
<span class="w">    </span><span class="c1"># but they&#39;re optional.</span>

<span class="w">    </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">pre_hook</span><span class="p">;</span><span class="w"> </span><span class="k">end</span>

<span class="w">    </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">post_hook</span><span class="p">;</span><span class="w"> </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">Configure</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="no">WorkflowStep</span>
<span class="w">    </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Sig</span>

<span class="w">    </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">pre_hook</span>
<span class="w">      </span><span class="nb">puts</span><span class="w"> </span><span class="s1">&#39;Configuring...&#39;</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c1"># To implement an abstract method, mark the signature with `override`.</span>
<span class="w">    </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">override</span><span class="o">.</span><span class="n">params</span><span class="p">(</span><span class="ss">args</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="nb">Array</span><span class="o">[</span><span class="nb">String</span><span class="o">]</span><span class="p">)</span><span class="o">.</span><span class="n">void</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="w">      </span><span class="c1"># ...</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># And here&#39;s an interface:</span>

<span class="w">  </span><span class="k">module</span><span class="w"> </span><span class="nn">Queue</span>
<span class="w">    </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Sig</span>

<span class="w">    </span><span class="c1"># Bring in the inheritance helpers.</span>
<span class="w">    </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Helpers</span>

<span class="w">    </span><span class="c1"># Mark this module as an interface. This adds the following restrictions:</span>
<span class="w">    </span><span class="c1"># 1. All of its methods must be abstract.</span>
<span class="w">    </span><span class="c1"># 2. It cannot have any private or protected methods.</span>
<span class="w">    </span><span class="n">interface!</span>

<span class="w">    </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">abstract</span><span class="o">.</span><span class="n">params</span><span class="p">(</span><span class="ss">num</span><span class="p">:</span><span class="w"> </span><span class="nb">Integer</span><span class="p">)</span><span class="o">.</span><span class="n">void</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">push</span><span class="p">(</span><span class="n">num</span><span class="p">);</span><span class="w"> </span><span class="k">end</span>

<span class="w">    </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">abstract</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">nilable</span><span class="p">(</span><span class="nb">Integer</span><span class="p">))</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">pop</span><span class="p">;</span><span class="w"> </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">PriorityQueue</span>
<span class="w">    </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Sig</span>

<span class="w">    </span><span class="c1"># Include the interface to tell Sorbet that this class implements it.</span>
<span class="w">    </span><span class="c1"># Sorbet doesn&#39;t support implicitly implemented interfaces (also known as</span>
<span class="w">    </span><span class="c1"># &quot;duck typing&quot;).</span>
<span class="w">    </span><span class="kp">include</span><span class="w"> </span><span class="no">Queue</span>

<span class="w">    </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">initialize</span>
<span class="w">      </span><span class="vi">@items</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">let</span><span class="p">(</span><span class="o">[]</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="nb">Array</span><span class="o">[</span><span class="nb">Integer</span><span class="o">]</span><span class="p">)</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c1"># Implement the Queue interface&#39;s abstract methods. Remember to use</span>
<span class="w">    </span><span class="c1"># `override`!</span>

<span class="w">    </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">override</span><span class="o">.</span><span class="n">params</span><span class="p">(</span><span class="ss">num</span><span class="p">:</span><span class="w"> </span><span class="nb">Integer</span><span class="p">)</span><span class="o">.</span><span class="n">void</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">push</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
<span class="w">      </span><span class="vi">@items</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">num</span>
<span class="w">      </span><span class="vi">@items</span><span class="o">.</span><span class="n">sort!</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">override</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">nilable</span><span class="p">(</span><span class="nb">Integer</span><span class="p">))</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">pop</span>
<span class="w">      </span><span class="vi">@items</span><span class="o">.</span><span class="n">shift</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># If you use the `included` hook to get class methods from your modules,</span>
<span class="w">  </span><span class="c1"># you&#39;ll have to use `mixes_in_class_methods` to get them to type-check.</span>

<span class="w">  </span><span class="k">module</span><span class="w"> </span><span class="nn">Mixin</span>
<span class="w">    </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Helpers</span>
<span class="w">    </span><span class="n">interface!</span>

<span class="w">    </span><span class="k">module</span><span class="w"> </span><span class="nn">ClassMethods</span>
<span class="w">      </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Sig</span>

<span class="w">      </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="p">}</span>
<span class="w">      </span><span class="k">def</span><span class="w"> </span><span class="nf">whisk</span>
<span class="w">        </span><span class="s1">&#39;fskfskfsk&#39;</span>
<span class="w">      </span><span class="k">end</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="n">mixes_in_class_methods</span><span class="p">(</span><span class="no">ClassMethods</span><span class="p">)</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">EggBeater</span>
<span class="w">    </span><span class="kp">include</span><span class="w"> </span><span class="no">Mixin</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="no">EggBeater</span><span class="o">.</span><span class="n">whisk</span><span class="w"> </span><span class="c1"># Meringue!</span>
<span class="k">end</span>

<span class="k">module</span><span class="w"> </span><span class="nn">EscapeHatches</span>
<span class="w">  </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Sig</span>

<span class="w">  </span><span class="c1"># Ruby is a very dynamic language, and sometimes Sorbet can&#39;t infer the</span>
<span class="w">  </span><span class="c1"># properties you already know to be true. Although there are ways to rewrite</span>
<span class="w">  </span><span class="c1"># your code so Sorbet can prove safety, you can also choose to &quot;break out&quot; of</span>
<span class="w">  </span><span class="c1"># Sorbet using these &quot;escape hatches&quot;.</span>

<span class="w">  </span><span class="c1"># Once you start using `T.nilable`, Sorbet will start telling you _all_ the</span>
<span class="w">  </span><span class="c1"># places you&#39;re not handling nils. Sometimes, you know a value can&#39;t be nil,</span>
<span class="w">  </span><span class="c1"># but it&#39;s not practical to fix the sigs so Sorbet can prove it. In that</span>
<span class="w">  </span><span class="c1"># case, you can use `T.must`.</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">maybe_str</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">nilable</span><span class="p">(</span><span class="nb">String</span><span class="p">))</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">no_nils_here</span><span class="p">(</span><span class="n">maybe_str</span><span class="p">)</span>
<span class="w">    </span><span class="c1"># If maybe_str _is_ actually nil, this will error at runtime.</span>
<span class="w">    </span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">must</span><span class="p">(</span><span class="n">maybe_str</span><span class="p">)</span>
<span class="w">    </span><span class="n">str</span><span class="o">.</span><span class="n">downcase</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># More generally, if you know that a value must be a specific type, you can</span>
<span class="w">  </span><span class="c1"># use `T.cast`.</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="n">params</span><span class="p">(</span>
<span class="w">      </span><span class="ss">str_or_ary</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="nb">Array</span><span class="o">[</span><span class="nb">String</span><span class="o">]</span><span class="p">),</span>
<span class="w">      </span><span class="ss">idx_or_range</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="nb">Integer</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Range</span><span class="o">[</span><span class="nb">Integer</span><span class="o">]</span><span class="p">),</span>
<span class="w">    </span><span class="p">)</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="n">T</span><span class="o">::</span><span class="nb">Array</span><span class="o">[</span><span class="nb">String</span><span class="o">]</span><span class="p">)</span>
<span class="w">  </span><span class="k">end</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">slice2</span><span class="p">(</span><span class="n">str_or_ary</span><span class="p">,</span><span class="w"> </span><span class="n">idx_or_range</span><span class="p">)</span>
<span class="w">    </span><span class="c1"># Let&#39;s say that, for some reason, we want individual characters from</span>
<span class="w">    </span><span class="c1"># strings or sub-arrays from arrays. The other options are not allowed.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">str_or_ary</span><span class="o">.</span><span class="n">is_a?</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span>
<span class="w">      </span><span class="c1"># Here, we know that `idx_or_range` must be a single index. If it&#39;s not,</span>
<span class="w">      </span><span class="c1"># this will error at runtime.</span>
<span class="w">      </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">idx_or_range</span><span class="p">,</span><span class="w"> </span><span class="nb">Integer</span><span class="p">)</span>
<span class="w">      </span><span class="o">[</span><span class="n">str_or_ary</span><span class="o">.</span><span class="n">chars</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">]</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">      </span><span class="c1"># Here, we know that `idx_or_range` must be a range. If it&#39;s not, this</span>
<span class="w">      </span><span class="c1"># will error at runtime.</span>
<span class="w">      </span><span class="n">range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">idx_or_range</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Range</span><span class="o">[</span><span class="nb">Integer</span><span class="o">]</span><span class="p">)</span>
<span class="w">      </span><span class="n">str_or_ary</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">range</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">[]</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># If you know that a method exists, but Sorbet doesn&#39;t, you can use</span>
<span class="w">  </span><span class="c1"># `T.unsafe` so Sorbet will let you call it. Although we tend to think of</span>
<span class="w">  </span><span class="c1"># this as being an &quot;unsafe method call&quot;, `T.unsafe` is called on the receiver</span>
<span class="w">  </span><span class="c1"># rather than the whole expression.</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">count</span><span class="p">:</span><span class="w"> </span><span class="nb">Integer</span><span class="p">)</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="no">Date</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">the_future</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
<span class="w">    </span><span class="c1"># Let&#39;s say you&#39;ve defined some extra date helpers that Sorbet can&#39;t find.</span>
<span class="w">    </span><span class="c1"># So `2.decades` is effectively `(2*10).years` from ActiveSupport.</span>
<span class="w">    </span><span class="no">Date</span><span class="o">.</span><span class="n">today</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">unsafe</span><span class="p">(</span><span class="n">count</span><span class="p">)</span><span class="o">.</span><span class="n">decades</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># If this is a method on the implicit `self`, you&#39;ll have to make that</span>
<span class="w">  </span><span class="c1"># explicit to use `T.unsafe`.</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">count</span><span class="p">:</span><span class="w"> </span><span class="nb">Integer</span><span class="p">)</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="no">Date</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">the_past</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
<span class="w">    </span><span class="c1"># Let&#39;s say that metaprogramming defines a `now` helper method for</span>
<span class="w">    </span><span class="c1"># `Time.new`. Using it would normally look like this:</span>
<span class="w">    </span><span class="c1">#</span>
<span class="w">    </span><span class="c1">#     now - 1234</span>
<span class="w">    </span><span class="c1">#</span>
<span class="w">    </span><span class="n">T</span><span class="o">.</span><span class="n">unsafe</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span><span class="o">.</span><span class="n">now</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1234</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># There&#39;s a special type in Sorbet called `T.untyped`. For any value of this</span>
<span class="w">  </span><span class="c1"># type, Sorbet will allow it to be used for any method argument and receive</span>
<span class="w">  </span><span class="c1"># any method call.</span>

<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">num</span><span class="p">:</span><span class="w"> </span><span class="nb">Integer</span><span class="p">,</span><span class="w"> </span><span class="ss">anything</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">untyped</span><span class="p">)</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">untyped</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">nothing_to_see_here</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="w"> </span><span class="n">anything</span><span class="p">)</span>
<span class="w">    </span><span class="n">anything</span><span class="o">.</span><span class="n">digits</span><span class="w"> </span><span class="c1"># Is it an Integer...</span>
<span class="w">    </span><span class="n">anything</span><span class="o">.</span><span class="n">upcase</span><span class="w"> </span><span class="c1"># ... or a String?</span>

<span class="w">    </span><span class="c1"># Sorbet will not be able to infer anything about this return value because</span>
<span class="w">    </span><span class="c1"># it&#39;s untyped.</span>
<span class="w">    </span><span class="no">BasicObject</span><span class="o">.</span><span class="n">new</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">see_here</span>
<span class="w">    </span><span class="c1"># It&#39;s actually nil!  This will crash at runtime, but Sorbet allows it.</span>
<span class="w">    </span><span class="n">nothing_to_see_here</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kp">nil</span><span class="p">)</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># For a method without a sig, Sorbet infers the type of each argument and the</span>
<span class="w">  </span><span class="c1"># return value to be `T.untyped`.</span>
<span class="k">end</span>

<span class="c1"># The following types are not officially documented but are still useful. They</span>
<span class="c1"># may be experimental, deprecated, or not supported.</span>

<span class="k">module</span><span class="w"> </span><span class="nn">ValueSet</span>
<span class="w">  </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Sig</span>

<span class="w">  </span><span class="c1"># A common pattern in Ruby is to have a method accept one value from a set of</span>
<span class="w">  </span><span class="c1"># options. Especially when starting out with Sorbet, it may not be practical</span>
<span class="w">  </span><span class="c1"># to refactor the code to use `T::Enum`. In this case, you can use `T.enum`.</span>
<span class="w">  </span><span class="c1">#</span>
<span class="w">  </span><span class="c1"># Note: Sorbet can&#39;t check this statically becuase it doesn&#39;t track the</span>
<span class="w">  </span><span class="c1"># values themselves.</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="n">params</span><span class="p">(</span>
<span class="w">      </span><span class="ss">data</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="nb">Array</span><span class="o">[</span><span class="no">Numeric</span><span class="o">]</span><span class="p">,</span>
<span class="w">      </span><span class="ss">shape</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">enum</span><span class="p">(</span><span class="o">[</span><span class="ss">:circle</span><span class="p">,</span><span class="w"> </span><span class="ss">:square</span><span class="p">,</span><span class="w"> </span><span class="ss">:triangle</span><span class="o">]</span><span class="p">)</span>
<span class="w">    </span><span class="p">)</span><span class="o">.</span><span class="n">void</span>
<span class="w">  </span><span class="k">end</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">plot_points</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="ss">shape</span><span class="p">:</span><span class="w"> </span><span class="ss">:circle</span><span class="p">)</span>
<span class="w">    </span><span class="n">data</span><span class="o">.</span><span class="n">each_with_index</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="o">|</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="o">|</span>
<span class="w">      </span><span class="no">Kernel</span><span class="o">.</span><span class="n">puts</span><span class="w"> </span><span class="s2">&quot;</span><span class="si">#{</span><span class="n">x</span><span class="si">}</span><span class="s2">: </span><span class="si">#{</span><span class="n">y</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>
<span class="k">end</span>

<span class="k">module</span><span class="w"> </span><span class="nn">Generics</span>
<span class="w">  </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Sig</span>

<span class="w">  </span><span class="c1"># Generics are useful when you have a class whose method types change based</span>
<span class="w">  </span><span class="c1"># on the data it contains or a method whose method type changes based on what</span>
<span class="w">  </span><span class="c1"># its arguments are.</span>

<span class="w">  </span><span class="c1"># A generic method uses `type_parameters` to declare type variables and</span>
<span class="w">  </span><span class="c1"># `T.type_parameter` to refer back to them.</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="n">type_parameters</span><span class="p">(</span><span class="ss">:element</span><span class="p">)</span>
<span class="w">      </span><span class="o">.</span><span class="n">params</span><span class="p">(</span>
<span class="w">        </span><span class="ss">element</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">type_parameter</span><span class="p">(</span><span class="ss">:element</span><span class="p">),</span>
<span class="w">        </span><span class="ss">count</span><span class="p">:</span><span class="w"> </span><span class="nb">Integer</span><span class="p">,</span>
<span class="w">      </span><span class="p">)</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="n">T</span><span class="o">::</span><span class="nb">Array</span><span class="o">[</span><span class="n">T</span><span class="o">.</span><span class="n">type_parameter</span><span class="p">(</span><span class="ss">:element</span><span class="p">)</span><span class="o">]</span><span class="p">)</span>
<span class="w">  </span><span class="k">end</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">repeat_value</span><span class="p">(</span><span class="n">element</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">)</span>
<span class="w">    </span><span class="n">count</span><span class="o">.</span><span class="n">times</span><span class="o">.</span><span class="n">each_with_object</span><span class="p">(</span><span class="o">[]</span><span class="p">)</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="o">|</span><span class="n">elt</span><span class="p">,</span><span class="w"> </span><span class="n">ary</span><span class="o">|</span>
<span class="w">      </span><span class="n">ary</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">elt</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="n">type_parameters</span><span class="p">(</span><span class="ss">:element</span><span class="p">)</span>
<span class="w">      </span><span class="o">.</span><span class="n">params</span><span class="p">(</span>
<span class="w">        </span><span class="ss">count</span><span class="p">:</span><span class="w"> </span><span class="nb">Integer</span><span class="p">,</span>
<span class="w">        </span><span class="ss">block</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">proc</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">type_parameter</span><span class="p">(</span><span class="ss">:element</span><span class="p">)),</span>
<span class="w">      </span><span class="p">)</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="n">T</span><span class="o">::</span><span class="nb">Array</span><span class="o">[</span><span class="n">T</span><span class="o">.</span><span class="n">type_parameter</span><span class="p">(</span><span class="ss">:element</span><span class="p">)</span><span class="o">]</span><span class="p">)</span>
<span class="w">  </span><span class="k">end</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">repeat_cached</span><span class="p">(</span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
<span class="w">    </span><span class="n">elt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block</span><span class="o">.</span><span class="n">call</span>
<span class="w">    </span><span class="n">ary</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[]</span>
<span class="w">    </span><span class="n">count</span><span class="o">.</span><span class="n">times</span><span class="w"> </span><span class="k">do</span>
<span class="w">      </span><span class="n">ary</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">elt</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="n">ary</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># A generic class uses `T::Generic.type_member` to define type variables that</span>
<span class="w">  </span><span class="c1"># can be like regular type names.</span>
<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">BidirectionalHash</span>
<span class="w">    </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Sig</span>
<span class="w">    </span><span class="kp">extend</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Generic</span>

<span class="w">    </span><span class="no">Left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">type_member</span>
<span class="w">    </span><span class="no">Right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">type_member</span>

<span class="w">    </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">initialize</span>
<span class="w">      </span><span class="vi">@left_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">let</span><span class="p">({},</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Hash</span><span class="o">[</span><span class="no">Left</span><span class="p">,</span><span class="w"> </span><span class="no">Right</span><span class="o">]</span><span class="p">)</span>
<span class="w">      </span><span class="vi">@right_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">let</span><span class="p">({},</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="no">Hash</span><span class="o">[</span><span class="no">Right</span><span class="p">,</span><span class="w"> </span><span class="no">Left</span><span class="o">]</span><span class="p">)</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c1"># Implement just enough to make the methods below work.</span>

<span class="w">    </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">lkey</span><span class="p">:</span><span class="w"> </span><span class="no">Left</span><span class="p">)</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="n">T</span><span class="o">::</span><span class="no">Boolean</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">lhas?</span><span class="p">(</span><span class="n">lkey</span><span class="p">)</span>
<span class="w">      </span><span class="vi">@left_hash</span><span class="o">.</span><span class="n">has_key?</span><span class="p">(</span><span class="n">lkey</span><span class="p">)</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="n">sig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">params</span><span class="p">(</span><span class="ss">rkey</span><span class="p">:</span><span class="w"> </span><span class="no">Right</span><span class="p">)</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">nilable</span><span class="p">(</span><span class="no">Left</span><span class="p">))</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">rget</span><span class="p">(</span><span class="n">rkey</span><span class="p">)</span>
<span class="w">      </span><span class="vi">@right_hash</span><span class="o">[</span><span class="n">rkey</span><span class="o">]</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># To specialize a generic type, use brackets.</span>
<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="n">params</span><span class="p">(</span>
<span class="w">      </span><span class="ss">options</span><span class="p">:</span><span class="w"> </span><span class="no">BidirectionalHash</span><span class="o">[</span><span class="no">Symbol</span><span class="p">,</span><span class="w"> </span><span class="nb">Integer</span><span class="o">]</span><span class="p">,</span>
<span class="w">      </span><span class="ss">choice</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="no">Symbol</span><span class="p">,</span><span class="w"> </span><span class="nb">Integer</span><span class="p">),</span>
<span class="w">    </span><span class="p">)</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">nilable</span><span class="p">(</span><span class="nb">String</span><span class="p">))</span>
<span class="w">  </span><span class="k">end</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">lookup</span><span class="p">(</span><span class="n">options</span><span class="p">,</span><span class="w"> </span><span class="n">choice</span><span class="p">)</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="n">choice</span>
<span class="w">    </span><span class="k">when</span><span class="w"> </span><span class="no">Symbol</span>
<span class="w">      </span><span class="n">options</span><span class="o">.</span><span class="n">lhas?</span><span class="p">(</span><span class="n">choice</span><span class="p">)</span><span class="w"> </span><span class="p">?</span><span class="w"> </span><span class="n">choice</span><span class="o">.</span><span class="n">to_s</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kp">nil</span>
<span class="w">    </span><span class="k">when</span><span class="w"> </span><span class="nb">Integer</span>
<span class="w">      </span><span class="n">options</span><span class="o">.</span><span class="n">rget</span><span class="p">(</span><span class="n">choice</span><span class="p">)</span><span class="o">.</span><span class="n">to_s</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">      </span><span class="n">T</span><span class="o">.</span><span class="n">absurd</span><span class="p">(</span><span class="n">choice</span><span class="p">)</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># To specialize through inheritance, re-declare the `type_member` with</span>
<span class="w">  </span><span class="c1"># `fixed`.</span>
<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">Options</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="no">BidirectionalHash</span>
<span class="w">    </span><span class="no">Left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">type_member</span><span class="p">(</span><span class="ss">fixed</span><span class="p">:</span><span class="w"> </span><span class="no">Symbol</span><span class="p">)</span>
<span class="w">    </span><span class="no">Right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">type_member</span><span class="p">(</span><span class="ss">fixed</span><span class="p">:</span><span class="w"> </span><span class="nb">Integer</span><span class="p">)</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="n">sig</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="n">params</span><span class="p">(</span>
<span class="w">      </span><span class="ss">options</span><span class="p">:</span><span class="w"> </span><span class="no">Options</span><span class="p">,</span>
<span class="w">      </span><span class="ss">choice</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="no">Symbol</span><span class="p">,</span><span class="w"> </span><span class="nb">Integer</span><span class="p">),</span>
<span class="w">    </span><span class="p">)</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">nilable</span><span class="p">(</span><span class="nb">String</span><span class="p">))</span>
<span class="w">  </span><span class="k">end</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">lookup2</span><span class="p">(</span><span class="n">options</span><span class="p">,</span><span class="w"> </span><span class="n">choice</span><span class="p">)</span>
<span class="w">    </span><span class="n">lookup</span><span class="p">(</span><span class="n">options</span><span class="p">,</span><span class="w"> </span><span class="n">choice</span><span class="p">)</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># There are other variance annotations you can add to `type_member`, but</span>
<span class="w">  </span><span class="c1"># they&#39;re rarely used.</span>
<span class="k">end</span>
</pre></div>
<h2>Additional resources</h2>

<ul>
<li><a href="https://sorbet.org/docs/overview">Official Documentation</a></li>
<li><a href="https://sorbet.run">sorbet.run</a> - Playground</li>
</ul>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/sorbet.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by Jeremy Kaplan, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/sorbet.html.markdown">0 contributors</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="https://jdkaplan.dev">Jeremy Kaplan</a>
    </p>

    <p>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
