<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="en-us" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="en-us" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="en-us" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="en-us" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="en-us">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn chapel in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/chapel/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fchapel%2F&text=Learn+X+in+Y+minutes%2C+where+X%3Dchapel">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="/">Learn X in Y minutes</a></h1>
  <h2>Where X=chapel</h2>
    <p class="filelink">
    Get the code:
    <a href="/docs/files/learnchapel.chpl">learnchapel.chpl</a>
    </p>
  <div id="doc">
    <p>You can read all about Chapel at <a href="https://chapel-lang.org">Cray&rsquo;s official Chapel website</a>.
In short, Chapel is an open-source, high-productivity, parallel-programming
language in development at Cray Inc., and is designed to run on multi-core PCs
as well as multi-kilocore supercomputers.</p>

<p>More information and support can be found at the bottom of this document.</p>
<div class="highlight"><pre><span></span><span class="c1">// Comments are C-family style</span>

<span class="c1">// one line comment</span>
<span class="cm">/*</span>
<span class="cm"> multi-line comment</span>
<span class="cm">*/</span>

<span class="c1">// Basic printing</span>

<span class="nx">write</span><span class="p">(</span><span class="s">&quot;Hello, &quot;</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;World!&quot;</span><span class="p">);</span>

<span class="c1">// write and writeln can take a list of things to print.</span>
<span class="c1">// Each thing is printed right next to the others, so include your spacing!</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;There are &quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; commas (\&quot;,\&quot;) in this line of code&quot;</span><span class="p">);</span>

<span class="c1">// Different output channels:</span>
<span class="nx">stdout</span><span class="p">.</span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;This goes to standard output, just like plain writeln() does&quot;</span><span class="p">);</span>
<span class="nx">stderr</span><span class="p">.</span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;This goes to standard error&quot;</span><span class="p">);</span>


<span class="c1">// Variables don&#39;t have to be explicitly typed as long as</span>
<span class="c1">// the compiler can figure out the type that it will hold.</span>
<span class="c1">// 10 is an int, so myVar is implicitly an int</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="nx">myVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">10</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">mySecondVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">myVar</span><span class="p">;</span>
<span class="c1">// var anError; would be a compile-time error.</span>

<span class="c1">// We can (and should) explicitly type things.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myThirdVar</span><span class="p">:</span><span class="w"> </span><span class="kt">real</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myFourthVar</span><span class="p">:</span><span class="w"> </span><span class="kt">real</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">1.234</span><span class="p">;</span>
<span class="nx">myThirdVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">myFourthVar</span><span class="p">;</span>

<span class="c1">// Types</span>

<span class="c1">// There are a number of basic types.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myInt</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="c1">// Signed ints</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myUint</span><span class="p">:</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1234</span><span class="p">;</span><span class="w"> </span><span class="c1">// Unsigned ints</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myReal</span><span class="p">:</span><span class="w"> </span><span class="kt">real</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">9.876</span><span class="p">;</span><span class="w"> </span><span class="c1">// Floating point numbers</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myImag</span><span class="p">:</span><span class="w"> </span><span class="kt">imag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">5.0i</span><span class="p">;</span><span class="w"> </span><span class="c1">// Imaginary numbers</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myCplx</span><span class="p">:</span><span class="w"> </span><span class="kt">complex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">9i</span><span class="p">;</span><span class="w"> </span><span class="c1">// Complex numbers</span>
<span class="nx">myCplx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">myInt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">myImag</span><span class="p">;</span><span class="w"> </span><span class="c1">// Another way to form complex numbers</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myBool</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Booleans</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myStr</span><span class="p">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Some string...&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Strings</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">singleQuoteStr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#39;Another string...&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// String literal with single quotes</span>

<span class="c1">// Some types can have sizes.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">my8Int</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="c1">// 8 bit (one byte) sized int;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">my64Real</span><span class="p">:</span><span class="w"> </span><span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.516</span><span class="p">;</span><span class="w"> </span><span class="c1">// 64 bit (8 bytes) sized real</span>

<span class="c1">// Typecasting.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">intFromReal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">myReal</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">intFromReal2</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">myReal</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>

<span class="c1">// Type aliasing.</span>
<span class="kd">type</span><span class="w"> </span><span class="nx">chroma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w">        </span><span class="c1">// Type of a single hue</span>
<span class="kd">type</span><span class="w"> </span><span class="nx">RGBColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">*</span><span class="nx">chroma</span><span class="p">;</span><span class="w"> </span><span class="c1">// Type representing a full color</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">black</span><span class="p">:</span><span class="w"> </span><span class="nx">RGBColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">white</span><span class="p">:</span><span class="w"> </span><span class="nx">RGBColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">255</span><span class="p">,</span><span class="w"> </span><span class="mi">255</span><span class="p">,</span><span class="w"> </span><span class="mi">255</span><span class="p">);</span>

<span class="c1">// Constants and Parameters</span>

<span class="c1">// A const is a constant, and cannot be changed after set in runtime.</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">almostPi</span><span class="p">:</span><span class="w"> </span><span class="kt">real</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">22.0</span><span class="o">/</span><span class="mf">7.0</span><span class="p">;</span>

<span class="c1">// A param is a constant whose value must be known statically at</span>
<span class="c1">// compile-time.</span>
<span class="kd">param</span><span class="w"> </span><span class="nx">compileTimeConst</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>

<span class="c1">// The config modifier allows values to be set at the command line.</span>
<span class="c1">// Set with --varCmdLineArg=Value or --varCmdLineArg Value at runtime.</span>
<span class="kd">config</span><span class="w"> </span><span class="kd">var</span><span class="w"> </span><span class="nx">varCmdLineArg</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">123</span><span class="p">;</span>
<span class="kd">config</span><span class="w"> </span><span class="kd">const</span><span class="w"> </span><span class="nx">constCmdLineArg</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">777</span><span class="p">;</span>

<span class="c1">// config param can be set at compile-time.</span>
<span class="c1">// Set with --set paramCmdLineArg=value at compile-time.</span>
<span class="kd">config</span><span class="w"> </span><span class="kd">param</span><span class="w"> </span><span class="nx">paramCmdLineArg</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">varCmdLineArg</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">constCmdLineArg</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">paramCmdLineArg</span><span class="p">);</span>

<span class="c1">// References</span>

<span class="c1">// ref operates much like a reference in C++. In Chapel, a ref cannot</span>
<span class="c1">// be made to alias a variable other than the variable it is initialized with.</span>
<span class="c1">// Here, refToActual refers to actual.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">actual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="kd">ref</span><span class="w"> </span><span class="nx">refToActual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">actual</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">actual</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; == &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">refToActual</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints the same value</span>
<span class="nx">actual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">123</span><span class="p">;</span><span class="w"> </span><span class="c1">// modify actual (which refToActual refers to)</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">actual</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; == &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">refToActual</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints the same value</span>
<span class="nx">refToActual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">99999999</span><span class="p">;</span><span class="w"> </span><span class="c1">// modify what refToActual refers to (which is actual)</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">actual</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; == &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">refToActual</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints the same value</span>

<span class="c1">// Operators</span>

<span class="c1">// Math operators:</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">a</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1234</span><span class="p">,</span><span class="w"> </span><span class="nx">thatInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5678</span><span class="p">;</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">  </span><span class="c1">// Addition</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">  </span><span class="c1">// Multiplication</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">  </span><span class="c1">// Subtraction</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">  </span><span class="c1">// Division</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w"> </span><span class="c1">// Exponentiation</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">  </span><span class="c1">// Remainder (modulo)</span>

<span class="c1">// Logical operators:</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">b</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="nx">thisBool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="nx">thatBool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisBool</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">thatBool</span><span class="p">;</span><span class="w"> </span><span class="c1">// Logical and</span>
<span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisBool</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">thatBool</span><span class="p">;</span><span class="w"> </span><span class="c1">// Logical or</span>
<span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="nx">thisBool</span><span class="p">;</span><span class="w">            </span><span class="c1">// Logical negation</span>

<span class="c1">// Relational operators:</span>
<span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">           </span><span class="c1">// Greater-than</span>
<span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">          </span><span class="c1">// Greater-than-or-equal-to</span>
<span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w"> </span><span class="c1">// Less-than, and, less-than-or-equal-to</span>
<span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">          </span><span class="c1">// Not-equal-to</span>
<span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">          </span><span class="c1">// Equal-to</span>

<span class="c1">// Bitwise operators:</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">     </span><span class="c1">// Left-bit-shift by 10 bits;</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thatInt</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">      </span><span class="c1">// Right-bit-shift by 5 bits;</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">~</span><span class="nx">thisInt</span><span class="p">;</span><span class="w">          </span><span class="c1">// Bitwise-negation</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w"> </span><span class="c1">// Bitwise exclusive-or</span>

<span class="c1">// Compound assignment operators:</span>
<span class="nx">a</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">thisInt</span><span class="p">;</span><span class="w">          </span><span class="c1">// Addition-equals (a = a + thisInt;)</span>
<span class="nx">a</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">          </span><span class="c1">// Times-equals (a = a * thatInt;)</span>
<span class="nx">b</span><span class="w"> </span><span class="o">&amp;&amp;=</span><span class="w"> </span><span class="nx">thatBool</span><span class="p">;</span><span class="w">        </span><span class="c1">// Logical-and-equals (b = b &amp;&amp; thatBool;)</span>
<span class="nx">a</span><span class="w"> </span><span class="o">&lt;&lt;=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">               </span><span class="c1">// Left-bit-shift-equals (a = a &lt;&lt; 10;)</span>

<span class="c1">// Unlike other C family languages, there are no</span>
<span class="c1">// pre/post-increment/decrement operators, such as:</span>
<span class="c1">//</span>
<span class="c1">// ++j, --j, j++, j--</span>

<span class="c1">// Swap operator:</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">old_this</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">old_that</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span>
<span class="nx">thisInt</span><span class="w"> </span><span class="o">&lt;=&gt;</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w"> </span><span class="c1">// Swap the values of thisInt and thatInt</span>
<span class="nx">writeln</span><span class="p">((</span><span class="nx">old_this</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="nx">old_that</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">thisInt</span><span class="p">));</span>

<span class="c1">// Operator overloads can also be defined, as we&#39;ll see with procedures.</span>

<span class="c1">// Tuples</span>

<span class="c1">// Tuples can be of the same type or different types.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">sameTup</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">sameTup2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">6</span><span class="p">);</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">diffTup</span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">real</span><span class="p">,</span><span class="kt">complex</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mf">1.928</span><span class="p">,</span><span class="w"> </span><span class="nx">myCplx</span><span class="p">);</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">diffTupe2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mf">5.64</span><span class="p">,</span><span class="w"> </span><span class="mf">6.0</span><span class="o">+</span><span class="m">1.5i</span><span class="p">);</span>

<span class="c1">// Tuples can be accessed using square brackets or parentheses, and are</span>
<span class="c1">// 1-indexed.</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;(&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">sameTup</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">sameTup</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">diffTup</span><span class="p">);</span>

<span class="c1">// Tuples can also be written into.</span>
<span class="nx">diffTup</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="c1">// Tuple values can be expanded into their own variables.</span>
<span class="kd">var</span><span class="w"> </span><span class="p">(</span><span class="nx">tupInt</span><span class="p">,</span><span class="w"> </span><span class="nx">tupReal</span><span class="p">,</span><span class="w"> </span><span class="nx">tupCplx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">diffTup</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">diffTup</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="nx">tupInt</span><span class="p">,</span><span class="w"> </span><span class="nx">tupReal</span><span class="p">,</span><span class="w"> </span><span class="nx">tupCplx</span><span class="p">));</span>

<span class="c1">// They are also useful for writing a list of variables, as is common in debugging.</span>
<span class="nx">writeln</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">thisInt</span><span class="p">,</span><span class="nx">thatInt</span><span class="p">,</span><span class="nx">thisBool</span><span class="p">,</span><span class="nx">thatBool</span><span class="p">));</span>

<span class="c1">// Control Flow</span>

<span class="c1">// if - then - else works just like any other C-family language.</span>
<span class="k">if</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="k">then</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;All is well&quot;</span><span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">then</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Continuing to believe reality&quot;</span><span class="p">);</span>
<span class="k">else</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Send mathematician, something is wrong&quot;</span><span class="p">);</span>

<span class="c1">// You can use parentheses if you prefer.</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">10</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Universe broken. Please reboot universe.&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; is even.&quot;</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; is odd.&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; is even divisible by 3.&quot;</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; is divided by 3 with a remainder of 1.&quot;</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; is divided by 3 with a remainder of 2.&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Ternary: if - then - else in a statement.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">maximum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">thatInt</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="nx">thatInt</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="nx">thisInt</span><span class="p">;</span>

<span class="c1">// select statements are much like switch statements in other languages.</span>
<span class="c1">// However, select statements do not cascade like in C or Java.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">inputOption</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;anOption&quot;</span><span class="p">;</span>
<span class="k">select</span><span class="w"> </span><span class="nx">inputOption</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">when</span><span class="w"> </span><span class="s">&quot;anOption&quot;</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Chose &#39;anOption&#39;&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">when</span><span class="w"> </span><span class="s">&quot;otherOption&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Chose &#39;otherOption&#39;&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Which has a body&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">otherwise</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Any other Input&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;the otherwise case does not need a do if the body is one line&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// while and do-while loops also behave like their C counterparts.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">j</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">jSum</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nx">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1000</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">jSum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">j</span><span class="p">;</span>
<span class="w">  </span><span class="nx">j</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">jSum</span><span class="p">);</span>

<span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">jSum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">j</span><span class="p">;</span>
<span class="w">  </span><span class="nx">j</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nx">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">10000</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">jSum</span><span class="p">);</span>

<span class="c1">// for loops are much like those in Python in that they iterate over a</span>
<span class="c1">// range. Ranges (like the 1..10 expression below) are a first-class object</span>
<span class="c1">// in Chapel, and as such can be stored in variables.</span>
<span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">write</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">();</span>

<span class="kd">var</span><span class="w"> </span><span class="nx">iSum</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">1000</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">iSum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">i</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">iSum</span><span class="p">);</span>

<span class="k">for</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">write</span><span class="p">((</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;\t&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Ranges and Domains</span>

<span class="c1">// For-loops and arrays both use ranges and domains to define an index set that</span>
<span class="c1">// can be iterated over. Ranges are single dimensional integer indices, while</span>
<span class="c1">// domains can be multi-dimensional and represent indices of different types.</span>

<span class="c1">// They are first-class citizen types, and can be assigned into variables.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">range1to10</span><span class="p">:</span><span class="w"> </span><span class="kt">range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">;</span><span class="w">  </span><span class="c1">// 1, 2, 3, ..., 10</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">range2to11</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="o">..</span><span class="mi">11</span><span class="p">;</span><span class="w"> </span><span class="c1">// 2, 3, 4, ..., 11</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">rangeThisToThat</span><span class="p">:</span><span class="w"> </span><span class="kt">range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="o">..</span><span class="nx">thatInt</span><span class="p">;</span><span class="w"> </span><span class="c1">// using variables</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">rangeEmpty</span><span class="p">:</span><span class="w"> </span><span class="kt">range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="o">..-</span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="c1">// this is valid but contains no indices</span>

<span class="c1">// Ranges can be unbounded.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">range1toInf</span><span class="p">:</span><span class="w"> </span><span class="kt">range</span><span class="p">(</span><span class="nx">boundedType</span><span class="o">=</span><span class="nx">BoundedRangeType</span><span class="p">.</span><span class="nx">boundedLow</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="c1">// 1, 2, 3, 4, 5, ...</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">rangeNegInfTo1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">..</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// ..., -4, -3, -2, -1, 0, 1</span>

<span class="c1">// Ranges can be strided (and reversed) using the by operator.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">range2to10by2</span><span class="p">:</span><span class="w"> </span><span class="kt">range</span><span class="p">(</span><span class="nx">stridable</span><span class="o">=</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// 2, 4, 6, 8, 10</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">reverse2to10by2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// 10, 8, 6, 4, 2</span>

<span class="kd">var</span><span class="w"> </span><span class="nx">trapRange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="o">..</span><span class="mi">1</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Do not be fooled, this is still an empty range</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Size of range &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">trapRange</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; = &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">trapRange</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>

<span class="c1">// Note: range(boundedType= ...) and range(stridable= ...) are only</span>
<span class="c1">// necessary if we explicitly type the variable.</span>

<span class="c1">// The end point of a range can be determined using the count (#) operator.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">rangeCount</span><span class="p">:</span><span class="w"> </span><span class="kt">range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">5</span><span class="o">..#</span><span class="mi">12</span><span class="p">;</span><span class="w"> </span><span class="c1">// range from -5 to 6</span>

<span class="c1">// Operators can be mixed.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">rangeCountBy</span><span class="p">:</span><span class="w"> </span><span class="kt">range</span><span class="p">(</span><span class="nx">stridable</span><span class="o">=</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">5</span><span class="o">..#</span><span class="mi">12</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// -5, -3, -1, 1, 3, 5</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">rangeCountBy</span><span class="p">);</span>

<span class="c1">// Properties of the range can be queried.</span>
<span class="c1">// In this example, printing the first index, last index, number of indices,</span>
<span class="c1">// stride, and if 2 is include in the range.</span>
<span class="nx">writeln</span><span class="p">((</span><span class="nx">rangeCountBy</span><span class="p">.</span><span class="nx">first</span><span class="p">,</span><span class="w"> </span><span class="nx">rangeCountBy</span><span class="p">.</span><span class="nx">last</span><span class="p">,</span><span class="w"> </span><span class="nx">rangeCountBy</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span>
<span class="w">           </span><span class="nx">rangeCountBy</span><span class="p">.</span><span class="nx">stride</span><span class="p">,</span><span class="w"> </span><span class="nx">rangeCountBy</span><span class="p">.</span><span class="nx">member</span><span class="p">(</span><span class="mi">2</span><span class="p">)));</span>

<span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">rangeCountBy</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">write</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">rangeCountBy</span><span class="p">.</span><span class="nx">last</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="s">&quot;\n&quot;</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Rectangular domains are defined using the same range syntax,</span>
<span class="c1">// but they are required to be bounded (unlike ranges).</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">domain1to10</span><span class="p">:</span><span class="w"> </span><span class="k">domain</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">};</span><span class="w">        </span><span class="c1">// 1D domain from 1..10;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">twoDimensions</span><span class="p">:</span><span class="w"> </span><span class="k">domain</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="o">..</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="o">..</span><span class="mi">2</span><span class="p">};</span><span class="w"> </span><span class="c1">// 2D domain over product of ranges</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">thirdDim</span><span class="p">:</span><span class="w"> </span><span class="kt">range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">16</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">threeDims</span><span class="p">:</span><span class="w"> </span><span class="k">domain</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="nx">thirdDim</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="o">..</span><span class="mi">10</span><span class="p">};</span><span class="w"> </span><span class="c1">// using a range variable</span>

<span class="c1">// Domains can also be resized</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">resizedDom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">};</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;before, resizedDom = &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">resizedDom</span><span class="p">);</span>
<span class="nx">resizedDom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="o">-</span><span class="mi">10</span><span class="o">..#</span><span class="mi">10</span><span class="p">};</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;after, resizedDom = &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">resizedDom</span><span class="p">);</span>

<span class="c1">// Indices can be iterated over as tuples.</span>
<span class="k">for</span><span class="w"> </span><span class="nx">idx</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">twoDimensions</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="nx">write</span><span class="p">(</span><span class="nx">idx</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">();</span>

<span class="c1">// These tuples can also be deconstructed.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">)</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">twoDimensions</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">write</span><span class="p">(</span><span class="s">&quot;(&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">writeln</span><span class="p">();</span>

<span class="c1">// Associative domains act like sets.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">stringSet</span><span class="p">:</span><span class="w"> </span><span class="k">domain</span><span class="p">(</span><span class="kt">string</span><span class="p">);</span><span class="w"> </span><span class="c1">// empty set of strings</span>
<span class="nx">stringSet</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="p">;</span>
<span class="nx">stringSet</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;b&quot;</span><span class="p">;</span>
<span class="nx">stringSet</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;c&quot;</span><span class="p">;</span>
<span class="nx">stringSet</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Redundant add &quot;a&quot;</span>
<span class="nx">stringSet</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="s">&quot;c&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Remove &quot;c&quot;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">stringSet</span><span class="p">.</span><span class="nx">sorted</span><span class="p">());</span>

<span class="c1">// Associative domains can also have a literal syntax</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">intSet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">};</span>

<span class="c1">// Both ranges and domains can be sliced to produce a range or domain with the</span>
<span class="c1">// intersection of indices.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">rangeA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="c1">// range from 1 to infinity</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">rangeB</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="o">..</span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// range from negative infinity to 5</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">rangeC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">rangeA</span><span class="p">[</span><span class="nx">rangeB</span><span class="p">];</span><span class="w"> </span><span class="c1">// resulting range is 1..5</span>
<span class="nx">writeln</span><span class="p">((</span><span class="nx">rangeA</span><span class="p">,</span><span class="w"> </span><span class="nx">rangeB</span><span class="p">,</span><span class="w"> </span><span class="nx">rangeC</span><span class="p">));</span>

<span class="kd">var</span><span class="w"> </span><span class="nx">domainA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="o">..</span><span class="mi">20</span><span class="p">};</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">domainB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="o">-</span><span class="mi">5</span><span class="o">..</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">};</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">domainC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">domainA</span><span class="p">[</span><span class="nx">domainB</span><span class="p">];</span>
<span class="nx">writeln</span><span class="p">((</span><span class="nx">domainA</span><span class="p">,</span><span class="w"> </span><span class="nx">domainB</span><span class="p">,</span><span class="w"> </span><span class="nx">domainC</span><span class="p">));</span>

<span class="c1">// Arrays</span>

<span class="c1">// Arrays are similar to those of other languages.</span>
<span class="c1">// Their sizes are defined using domains that represent their indices.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">intArray</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">intArray2</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">}]</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w"> </span><span class="c1">// equivalent</span>

<span class="c1">// They can be accessed using either brackets or parentheses</span>
<span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="nx">intArray</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="nx">i</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">intArray</span><span class="p">);</span>

<span class="c1">// We cannot access intArray[0] because it exists outside</span>
<span class="c1">// of the index set, {1..10}, we defined it to have.</span>
<span class="c1">// intArray[11] is illegal for the same reason.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">realDomain</span><span class="p">:</span><span class="w"> </span><span class="k">domain</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="o">..</span><span class="mi">7</span><span class="p">};</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">realArray</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="nx">realDomain</span><span class="p">]</span><span class="w"> </span><span class="kt">real</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">realArray2</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="o">..</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="kt">real</span><span class="p">;</span><span class="w">   </span><span class="c1">// equivalent</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">realArray3</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="o">..</span><span class="mi">7</span><span class="p">}]</span><span class="w"> </span><span class="kt">real</span><span class="p">;</span><span class="w"> </span><span class="c1">// equivalent</span>

<span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">realDomain</span><span class="p">.</span><span class="nx">dim</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">   </span><span class="c1">// Only use the 2nd dimension of the domain</span>
<span class="w">    </span><span class="nx">realArray</span><span class="p">[</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">1.61803</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">j</span><span class="p">;</span><span class="w">  </span><span class="c1">// Access using index list</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">idx</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">);</span><span class="w">                   </span><span class="c1">// Note: &#39;index&#39; is a keyword</span>
<span class="w">    </span><span class="nx">realArray</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">realArray</span><span class="p">[(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)];</span><span class="w">      </span><span class="c1">// Index using tuples</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Arrays have domains as members, and can be iterated over as normal.</span>
<span class="k">for</span><span class="w"> </span><span class="nx">idx</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">realArray</span><span class="p">.</span><span class="k">domain</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// Again, idx is a 2*int tuple</span>
<span class="w">  </span><span class="nx">realArray</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">realArray</span><span class="p">[</span><span class="nx">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="nx">idx</span><span class="p">[</span><span class="mi">2</span><span class="p">]];</span><span class="w"> </span><span class="c1">// Access by tuple and list</span>
<span class="p">}</span>

<span class="nx">writeln</span><span class="p">(</span><span class="nx">realArray</span><span class="p">);</span>

<span class="c1">// The values of an array can also be iterated directly.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">rSum</span><span class="p">:</span><span class="w"> </span><span class="kt">real</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">realArray</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">rSum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">value</span><span class="p">;</span><span class="w"> </span><span class="c1">// Read a value</span>
<span class="w">  </span><span class="nx">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">rSum</span><span class="p">;</span><span class="w">  </span><span class="c1">// Write a value</span>
<span class="p">}</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">rSum</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">realArray</span><span class="p">);</span>

<span class="c1">// Associative arrays (dictionaries) can be created using associative domains.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">dictDomain</span><span class="p">:</span><span class="w"> </span><span class="k">domain</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;one&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;two&quot;</span><span class="w"> </span><span class="p">};</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">dict</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="nx">dictDomain</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;one&quot;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;two&quot;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span>
<span class="nx">dict</span><span class="p">[</span><span class="s">&quot;three&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// Adds &#39;three&#39; to &#39;dictDomain&#39; implicitly</span>
<span class="k">for</span><span class="w"> </span><span class="nx">key</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">dictDomain</span><span class="p">.</span><span class="nx">sorted</span><span class="p">()</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">dict</span><span class="p">[</span><span class="nx">key</span><span class="p">]);</span>

<span class="c1">// Arrays can be assigned to each other in a few different ways.</span>
<span class="c1">// These arrays will be used in the example.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">thisArray</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">thatArray</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>

<span class="c1">// First, simply assign one to the other. This copies thisArray into</span>
<span class="c1">// thatArray, instead of just creating a reference. Therefore, modifying</span>
<span class="c1">// thisArray does not also modify thatArray.</span>

<span class="nx">thatArray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisArray</span><span class="p">;</span>
<span class="nx">thatArray</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">((</span><span class="nx">thisArray</span><span class="p">,</span><span class="w"> </span><span class="nx">thatArray</span><span class="p">));</span>

<span class="c1">// Assign a slice from one array to a slice (of the same size) in the other.</span>
<span class="nx">thatArray</span><span class="p">[</span><span class="mi">4</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisArray</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">2</span><span class="p">];</span>
<span class="nx">writeln</span><span class="p">((</span><span class="nx">thisArray</span><span class="p">,</span><span class="w"> </span><span class="nx">thatArray</span><span class="p">));</span>

<span class="c1">// Operations can also be promoted to work on arrays. &#39;thisPlusThat&#39; is also</span>
<span class="c1">// an array.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">thisPlusThat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisArray</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">thatArray</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">thisPlusThat</span><span class="p">);</span>

<span class="c1">// Moving on, arrays and loops can also be expressions, where the loop</span>
<span class="c1">// body expression is the result of each iteration.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">arrayFromLoop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">i</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">arrayFromLoop</span><span class="p">);</span>

<span class="c1">// An expression can result in nothing, such as when filtering with an if-expression.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">evensOrFives</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="nx">i</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="nx">arrayFromLoop</span><span class="p">);</span>

<span class="c1">// Array expressions can also be written with a bracket notation.</span>
<span class="c1">// Note: this syntax uses the forall parallel concept discussed later.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">evensOrFivesAgain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="nx">i</span><span class="p">;</span>

<span class="c1">// They can also be written over the values of the array.</span>
<span class="nx">arrayFromLoop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nx">value</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">arrayFromLoop</span><span class="p">]</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>


<span class="c1">// Procedures</span>

<span class="c1">// Chapel procedures have similar syntax functions in other languages.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">fibonacci</span><span class="p">(</span><span class="nx">n</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">n</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">fibonacci</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">fibonacci</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Input parameters can be untyped to create a generic procedure.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">doublePrint</span><span class="p">(</span><span class="nx">thing</span><span class="p">):</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">write</span><span class="p">(</span><span class="nx">thing</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">thing</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;\n&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// The return type can be inferred, as long as the compiler can figure it out.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">addThree</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">doublePrint</span><span class="p">(</span><span class="nx">addThree</span><span class="p">(</span><span class="nx">fibonacci</span><span class="p">(</span><span class="mi">20</span><span class="p">)));</span>

<span class="c1">// It is also possible to take a variable number of parameters.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">maxOf</span><span class="p">(</span><span class="nx">x</span><span class="w"> </span><span class="o">..</span><span class="p">.?</span><span class="nx">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// x refers to a tuple of one type, with k elements</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">maximum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">x</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">2</span><span class="o">..</span><span class="nx">k</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">maximum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nx">maximum</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="nx">maximum</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">maximum</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">maxOf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">189</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">9071982</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">17</span><span class="p">,</span><span class="w"> </span><span class="mi">20001</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">));</span>

<span class="c1">// Procedures can have default parameter values, and</span>
<span class="c1">// the parameters can be named in the call, even out of order.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">defaultsProc</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="p">:</span><span class="w"> </span><span class="kt">real</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.2634</span><span class="p">):</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">real</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">writeln</span><span class="p">(</span><span class="nx">defaultsProc</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">defaultsProc</span><span class="p">(</span><span class="nx">x</span><span class="o">=</span><span class="mi">11</span><span class="p">));</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">defaultsProc</span><span class="p">(</span><span class="nx">x</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="o">=</span><span class="mf">5.432</span><span class="p">));</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">defaultsProc</span><span class="p">(</span><span class="nx">y</span><span class="o">=</span><span class="mf">9.876</span><span class="p">,</span><span class="w"> </span><span class="nx">x</span><span class="o">=</span><span class="mi">13</span><span class="p">));</span>

<span class="c1">// The ? operator is called the query operator, and is used to take</span>
<span class="c1">// undetermined values like tuple or array sizes and generic types.</span>
<span class="c1">// For example, taking arrays as parameters. The query operator is used to</span>
<span class="c1">// determine the domain of A. This is uesful for defining the return type,</span>
<span class="c1">// though it&#39;s not required.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">invertArray</span><span class="p">(</span><span class="nx">A</span><span class="p">:</span><span class="w"> </span><span class="p">[?</span><span class="nx">D</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="p">):</span><span class="w"> </span><span class="p">[</span><span class="nx">D</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">A</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="nx">a</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">A</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">writeln</span><span class="p">(</span><span class="nx">invertArray</span><span class="p">(</span><span class="nx">intArray</span><span class="p">));</span>

<span class="c1">// We can query the type of arguments to generic procedures.</span>
<span class="c1">// Here we define a procedure that takes two arguments of</span>
<span class="c1">// the same type, yet we don&#39;t define what that type is.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">genericProc</span><span class="p">(</span><span class="nx">arg1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">?</span><span class="nx">valueType</span><span class="p">,</span><span class="w"> </span><span class="nx">arg2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">valueType</span><span class="p">):</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">select</span><span class="p">(</span><span class="nx">valueType</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">when</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">arg1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; and &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">arg2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; are ints&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">when</span><span class="w"> </span><span class="kt">real</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">arg1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; and &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">arg2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; are reals&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">otherwise</span><span class="w"> </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">arg1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; and &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">arg2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; are somethings!&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="nx">genericProc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="nx">genericProc</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span><span class="w"> </span><span class="mf">2.3</span><span class="p">);</span>
<span class="nx">genericProc</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="m">2.0i</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0</span><span class="o">+</span><span class="m">4.0i</span><span class="p">);</span>

<span class="c1">// We can also enforce a form of polymorphism with the where clause</span>
<span class="c1">// This allows the compiler to decide which function to use.</span>
<span class="c1">// Note: That means that all information needs to be known at compile-time.</span>
<span class="c1">// The param modifier on the arg is used to enforce this constraint.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">whereProc</span><span class="p">(</span><span class="kd">param</span><span class="w"> </span><span class="nx">N</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">):</span><span class="w"> </span><span class="kt">void</span>
<span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="p">(</span><span class="nx">N</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;N is greater than 0&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">proc</span><span class="w"> </span><span class="nf">whereProc</span><span class="p">(</span><span class="kd">param</span><span class="w"> </span><span class="nx">N</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">):</span><span class="w"> </span><span class="kt">void</span>
<span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="p">(</span><span class="nx">N</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;N is less than 0&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">whereProc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="nx">whereProc</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">// whereProc(0) would result in a compiler error because there</span>
<span class="c1">// are no functions that satisfy the where clause&#39;s condition.</span>
<span class="c1">// We could have defined a whereProc without a where clause</span>
<span class="c1">// that would then have served as a catch all for all the other cases</span>
<span class="c1">// (of which there is only one).</span>

<span class="c1">// where clauses can also be used to constrain based on argument type.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">whereType</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span><span class="w"> </span><span class="p">?</span><span class="nx">t</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="nx">t</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Inside &#39;int&#39; version of &#39;whereType&#39;: &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">proc</span><span class="w"> </span><span class="nf">whereType</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span><span class="w"> </span><span class="p">?</span><span class="nx">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Inside general version of &#39;whereType&#39;: &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">whereType</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="nx">whereType</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">);</span>

<span class="c1">// Intents</span>

<span class="cm">/* Intent modifiers on the arguments convey how those arguments are passed to the procedure.</span>

<span class="cm">     * in: copy arg in, but not out</span>
<span class="cm">     * out: copy arg out, but not in</span>
<span class="cm">     * inout: copy arg in, copy arg out</span>
<span class="cm">     * ref: pass arg by reference</span>
<span class="cm">*/</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">intentsProc</span><span class="p">(</span><span class="kd">in</span><span class="w"> </span><span class="nx">inarg</span><span class="p">,</span><span class="w"> </span><span class="kd">out</span><span class="w"> </span><span class="nx">outarg</span><span class="p">,</span><span class="w"> </span><span class="kd">inout</span><span class="w"> </span><span class="nx">inoutarg</span><span class="p">,</span><span class="w"> </span><span class="kd">ref</span><span class="w"> </span><span class="nx">refarg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Inside Before: &quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="nx">inarg</span><span class="p">,</span><span class="w"> </span><span class="nx">outarg</span><span class="p">,</span><span class="w"> </span><span class="nx">inoutarg</span><span class="p">,</span><span class="w"> </span><span class="nx">refarg</span><span class="p">));</span>
<span class="w">  </span><span class="nx">inarg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">inarg</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w">  </span><span class="nx">outarg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">outarg</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w">  </span><span class="nx">inoutarg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">inoutarg</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w">  </span><span class="nx">refarg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">refarg</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Inside After: &quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="nx">inarg</span><span class="p">,</span><span class="w"> </span><span class="nx">outarg</span><span class="p">,</span><span class="w"> </span><span class="nx">inoutarg</span><span class="p">,</span><span class="w"> </span><span class="nx">refarg</span><span class="p">));</span>
<span class="p">}</span>

<span class="kd">var</span><span class="w"> </span><span class="nx">inVar</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">outVar</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">inoutVar</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">refVar</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Outside Before: &quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="nx">inVar</span><span class="p">,</span><span class="w"> </span><span class="nx">outVar</span><span class="p">,</span><span class="w"> </span><span class="nx">inoutVar</span><span class="p">,</span><span class="w"> </span><span class="nx">refVar</span><span class="p">));</span>
<span class="nx">intentsProc</span><span class="p">(</span><span class="nx">inVar</span><span class="p">,</span><span class="w"> </span><span class="nx">outVar</span><span class="p">,</span><span class="w"> </span><span class="nx">inoutVar</span><span class="p">,</span><span class="w"> </span><span class="nx">refVar</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Outside After: &quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="nx">inVar</span><span class="p">,</span><span class="w"> </span><span class="nx">outVar</span><span class="p">,</span><span class="w"> </span><span class="nx">inoutVar</span><span class="p">,</span><span class="w"> </span><span class="nx">refVar</span><span class="p">));</span>

<span class="c1">// Similarly, we can define intents on the return type.</span>
<span class="c1">// refElement returns a reference to an element of array.</span>
<span class="c1">// This makes more practical sense for class methods where references to</span>
<span class="c1">// elements in a data-structure are returned via a method or iterator.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">refElement</span><span class="p">(</span><span class="nx">array</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[?</span><span class="nx">D</span><span class="p">]</span><span class="w"> </span><span class="p">?</span><span class="nx">T</span><span class="p">,</span><span class="w"> </span><span class="nx">idx</span><span class="p">)</span><span class="w"> </span><span class="kd">ref</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">T</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">array</span><span class="p">[</span><span class="nx">idx</span><span class="p">];</span>
<span class="p">}</span>

<span class="kd">var</span><span class="w"> </span><span class="nx">myChangingArray</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">myChangingArray</span><span class="p">);</span>
<span class="kd">ref</span><span class="w"> </span><span class="nx">refToElem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">refElement</span><span class="p">(</span><span class="nx">myChangingArray</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// store reference to element in ref variable</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">refToElem</span><span class="p">);</span>
<span class="nx">refToElem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// modify reference which modifies actual value in array</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">refToElem</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">myChangingArray</span><span class="p">);</span>

<span class="c1">// Operator Definitions</span>

<span class="c1">// Chapel allows for operators to be overloaded.</span>
<span class="c1">// We can define the unary operators:</span>
<span class="c1">// + - ! ~</span>
<span class="c1">// and the binary operators:</span>
<span class="c1">// + - * / % ** == &lt;= &gt;= &lt; &gt; &lt;&lt; &gt;&gt; &amp; | ˆ by</span>
<span class="c1">// += -= *= /= %= **= &amp;= |= ˆ= &lt;&lt;= &gt;&gt;= &lt;=&gt;</span>

<span class="c1">// Boolean exclusive or operator.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">^</span><span class="p">(</span><span class="nx">left</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="nx">right</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">):</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nx">left</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">right</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="nx">left</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">right</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">writeln</span><span class="p">(</span><span class="kc">true</span><span class="w">  </span><span class="o">^</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="kc">false</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="kc">true</span><span class="w">  </span><span class="o">^</span><span class="w"> </span><span class="kc">false</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="kc">false</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="kc">false</span><span class="p">);</span>

<span class="c1">// Define a * operator on any two types that returns a tuple of those types.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">*</span><span class="p">(</span><span class="nx">left</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">?</span><span class="nx">ltype</span><span class="p">,</span><span class="w"> </span><span class="nx">right</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">?</span><span class="nx">rtype</span><span class="p">):</span><span class="w"> </span><span class="p">(</span><span class="nx">ltype</span><span class="p">,</span><span class="w"> </span><span class="nx">rtype</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;\tIn our &#39;*&#39; overload!&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nx">left</span><span class="p">,</span><span class="w"> </span><span class="nx">right</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">writeln</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Uses our * operator.</span>
<span class="nx">writeln</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">   </span><span class="c1">// Uses the default * operator.</span>

<span class="c1">//  Note: You could break everything if you get careless with your overloads.</span>
<span class="c1">//  This here will break everything. Don&#39;t do it.</span>

<span class="cm">/*</span>
<span class="cm">    proc +(left: int, right: int): int {</span>
<span class="cm">      return left - right;</span>
<span class="cm">    }</span>
<span class="cm">*/</span>

<span class="c1">// Iterators</span>

<span class="c1">// Iterators are sisters to the procedure, and almost everything about</span>
<span class="c1">// procedures also applies to iterators. However, instead of returning a single</span>
<span class="c1">// value, iterators may yield multiple values to a loop.</span>
<span class="c1">//</span>
<span class="c1">// This is useful when a complicated set or order of iterations is needed, as</span>
<span class="c1">// it allows the code defining the iterations to be separate from the loop</span>
<span class="c1">// body.</span>
<span class="k">iter</span><span class="w"> </span><span class="nf">oddsThenEvens</span><span class="p">(</span><span class="nx">N</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">):</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="nx">N</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="k">yield</span><span class="w"> </span><span class="nx">i</span><span class="p">;</span><span class="w"> </span><span class="c1">// yield values instead of returning.</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">2</span><span class="o">..</span><span class="nx">N</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="k">yield</span><span class="w"> </span><span class="nx">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">oddsThenEvens</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">write</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">();</span>

<span class="c1">// Iterators can also yield conditionally, the result of which can be nothing</span>
<span class="k">iter</span><span class="w"> </span><span class="nf">absolutelyNothing</span><span class="p">(</span><span class="nx">N</span><span class="p">):</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="nx">N</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">N</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Always false</span>
<span class="w">      </span><span class="k">yield</span><span class="w"> </span><span class="nx">i</span><span class="p">;</span><span class="w">     </span><span class="c1">// Yield statement never happens</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">absolutelyNothing</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Woa there! absolutelyNothing yielded &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// We can zipper together two or more iterators (who have the same number</span>
<span class="c1">// of iterations) using zip() to create a single zipped iterator, where each</span>
<span class="c1">// iteration of the zipped iterator yields a tuple of one value yielded</span>
<span class="c1">// from each iterator.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">positive</span><span class="p">,</span><span class="w"> </span><span class="nx">negative</span><span class="p">)</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="k">zip</span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">5</span><span class="o">..-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">((</span><span class="nx">positive</span><span class="p">,</span><span class="w"> </span><span class="nx">negative</span><span class="p">));</span>

<span class="c1">// Zipper iteration is quite important in the assignment of arrays,</span>
<span class="c1">// slices of arrays, and array/loop expressions.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">fromThatArray</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..#</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">toThisArray</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">100</span><span class="o">..#</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>

<span class="c1">// Some zipper operations implement other operations.</span>
<span class="c1">// The first statement and the loop are equivalent.</span>
<span class="nx">toThisArray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">fromThatArray</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="k">zip</span><span class="p">(</span><span class="nx">toThisArray</span><span class="p">.</span><span class="k">domain</span><span class="p">,</span><span class="w"> </span><span class="nx">fromThatArray</span><span class="p">.</span><span class="k">domain</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">toThisArray</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">fromThatArray</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// These two chunks are also equivalent.</span>
<span class="nx">toThisArray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nx">j</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="o">-</span><span class="mi">100</span><span class="o">..#</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="nx">j</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">toThisArray</span><span class="p">);</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">j</span><span class="p">)</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="k">zip</span><span class="p">(</span><span class="nx">toThisArray</span><span class="p">.</span><span class="k">domain</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">100</span><span class="o">..#</span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">toThisArray</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">j</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">toThisArray</span><span class="p">);</span>

<span class="c1">// This is very important in understanding why this statement exhibits a</span>
<span class="c1">// runtime error.</span>

<span class="cm">/*</span>
<span class="cm">  var iterArray : [1..10] int = [i in 1..10] if (i % 2 == 1) then i;</span>
<span class="cm">*/</span>

<span class="c1">// Even though the domain of the array and the loop-expression are</span>
<span class="c1">// the same size, the body of the expression can be thought of as an iterator.</span>
<span class="c1">// Because iterators can yield nothing, that iterator yields a different number</span>
<span class="c1">// of things than the domain of the array or loop, which is not allowed.</span>

<span class="c1">// Classes</span>

<span class="c1">// Classes are similar to those in C++ and Java, allocated on the heap.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="w"> </span><span class="p">{</span>

<span class="c1">// Member variables</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">memberInt</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">memberBool</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>

<span class="c1">// Explicitly defined initializer.</span>
<span class="c1">// We also get the compiler-generated initializer, with one argument per field.</span>
<span class="c1">// Note that soon there will be no compiler-generated initializer when we</span>
<span class="c1">// define any initializer(s) explicitly.</span>
<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="nx">val</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">real</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">memberInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">ceil</span><span class="p">(</span><span class="nx">val</span><span class="p">):</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// Explicitly defined deinitializer.</span>
<span class="c1">// If we did not write one, we would get the compiler-generated deinitializer,</span>
<span class="c1">// which has an empty body.</span>
<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">deinit</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;MyClass deinitializer called &quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">memberInt</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">memberBool</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// Class methods.</span>
<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">setMemberInt</span><span class="p">(</span><span class="nx">val</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">memberInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">val</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">setMemberBool</span><span class="p">(</span><span class="nx">val</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">memberBool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">val</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">getMemberInt</span><span class="p">():</span><span class="w"> </span><span class="kt">int</span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">memberInt</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">getMemberBool</span><span class="p">():</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">memberBool</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// end MyClass</span>

<span class="c1">// Call compiler-generated initializer, using default value for memberBool.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nx">MyClass</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="nx">myObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nx">MyClass</span><span class="p">(</span><span class="nx">memberInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="c1">// Equivalent</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">myObject</span><span class="p">.</span><span class="nx">getMemberInt</span><span class="p">());</span>

<span class="c1">// Same, but provide a memberBool value explicitly.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myDiffObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nx">MyClass</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span>
<span class="w">    </span><span class="nx">myDiffObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nx">MyClass</span><span class="p">(</span><span class="nx">memberInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="w">                                </span><span class="nx">memberBool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span><span class="w"> </span><span class="c1">// Equivalent</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">myDiffObject</span><span class="p">);</span>

<span class="c1">// Call the initializer we wrote.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myOtherObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nx">MyClass</span><span class="p">(</span><span class="mf">1.95</span><span class="p">);</span>
<span class="w">    </span><span class="nx">myOtherObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nx">MyClass</span><span class="p">(</span><span class="nx">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.95</span><span class="p">);</span><span class="w"> </span><span class="c1">// Equivalent</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">myOtherObject</span><span class="p">.</span><span class="nx">getMemberInt</span><span class="p">());</span>

<span class="c1">// We can define an operator on our class as well, but</span>
<span class="c1">// the definition has to be outside the class definition.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">+</span><span class="p">(</span><span class="nx">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">MyClass</span><span class="p">,</span><span class="w"> </span><span class="nx">B</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">MyClass</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">MyClass</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nx">MyClass</span><span class="p">(</span><span class="nx">memberInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">A</span><span class="p">.</span><span class="nx">getMemberInt</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">B</span><span class="p">.</span><span class="nx">getMemberInt</span><span class="p">(),</span>
<span class="w">                      </span><span class="nx">memberBool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">A</span><span class="p">.</span><span class="nx">getMemberBool</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">B</span><span class="p">.</span><span class="nx">getMemberBool</span><span class="p">());</span>
<span class="p">}</span>

<span class="kd">var</span><span class="w"> </span><span class="nx">plusObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">myObject</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">myDiffObject</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">plusObject</span><span class="p">);</span>

<span class="c1">// Destruction.</span>
<span class="k">delete</span><span class="w"> </span><span class="nx">myObject</span><span class="p">;</span>
<span class="k">delete</span><span class="w"> </span><span class="nx">myDiffObject</span><span class="p">;</span>
<span class="k">delete</span><span class="w"> </span><span class="nx">myOtherObject</span><span class="p">;</span>
<span class="k">delete</span><span class="w"> </span><span class="nx">plusObject</span><span class="p">;</span>

<span class="c1">// Classes can inherit from one or more parent classes</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MyChildClass</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">MyClass</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">memberComplex</span><span class="p">:</span><span class="w"> </span><span class="kt">complex</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Here&#39;s an example of generic classes.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">GenericClass</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">type</span><span class="w"> </span><span class="nx">classType</span><span class="p">;</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">classDomain</span><span class="p">:</span><span class="w"> </span><span class="k">domain</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">classArray</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="nx">classDomain</span><span class="p">]</span><span class="w"> </span><span class="nx">classType</span><span class="p">;</span>

<span class="c1">// Explicit constructor.</span>
<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">GenericClass</span><span class="p">(</span><span class="kd">type</span><span class="w"> </span><span class="nx">classType</span><span class="p">,</span><span class="w"> </span><span class="nx">elements</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">classDomain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="o">..#</span><span class="nx">elements</span><span class="p">};</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// Copy constructor.</span>
<span class="c1">// Note: We still have to put the type as an argument, but we can</span>
<span class="c1">// default to the type of the other object using the query (?) operator.</span>
<span class="c1">// Further, we can take advantage of this to allow our copy constructor</span>
<span class="c1">// to copy classes of different types and cast on the fly.</span>
<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">GenericClass</span><span class="p">(</span><span class="nx">other</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">GenericClass</span><span class="p">(?</span><span class="nx">otherType</span><span class="p">),</span>
<span class="w">                     </span><span class="kd">type</span><span class="w"> </span><span class="nx">classType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">otherType</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">classDomain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">other</span><span class="p">.</span><span class="nx">classDomain</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Copy and cast</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">idx</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">classDomain</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="k">this</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">other</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">classType</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// Define bracket notation on a GenericClass</span>
<span class="c1">// object so it can behave like a normal array</span>
<span class="c1">// i.e. objVar[i] or objVar(i)</span>
<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">this</span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kd">ref</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">classType</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">classArray</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// Define an implicit iterator for the class</span>
<span class="c1">// to yield values from the array to a loop</span>
<span class="c1">// i.e. for i in objVar do ...</span>
<span class="w">  </span><span class="k">iter</span><span class="w"> </span><span class="nf">these</span><span class="p">()</span><span class="w"> </span><span class="kd">ref</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">classType</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">classDomain</span><span class="w"> </span><span class="k">do</span>
<span class="w">      </span><span class="k">yield</span><span class="w"> </span><span class="k">this</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// end GenericClass</span>

<span class="c1">// We can assign to the member array of the object using the bracket</span>
<span class="c1">// notation that we defined.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">realList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nx">GenericClass</span><span class="p">(</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">realList</span><span class="p">.</span><span class="nx">classDomain</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">realList</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>

<span class="c1">// We can iterate over the values in our list with the iterator</span>
<span class="c1">// we defined.</span>
<span class="k">for</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">realList</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">write</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">();</span>

<span class="c1">// Make a copy of realList using the copy constructor.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">copyList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nx">GenericClass</span><span class="p">(</span><span class="nx">realList</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">copyList</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">write</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">();</span>

<span class="c1">// Make a copy of realList and change the type, also using the copy constructor.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">copyNewTypeList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nx">GenericClass</span><span class="p">(</span><span class="nx">realList</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">copyNewTypeList</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">write</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">();</span>


<span class="c1">// Modules</span>

<span class="c1">// Modules are Chapel&#39;s way of managing name spaces.</span>
<span class="c1">// The files containing these modules do not need to be named after the modules</span>
<span class="c1">// (as in Java), but files implicitly name modules.</span>
<span class="c1">// For example, this file implicitly names the learnChapelInYMinutes module</span>

<span class="k">module</span><span class="w"> </span><span class="nc">OurModule</span><span class="w"> </span><span class="p">{</span>

<span class="c1">// We can use modules inside of other modules.</span>
<span class="c1">// Time is one of the standard modules.</span>
<span class="w">  </span><span class="k">use</span><span class="w"> </span><span class="nx">Time</span><span class="p">;</span>

<span class="c1">// We&#39;ll use this procedure in the parallelism section.</span>
<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">countdown</span><span class="p">(</span><span class="nx">seconds</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="nx">seconds</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
<span class="w">      </span><span class="nx">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// It is possible to create arbitrarily deep module nests.</span>
<span class="c1">// i.e. submodules of OurModule</span>
<span class="w">  </span><span class="k">module</span><span class="w"> </span><span class="nc">ChildModule</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">proc</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;ChildModule.foo()&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">module</span><span class="w"> </span><span class="nc">SiblingModule</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">proc</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;SiblingModule.foo()&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// end OurModule</span>

<span class="c1">// Using OurModule also uses all the modules it uses.</span>
<span class="c1">// Since OurModule uses Time, we also use Time.</span>
<span class="k">use</span><span class="w"> </span><span class="nx">OurModule</span><span class="p">;</span>

<span class="c1">// At this point we have not used ChildModule or SiblingModule so</span>
<span class="c1">// their symbols (i.e. foo) are not available to us. However, the module</span>
<span class="c1">// names are available, and we can explicitly call foo() through them.</span>
<span class="nx">SiblingModule</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span>
<span class="nx">OurModule</span><span class="p">.</span><span class="nx">ChildModule</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span>

<span class="c1">// Now we use ChildModule, enabling unqualified calls.</span>
<span class="k">use</span><span class="w"> </span><span class="nx">ChildModule</span><span class="p">;</span>
<span class="nx">foo</span><span class="p">();</span>

<span class="c1">// Parallelism</span>

<span class="c1">// In other languages, parallelism is typically done with</span>
<span class="c1">// complicated libraries and strange class structure hierarchies.</span>
<span class="c1">// Chapel has it baked right into the language.</span>

<span class="c1">// We can declare a main procedure, but all the code above main still gets</span>
<span class="c1">// executed.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="c1">// A begin statement will spin the body of that statement off</span>
<span class="c1">// into one new task.</span>
<span class="c1">// A sync statement will ensure that the progress of the main</span>
<span class="c1">// task will not progress until the children have synced back up.</span>

<span class="w">  </span><span class="k">sync</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">begin</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Start of new task&#39;s body</span>
<span class="w">      </span><span class="kd">var</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">1000</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Done: &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">a</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// End of new tasks body</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;spun off a task!&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Back together&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">printFibb</span><span class="p">(</span><span class="nx">n</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;fibonacci(&quot;</span><span class="p">,</span><span class="nx">n</span><span class="p">,</span><span class="s">&quot;) = &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">fibonacci</span><span class="p">(</span><span class="nx">n</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// A cobegin statement will spin each statement of the body into one new</span>
<span class="c1">// task. Notice here that the prints from each statement may happen in any</span>
<span class="c1">// order.</span>
<span class="w">  </span><span class="k">cobegin</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">printFibb</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w"> </span><span class="c1">// new task</span>
<span class="w">    </span><span class="nx">printFibb</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="c1">// new task</span>
<span class="w">    </span><span class="nx">printFibb</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w">  </span><span class="c1">// new task</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// This is a nested statement body and thus is a single statement</span>
<span class="w">      </span><span class="c1">// to the parent statement, executed by a single task.</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;this gets&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;executed as&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;a whole&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// A coforall loop will create a new task for EACH iteration.</span>
<span class="c1">// Again we see that prints happen in any order.</span>
<span class="c1">// NOTE: coforall should be used only for creating tasks!</span>
<span class="c1">// Using it to iterating over a structure is very a bad idea!</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">num_tasks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="c1">// Number of tasks we want</span>
<span class="w">  </span><span class="k">coforall</span><span class="w"> </span><span class="nx">taskID</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..#</span><span class="nx">num_tasks</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Hello from task# &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">taskID</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// forall loops are another parallel loop, but only create a smaller number</span>
<span class="c1">// of tasks, specifically --dataParTasksPerLocale= number of tasks.</span>
<span class="w">  </span><span class="k">forall</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">write</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">();</span>

<span class="c1">// Here we see that there are sections that are in order, followed by</span>
<span class="c1">// a section that would not follow (e.g. 1, 2, 3, 7, 8, 9, 4, 5, 6,).</span>
<span class="c1">// This is because each task is taking on a chunk of the range 1..10</span>
<span class="c1">// (1..3, 4..6, or 7..9) doing that chunk serially, but each task happens</span>
<span class="c1">// in parallel. Your results may depend on your machine and configuration</span>

<span class="c1">// For both the forall and coforall loops, the execution of the</span>
<span class="c1">// parent task will not continue until all the children sync up.</span>

<span class="c1">// forall loops are particularly useful for parallel iteration over arrays.</span>
<span class="c1">// Lets run an experiment to see how much faster a parallel loop is</span>
<span class="w">  </span><span class="k">use</span><span class="w"> </span><span class="nx">Time</span><span class="p">;</span><span class="w"> </span><span class="c1">// Import the Time module to use Timer objects</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">timer</span><span class="p">:</span><span class="w"> </span><span class="nx">Timer</span><span class="p">;</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">myBigArray</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="mi">1</span><span class="o">..</span><span class="mi">4000</span><span class="p">,</span><span class="mi">1</span><span class="o">..</span><span class="mi">4000</span><span class="p">}]</span><span class="w"> </span><span class="kt">real</span><span class="p">;</span><span class="w"> </span><span class="c1">// Large array we will write into</span>

<span class="c1">// Serial Experiment:</span>
<span class="w">  </span><span class="nx">timer</span><span class="p">.</span><span class="nx">start</span><span class="p">();</span><span class="w"> </span><span class="c1">// Start timer</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">)</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">myBigArray</span><span class="p">.</span><span class="k">domain</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Serial iteration</span>
<span class="w">    </span><span class="nx">myBigArray</span><span class="p">[</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">x</span><span class="p">:</span><span class="kt">real</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="nx">y</span><span class="p">:</span><span class="kt">real</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nx">timer</span><span class="p">.</span><span class="nx">stop</span><span class="p">();</span><span class="w"> </span><span class="c1">// Stop timer</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Serial: &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">timer</span><span class="p">.</span><span class="nx">elapsed</span><span class="p">());</span><span class="w"> </span><span class="c1">// Print elapsed time</span>
<span class="w">  </span><span class="nx">timer</span><span class="p">.</span><span class="nx">clear</span><span class="p">();</span><span class="w"> </span><span class="c1">// Clear timer for parallel loop</span>

<span class="c1">// Parallel Experiment:</span>
<span class="w">  </span><span class="nx">timer</span><span class="p">.</span><span class="nx">start</span><span class="p">();</span><span class="w"> </span><span class="c1">// start timer</span>
<span class="w">  </span><span class="k">forall</span><span class="w"> </span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">)</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">myBigArray</span><span class="p">.</span><span class="k">domain</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Parallel iteration</span>
<span class="w">    </span><span class="nx">myBigArray</span><span class="p">[</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">x</span><span class="p">:</span><span class="kt">real</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="nx">y</span><span class="p">:</span><span class="kt">real</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nx">timer</span><span class="p">.</span><span class="nx">stop</span><span class="p">();</span><span class="w"> </span><span class="c1">// Stop timer</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Parallel: &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">timer</span><span class="p">.</span><span class="nx">elapsed</span><span class="p">());</span><span class="w"> </span><span class="c1">// Print elapsed time</span>
<span class="w">  </span><span class="nx">timer</span><span class="p">.</span><span class="nx">clear</span><span class="p">();</span>

<span class="c1">// You may have noticed that (depending on how many cores you have)</span>
<span class="c1">// the parallel loop went faster than the serial loop.</span>

<span class="c1">// The bracket style loop-expression described</span>
<span class="c1">// much earlier implicitly uses a forall loop.</span>
<span class="w">  </span><span class="p">[</span><span class="nx">val</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">myBigArray</span><span class="p">]</span><span class="w"> </span><span class="nx">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">val</span><span class="p">;</span><span class="w"> </span><span class="c1">// Parallel operation</span>

<span class="c1">// Atomic variables, common to many languages, are ones whose operations</span>
<span class="c1">// occur uninterrupted. Multiple threads can therefore modify atomic</span>
<span class="c1">// variables and can know that their values are safe.</span>
<span class="c1">// Chapel atomic variables can be of type bool, int,</span>
<span class="c1">// uint, and real.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">uranium</span><span class="p">:</span><span class="w"> </span><span class="k">atomic</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>
<span class="w">  </span><span class="nx">uranium</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="mi">238</span><span class="p">);</span><span class="w">      </span><span class="c1">// atomically write a variable</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">uranium</span><span class="p">.</span><span class="nx">read</span><span class="p">());</span><span class="w"> </span><span class="c1">// atomically read a variable</span>

<span class="c1">// Atomic operations are described as functions, so you can define your own.</span>
<span class="w">  </span><span class="nx">uranium</span><span class="p">.</span><span class="nx">sub</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"> </span><span class="c1">// atomically subtract a variable</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">uranium</span><span class="p">.</span><span class="nx">read</span><span class="p">());</span>

<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">replaceWith</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">239</span><span class="p">;</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">was</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">uranium</span><span class="p">.</span><span class="nx">exchange</span><span class="p">(</span><span class="nx">replaceWith</span><span class="p">);</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;uranium was &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">was</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; but is now &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">replaceWith</span><span class="p">);</span>

<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">isEqualTo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">235</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">uranium</span><span class="p">.</span><span class="nx">compareExchange</span><span class="p">(</span><span class="nx">isEqualTo</span><span class="p">,</span><span class="w"> </span><span class="nx">replaceWith</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;uranium was equal to &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">isEqualTo</span><span class="p">,</span>
<span class="w">             </span><span class="s">&quot; so replaced value with &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">replaceWith</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;uranium was not equal to &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">isEqualTo</span><span class="p">,</span>
<span class="w">             </span><span class="s">&quot; so value stays the same...  whatever it was&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">sync</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">begin</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Reader task</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Reader: waiting for uranium to be &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">isEqualTo</span><span class="p">);</span>
<span class="w">      </span><span class="nx">uranium</span><span class="p">.</span><span class="nx">waitFor</span><span class="p">(</span><span class="nx">isEqualTo</span><span class="p">);</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Reader: uranium was set (by someone) to &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">isEqualTo</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">begin</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Writer task</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Writer: will set uranium to the value &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">isEqualTo</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; in...&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="nx">countdown</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="w">      </span><span class="nx">uranium</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">isEqualTo</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// sync variables have two states: empty and full.</span>
<span class="c1">// If you read an empty variable or write a full variable, you are waited</span>
<span class="c1">// until the variable is full or empty again.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">someSyncVar$</span><span class="p">:</span><span class="w"> </span><span class="k">sync</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w"> </span><span class="c1">// varName$ is a convention not a law.</span>
<span class="w">  </span><span class="k">sync</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">begin</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Reader task</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Reader: waiting to read.&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="kd">var</span><span class="w"> </span><span class="nx">read_sync</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">someSyncVar$</span><span class="p">;</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Reader: value is &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">read_sync</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">begin</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Writer task</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Writer: will write in...&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="nx">countdown</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="w">      </span><span class="nx">someSyncVar$</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">123</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// single vars can only be written once. A read on an unwritten single</span>
<span class="c1">// results in a wait, but when the variable has a value it can be read</span>
<span class="c1">// indefinitely.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">someSingleVar$</span><span class="p">:</span><span class="w"> </span><span class="k">single</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w"> </span><span class="c1">// varName$ is a convention not a law.</span>
<span class="w">  </span><span class="k">sync</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">begin</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Reader task</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Reader: waiting to read.&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">var</span><span class="w"> </span><span class="nx">read_single</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">someSingleVar$</span><span class="p">;</span>
<span class="w">        </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Reader: iteration &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">,</span><span class="s">&quot;, and the value is &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">read_single</span><span class="p">);</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">begin</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Writer task</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Writer: will write in...&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="nx">countdown</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="w">      </span><span class="nx">someSingleVar$</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// first and only write ever.</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// Here&#39;s an example using atomics and a sync variable to create a</span>
<span class="c1">// count-down mutex (also known as a multiplexer).</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">count</span><span class="p">:</span><span class="w"> </span><span class="k">atomic</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w"> </span><span class="c1">// our counter</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">lock$</span><span class="p">:</span><span class="w"> </span><span class="k">sync</span><span class="w"> </span><span class="kt">bool</span><span class="p">;</span><span class="w">   </span><span class="c1">// the mutex lock</span>

<span class="w">  </span><span class="nx">count</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w">       </span><span class="c1">// Only let two tasks in at a time.</span>
<span class="w">  </span><span class="nx">lock$</span><span class="p">.</span><span class="nx">writeXF</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span><span class="w">  </span><span class="c1">// Set lock$ to full (unlocked)</span>
<span class="w">  </span><span class="c1">// Note: The value doesn&#39;t actually matter, just the state</span>
<span class="w">  </span><span class="c1">// (full:unlocked / empty:locked)</span>
<span class="w">  </span><span class="c1">// Also, writeXF() fills (F) the sync var regardless of its state (X)</span>

<span class="w">  </span><span class="k">coforall</span><span class="w"> </span><span class="nx">task</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..#</span><span class="mi">5</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Generate tasks</span>
<span class="w">    </span><span class="c1">// Create a barrier</span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">lock$</span><span class="p">;</span><span class="w">                 </span><span class="c1">// Read lock$ (wait)</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nx">count</span><span class="p">.</span><span class="nx">read</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// Keep waiting until a spot opens up</span>

<span class="w">    </span><span class="nx">count</span><span class="p">.</span><span class="nx">sub</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">          </span><span class="c1">// decrement the counter</span>
<span class="w">    </span><span class="nx">lock$</span><span class="p">.</span><span class="nx">writeXF</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span><span class="w"> </span><span class="c1">// Set lock$ to full (signal)</span>

<span class="w">    </span><span class="c1">// Actual &#39;work&#39;</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Task #&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">task</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; doing work.&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="nx">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="w">    </span><span class="nx">count</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">        </span><span class="c1">// Increment the counter</span>
<span class="w">    </span><span class="nx">lock$</span><span class="p">.</span><span class="nx">writeXF</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span><span class="w"> </span><span class="c1">// Set lock$ to full (signal)</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// We can define the operations + * &amp; | ^ &amp;&amp; || min max minloc maxloc</span>
<span class="c1">// over an entire array using scans and reductions.</span>
<span class="c1">// Reductions apply the operation over the entire array and</span>
<span class="c1">// result in a scalar value.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">listOfValues</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">15</span><span class="p">,</span><span class="mi">57</span><span class="p">,</span><span class="mi">354</span><span class="p">,</span><span class="mi">36</span><span class="p">,</span><span class="mi">45</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">456</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">678</span><span class="p">,</span><span class="mi">2</span><span class="p">];</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">sumOfValues</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">reduce</span><span class="w"> </span><span class="nx">listOfValues</span><span class="p">;</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">maxValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">max</span><span class="w"> </span><span class="k">reduce</span><span class="w"> </span><span class="nx">listOfValues</span><span class="p">;</span><span class="w"> </span><span class="c1">// &#39;max&#39; give just max value</span>

<span class="c1">// maxloc gives max value and index of the max value.</span>
<span class="c1">// Note: We have to zip the array and domain together with the zip iterator.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="p">(</span><span class="nx">theMaxValue</span><span class="p">,</span><span class="w"> </span><span class="nx">idxOfMax</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">maxloc</span><span class="w"> </span><span class="k">reduce</span><span class="w"> </span><span class="k">zip</span><span class="p">(</span><span class="nx">listOfValues</span><span class="p">,</span>
<span class="w">                                                  </span><span class="nx">listOfValues</span><span class="p">.</span><span class="k">domain</span><span class="p">);</span>

<span class="w">  </span><span class="nx">writeln</span><span class="p">((</span><span class="nx">sumOfValues</span><span class="p">,</span><span class="w"> </span><span class="nx">maxValue</span><span class="p">,</span><span class="w"> </span><span class="nx">idxOfMax</span><span class="p">,</span><span class="w"> </span><span class="nx">listOfValues</span><span class="p">[</span><span class="nx">idxOfMax</span><span class="p">]));</span>

<span class="c1">// Scans apply the operation incrementally and return an array with the</span>
<span class="c1">// values of the operation at that index as it progressed through the</span>
<span class="c1">// array from array.domain.low to array.domain.high.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">runningSumOfValues</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">scan</span><span class="w"> </span><span class="nx">listOfValues</span><span class="p">;</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">maxScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">max</span><span class="w"> </span><span class="k">scan</span><span class="w"> </span><span class="nx">listOfValues</span><span class="p">;</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">runningSumOfValues</span><span class="p">);</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">maxScan</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// end main()</span>
</pre></div>
<h2>Who is this tutorial for?</h2>

<p>This tutorial is for people who want to learn the ropes of chapel without
having to hear about what fiber mixture the ropes are, or how they were
braided, or how the braid configurations differ between one another. It won&rsquo;t
teach you how to develop amazingly performant code, and it&rsquo;s not exhaustive.
Refer to the <a href="https://chapel-lang.org/docs/latest/language/spec.html">language specification</a> and
the <a href="https://chapel-lang.org/docs/latest/">module documentation</a> for more
details.</p>

<p>Occasionally check back here and on the <a href="https://chapel-lang.org">Chapel site</a>
to see if more topics have been added or more tutorials created.</p>

<h3>What this tutorial is lacking:</h3>

<ul>
<li>Exposition of the <a href="https://chapel-lang.org/docs/latest/modules/standard.html">standard modules</a></li>
<li>Multiple Locales (distributed memory system)</li>
<li>Records</li>
<li>Parallel iterators</li>
</ul>

<h2>Your input, questions, and discoveries are important to the developers!</h2>

<p>The Chapel language is still in active development, so there are
occasional hiccups with performance and language features. The more information
you give the Chapel development team about issues you encounter or features you
would like to see, the better the language becomes.
There are several ways to interact with the developers:
+ <a href="https://gitter.im/chapel-lang/chapel">Gitter chat</a>
+ <a href="https://sourceforge.net/p/chapel/mailman">sourceforge email lists</a></p>

<p>If you&rsquo;re really interested in the development of the compiler or contributing
to the project, <a href="https://github.com/chapel-lang/chapel">check out the master GitHub repository</a>.
It is under the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache 2.0 License</a>.</p>

<h2>Installing the Compiler</h2>

<p><a href="https://chapel-lang.org/docs/usingchapel/QUICKSTART.html">The Official Chapel documentation details how to download and compile the Chapel compiler.</a></p>

<p>Chapel can be built and installed on your average &lsquo;nix machine (and cygwin).
<a href="https://github.com/chapel-lang/chapel/releases/">Download the latest release version</a>
and it&rsquo;s as easy as</p>

<ol>
<li><code>tar -xvf chapel-&lt;VERSION&gt;.tar.gz</code></li>
<li><code>cd chapel-&lt;VERSION&gt;</code></li>
<li><code>source util/setchplenv.bash # or .sh or .csh or .fish</code></li>
<li><code>make</code></li>
<li><code>make check # optional</code></li>
</ol>

<p>You will need to <code>source util/setchplenv.EXT</code> from within the Chapel directory
(<code>$CHPL_HOME</code>) every time your terminal starts so it&rsquo;s suggested that you drop
that command in a script that will get executed on startup (like .bashrc).</p>

<p>Chapel is easily installed with Brew for macOS</p>

<ol>
<li><code>brew update</code></li>
<li><code>brew install chapel</code></li>
</ol>

<h2>Compiling Code</h2>

<p>Builds like other compilers:</p>

<p><code>chpl myFile.chpl -o myExe</code></p>

<p>Notable arguments:</p>

<ul>
<li><code>--fast</code>: enables a number of optimizations and disables array bounds
checks. Should only enable when application is stable.</li>
<li><code>--set &lt;Symbol Name&gt;=&lt;Value&gt;</code>: set config param <code>&lt;Symbol Name&gt;</code> to <code>&lt;Value&gt;</code>
at compile-time.</li>
<li><code>--main-module &lt;Module Name&gt;</code>: use the main() procedure found in the module
<code>&lt;Module Name&gt;</code> as the executable&rsquo;s main.</li>
<li><code>--module-dir &lt;Directory&gt;</code>: includes <code>&lt;Directory&gt;</code> in the module search path.</li>
</ul>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/chapel.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by Ian J. Bertolacci, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/chapel.html.markdown">11 contributors</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="https://www.cs.arizona.edu/~ianbertolacci/">Ian J. Bertolacci</a>,
        <a href="https://github.com/benharsh/">Ben Harshbarger</a>
    </p>

    <p>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
