<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="tr-tr" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="tr-tr" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="tr-tr" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="tr-tr" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="tr-tr">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn C++ in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/tr-tr/c++-tr/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Ftr-tr%2Fc%2B%2B-tr%2F&text=Y+dakikada+X+%C3%B6%C4%9Fren%2C+burada+X%3DC%2B%2B">
        Bu sayfayı paylaş
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Tema seçin:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">hafif</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">karanlık</button>
  </div>
  <h1><a href="/">Y dakikada X öğren</a></h1>
  <h2>Burada X=C++</h2>
    <p class="filelink">
    Kodu al:
    <a href="/docs/files/learncpp-tr.cpp">learncpp-tr.cpp</a>
    </p>
  <div id="doc">
    <p>C++ 
<a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">yaratıcısı Bjarne Stroustrup&#39;a göre</a>,</p>

<ul>
<li>&ldquo;daha iyi bir C&rdquo; yapmak</li>
<li>veri soyutlamayı desteklemek </li>
<li>nesneye yönelik programlamayı deskteklemek</li>
<li>tipten bağımsız programlamayı desteklemek </li>
</ul>

<p>için tasarlanmış bir sistem programlama dilir.</p>

<p>Sözdizimi daha yeni dillerden daha zor veya karmaşık olsa da işlemcinin doğrudan çalıştırabileceği
native komutlara derlenerek, donanım üzerinde (C gibi) sıkı bir kontrol sağlar, bunu yaparken
tipten bağımsızlık, exception&#39;lar ve sınıflar gibi yüksek-seviyeli özellikleri destekler.
Bu hız ve kullanışlılık C++&lsquo;ı en çok kullanılan dillerden biri yapar.</p>
<div class="highlight"><pre><span></span><span class="c1">//////////////////////</span>
<span class="c1">// C ile karşılaştırma</span>
<span class="c1">//////////////////////</span>

<span class="c1">// C++ _neredeyse_ C&#39;nin bir üstkümesidir, değişken tanımı, basit tipleri</span>
<span class="c1">// ve fonksiyonları için temelde aynı sözdizimini paylaşır.</span>

<span class="c1">// Aynı C gibi, programın başlangıç noktası bir integer döndüren </span>
<span class="c1">// main fonksiyonudur.</span>
<span class="c1">// Bu değer programın bitiş statüsünü belli eder.</span>
<span class="c1">// Daha fazla bilgi için bknz http://en.wikipedia.org/wiki/Exit_status .</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Komut satırı argümanları C&#39;de olduğu gibi argv ve argc ile geçilir</span>
<span class="w">    </span><span class="c1">// argc, argüman sayısını belli eder,</span>
<span class="w">    </span><span class="c1">// argv, argümanları belli eden, C-stili string&#39;lerin (char*) dizisidir.</span>
<span class="w">    </span><span class="c1">// İlk argüman çağrılan programın adıdır.</span>
<span class="w">    </span><span class="c1">// Eğer argümanları umursamıyorsan, argv ve argc kullanılmayabilir </span>
<span class="w">    </span><span class="c1">// int main() gibi</span>

<span class="w">    </span><span class="c1">// 0 çıkış durumu başarıyı belirtir.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Bunlara rağmen C++ aşağıdaki noktalarda farklılaşır:</span>

<span class="c1">// C++&#39;ta, karakterler char türündendir</span>
<span class="k">sizeof</span><span class="p">(</span><span class="sc">&#39;c&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span>

<span class="c1">// C&#39;de, karakterler int türündendir</span>
<span class="k">sizeof</span><span class="p">(</span><span class="sc">&#39;c&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>


<span class="c1">// C++ katı bir prototip kuralına sahiptir</span>
<span class="kt">void</span><span class="w"> </span><span class="n">func</span><span class="p">();</span><span class="w"> </span><span class="c1">// fonksiyon argüman kabul etmez</span>

<span class="c1">// C&#39;de</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">();</span><span class="w"> </span><span class="c1">// fonksiyon herhangi bir sayıda argüman kabul edebilir</span>

<span class="c1">// C++&#39;da NULL yerine nullptr kullanılır</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="c1">// C standard başlıkları başına &quot;c&quot; eklenip, sondaki .h</span>
<span class="c1">// kullanılmadan C++&#39;ta kullanılabilir</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdio&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, world!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//////////////////////////////////</span>
<span class="c1">// Fonksiyonun fazladan yüklenmesi</span>
<span class="c1">//////////////////////////////////</span>

<span class="c1">// C++ herbir fonksiyonun farklı parametereler</span>
<span class="c1">// aldığı fonksiyon fazladan yüklenmesini desktekler </span>

<span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">myString</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;String %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">myString</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">myInt</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;My int is %d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">myInt</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// void print(const char*) fonksiyonunu çağırır.</span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span><span class="w"> </span><span class="c1">// void print(int) fonksiyonunu çağırır.</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////</span>
<span class="c1">// Default fonksiyon argümanları</span>
<span class="c1">////////////////////////////////</span>

<span class="c1">// Eğer çağırıcı tarafından fonksiyona argüman sağlanmamışsa,</span>
<span class="c1">// fonksiyona default argüman verebilirsin</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">doSomethingWithInts</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Burada int&#39;lerle birşeyler yap</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">doSomethingWithInts</span><span class="p">();</span><span class="w">      </span><span class="c1">// a = 1,  b = 4</span>
<span class="w">    </span><span class="n">doSomethingWithInts</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w">    </span><span class="c1">// a = 20, b = 4</span>
<span class="w">    </span><span class="n">doSomethingWithInts</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// a = 20, b = 5</span>
<span class="p">}</span>

<span class="c1">// Default argümanlar, argüman listesinin sonunda yer almalı.</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">invalidDeclaration</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="c1">// Hata!</span>
<span class="p">{</span>
<span class="p">}</span>


<span class="c1">/////////////////////////</span>
<span class="c1">// Namespace(İsim uzayı)</span>
<span class="c1">/////////////////////////</span>

<span class="c1">// Namespace&#39;ler değişken, fonksiyon ve diğer bildirimlerin </span>
<span class="c1">// kapsama alanını ayırır. </span>
<span class="c1">// Namespace&#39;ler içiçe geçebilir.</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">First</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Nested</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;This is First::Nested::foo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// Nested namespace&#39;inin sonu</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// First namespace&#39;inin sonu</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">Second</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;This is Second::foo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;This is global foo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Second namespace&#39;i içinideki tüm sembolleri mevcut kapsama alanına dahil eder.</span>
<span class="w">    </span><span class="c1">// Dikkat edersen artık yalnızca foo() çağrısı çalışmayacaktır çünkü hangi</span>
<span class="w">    </span><span class="c1">// namespace&#39;ten çağrıldığı açık değildir.</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Second</span><span class="p">;</span>

<span class="w">    </span><span class="n">Second</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// &quot;This is Second::foo&quot; yazdırıır</span>
<span class="w">    </span><span class="n">First</span><span class="o">::</span><span class="n">Nested</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// &quot;This is First::Nested::foo&quot; yazdırır</span>
<span class="w">    </span><span class="o">::</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// &quot;This is global foo&quot; yazdırır.</span>
<span class="p">}</span>

<span class="c1">///////////////</span>
<span class="c1">// Input/Output</span>
<span class="c1">///////////////</span>

<span class="c1">// C++&#39;ta input ve output stream&#39;leri kullanır.</span>
<span class="c1">// cin, cout ve cerr,sırasıyla, stdin, stdout, ve stderr&#39;i temsil eder.</span>
<span class="c1">// &lt;&lt; araya ekleme ve &gt;&gt; aradan çıkarma operatörüdür.</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="c1"> // I/O stream&#39;lerini dahil etmek için</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"> </span><span class="c1">// Streamler std namespace&#39;i içindedir(standard kütüphane)</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">myInt</span><span class="p">;</span>

<span class="w">   </span><span class="c1">// stdout (veya terminal/screen)&#39;ta çıktı verir</span>
<span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Enter your favorite number:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">   </span><span class="c1">// Girdiyi alır </span>
<span class="w">   </span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">myInt</span><span class="p">;</span>

<span class="w">   </span><span class="c1">// cout ayrıca formatlanabilir</span>
<span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Your favorite number is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myInt</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">   </span><span class="c1">// prints &quot;Your favorite number is &lt;myInt&gt;&quot;</span>

<span class="w">    </span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Used for error messages&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//////////////</span>
<span class="c1">// String&#39;ler</span>
<span class="c1">/////////////</span>

<span class="c1">// String&#39;ler C++&#39;ta nesnedir ve pek çok üye fonksiyonu vardır</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"> </span><span class="c1">// String&#39;ler de std namespace&#39;i içindedir. (standard kütüphane)</span>

<span class="n">string</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span><span class="p">;</span>
<span class="n">string</span><span class="w"> </span><span class="n">myOtherString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot; World&quot;</span><span class="p">;</span>

<span class="c1">// + eklemek için kullanıldır </span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">myOtherString</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;Hello World&quot;</span>

<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; You&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;Hello You&quot;</span>

<span class="c1">// C++&#39;ta  stringler are mutable&#39;dır (değişebilir).</span>
<span class="n">myString</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot; Dog&quot;</span><span class="p">);</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myString</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;Hello Dog&quot;</span>


<span class="c1">///////////////////////</span>
<span class="c1">// Reference (Referans)</span>
<span class="c1">///////////////////////</span>

<span class="c1">// C&#39;deki pointer&#39;lara ek olarak </span>
<span class="c1">// C++ _reference_&#39;lara sahiptir.</span>
<span class="c1">// Bunlar bir kere atandınğında tekrardan atanamayan pointer&#39;dır</span>
<span class="c1">// ve null olamaz.</span>
<span class="c1">// Değişkenin kendisiyle aynı sözdizimine sahiptir:</span>
<span class="c1">// Değerine ulaşmak için * ihtiyaç yoktur ve</span>
<span class="c1">// atama için &amp; (address of) kullanılmaz.</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="n">string</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;I am foo&quot;</span><span class="p">;</span>
<span class="n">string</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;I am bar&quot;</span><span class="p">;</span>


<span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">fooRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w"> </span><span class="c1">// Bu foo&#39;nun reference&#39;ını oluşturur.</span>
<span class="n">fooRef</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;. Hi!&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// foo&#39;yu reference&#39;ı üzerinden değiştirir.</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fooRef</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;I am foo. Hi!&quot; yazdırır.</span>

<span class="c1">// &quot;fooRef&quot;e yeniden atama yapmaz. Bu &quot;foo = bar&quot; denktir ve bu satırdan sonra</span>
<span class="c1">//  foo == &quot;I am bar&quot; olur</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fooRef</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// foo&#39;un adresini yazdırır</span>
<span class="n">fooRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fooRef</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">//Hala foo&#39;nun adresini yazdırır</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fooRef</span><span class="p">;</span><span class="w">  </span><span class="c1">//&quot;I am bar&quot; yazdırır</span>

<span class="c1">// fooRef&#39;in adresi aynı kalır yani hala foo&#39;nun adresidir.</span>

<span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">barRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span><span class="w"> </span><span class="c1">// bar&#39;a const reference oluşturur</span>
<span class="c1">// C&#39;de olduğu gibi, const değerler (pointer&#39;lar ve reference&#39;ler) değiştirilemez.</span>
<span class="n">barRef</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;. Hi!&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Hata, const reference&#39;ler değiştirilemez.</span>

<span class="c1">// Kısa bir ekleme: reference&#39;lere devam etmeden önce, geçici nesne konseptinden</span>
<span class="c1">// bahsetmeliyiz. Mesela aşadaki gibi bir kod var:</span>
<span class="n">string</span><span class="w"> </span><span class="nf">tempObjectFun</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="n">string</span><span class="w"> </span><span class="n">retVal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tempObjectFun</span><span class="p">();</span>

<span class="c1">// Bu iki satırda aslında ne oluyor:</span>
<span class="c1">//   - tempObjectFun fonksiyonundan bir string nesnesi dönüyor</span>
<span class="c1">//   - dönmüş olan nesneyle yeni bir string oluşturuyor</span>
<span class="c1">//   - dönmüş olan nesne yok ediliyor</span>
<span class="c1">// İşte bu dönen nesneye geçici nesne denir. Geçici nesneler fonksiyon nesne</span>
<span class="c1">// döndürdüğünde oluşturulur ve ifade işini bitirdiğinde yok edilir (Aslında,</span>
<span class="c1">// standard&#39;ın söylediği şey bu ama derleyiciler bu davranışı değiştirmemize </span>
<span class="c1">// izin veriyor. Daha fazla detay için &quot;return value optimization&quot; diye</span>
<span class="c1">// aratabilirsin. Sonuç olarak aşağıdaki kodda:</span>
<span class="n">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">(</span><span class="n">tempObjectFun</span><span class="p">()))</span>

<span class="c1">// foo ve bar&#39;ın varolduğunu kabul ediyoruz, tempObjectFun&#39;dan dönen nesne</span>
<span class="c1">// bar&#39;a geçti ve foo çağrılmadan önce yokedildir.</span>

<span class="c1">// Şimdi reference&#39;lara dönelim. &quot;ifadenin sonunda&quot; kuralının bir istisnası</span>
<span class="c1">// eğer geçici nesne const reference&#39;a geçildiyse oratya çıkar, bu durumda</span>
<span class="c1">// nesnenin ömrü mevcut kapsama alanına kadar uzar:</span>

<span class="kt">void</span><span class="w"> </span><span class="n">constReferenceTempObjectFun</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// constRef geçici nesneyi alır ve bu durum fonksiyonun sonuna kadar geçerlidir.</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">constRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tempObjectFun</span><span class="p">();</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>

<span class="c1">// C++11 ile gelen diğer bir reference geçici nesnelere özeldir. Bu türden birden </span>
<span class="c1">// bir tip tanımlayamazsın ama aşırı yüklenme sırasında bu tipler öncelik alır:</span>
<span class="kt">void</span><span class="w"> </span><span class="n">someFun</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">  </span><span class="c1">// Regular reference</span>
<span class="kt">void</span><span class="w"> </span><span class="n">someFun</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">  </span><span class="c1">// Geçici nesneye reference </span>

<span class="n">string</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>
<span class="n">someFun</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span><span class="w">  </span><span class="c1">// regular reference&#39;ı çağırır</span>
<span class="n">someFun</span><span class="p">(</span><span class="n">tempObjectFun</span><span class="p">());</span><span class="w">  </span><span class="c1">// geçici reference&#39;ı çağırır</span>

<span class="c1">/////////////////////</span>
<span class="c1">// Enum</span>
<span class="c1">/////////////////////</span>

<span class="c1">// Enum&#39;lar sabit değerler yapmak için kullanılır ve çoğunlukla kodun daha okunaklı</span>
<span class="c1">// olması için kullanılır</span>

<span class="k">enum</span><span class="w"> </span><span class="nc">ECarTypes</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Sedan</span><span class="p">,</span>
<span class="w">  </span><span class="n">Hatchback</span><span class="p">,</span>
<span class="w">  </span><span class="n">SUV</span><span class="p">,</span>
<span class="w">  </span><span class="n">Wagon</span>
<span class="p">};</span>

<span class="n">ECarTypes</span><span class="w"> </span><span class="nf">GetPreferredCarType</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ECarTypes</span><span class="o">::</span><span class="n">Hatchback</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// C++11 ile beraber bir tipi enum&#39;a atamanın kolay bir yolu var, bu enum&#39;un istenen</span>
<span class="c1">// tipe dönüştürmek için kullanışlı bir yöntem</span>
<span class="k">enum</span><span class="w"> </span><span class="nc">ECarTypes</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">uint8_t</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Sedan</span><span class="p">,</span><span class="w"> </span><span class="c1">// 0</span>
<span class="w">  </span><span class="n">Hatchback</span><span class="p">,</span><span class="w"> </span><span class="c1">// 1</span>
<span class="w">  </span><span class="n">SUV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">254</span><span class="p">,</span><span class="w"> </span><span class="c1">// 254</span>
<span class="w">  </span><span class="n">Hybrid</span><span class="w"> </span><span class="c1">// 255</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">WriteByteToFile</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">InputValue</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Serialize the InputValue to a file</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">WritePreferredCarTypeToFile</span><span class="p">(</span><span class="n">ECarTypes</span><span class="w"> </span><span class="n">InputCarType</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// enum uint8_t tipine dönüştürüldü</span>
<span class="w">    </span><span class="n">WriteByteToFile</span><span class="p">(</span><span class="n">InputCarType</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Diğer yandan enum&#39;ların yanlışlıkla integer tipini veya diğer enumlara dönüşmesini</span>
<span class="c1">// istemiyorsan enum class olarak tanımlayabilirsin</span>
<span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">ECarTypes</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">uint8_t</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Sedan</span><span class="p">,</span><span class="w"> </span><span class="c1">// 0</span>
<span class="w">  </span><span class="n">Hatchback</span><span class="p">,</span><span class="w"> </span><span class="c1">// 1</span>
<span class="w">  </span><span class="n">SUV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">254</span><span class="p">,</span><span class="w"> </span><span class="c1">// 254</span>
<span class="w">  </span><span class="n">Hybrid</span><span class="w"> </span><span class="c1">// 255</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">WriteByteToFile</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">InputValue</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Serialize the InputValue to a file</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">WritePreferredCarTypeToFile</span><span class="p">(</span><span class="n">ECarTypes</span><span class="w"> </span><span class="n">InputCarType</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// ECarTypes, uint8_t tipinde olmasına rağmen, &quot;enum class&quot; olarak </span>
<span class="w">    </span><span class="c1">// tanımlandığından derlenmeyecektir!</span>
<span class="w">    </span><span class="n">WriteByteToFile</span><span class="p">(</span><span class="n">InputCarType</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">///////////////////////////////////////////</span>
<span class="c1">// Sınıflar ve nesneye yönelik proglamalama</span>
<span class="c1">///////////////////////////////////////////</span>

<span class="c1">// Sınıflara(class) ilk örnek</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="c1">// Sınıfı tanımla.</span>
<span class="c1">// Sınıflar genelde header (.h veya .hpp) dosyalarında tanımlanır.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Dog</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Üye değişkenler ve fonksiyonlar default olarak private&#39;dir.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">weight</span><span class="p">;</span>

<span class="c1">// Aşağıda, &quot;private:&quot; veya &quot;protected:&quot; bulunana kadar</span>
<span class="c1">// bütün üyeler public&#39;tir.</span>
<span class="k">public</span><span class="o">:</span>

<span class="w">    </span><span class="c1">// Default constructor</span>
<span class="w">    </span><span class="n">Dog</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Üye fonksiyon bildirimi (gerçeklenimi aşağıda)</span>
<span class="w">    </span><span class="c1">// Dikkat ederseniz using namespace std; yerine</span>
<span class="w">    </span><span class="c1">// std::string kullandık.</span>
<span class="w">    </span><span class="c1">// Hiçbir zaman header dosyasında &quot;using namespace std;&quot; kullanma.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">setName</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dogsName</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">setWeight</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">dogsWeight</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Nesnenin durumunu değiştirmeyen fonksiyonlar const ile işaretlenmelidir</span>

<span class="w">    </span><span class="c1">// Türetilen sınıflarda fonksiyonu override edebilmek için başına </span>
<span class="w">    </span><span class="c1">// _virtual_ eklenmelidir.</span>
<span class="w">    </span><span class="c1">// Fonksiyonlar, performanslar ilgili nedenlerden ötürü default olarak virtual değildir</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Fonksiyonlar class içinde de tanımlanabilir.</span>
<span class="w">    </span><span class="c1">// Bu şekille tanımlanan fonksiyonlar otomatik olarak inline olur.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">bark</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; barks!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// C++ constructor&#39;ların yanında destructor&#39;da sağlar.</span>
<span class="w">    </span><span class="c1">// Bunlar nesne silindiğinde veya scope&#39;un dışına çıktığında çağrılır.</span>
<span class="w">    </span><span class="c1">// Bu RAII gibi güçlü paradigmaları etkin kılar.</span>
<span class="w">    </span><span class="c1">// (aşağıda açıklandı)</span>
<span class="w">    </span><span class="c1">// Eğer sınıf kendisinden türetiliyorsa, destructor virtual olmalıdır,</span>
<span class="w">    </span><span class="c1">// eğer virtual değilse, türetilmiş sınıfın destructor&#39;ı nesne, ana sınıf</span>
<span class="w">    </span><span class="c1">// referans&#39;ı veya pointer&#39;ı üzerinden yok edildiğinde, çağrılmayacaktır.</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Dog</span><span class="p">();</span>

<span class="p">};</span><span class="w"> </span><span class="c1">// class tanımının sonuda noktalı virgül(;) olmalıdır.</span>

<span class="c1">// Sınıfın üye fonksiyonları genelde .cpp dosyaları içinde gerçeklenir.</span>
<span class="n">Dog</span><span class="o">::</span><span class="n">Dog</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;A dog has been constructed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Objects (such as strings) should be passed by reference</span>
<span class="c1">// Nesneler (string gibi) reference ile fonksiyonlara geçilmelidir</span>
<span class="c1">// Eğer nesneleri değiştirilecekse reference ile fonksiyonlara geçilmelidir,</span>
<span class="c1">// değiştirilmeyecekse const reference ile geçilmelidir.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">Dog</span><span class="o">::</span><span class="n">setName</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dogsName</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dogsName</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">Dog</span><span class="o">::</span><span class="n">setWeight</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">dogsWeight</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dogsWeight</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Dikkat edersen &quot;virtual&quot; yalnızca bildirimde gerekli, tanımlamada değil.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">Dog</span><span class="o">::</span><span class="n">print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Dog is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; and weighs &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;kg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Dog</span><span class="o">::~</span><span class="n">Dog</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Goodbye &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Dog</span><span class="w"> </span><span class="n">myDog</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;A dog has been constructed&quot; yazdırır</span>
<span class="w">    </span><span class="n">myDog</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">&quot;Barkley&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">myDog</span><span class="p">.</span><span class="n">setWeight</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="n">myDog</span><span class="p">.</span><span class="n">print</span><span class="p">();</span><span class="w"> </span><span class="c1">// &quot;Dog is Barkley and weighs 10 kg&quot; yazdırır.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// &quot;Goodbye Barkley&quot; yazdırır.</span>

<span class="c1">// Inheritance(Miras)</span>

<span class="c1">// Bu sınıf, Dog sınıfında public ve protected olan herşeyi miras alır, </span>
<span class="c1">// private olanları da miras alır ama, public ve protected sınıflar aracılıyla</span>
<span class="c1">// yapılmıyorsa, doğrudan erişemez.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">OwnedDog</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Dog</span><span class="w"> </span><span class="p">{</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">setOwner</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dogsOwner</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// print fonksiyonunun davranışını bütün OwnedDogs sınıfı için override eder</span>
<span class="w">    </span><span class="c1">// (üstünden geçer, kendine uyarlar).</span>
<span class="w">    </span><span class="c1">// bknz http://en.wikipedia.org/wiki/Polymorphism_(computer_science)</span>
<span class="w">    </span><span class="c1">// override anahtar sözcüpü kullanılma da olur ama kullanılması aslında bir temel</span>
<span class="w">    </span><span class="c1">// temel sınıf fonksiyonunun üzerinden geçtiğimizi gösterir.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">owner</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Bu arada takip eden .cpp dosyasında:</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">OwnedDog::setOwner</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dogsOwner</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dogsOwner</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">OwnedDog::print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Dog</span><span class="o">::</span><span class="n">print</span><span class="p">();</span><span class="w"> </span><span class="c1">// Ana dog sınıfındaki print fonksiyonunu çağırır </span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Dog is owned by &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">owner</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//        &quot;Dog is &lt;name&gt; and weights &lt;weight&gt;&quot;</span>
<span class="w">    </span><span class="c1">//        &quot;Dog is owned by &lt;owner&gt;&quot;</span>
<span class="w">    </span><span class="c1">//         yazdırır</span>
<span class="p">}</span>

<span class="c1">/////////////////////////////////////////////////////</span>
<span class="c1">// ilk değer atama ve Operatörün fazladan yüklenmesi</span>
<span class="c1">/////////////////////////////////////////////////////</span>

<span class="c1">// C++ dilinde +, -, *, /, gibi operatörlerin davranışını fazladan yükleyebilirsiniz.</span>
<span class="c1">// Bu, operator her kullandınıldığında çağrılan bir fonksiyon tanımlamasıyla yapılır.</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Point</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// Üye değişkenkenlere default değer atanabilir.</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Default constructor</span>
<span class="w">    </span><span class="n">Point</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span>

<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">        </span><span class="n">x</span><span class="p">(</span><span class="n">a</span><span class="p">),</span>
<span class="w">        </span><span class="n">y</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="cm">/* İlk değer atama dışında birşey yapma */</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// + operatorünün fazladan yükle.</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// += operatorünü fazladan yükle</span>
<span class="w">    </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// - ve -= operatorleri fazladan yüklemek de mantıklı olurdu</span>
<span class="w">    </span><span class="c1">// ama kısa tutmak için burda değinmedik.</span>
<span class="p">};</span>

<span class="n">Point</span><span class="w"> </span><span class="n">Point</span><span class="o">::</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// yeni bir nokta oluştur ve bunu rhs ile topla</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Point</span><span class="o">::</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="nf">up</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="nf">right</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Bu Point + operatorünü çağırır</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// &quot;Result is upright (1,1)&quot; yazdırır.</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Result is upright (&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;,&#39;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">////////////////////////</span>
<span class="c1">// Şablonlar (Templates)</span>
<span class="c1">////////////////////////</span>

<span class="c1">// Şablonlar C++ dilinde tipten bağımsız programlama için kullanılır.</span>

<span class="c1">// Zaten aşina olduğun tipten bağımsız programlamayla başladık. Bir tip parametresi</span>
<span class="c1">// alan fonksiyon veya sınıf tanımlamaık için:</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Box</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// Bu sınıfta T, herhangi bir tip için kullanılabilir.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Derleme esnasında derleyici aslında, parametreleri yerine konmuş şekilde herbir şablonu üretir,</span>
<span class="c1">// bu yüzden sınıfın tam tanımı her çağrılma sırasında var olmak zorundadır. Bu nedenle şablon sınıflarını</span>
<span class="c1">// tamamen header dosyalarında görürsün.</span>

<span class="c1">// Stack&#39;ta şablon sınıfın bir örneğini oluşturmak için:</span>
<span class="n">Box</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">intBox</span><span class="p">;</span>

<span class="c1">// ve, anladığın gibi, kullanabilirsin:</span>
<span class="n">intBox</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>

<span class="c1">// Tabi, şablonları içiçe geçirebilirsin:</span>
<span class="n">Box</span><span class="o">&lt;</span><span class="n">Box</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">boxOfBox</span><span class="p">;</span>
<span class="n">boxOfBox</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">intBox</span><span class="p">);</span>

<span class="c1">// C++11&#39;den önce iki &#39;&gt;&#39; arasına boşluk koymak zorundaydık yoksa sağa kaydırma </span>
<span class="c1">// operatörü olarak algılanabilirdi.</span>

<span class="c1">// Bazen şunu da görebilirsin</span>
<span class="c1">//   template&lt;typename T&gt;</span>
<span class="c1">// &#39;class&#39; ve &#39;typename&#39; anahtar sözcükleri çoğunlukla </span>
<span class="c1">// birbirlerinin yerine kullanılabilir. Tam açıklama için, bknz.</span>
<span class="c1">//   http://en.wikipedia.org/wiki/Typename</span>
<span class="c1">// (evet, bu anahtar sözcüğün kendi Wikipedia sayfası var).</span>

<span class="c1">// Benzer şekilde, bir şablon fonksiyon:</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">barkThreeTimes</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">input</span><span class="p">.</span><span class="n">bark</span><span class="p">();</span>
<span class="w">    </span><span class="n">input</span><span class="p">.</span><span class="n">bark</span><span class="p">();</span>
<span class="w">    </span><span class="n">input</span><span class="p">.</span><span class="n">bark</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Dikkat edersen tip parametresi hakkında birşey belirtilmedi. Derleyici bunları üretecek</span>
<span class="c1">// ve her parametre geçişinde tip-kontrolü yapacaktır, bu nedenle de fonksiyon herhangi bir T</span>
<span class="c1">// tipi için çalışacaktır!</span>

<span class="n">Dog</span><span class="w"> </span><span class="n">fluffy</span><span class="p">;</span>
<span class="n">fluffy</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">&quot;Fluffy&quot;</span><span class="p">)</span>
<span class="n">barkThreeTimes</span><span class="p">(</span><span class="n">fluffy</span><span class="p">);</span><span class="w"> </span><span class="c1">// Üç kere &quot;Fluffy barks&quot; yazdırır.</span>

<span class="c1">// Şablonun parametresi sınıf olmak zorunda değildir:</span>
<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">Y</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">printMessage</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Learn C++ in &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; minutes!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Ve template&#39;i daha etkili kod için dışarıdan özelleştirebilirsin. </span>
<span class="c1">// Tabiki gerçek-dünya kullanımlarında özelleştirme bunun kadar kolay değildir.</span>
<span class="c1">// Dikkat edersen, bütün parametreleri dıştan özelleştirmiş olsak bile</span>
<span class="c1">// hala fonksiyonu (veya sınıfı( template olarak tanımlamamız gerekli.</span>
<span class="k">template</span><span class="o">&lt;&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">printMessage</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Learn C++ faster in only 10 minutes!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">printMessage</span><span class="o">&lt;</span><span class="mi">20</span><span class="o">&gt;</span><span class="p">();</span><span class="w">  </span><span class="c1">// &quot;Learn C++ in 20 minutes!&quot; yazdırır</span>
<span class="n">printMessage</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span><span class="p">();</span><span class="w">  </span><span class="c1">// &quot;Learn C++ faster in only 10 minutes!&quot; yazdırır</span>


<span class="c1">///////////////////////////////////////////////</span>
<span class="c1">// İstisnai Durum Yönetimi (Exception Handling)</span>
<span class="c1">///////////////////////////////////////////////</span>

<span class="c1">// Standard kütüphane bazı istisnai tipler sağlar</span>
<span class="c1">// (bknz http://en.cppreference.com/w/cpp/error/exception)</span>
<span class="c1">// ama herhangi bir tip de istisnai durum fırlatabilir </span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exception&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdexcept&gt;</span>

<span class="c1">// _try_ bloğu içinde fırlatılan bütün istisnai durumlar, takip eden, _catch_ ile </span>
<span class="c1">// yakalanabilir.</span>
<span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// _new_ kullanarak heap&#39;ten istisnai durumlar için yer ayırma</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;A problem occurred&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// istisnai durumlar nesne ise  const reference ile yakala</span>
<span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Bir önceki _catch_ bloğundan kaçan istisnai durum burda yakala</span>
<span class="k">catch</span><span class="w"> </span><span class="p">(...)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Unknown exception caught&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">throw</span><span class="p">;</span><span class="w"> </span><span class="c1">// Tekrardan istisnai durum fırlatır</span>
<span class="p">}</span>

<span class="c1">///////</span>
<span class="c1">// RAII</span>
<span class="c1">///////</span>

<span class="c1">// RAII, &quot;Resource Acquisition Is Initialization&quot; kelimelerinin kısaltmasıdır.</span>
<span class="c1">// Bu Türkçe, &quot;Kaynak alımı aynı zamanda ilk değer atamasıdır.&quot; olarak çevrilebilir.</span>
<span class="c1">// Bunu basitçe constructor ile ayrılan hafızanın destructor ile iade edilmesi olarak </span>
<span class="c1">// düşünebiliriz.</span>

<span class="c1">// Bunun ne şekilde kullanışlı olduğunu görmek için</span>
<span class="c1">// bir C dosyasının, dosya işleme biçimine bakabiliriz:</span>
<span class="kt">void</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Başlangıçta herşeyin yolunda gittiğini düşünelim</span>

<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Dosyayı okuma modunda aç</span>

<span class="w">    </span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Dosyayı kapat</span>
<span class="p">}</span>

<span class="c1">// Malesef hatalarla başa çıkmaya çalışırken işler hızlıca karmaşıklaşır.</span>
<span class="c1">// Mesela fopen&#39;ın başarısız olduğunu varsayalım, ve doSoomethingWithTheFile ve </span>
<span class="c1">// doSomethingWithIt hata kodları gönderdi.</span>
<span class="c1">//  (İstisnai durumlar yonetimi, hata koduna tercih ediler bir yöntemdir, ama bazı</span>
<span class="c1">//   programcılar, özellikle C arkaplanı olanlar, aynı fikirde değildir.</span>
<span class="c1">// Bu durumda her bir fonksiyon çağrısını kontrol etmeli ve bir problem oluştuysa</span>
<span class="c1">// dosyayı kapatmalıyız.</span>

<span class="kt">bool</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span><span class="w">  </span><span class="c1">// Dosyayı okuma modunda aç</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fh</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="c1">// Başarısız olma durumunda dönen değer null olur</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Başarısız olma durumunu çağırıcıya bildir</span>

<span class="w">    </span><span class="c1">// Başarısız olma durumunda her iki fonksiyonun da false döndürdüğünü kabul edelim</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Dosyayı kapatalım, akıntı olmasın.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Hatayı bildir</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Dosyayı kapatalım, akıntı olmasın.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Hatayı bildir</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Dosyayı kapat</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// Başarı durumunu ifade eder</span>
<span class="p">}</span>

<span class="c1">// C programcıları biraz goto kullanarak bu durumu temizler</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fh</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">failure</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">failure</span><span class="p">;</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Dosyayı kapat </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// Başarı durumunu ifade eder</span>

<span class="nl">failure</span><span class="p">:</span>
<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Hatayı bildir</span>
<span class="p">}</span>

<span class="c1">// Eğer fonksiyon istisnai durum yönetimi araçlarını kullanırsa</span>
<span class="c1">// işler daha temiz olur ama hala en iyi durumun altında kalır.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fh</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Could not open the file.&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">        </span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">catch</span><span class="w"> </span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Hata durumunda dosyayı kapattığından emin ol</span>
<span class="w">        </span><span class="k">throw</span><span class="p">;</span><span class="w"> </span><span class="c1">// Sonra, tekrardan istisnai durum fırlat</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Dosyayı kapat</span>
<span class="w">    </span><span class="c1">// Herşey başarılı</span>
<span class="p">}</span>

<span class="c1">// Şimdi aynı şeyi C++&#39;ın dosya stream sınıfıyla (fstream) karşılaştıralım</span>
<span class="c1">// fstream, dosyayı kapatmak için kendi destructor&#39;ını kullanır.</span>
<span class="c1">// Destructor&#39;ın, nesne scope dışına çıktığında otomatik olarak çağrıldığını </span>
<span class="c1">// hatırlayın.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span><span class="w"> </span><span class="nf">fh</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span><span class="w"> </span><span class="c1">// Dosyayı aç</span>

<span class="w">    </span><span class="c1">// Dosyayla birşeyler yap</span>
<span class="w">    </span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// Dosya, destructor tarafından otomatik olarak kapatıldı</span>

<span class="c1">// Bunun _çok büyük_ avantajları var:</span>
<span class="c1">// 1. Ne olursa olursun,</span>
<span class="c1">//    kaynak (bu örnekte dosya tutucusu) temizlenecektir.</span>
<span class="c1">//    Destructor doğru yazıldığında,</span>
<span class="c1">//    Tutucuyu kapatmayı unutma ve kaynak akıntısı _imkansız_dır.</span>
<span class="c1">// 2. Kodun çok daha temiz olduğuna dikkat edin.</span>
<span class="c1">//    Destructor, dosyayı kapatma işini, endilenmemize gerek kalmadan</span>
<span class="c1">//    arka planda halleder.</span>
<span class="c1">// 3. Kod, istisnai durumlara karşı korunaklıdır.</span>
<span class="c1">//    İstisnai durum fonksiyonun herhangi bir yerinde fırlatılabilir ve</span>
<span class="c1">//    temizleme işi gene de yapılır.</span>

<span class="c1">// Bütün C++ kodu deyimleri RAII prensibini tüm kaynakları için kullanır.</span>
<span class="c1">// Ek örnekler şunlardır:</span>
<span class="c1">// - unique_ptr ve shared_ptr ile hafıza kullanımı</span>
<span class="c1">// - Tutucular - standard kütüphane linked list,</span>
<span class="c1">//   vector (yani kendiliğinden boyu ayarlanan dizi), hash map vs.</span>
<span class="c1">//   scope&#39;un dışına çıktığında içerini otomatik olarak yok eden tüm yapılar.</span>
<span class="c1">// - lock_guard ve unique_lock kullanan mutex&#39;ler</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Lambda İfadeleri (C++11 ve yukarısı)</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// lambda&#39;lar, tam olarak çağrıldığı yerde bir anonim fonksiyon tanımlamak</span>
<span class="c1">// veya fonksiyona argüman geçmek için uygun bir yoldur.</span>

<span class="c1">// Mesela, pair&#39;lardan oluşan bir vector&#39;u, pair&#39;ın ikinci değerine </span>
<span class="c1">// göre sıralamak isteyelim</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">tester</span><span class="p">;</span>
<span class="n">tester</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">));</span>
<span class="n">tester</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">));</span>
<span class="n">tester</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span>

<span class="c1">// sort fonksiyonuna üçüncü argüman olarak lambda ifadesini geç</span>
<span class="c1">// sort, &lt;algorithm&gt; başlığında tanımlı</span>

<span class="n">sort</span><span class="p">(</span><span class="n">tester</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">tester</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">lhs</span><span class="p">.</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<span class="w">    </span><span class="p">});</span>

<span class="c1">// Lambda ifadesinin söz dizimine dikkat edin, </span>
<span class="c1">// lambda&#39;daki [], değişkenleri &quot;tutmak&quot; için kullanılır</span>
<span class="c1">// &quot;Tutma listesi&quot;, fonksiyon gövdesinde nelerin, ne şekilde erişilebilir olduğunu tanımlar</span>
<span class="c1">// Şunlardan biri olabilir:</span>
<span class="c1">//  1. bir değer : [x]</span>
<span class="c1">//  2. bir referans : [&amp;x]</span>
<span class="c1">//  3. mevcut scope içindeki herhangi bir değişkene referans ile [&amp;]</span>
<span class="c1">//  4. 3 ile aynı, ama değer ile [=]</span>
<span class="c1">// Mesela:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dog_ids</span><span class="p">;</span>
<span class="c1">// number_of_dogs = 3;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">dog_ids</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">weight</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">30</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">};</span>

<span class="c1">// Mesela dog_ids vector&#39;unu dog&#39;ların ağırlıklarına göre sıralamak isteyelim</span>
<span class="c1">// Yani en sonunda şöyle olmalı: [2, 0, 1]</span>

<span class="c1">// Burada lambda ifadesi oldukça kullanışlıdır</span>

<span class="n">sort</span><span class="p">(</span><span class="n">dog_ids</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">dog_ids</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">weight</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">weight</span><span class="p">[</span><span class="n">lhs</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">weight</span><span class="p">[</span><span class="n">rhs</span><span class="p">];</span>
<span class="w">    </span><span class="p">});</span>
<span class="c1">// Dikkat edersen &quot;weight&quot; dizisini referans ile aldık.</span>
<span class="c1">// C++&#39;da lambdalar hakkında daha fazla bilgi için : http://stackoverflow.com/questions/7627098/what-is-a-lambda-expression-in-c11</span>

<span class="c1">//////////////////////////////////</span>
<span class="c1">// Akıllı For (C++11 ve yukarısı)</span>
<span class="c1">//////////////////////////////////</span>

<span class="c1">// Akıllı for döngüsünü bir tutucuyu dolaşmak için kullanabilirsin</span>
<span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span>

<span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">elem</span><span class="o">:</span><span class="w"> </span><span class="n">arr</span><span class="p">){</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Tutucunun elemanlarının tipi için endişe etmeden &quot;auto&quot; kullanabilirsin</span>
<span class="c1">// Mesela:</span>

<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">elem</span><span class="o">:</span><span class="w"> </span><span class="n">arr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// arr dizisinin elemanlarıyla ilgili bir şeyler yap</span>
<span class="p">}</span>

<span class="c1">////////////////</span>
<span class="c1">// Güzel Şeyler</span>
<span class="c1">////////////////</span>

<span class="c1">// C++ dilinin bakış açısı yeni başlayanlar için (hatta dili iyi bilenler için bile)</span>
<span class="c1">// şaşırtıcı olabilir. </span>
<span class="c1">// Bu bölüm, ne yazık ki, büyük ölçüde tam değil; C++ kendi ayağına ateş edilebilecek kolay</span>
<span class="c1">// dillerden biridir.</span>

<span class="c1">// private metodları override edebilirsin!</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">();</span>
<span class="p">};</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FooSub</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">();</span><span class="w">  </span><span class="c1">// Foo::bar fonksiyonu override edilir!</span>
<span class="p">};</span>


<span class="c1">// 0 == false == NULL (çoğu zaman)!</span>
<span class="kt">bool</span><span class="o">*</span><span class="w"> </span><span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">bool</span><span class="p">;</span>
<span class="o">*</span><span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// &#39;pt&#39;nin gösterdiği değere false atar.</span>
<span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// &#39;pt&#39;ye null pointer atar. Her iki satır uyarısız derlenir.</span>

<span class="c1">// nullptr&#39;ın bu meselenin bazılarını çözmesi beklenmiştir:</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">pt2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>
<span class="o">*</span><span class="n">pt2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"> </span><span class="c1">// Derlenmez.</span>
<span class="n">pt2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w">  </span><span class="c1">// pt2&#39;ye null atar.</span>

<span class="c1">// bool tipleri için bir istisna vardır.</span>
<span class="c1">// Bu null pointer&#39;ları if(!ptr) ile test etmek içindir.</span>
<span class="c1">// ama sonuç olarak bir bool değerine nullptr atayabilirsin!</span>
<span class="o">*</span><span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w">  </span><span class="c1">// &#39;*pt&#39; değeri bir boll olmasına rağmen, hala derlenir!</span>


<span class="c1">// &#39;=&#39; != &#39;=&#39; != &#39;=&#39;!</span>
<span class="c1">// Calls Foo::Foo(const Foo&amp;) or some variant (see move semantics) copy</span>
<span class="c1">// Foo::Foo(const Foo&amp;) çağrısını veya kopyalama constructor&#39;ının bir çeşidinin çağrısınıyapar(taşıma semantiklerine bknz.)</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span>

<span class="c1">// Foo::operator=(Foo&amp;) çağrısını yapar.</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f1</span><span class="p">;</span>
<span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span>


<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Tuple (C++11 ve yukarısı)</span>
<span class="c1">///////////////////////////////////////</span>

<span class="cp">#include</span><span class="cpf">&lt;tuple&gt;</span>

<span class="c1">// Ana fikir olarak, Tuple, eski veri yapılarına (C&#39;deki struct&#39;lar) benzer ama isimli veri üyeleri yerine </span>
<span class="c1">// elemanlarına tuple içindeki sırasına göre erişilir.</span>

<span class="c1">// Tuple&#39;ı inşa ederek başlayalım</span>
<span class="c1">// değişkenleri tuple içinde paketliyoruz</span>
<span class="k">auto</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;A&#39;</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maxN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1e9</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maxL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">15</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_tuple</span><span class="p">(</span><span class="n">maxN</span><span class="p">,</span><span class="w"> </span><span class="n">maxL</span><span class="p">);</span>

<span class="c1">// &#39;first&#39; tuple&#39;ının değerlerini yazdırma</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">first</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">first</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 10 A yazdırır</span>

<span class="c1">// &#39;second&#39; tuple&#39;ının değerlerini yazdırma</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">second</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">second</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 1000000000 15 yazdırır</span>

<span class="c1">// Değişkenleri tuple&#39;dan çıkarma</span>

<span class="kt">int</span><span class="w"> </span><span class="n">first_int</span><span class="p">;</span>
<span class="kt">char</span><span class="w"> </span><span class="n">first_char</span><span class="p">;</span>
<span class="n">tie</span><span class="p">(</span><span class="n">first_int</span><span class="p">,</span><span class="w"> </span><span class="n">first_char</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first</span><span class="p">;</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">first_int</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">first_char</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w">  </span><span class="c1">// 10 A yazdırır</span>

<span class="c1">// Ayrıca şu şekide de tuple oluşturabiliriz.</span>

<span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">third</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;A&#39;</span><span class="p">,</span><span class="w"> </span><span class="mf">3.14141</span><span class="p">);</span>
<span class="c1">// tuple_size, tuple&#39;daki eleman sayısını (constexpr olarak) döndürür</span>

<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">tuple_size</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">third</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 3 yazdırır</span>

<span class="c1">// tuple_cat, tuple&#39;daki tüm elemanları aynı sırada birleştirir.</span>

<span class="k">auto</span><span class="w"> </span><span class="n">concatenated_tuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tuple_cat</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">second</span><span class="p">,</span><span class="w"> </span><span class="n">third</span><span class="p">);</span>
<span class="c1">// concatenated_tuple = (10, &#39;A&#39;, 1e9, 15, 11, &#39;A&#39;, 3.14141) olur</span>

<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">concatenated_tuple</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 10 yazdırır</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">concatenated_tuple</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 15 yazdırır</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">&gt;</span><span class="p">(</span><span class="n">concatenated_tuple</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// &#39;A&#39; yazdırır</span>


<span class="c1">/////////////////////</span>
<span class="c1">// Tutucular</span>
<span class="c1">/////////////////////</span>

<span class="c1">// Tutucular veya Standard Şablon Kütüphanesi(STL) önceden tanımlanmış şablonlar sunar.</span>
<span class="c1">// Bunlar elemanları için ayrılan hafıza alanını yönetir</span>
<span class="c1">// ve onlara erişim ve değiştirmek için üye fonksiyonlar sağlar</span>

<span class="c1">// Bazı tutucular şunlardır:</span>

<span class="c1">// Vector (Dinamik Dizi)</span>
<span class="c1">// koşma anında nesne dizisi veya list oluşturmamızı sağlar</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<span class="n">string</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">my_vector</span><span class="p">;</span><span class="w"> </span><span class="c1">// vector&#39;ü tanımla</span>
<span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="n">my_vector</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">val</span><span class="p">);</span><span class="w"> </span><span class="c1">// val değerini my_vector vectörüne push edecektir</span>
<span class="n">my_vector</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">val</span><span class="p">);</span><span class="w"> </span><span class="c1">// val değerini yeniden push edecektir (şu an iki elemanı var)</span>

<span class="c1">// vector içinde dolaşmak için iki seçenek var:</span>
<span class="c1">// ya klasik döngüyle (0. index&#39;ten son index&#39;e kadar iterasyon yaparak)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">my_vector</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">my_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// vector&#39;ün elemanlarına uşamak için [] operatörünü kullanabiliriz</span>
<span class="p">}</span>

<span class="c1">// ya da iteratör kulllanarak:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="p">;</span><span class="w"> </span><span class="c1">// vector için iterator tanımla</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_vector</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">my_vector</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="w">  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Set(Küme)</span>
<span class="c1">// Set&#39;ler benzersiz(unique) elemanları belirli bir sırada saklayan tutuculardır.</span>
<span class="c1">// Set, benzersiz değerleri, herhangi bir fonksiyon veya kod gerektirmeksizin, sıralı olarak</span>

<span class="cp">#include</span><span class="cpf">&lt;set&gt;</span>
<span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ST</span><span class="p">;</span><span class="w">    </span><span class="c1">// int tipi için set tanımlar</span>
<span class="n">ST</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span><span class="w">  </span><span class="c1">// ST kümesini 30 değerini dahil eder</span>
<span class="n">ST</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w">  </span><span class="c1">// ST kümesini 10 değerini dahil eder</span>
<span class="n">ST</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w">  </span><span class="c1">// ST kümesini 20 değerini dahil eder</span>
<span class="n">ST</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span><span class="w">  </span><span class="c1">// ST kümesini 30 değerini dahil eder</span>
<span class="c1">// Şimdi kümedeki elemanlar aşağıdaki gibidir</span>
<span class="c1">//  10 20 30</span>

<span class="c1">// Bir eleman silmek için:</span>
<span class="n">ST</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w">  </span><span class="c1">// 20 değerine sahip elemanı siler</span>
<span class="c1">// Set ST: 10 30</span>
<span class="c1">// Iterator kullanarak Set içinde iterasyon yapmak için:</span>
<span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="n">it</span><span class="o">=</span><span class="n">ST</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="n">it</span><span class="o">&lt;</span><span class="n">ST</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="n">it</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// Output:</span>
<span class="c1">// 10</span>
<span class="c1">// 30</span>

<span class="c1">// Tutucuyu tamamen silmek için Tutucu_Adi.clear() kullanırız</span>
<span class="n">ST</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ST</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w">  </span><span class="c1">// ST kümesinin eleman sayısı(size)nı yazdırır.</span>
<span class="c1">// Output: 0</span>

<span class="c1">// NOTE: Aynı elemanlari içerebilen kümle için multiset kullanırız</span>

<span class="c1">// Map(Harita)</span>
<span class="c1">// Map, elemanları anahtar değer, haritalanmış değer şeklinde özel bir sırada saklar.</span>
<span class="c1">// anahtar_değer -&gt; haritalanmış_değer</span>

<span class="cp">#include</span><span class="cpf">&lt;map&gt;</span>
<span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mymap</span><span class="p">;</span><span class="w">  </span><span class="c1">// Anahtar char ve değer int olacak şekilde map tanımlar</span>

<span class="n">mymap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="sc">&#39;A&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
<span class="c1">// 1 değeri için A anahtar değerini ekler</span>
<span class="n">mymap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="sc">&#39;Z&#39;</span><span class="p">,</span><span class="mi">26</span><span class="p">));</span>
<span class="c1">// 26 değeri için Z anahtar değerini ekler</span>

<span class="c1">// Map&#39;te dolaşma</span>
<span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">it</span><span class="o">=</span><span class="n">mymap</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="o">!=</span><span class="n">mymap</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;-&gt;&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="c1">// Output:</span>
<span class="c1">// A-&gt;1</span>
<span class="c1">// Z-&gt;26</span>

<span class="c1">// Anahtar&#39;a atanmış değeri bulmak için</span>
<span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mymap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39;Z&#39;</span><span class="p">);</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>

<span class="c1">// Output: 26</span>


<span class="c1">/////////////////////////////////////////////</span>
<span class="c1">// Mantıksal ve Bit seviyesindeki operatörler</span>
<span class="c1">/////////////////////////////////////////////</span>

<span class="c1">// Pek çok C++ operatörleri diğer dillerdekiyle aynıdır</span>

<span class="c1">// Mantıksal operatörler</span>

<span class="c1">// C++, bool ifadelerinde Kısa-devre değerlendirmesini kullanır yani ikinci argüman yalnızca ilk argüman</span>
<span class="c1">// ifadenin değerine karar vermek için yeterli değilse çalıştırılır</span>

<span class="nb">true</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="c1">// **mantıksal ve** işlemi yapılır ve yanlış sonucu üretilir</span>
<span class="nb">true</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="c1">// **mantıksal veya** işlemi yapılır ve true  sonucu üretilir </span>
<span class="o">!</span><span class="w"> </span><span class="nb">true</span><span class="w">        </span><span class="c1">// **mantıksal değil** işlemi yapılır ve yalnış sonucu üretilir</span>

<span class="c1">// Sembolleri kullanmak yerine onlara karşılık gelen anahtar kelimeler kullanılabilir</span>
<span class="nb">true</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="c1">// **mantıksal ve** işlemi yapılır ve yanlış sonucu üretilir</span>
<span class="nb">true</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="nb">false</span><span class="w">  </span><span class="c1">// **mantıksal veya** işlemi yapılır ve true  sonucu üretilir </span>
<span class="n">not</span><span class="w"> </span><span class="nb">true</span><span class="w">       </span><span class="c1">// **mantıksal değil** işlemi yapılır ve yalnış sonucu üretilir</span>

<span class="c1">// Bit seviyesindeki operatörler</span>

<span class="c1">// **&lt;&lt;** Sola kaydırma operatörü</span>
<span class="c1">// &lt;&lt; bitleri sola kaydırır</span>
<span class="mi">4</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// 4&#39;ün bitlerini 1 sola kaydırır ve 8 sonucunu verir</span>
<span class="c1">// x &lt;&lt; n, x * 2^n olarak düşünülebilir</span>


<span class="c1">// **&gt;&gt;** Sağa kaydırma operatörü</span>
<span class="c1">// &gt;&gt; bitleri sağa kaydırır</span>
<span class="mi">4</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// 4&#39;ün bitlerini 1 sağa kaydırır ve 2 sonucunu verir</span>
<span class="c1">// x &gt;&gt; n, x / 2^n olarak düşünülebilir</span>

<span class="o">~</span><span class="mi">4</span><span class="w">    </span><span class="c1">// Bit seviyesinde değil işlemini gerçekleştirir</span>
<span class="mi">4</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">// Bit seviyesinde veya işlemini gerçekleştirir</span>
<span class="mi">4</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">// Bit seviyesinde ve işlemini gerçekleştirir</span>
<span class="mi">4</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">// Bit seviyesinde xor işlemini gerçekleştirir</span>

<span class="c1">// Eşdeğer anahtar kelimeler</span>
<span class="n">compl</span><span class="w"> </span><span class="mi">4</span><span class="w">    </span><span class="c1">// Bit seviyesinde değil işlemini gerçekleştirir</span>
<span class="mi">4</span><span class="w"> </span><span class="n">bitor</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="c1">// Bit seviyesinde veya işlemini gerçekleştiri</span>
<span class="mi">4</span><span class="w"> </span><span class="n">bitand</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">// Bit seviyesinde ve işlemini gerçekleştirir</span>
<span class="mi">4</span><span class="w"> </span><span class="n">xor</span><span class="w"> </span><span class="mi">3</span><span class="w">    </span><span class="c1">// Bit seviyesinde xor işlemini gerçekleştirir</span>
</pre></div>
<p>İleri okuma:</p>

<ul>
<li>Güncel bir referans <a href="http://cppreference.com/w/cpp">CPP Reference</a> adresinde bulunabilir.</li>
<li>Ek kaynaklar <a href="http://cplusplus.com">CPlusPlus</a> adresinde bulunabilir.</li>
<li>Dilin temellerini ve kodlama ortamını belirleyen bir öğretici <a href="https://www.youtube.com/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb">TheChernoProject - C ++</a> adresinde bulunabilir.</li>
</ul>

    <hr>
    <p>Bir öneriniz mi var? Belki bir düzeltme? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Bir konu açın</a> Github deposundan, ya da kendi <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/tr-tr/c++-tr.html.markdown">PR</a>'nizi hazırlayın!
    </p>
    <p class="contributed">
    Aslen katkıda bulunan Steven Basart, ve güncelleştiren <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/tr-tr/c++-tr.html.markdown">10 geliştirici(ler)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://github.com/xksteven">Steven Basart</a>,
        <a href="https://github.com/mrkline">Matt Kline</a>,
        <a href="http://geoffliu.me">Geoff Liu</a>,
        <a href="http://github.com/connorwaters">Connor Waters</a>,
        <a href="http://github.com/ankushg07">Ankush Goyal</a>,
        <a href="https://github.com/jatindhankhar">Jatin Dhankhar</a>,
        <a href="https://github.com/p1v0t">Adem Budak</a>
    </p>

    <p>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
