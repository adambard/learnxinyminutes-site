<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="en-us" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="en-us" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="en-us" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="en-us" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="en-us">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Coq in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/coq/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fcoq%2F&text=Learn+X+in+Y+minutes%2C+where+X%3DCoq">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="/">Learn X in Y minutes</a></h1>
  <h2>Where X=Coq</h2>
    <p class="filelink">
    Get the code:
    <a href="/docs/files/learncoq.v">learncoq.v</a>
    </p>
  <div id="doc">
    <p>The Coq system is a proof assistant. It is designed to build and verify mathematical proofs. The Coq system contains the functional programming language Gallina and is capable of proving properties about programs written in this language.</p>

<p>Coq is a dependently typed language. This means that the types of the language may depend on the values of variables. In this respect, it is similar to other related languages such as Agda, Idris, F*, Lean, and others. Via the Curry-Howard correspondence, programs, properties and proofs are formalized in the same language.</p>

<p>Coq is developed in OCaml and shares some syntactic and conceptual similarity with it. Coq is a language containing many fascinating but difficult topics. This tutorial will focus on the programming aspects of Coq, rather than the proving. It may be helpful, but not necessary to learn some OCaml first, especially if you are unfamiliar with functional programming. This tutorial is based upon its OCaml equivalent</p>

<p>The standard usage model of Coq is to write it with interactive tool assistance, which operates like a high powered REPL. Two common such editors are the CoqIDE and Proof General Emacs mode.</p>

<p>Inside Proof General <code>Ctrl+C Ctrl+&lt;Enter&gt;</code> will evaluate up to your cursor.</p>
<div class="highlight"><pre><span></span><span class="c">(*** Comments ***)</span>

<span class="c">(* Comments are enclosed in (* and *). It&#39;s fine to nest comments. *)</span>

<span class="c">(* There are no single-line comments. *)</span>

<span class="c">(*** Variables and functions ***)</span>

<span class="c">(* The Coq proof assistant can be controlled and queried by a command</span>
<span class="c">   language called the vernacular. Vernacular keywords are capitalized and</span>
<span class="c">   the commands end with a period.  Variable and function declarations are</span>
<span class="c">   formed with the Definition vernacular. *)</span>

<span class="kn">Definition</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">10</span><span class="o">.</span>

<span class="c">(* Coq can sometimes infer the types of arguments, but it is common practice</span>
<span class="c">   to annotate with types. *)</span>

<span class="kn">Definition</span> <span class="n">inc_nat</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">.</span>

<span class="c">(* There exists a large number of vernacular commands for querying</span>
<span class="c">   information.  These can be very useful. *)</span>

<span class="kn">Compute</span> <span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span> <span class="c">(* 2 : nat *)</span> <span class="c">(* Compute a result. *)</span>

<span class="kn">Check</span> <span class="n">tt</span><span class="o">.</span> <span class="c">(* tt : unit *)</span> <span class="c">(* Check the type of an expressions *)</span>

<span class="n">About</span> <span class="n">plus</span><span class="o">.</span> <span class="c">(* Prints information about an object *)</span>

<span class="c">(* Print information including the definition *)</span>
<span class="kn">Print</span> <span class="bp">true</span><span class="o">.</span> <span class="c">(* Inductive bool : Set := true : Bool | false : Bool *)</span>

<span class="kn">Search</span> <span class="n">nat</span><span class="o">.</span> <span class="c">(* Returns a large list of nat related values *)</span>
<span class="kn">Search</span> <span class="s2">&quot;_ + _&quot;</span><span class="o">.</span> <span class="c">(* You can also search on patterns *)</span>
<span class="kn">Search</span> <span class="o">(?</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">bool</span><span class="o">).</span> <span class="c">(* Patterns can have named parameters  *)</span>
<span class="kn">Search</span> <span class="o">(?</span><span class="n">a</span> <span class="o">*</span> <span class="o">?</span><span class="n">a</span><span class="o">).</span>

<span class="c">(* Locate tells you where notation is coming from. Very helpful when you</span>
<span class="c">   encounter new notation. *)</span>

<span class="n">Locate</span> <span class="s2">&quot;+&quot;</span><span class="o">.</span>

<span class="c">(* Calling a function with insufficient number of arguments does not cause</span>
<span class="c">   an error, it produces a new function. *)</span>
<span class="kn">Definition</span> <span class="n">make_inc</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">.</span> <span class="c">(* make_inc is nat -&gt; nat -&gt; nat *)</span>
<span class="kn">Definition</span> <span class="n">inc_2</span> <span class="o">:=</span> <span class="n">make_inc</span> <span class="mi">2</span><span class="o">.</span>   <span class="c">(* inc_2 is nat -&gt; nat *)</span>
<span class="kn">Compute</span> <span class="n">inc_2</span> <span class="mi">3</span><span class="o">.</span> <span class="c">(* Evaluates to 5 *)</span>


<span class="c">(* Definitions can be chained with &quot;let ... in&quot; construct.  This is roughly</span>
<span class="c">   the same to assigning values to multiple variables before using them in</span>
<span class="c">   expressions in imperative languages. *)</span>

<span class="kn">Definition</span> <span class="n">add_xy</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">10</span> <span class="k">in</span>
                           <span class="k">let</span> <span class="n">y</span> <span class="o">:=</span> <span class="mi">20</span> <span class="k">in</span>
                           <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">.</span>

<span class="c">(* Pattern matching is somewhat similar to switch statement in imperative</span>
<span class="c">   languages, but offers a lot more expressive power. *)</span>

<span class="kn">Definition</span> <span class="n">is_zero</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">match</span> <span class="n">x</span> <span class="k">with</span>
    <span class="o">|</span> <span class="mi">0</span> <span class="o">=&gt;</span> <span class="bp">true</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">=&gt;</span> <span class="bp">false</span>  <span class="c">(* The &quot;_&quot; pattern means &quot;anything else&quot;. *)</span>
    <span class="k">end</span><span class="o">.</span>

<span class="c">(* You can define recursive function definition using the Fixpoint</span>
<span class="c">   vernacular.*)</span>

<span class="kn">Fixpoint</span> <span class="n">factorial</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">match</span> <span class="n">n</span> <span class="k">with</span>
                        <span class="o">|</span> <span class="mi">0</span> <span class="o">=&gt;</span> <span class="mi">1</span>
                        <span class="o">|</span> <span class="o">(</span><span class="n">S</span> <span class="n">n&#39;</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span> <span class="n">n&#39;</span>
                        <span class="k">end</span><span class="o">.</span>

<span class="c">(* Function application usually doesn&#39;t need parentheses around arguments *)</span>
<span class="kn">Compute</span> <span class="n">factorial</span> <span class="mi">5</span><span class="o">.</span> <span class="c">(* 120 : nat *)</span>

<span class="c">(* ...unless the argument is an expression. *)</span>
<span class="kn">Compute</span> <span class="n">factorial</span> <span class="o">(</span><span class="mi">5</span><span class="o">-</span><span class="mi">1</span><span class="o">).</span> <span class="c">(* 24 : nat *)</span>

<span class="c">(* You can define mutually recursive functions using &quot;with&quot; *)</span>
<span class="kn">Fixpoint</span> <span class="n">is_even</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">bool</span> <span class="o">:=</span> <span class="k">match</span> <span class="n">n</span> <span class="k">with</span>
  <span class="o">|</span> <span class="mi">0</span> <span class="o">=&gt;</span> <span class="bp">true</span>
  <span class="o">|</span> <span class="o">(</span><span class="n">S</span> <span class="n">n</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">is_odd</span> <span class="n">n</span>
<span class="k">end</span> <span class="k">with</span>
  <span class="n">is_odd</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">match</span> <span class="n">n</span> <span class="k">with</span>
  <span class="o">|</span> <span class="mi">0</span> <span class="o">=&gt;</span> <span class="bp">false</span>
  <span class="o">|</span> <span class="o">(</span><span class="n">S</span> <span class="n">n</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">is_even</span> <span class="n">n</span>
              <span class="k">end</span><span class="o">.</span>

<span class="c">(* As Coq is a total programming language, it will only accept programs when</span>
<span class="c">   it can understand they terminate. It can be most easily seen when the</span>
<span class="c">   recursive call is on a pattern matched out subpiece of the input, as then</span>
<span class="c">   the input is always decreasing in size. Getting Coq to understand that</span>
<span class="c">   functions terminate is not always easy. See the references at the end of</span>
<span class="c">   the article for more on this topic. *)</span>

<span class="c">(* Anonymous functions use the following syntax: *)</span>

<span class="kn">Definition</span> <span class="n">my_square</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">-&gt;</span> <span class="n">nat</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span>

<span class="kn">Definition</span> <span class="n">my_id</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span>
<span class="kn">Definition</span> <span class="n">my_id2</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span> <span class="n">A</span> <span class="o">-&gt;</span> <span class="n">A</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">A</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">x</span><span class="o">.</span>
<span class="kn">Compute</span> <span class="n">my_id</span> <span class="n">nat</span> <span class="mi">3</span><span class="o">.</span> <span class="c">(* 3 : nat *)</span>

<span class="c">(* You can ask Coq to infer terms with an underscore *)</span>
<span class="kn">Compute</span> <span class="n">my_id</span> <span class="o">_</span> <span class="mi">3</span><span class="o">.</span>

<span class="c">(* An implicit argument of a function is an argument which can be inferred</span>
<span class="c">   from contextual knowledge. Parameters enclosed in {} are implicit by</span>
<span class="c">   default *)</span>

<span class="kn">Definition</span> <span class="n">my_id3</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="o">:=</span> <span class="n">x</span><span class="o">.</span>
<span class="kn">Compute</span> <span class="n">my_id3</span> <span class="mi">3</span><span class="o">.</span> <span class="c">(* 3 : nat *)</span>

<span class="c">(* Sometimes it may be necessary to turn this off. You can make all</span>
<span class="c">   arguments explicit again with @ *)</span>

<span class="kn">Compute</span> <span class="o">@</span><span class="n">my_id3</span> <span class="n">nat</span> <span class="mi">3</span><span class="o">.</span>

<span class="c">(* Or give arguments by name *)</span>
<span class="kn">Compute</span> <span class="n">my_id3</span> <span class="o">(</span><span class="n">A</span><span class="o">:=</span><span class="n">nat</span><span class="o">)</span> <span class="mi">3</span><span class="o">.</span>

<span class="c">(* Coq has the ability to extract code to OCaml, Haskell, and Scheme *)</span>
<span class="kn">Require</span> <span class="n">Extraction</span><span class="o">.</span>
<span class="n">Extraction</span> <span class="n">Language</span> <span class="n">OCaml</span><span class="o">.</span>
<span class="n">Extraction</span> <span class="s2">&quot;factorial.ml&quot;</span> <span class="n">factorial</span><span class="o">.</span>
<span class="c">(* The above produces a file factorial.ml and factorial.mli that holds:</span>

<span class="c">type nat =</span>
<span class="c">| O</span>
<span class="c">| S of nat</span>

<span class="c">(** val add : nat -&gt; nat -&gt; nat **)</span>

<span class="c">let rec add n m =</span>
<span class="c">  match n with</span>
<span class="c">  | O -&gt; m</span>
<span class="c">  | S p -&gt; S (add p m)</span>

<span class="c">(** val mul : nat -&gt; nat -&gt; nat **)</span>

<span class="c">let rec mul n m =</span>
<span class="c">  match n with</span>
<span class="c">  | O -&gt; O</span>
<span class="c">  | S p -&gt; add m (mul p m)</span>

<span class="c">(** val factorial : nat -&gt; nat **)</span>

<span class="c">let rec factorial n = match n with</span>
<span class="c">| O -&gt; S O</span>
<span class="c">| S n&#39; -&gt; mul n (factorial n&#39;)</span>
<span class="c">*)</span>


<span class="c">(*** Notation ***)</span>

<span class="c">(* Coq has a very powerful Notation system that can be used to write</span>
<span class="c">   expressions in more natural forms. *)</span>

<span class="kn">Compute</span> <span class="n">Nat.add</span> <span class="mi">3</span> <span class="mi">4</span><span class="o">.</span> <span class="c">(* 7 : nat *)</span>
<span class="kn">Compute</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="o">.</span> <span class="c">(* 7 : nat *)</span>

<span class="c">(* Notation is a syntactic transformation applied to the text of the program</span>
<span class="c">   before being evaluated. Notation is organized into notation scopes. Using</span>
<span class="c">   different notation scopes allows for a weak notion of overloading. *)</span>

<span class="c">(* Imports the Zarith module holding definitions related to the integers Z *)</span>

<span class="kn">Require</span> <span class="kn">Import</span> <span class="n">ZArith</span><span class="o">.</span>

<span class="c">(* Notation scopes can be opened *)</span>
<span class="kn">Open</span> <span class="kn">Scope</span> <span class="n">Z_scope</span><span class="o">.</span>

<span class="c">(* Now numerals and addition are defined on the integers. *)</span>
<span class="kn">Compute</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">7</span><span class="o">.</span> <span class="c">(* 8 : Z *)</span>

<span class="c">(* Integer equality checking *)</span>
<span class="kn">Compute</span> <span class="mi">1</span> <span class="o">=?</span> <span class="mi">2</span><span class="o">.</span> <span class="c">(* false : bool *)</span>

<span class="c">(* Locate is useful for finding the origin and definition of notations *)</span>
<span class="n">Locate</span> <span class="s2">&quot;_ =? _&quot;</span><span class="o">.</span> <span class="c">(* Z.eqb x y : Z_scope *)</span>
<span class="kn">Close</span> <span class="kn">Scope</span> <span class="n">Z_scope</span><span class="o">.</span>

<span class="c">(* We&#39;re back to nat being the default interpretation of &quot;+&quot; *)</span>
<span class="kn">Compute</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">7</span><span class="o">.</span> <span class="c">(* 8 : nat *)</span>

<span class="c">(* Scopes can also be opened inline with the shorthand % *)</span>
<span class="kn">Compute</span> <span class="o">(</span><span class="mi">3</span> <span class="o">*</span> <span class="o">-</span><span class="mi">7</span><span class="o">)%</span><span class="n">Z</span><span class="o">.</span> <span class="c">(* -21%Z : Z *)</span>

<span class="c">(* Coq declares by default the following interpretation scopes: core_scope,</span>
<span class="c">   type_scope, function_scope, nat_scope, bool_scope, list_scope, int_scope,</span>
<span class="c">   uint_scope. You may also want the numerical scopes Z_scope (integers) and</span>
<span class="c">   Q_scope (fractions) held in the ZArith and QArith module respectively. *)</span>

<span class="c">(* You can print the contents of scopes *)</span>
<span class="kn">Print</span> <span class="kn">Scope</span> <span class="n">nat_scope</span><span class="o">.</span>
<span class="c">(*</span>
<span class="c">Scope nat_scope</span>
<span class="c">Delimiting key is nat</span>
<span class="c">Bound to classes nat Nat.t</span>
<span class="c">&quot;x &#39;mod&#39; y&quot; := Nat.modulo x y</span>
<span class="c">&quot;x ^ y&quot; := Nat.pow x y</span>
<span class="c">&quot;x ?= y&quot; := Nat.compare x y</span>
<span class="c">&quot;x &gt;= y&quot; := ge x y</span>
<span class="c">&quot;x &gt; y&quot; := gt x y</span>
<span class="c">&quot;x =? y&quot; := Nat.eqb x y</span>
<span class="c">&quot;x &lt;? y&quot; := Nat.ltb x y</span>
<span class="c">&quot;x &lt;=? y&quot; := Nat.leb x y</span>
<span class="c">&quot;x &lt;= y &lt;= z&quot; := and (le x y) (le y z)</span>
<span class="c">&quot;x &lt;= y &lt; z&quot; := and (le x y) (lt y z)</span>
<span class="c">&quot;n &lt;= m&quot; := le n m</span>
<span class="c">&quot;x &lt; y &lt;= z&quot; := and (lt x y) (le y z)</span>
<span class="c">&quot;x &lt; y &lt; z&quot; := and (lt x y) (lt y z)</span>
<span class="c">&quot;x &lt; y&quot; := lt x y</span>
<span class="c">&quot;x / y&quot; := Nat.div x y</span>
<span class="c">&quot;x - y&quot; := Init.Nat.sub x y</span>
<span class="c">&quot;x + y&quot; := Init.Nat.add x y</span>
<span class="c">&quot;x * y&quot; := Init.Nat.mul x y</span>
<span class="c">*)</span>

<span class="c">(* Coq has exact fractions available as the type Q in the QArith module.</span>
<span class="c">   Floating point numbers and real numbers are also available but are a more</span>
<span class="c">   advanced topic, as proving properties about them is rather tricky. *)</span>

<span class="kn">Require</span> <span class="kn">Import</span> <span class="n">QArith</span><span class="o">.</span>

<span class="kn">Open</span> <span class="kn">Scope</span> <span class="n">Q_scope</span><span class="o">.</span>
<span class="kn">Compute</span> <span class="mi">1</span><span class="o">.</span> <span class="c">(* 1 : Q *)</span>

<span class="c">(* Only 1 and 0 are interpreted as fractions by Q_scope *)</span>
<span class="kn">Compute</span> <span class="mi">2</span><span class="o">.</span> <span class="c">(* 2 : nat *)</span>
<span class="kn">Compute</span> <span class="o">(</span><span class="mi">2</span> <span class="o">#</span> <span class="mi">3</span><span class="o">).</span> <span class="c">(* The fraction 2/3 *)</span>
<span class="kn">Compute</span> <span class="o">(</span><span class="mi">1</span> <span class="o">#</span> <span class="mi">3</span><span class="o">)</span> <span class="o">?=</span> <span class="o">(</span><span class="mi">2</span> <span class="o">#</span> <span class="mi">6</span><span class="o">).</span> <span class="c">(* Eq : comparison *)</span>
<span class="kn">Close</span> <span class="kn">Scope</span> <span class="n">Q_scope</span><span class="o">.</span>

<span class="kn">Compute</span> <span class="o">(</span> <span class="o">(</span><span class="mi">2</span> <span class="o">#</span> <span class="mi">3</span><span class="o">)</span> <span class="o">/</span> <span class="o">(</span><span class="mi">1</span> <span class="o">#</span> <span class="mi">5</span><span class="o">)</span> <span class="o">)%</span><span class="n">Q</span><span class="o">.</span> <span class="c">(* 10 # 3 : Q *)</span>


<span class="c">(*** Common data structures ***)</span>

<span class="c">(* Many common data types are included in the standard library *)</span>

<span class="c">(* The unit type has exactly one value, tt *)</span>
<span class="kn">Check</span> <span class="n">tt</span><span class="o">.</span> <span class="c">(* tt : unit *)</span>

<span class="c">(* The option type is useful for expressing computations that might fail *)</span>
<span class="kn">Compute</span> <span class="n">None</span><span class="o">.</span> <span class="c">(* None : option ?A *)</span>
<span class="kn">Check</span> <span class="n">Some</span> <span class="mi">3</span><span class="o">.</span> <span class="c">(* Some 3 : option nat *)</span>

<span class="c">(* The type sum A B allows for values of either type A or type B *)</span>
<span class="kn">Print</span> <span class="n">sum</span><span class="o">.</span>
<span class="kn">Check</span> <span class="n">inl</span> <span class="mi">3</span><span class="o">.</span> <span class="c">(* inl 3 : nat + ?B *)</span>
<span class="kn">Check</span> <span class="n">inr</span> <span class="bp">true</span><span class="o">.</span> <span class="c">(* inr true : ?A + bool *)</span>
<span class="kn">Check</span> <span class="n">sum</span> <span class="n">bool</span> <span class="n">nat</span><span class="o">.</span> <span class="c">(* (bool + nat)%type : Set *)</span>
<span class="kn">Check</span> <span class="o">(</span><span class="n">bool</span> <span class="o">+</span> <span class="n">nat</span><span class="o">)%</span><span class="n">type</span><span class="o">.</span> <span class="c">(* Notation for sum *)</span>

<span class="c">(* Tuples are (optionally) enclosed in parentheses, items are separated</span>
<span class="c">   by commas. *)</span>
<span class="kn">Check</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="bp">true</span><span class="o">).</span> <span class="c">(* (1, true) : nat * bool *)</span>
<span class="kn">Compute</span> <span class="n">prod</span> <span class="n">nat</span> <span class="n">bool</span><span class="o">.</span> <span class="c">(* (nat * bool)%type : Set *)</span>

<span class="kn">Definition</span> <span class="n">my_fst</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">A</span> <span class="o">*</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="o">:=</span> <span class="k">match</span> <span class="n">x</span> <span class="k">with</span>
                                                  <span class="o">|</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">a</span>
                                                  <span class="k">end</span><span class="o">.</span>

<span class="c">(* A destructuring let is available if a pattern match is irrefutable *)</span>
<span class="kn">Definition</span> <span class="n">my_fst2</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">A</span> <span class="o">*</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="o">:=</span> <span class="k">let</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">x</span> <span class="k">in</span>
                                                   <span class="n">a</span><span class="o">.</span>

<span class="c">(*** Lists ***)</span>

<span class="c">(* Lists are built by using cons and nil or by using notation available in</span>
<span class="c">   list_scope. *)</span>
<span class="kn">Compute</span> <span class="n">cons</span> <span class="mi">1</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">2</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">3</span> <span class="n">nil</span><span class="o">)).</span> <span class="c">(*  (1 :: 2 :: 3 :: nil)%list : list nat *)</span>
<span class="kn">Compute</span> <span class="o">(</span><span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="n">nil</span><span class="o">)%</span><span class="n">list</span><span class="o">.</span>

<span class="c">(* There is also list notation available in the ListNotations modules *)</span>
<span class="kn">Require</span> <span class="kn">Import</span> <span class="n">List</span><span class="o">.</span>
<span class="kn">Import</span> <span class="n">ListNotations</span><span class="o">.</span>
<span class="kn">Compute</span> <span class="o">[</span><span class="mi">1</span> <span class="o">;</span> <span class="mi">2</span> <span class="o">;</span> <span class="mi">3</span><span class="o">].</span> <span class="c">(* [1; 2; 3] : list nat *)</span>


<span class="c">(* There is a large number of list manipulation functions available,</span>
<span class="c">   including:</span>

<span class="c">• length</span>
<span class="c">• head : first element (with default)</span>
<span class="c">• tail : all but first element</span>
<span class="c">• app : appending</span>
<span class="c">• rev : reverse</span>
<span class="c">• nth : accessing n-th element (with default)</span>
<span class="c">• map : applying a function</span>
<span class="c">• flat_map : applying a function returning lists</span>
<span class="c">• fold_left : iterator (from head to tail)</span>
<span class="c">• fold_right : iterator (from tail to head)</span>

<span class="c"> *)</span>

<span class="kn">Definition</span> <span class="n">my_list</span> <span class="o">:</span> <span class="n">list</span> <span class="n">nat</span> <span class="o">:=</span> <span class="o">[</span><span class="mi">47</span><span class="o">;</span> <span class="mi">18</span><span class="o">;</span> <span class="mi">34</span><span class="o">].</span>

<span class="kn">Compute</span> <span class="n">List.length</span> <span class="n">my_list</span><span class="o">.</span> <span class="c">(* 3 : nat *)</span>

<span class="c">(* All functions in coq must be total, so indexing requires a default value *)</span>
<span class="kn">Compute</span> <span class="n">List.nth</span> <span class="mi">1</span> <span class="n">my_list</span> <span class="mi">0</span><span class="o">.</span> <span class="c">(* 18 : nat *)</span>
<span class="kn">Compute</span> <span class="n">List.map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span> <span class="n">my_list</span><span class="o">.</span> <span class="c">(* [94; 36; 68] : list nat *)</span>
<span class="kn">Compute</span> <span class="n">List.filter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">Nat.eqb</span> <span class="o">(</span><span class="n">Nat.modulo</span> <span class="n">x</span> <span class="mi">2</span><span class="o">)</span> <span class="mi">0</span><span class="o">)</span> <span class="n">my_list</span><span class="o">.</span>
                                               <span class="c">(* [18; 34] : list nat *)</span>
<span class="kn">Compute</span> <span class="o">(</span><span class="n">my_list</span> <span class="o">++</span> <span class="n">my_list</span><span class="o">)%</span><span class="n">list</span><span class="o">.</span> <span class="c">(* [47; 18; 34; 47; 18; 34] : list nat *)</span>

<span class="c">(*** Strings ***)</span>

<span class="kn">Require</span> <span class="kn">Import</span> <span class="n">Strings.String</span><span class="o">.</span>

<span class="c">(* Use double quotes for string literals. *)</span>
<span class="kn">Compute</span> <span class="s2">&quot;hi&quot;</span><span class="o">%</span><span class="n">string</span><span class="o">.</span>

<span class="kn">Open</span> <span class="kn">Scope</span> <span class="n">string_scope</span><span class="o">.</span>

<span class="c">(* Strings can be concatenated with the &quot;++&quot; operator. *)</span>
<span class="kn">Compute</span> <span class="n">String.append</span> <span class="s2">&quot;Hello &quot;</span> <span class="s2">&quot;World&quot;</span><span class="o">.</span> <span class="c">(* &quot;Hello World&quot; : string *)</span>
<span class="kn">Compute</span> <span class="s2">&quot;Hello &quot;</span> <span class="o">++</span> <span class="s2">&quot;World&quot;</span><span class="o">.</span> <span class="c">(* &quot;Hello World&quot; : string *)</span>

<span class="c">(* Strings can be compared for equality *)</span>
<span class="kn">Compute</span> <span class="n">String.eqb</span> <span class="s2">&quot;Coq is fun!&quot;</span> <span class="s2">&quot;Coq is fun!&quot;</span><span class="o">.</span> <span class="c">(* true : bool *)</span>
<span class="kn">Compute</span> <span class="s2">&quot;no&quot;</span> <span class="o">=?</span> <span class="s2">&quot;way&quot;</span><span class="o">.</span> <span class="c">(* false : bool *)</span>

<span class="kn">Close</span> <span class="kn">Scope</span> <span class="n">string_scope</span><span class="o">.</span>

<span class="c">(*** Other Modules ***)</span>

<span class="c">(* Other Modules in the standard library that may be of interest:</span>

<span class="c">• Logic : Classical logic and dependent equality</span>
<span class="c">• Arith : Basic Peano arithmetic</span>
<span class="c">• PArith : Basic positive integer arithmetic</span>
<span class="c">• NArith : Basic binary natural number arithmetic</span>
<span class="c">• ZArith : Basic relative integer arithmetic</span>

<span class="c">• Numbers : Various approaches to natural, integer and cyclic numbers</span>
<span class="c">            (currently axiomatically and on top of 2^31 binary words)</span>
<span class="c">• Bool : Booleans (basic functions and results)</span>

<span class="c">• Lists : Monomorphic and polymorphic lists (basic functions and results),</span>
<span class="c">          Streams (infinite sequences defined with co-inductive types)</span>
<span class="c">• Sets : Sets (classical, constructive, finite, infinite, power set, etc.)</span>
<span class="c">• FSets : Specification and implementations of finite sets and finite maps</span>
<span class="c">          (by lists and by AVL trees)</span>
<span class="c">• Reals : Axiomatization of real numbers (classical, basic functions,</span>
<span class="c">          integer part, fractional part, limit, derivative, Cauchy series,</span>
<span class="c">          power series and results,...)</span>
<span class="c">• Relations : Relations (definitions and basic results)</span>
<span class="c">• Sorting : Sorted list (basic definitions and heapsort correctness)</span>
<span class="c">• Strings : 8-bit characters and strings</span>
<span class="c">• Wellfounded : Well-founded relations (basic results)</span>
<span class="c"> *)</span>

<span class="c">(*** User-defined data types ***)</span>

<span class="c">(* Because Coq is dependently typed, defining type aliases is no different</span>
<span class="c">   than defining an alias for a value. *)</span>

<span class="kn">Definition</span> <span class="n">my_three</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="mi">3</span><span class="o">.</span>
<span class="kn">Definition</span> <span class="n">my_nat</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">nat</span><span class="o">.</span>

<span class="c">(* More interesting types can be defined using the Inductive vernacular.</span>
<span class="c">   Simple enumeration can be defined like so *)</span>

<span class="kn">Inductive</span> <span class="n">ml</span> <span class="o">:=</span> <span class="n">OCaml</span> <span class="o">|</span> <span class="n">StandardML</span> <span class="o">|</span> <span class="n">Coq</span><span class="o">.</span>
<span class="kn">Definition</span> <span class="n">lang</span> <span class="o">:=</span> <span class="n">Coq</span><span class="o">.</span>  <span class="c">(* Has type &quot;ml&quot;. *)</span>

<span class="c">(* For more complicated types, you will need to specify the types of the</span>
<span class="c">   constructors. *)</span>

<span class="c">(* Type constructors don&#39;t need to be empty. *)</span>
<span class="kn">Inductive</span> <span class="n">my_number</span> <span class="o">:=</span> <span class="n">plus_infinity</span>
                     <span class="o">|</span> <span class="n">nat_value</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">-&gt;</span> <span class="n">my_number</span><span class="o">.</span>
<span class="kn">Compute</span> <span class="n">nat_value</span> <span class="mi">3</span><span class="o">.</span> <span class="c">(* nat_value 3 : my_number *)</span>


<span class="c">(* Record syntax is sugar for tuple-like types. It defines named accessor</span>
<span class="c">   functions for the components. Record types are defined with the notation</span>
<span class="c">   {...} *)</span>

<span class="kn">Record</span> <span class="n">Point2d</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Set</span><span class="o">)</span> <span class="o">:=</span> <span class="n">mkPoint2d</span> <span class="o">{</span> <span class="n">x2</span> <span class="o">:</span> <span class="n">A</span> <span class="o">;</span> <span class="n">y2</span> <span class="o">:</span> <span class="n">A</span> <span class="o">}.</span>
<span class="c">(* Record values are constructed with the notation {|...|} *)</span>
<span class="kn">Definition</span> <span class="n">mypoint</span> <span class="o">:</span> <span class="n">Point2d</span> <span class="n">nat</span> <span class="o">:=</span>  <span class="o">{|</span> <span class="n">x2</span> <span class="o">:=</span> <span class="mi">2</span> <span class="o">;</span> <span class="n">y2</span> <span class="o">:=</span> <span class="mi">3</span> <span class="o">|}.</span>
<span class="kn">Compute</span> <span class="n">x2</span> <span class="n">nat</span> <span class="n">mypoint</span><span class="o">.</span> <span class="c">(* 2 : nat *)</span>
<span class="kn">Compute</span> <span class="n">mypoint</span><span class="o">.(</span><span class="n">x2</span> <span class="n">nat</span><span class="o">).</span> <span class="c">(* 2 : nat *)</span>

<span class="c">(* Types can be parameterized, like in this type for &quot;list of lists of</span>
<span class="c">   anything&quot;. &#39;a can be substituted with any type. *)</span>

<span class="kn">Definition</span> <span class="n">list_of_lists</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">a</span><span class="o">).</span>
<span class="kn">Definition</span> <span class="n">list_list_nat</span> <span class="o">:=</span> <span class="n">list_of_lists</span> <span class="n">nat</span><span class="o">.</span>

<span class="c">(* Types can also be recursive. Like in this type analogous to</span>
<span class="c">   built-in list of naturals. *)</span>

<span class="kn">Inductive</span> <span class="n">my_nat_list</span> <span class="o">:=</span>
  <span class="n">EmptyList</span> <span class="o">|</span> <span class="n">NatList</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">-&gt;</span> <span class="n">my_nat_list</span> <span class="o">-&gt;</span> <span class="n">my_nat_list</span><span class="o">.</span>

<span class="kn">Compute</span> <span class="n">NatList</span> <span class="mi">1</span> <span class="n">EmptyList</span><span class="o">.</span> <span class="c">(*  NatList 1 EmptyList : my_nat_list *)</span>

<span class="c">(** Matching type constructors **)</span>

<span class="kn">Inductive</span> <span class="n">animal</span> <span class="o">:=</span> <span class="n">Dog</span> <span class="o">:</span> <span class="n">string</span> <span class="o">-&gt;</span> <span class="n">animal</span> <span class="o">|</span> <span class="n">Cat</span> <span class="o">:</span> <span class="n">string</span> <span class="o">-&gt;</span> <span class="n">animal</span><span class="o">.</span>

<span class="kn">Definition</span> <span class="n">say</span> <span class="n">x</span> <span class="o">:=</span>
    <span class="k">match</span> <span class="n">x</span> <span class="k">with</span>
    <span class="o">|</span> <span class="n">Dog</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">x</span> <span class="o">++</span> <span class="s2">&quot; says woof&quot;</span><span class="o">)%</span><span class="n">string</span>
    <span class="o">|</span> <span class="n">Cat</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">x</span> <span class="o">++</span> <span class="s2">&quot; says meow&quot;</span><span class="o">)%</span><span class="n">string</span>
    <span class="k">end</span><span class="o">.</span>

<span class="kn">Compute</span> <span class="n">say</span> <span class="o">(</span><span class="n">Cat</span> <span class="s2">&quot;Fluffy&quot;</span><span class="o">).</span> <span class="c">(* &quot;Fluffy says meow&quot;. *)</span>

<span class="c">(** Traversing data structures with pattern matching **)</span>

<span class="c">(* Recursive types can be traversed with pattern matching easily.</span>
<span class="c">   Let&#39;s see how we can traverse a data structure of the built-in list type.</span>
<span class="c">   Even though the built-in cons (&quot;::&quot;) looks like an infix operator,</span>
<span class="c">   it&#39;s actually a type constructor and can be matched like any other. *)</span>
<span class="kn">Fixpoint</span> <span class="n">sum_list</span> <span class="n">l</span> <span class="o">:=</span>
    <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">=&gt;</span> <span class="mi">0</span>
    <span class="o">|</span> <span class="n">head</span> <span class="o">::</span> <span class="n">tail</span> <span class="o">=&gt;</span> <span class="n">head</span> <span class="o">+</span> <span class="o">(</span><span class="n">sum_list</span> <span class="n">tail</span><span class="o">)</span>
    <span class="k">end</span><span class="o">.</span>

<span class="kn">Compute</span> <span class="n">sum_list</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">].</span> <span class="c">(* Evaluates to 6 *)</span>


<span class="c">(*** A Taste of Proving ***)</span>

<span class="c">(* Explaining the proof language is out of scope for this tutorial, but here</span>
<span class="c">   is a taste to whet your appetite. Check the resources below for more. *)</span>

<span class="c">(* A fascinating feature of dependently type based theorem provers is that</span>
<span class="c">   the same primitive constructs underly the proof language as the</span>
<span class="c">   programming features.  For example, we can write and prove the</span>
<span class="c">   proposition A and B implies A in raw Gallina *)</span>

<span class="kn">Definition</span> <span class="n">my_theorem</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="n">A</span> <span class="o">/\</span> <span class="n">B</span> <span class="o">-&gt;</span> <span class="n">A</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">A</span> <span class="n">B</span> <span class="n">ab</span> <span class="o">=&gt;</span> <span class="k">match</span> <span class="n">ab</span> <span class="k">with</span>
                  <span class="o">|</span> <span class="o">(</span><span class="n">conj</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">a</span>
                <span class="k">end</span><span class="o">.</span>

<span class="c">(* Or we can prove it using tactics. Tactics are a macro language to help</span>
<span class="c">   build proof terms in a more natural style and automate away some</span>
<span class="c">   drudgery. *)</span>

<span class="kn">Theorem</span> <span class="n">my_theorem2</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="n">A</span> <span class="o">/\</span> <span class="n">B</span> <span class="o">-&gt;</span> <span class="n">A</span><span class="o">.</span>
<span class="kn">Proof</span><span class="o">.</span>
  <span class="k">intros</span> <span class="n">A</span> <span class="n">B</span> <span class="n">ab</span><span class="o">.</span>  <span class="k">destruct</span> <span class="n">ab</span> <span class="k">as</span> <span class="o">[</span> <span class="n">a</span> <span class="n">b</span> <span class="o">].</span> <span class="k">apply</span> <span class="n">a</span><span class="o">.</span>
<span class="kn">Qed</span><span class="o">.</span>

<span class="c">(* We can easily prove simple polynomial equalities using the</span>
<span class="c">   automated tactic ring. *)</span>

<span class="kn">Require</span> <span class="kn">Import</span> <span class="n">Ring</span><span class="o">.</span>
<span class="kn">Require</span> <span class="kn">Import</span> <span class="n">Arith</span><span class="o">.</span>
<span class="kn">Theorem</span> <span class="n">simple_poly</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">.</span>
  <span class="kn">Proof</span><span class="o">.</span> <span class="k">intros</span><span class="o">.</span> <span class="k">ring</span><span class="o">.</span> <span class="kn">Qed</span><span class="o">.</span>

<span class="c">(* Here we prove the closed form for the sum of all numbers 1 to n using</span>
<span class="c">   induction *)</span>

<span class="kn">Fixpoint</span> <span class="n">sumn</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">n</span> <span class="k">with</span>
  <span class="o">|</span> <span class="mi">0</span> <span class="o">=&gt;</span> <span class="mi">0</span>
  <span class="o">|</span> <span class="o">(</span><span class="n">S</span> <span class="n">n&#39;</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">n</span> <span class="o">+</span> <span class="o">(</span><span class="n">sumn</span> <span class="n">n&#39;</span><span class="o">)</span>
  <span class="k">end</span><span class="o">.</span>

<span class="kn">Theorem</span> <span class="n">sum_formula</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">n</span><span class="o">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="o">(</span><span class="n">sumn</span> <span class="n">n</span><span class="o">)</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="n">n</span><span class="o">.</span>
<span class="kn">Proof</span><span class="o">.</span> <span class="k">intros</span> <span class="n">n</span><span class="o">.</span> <span class="k">induction</span> <span class="n">n</span><span class="o">.</span>
       <span class="o">-</span> <span class="kp">reflexivity</span><span class="o">.</span> <span class="c">(* 0 = 0 base case *)</span>
       <span class="o">-</span> <span class="k">simpl</span><span class="o">.</span> <span class="k">ring</span> <span class="o">[</span><span class="n">IHn</span><span class="o">].</span> <span class="c">(* induction step *)</span>
<span class="kn">Qed</span><span class="o">.</span>
</pre></div>
<p>With this we have only scratched the surface of Coq. It is a massive
ecosystem with many interesting and peculiar topics leading all the way up
to modern research.</p>

<h2>Further reading</h2>

<ul>
<li><a href="https://coq.inria.fr/refman/">The Coq reference manual</a></li>
<li><a href="https://softwarefoundations.cis.upenn.edu/">Software Foundations</a></li>
<li><a href="http://adam.chlipala.net/cpdt/">Certified Programming with Dependent Types</a></li>
<li><a href="https://math-comp.github.io/mcb/">Mathematical Components</a></li>
<li><a href="http://www.cse.chalmers.se/research/group/logic/TypesSS05/resources/coq/CoqArt/">Coq&#39;Art: The Calculus of Inductive Constructions</a></li>
<li><a href="http://adam.chlipala.net/frap/">FRAP</a></li>
</ul>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/coq.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by Philip Zucker, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/coq.html.markdown">3 contributors</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://www.philipzucker.com/">Philip Zucker</a>
    </p>

    <p>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
