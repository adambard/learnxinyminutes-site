<!DOCTYPE html lang="ja-jp" xml:lang="ja-jp" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="ja-jp">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Julia in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/ja-jp/julia-jp/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fja-jp%2Fjulia-jp%2F&text=X%E3%82%92Y%E5%88%86%E3%81%A7%E5%AD%A6%E3%81%B6%2C+%E3%81%9F%E3%81%A0%E3%81%97+X%3DJulia">
        このページをシェアする
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">外観の選択：</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">ライト</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">ダーク</button>
  </div>
  <h1><a href="/">XをY分で学ぶ</a></h1>
  <h2>ただし X=Julia</h2>
    <p class="filelink">
    ソースコードの取得：
    <a href="/docs/files/learnjulia-jp.jl">learnjulia-jp.jl</a>
    </p>
  <div id="doc">
    <p>Julia は科学技術計算向けに作られた、同図像性を持った(homoiconic) プログラミング言語です。
マクロによる同図像性や第一級関数などの抽象化機能の恩恵を受けつつ、低階層をも扱えますが、
それでいてPython 並に学習しやすく、使いやすい言語となっています。</p>

<p>この文章は、Julia の2013年10月18日現在の開発バージョンを元にしています。</p>
<div class="highlight"><pre class="highlight ruby"><code><span class="c1"># ハッシュ（シャープ）記号から改行までは単一行コメントとなります。</span>
<span class="c1">#= 複数行コメントは、</span>
   <span class="s1">'#='</span> <span class="err">と</span> <span class="s1">'=#'</span> <span class="err">とで囲むことで行えます。</span>
   <span class="c1">#= </span>
   <span class="err">入れ子構造にすることもできます。</span>
   <span class="o">=</span><span class="c1">#</span>
<span class="o">=</span><span class="c1">#</span>

<span class="c1">####################################################</span>
<span class="c1">## 1. 基本的な型と演算子</span>
<span class="c1">####################################################</span>

<span class="c1"># Julia ではすべて式となります。</span>

<span class="c1"># 基本となる数値型がいくつかあります。</span>
<span class="mi">3</span> <span class="c1"># =&gt; 3 (Int64)</span>
<span class="mf">3.2</span> <span class="c1"># =&gt; 3.2 (Float64)</span>
<span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="n">im</span> <span class="c1"># =&gt; 2 + 1im (Complex{Int64})</span>
<span class="mi">2</span><span class="o">/</span><span class="sr">/3 # =&gt; 2/</span><span class="o">/</span><span class="mi">3</span> <span class="p">(</span><span class="no">Rational</span><span class="p">{</span><span class="no">Int64</span><span class="p">})</span>

<span class="c1"># 一般的な中置演算子が使用可能です。</span>
<span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># =&gt; 2</span>
<span class="mi">8</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># =&gt; 7</span>
<span class="mi">10</span> <span class="o">*</span> <span class="mi">2</span> <span class="c1"># =&gt; 20</span>
<span class="mi">35</span> <span class="o">/</span> <span class="mi">5</span> <span class="c1"># =&gt; 7.0</span>
<span class="mi">5</span> <span class="o">/</span> <span class="mi">2</span> <span class="c1"># =&gt; 2.5 # 整数型同士の割り算の結果は、浮動小数点数型になります</span>
<span class="n">div</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># =&gt; 2 # 整数のまま割り算するには、 div を使います</span>
<span class="mi">5</span> <span class="p">\</span> <span class="mi">35</span> <span class="c1"># =&gt; 7.0</span>
<span class="mi">2</span> <span class="o">^</span> <span class="mi">2</span> <span class="c1"># =&gt; 4 # べき乗です。排他的論理和ではありません</span>
<span class="mi">12</span> <span class="o">%</span> <span class="mi">10</span> <span class="c1"># =&gt; 2</span>

<span class="c1"># 丸括弧で演算の優先順位をコントロールできます</span>
<span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="c1"># =&gt; 8</span>

<span class="c1"># ビット演算</span>
<span class="o">~</span><span class="mi">2</span> <span class="c1"># =&gt; -3   # ビット反転</span>
<span class="mi">3</span> <span class="o">&amp;</span> <span class="mi">5</span> <span class="c1"># =&gt; 1 # ビット積</span>
<span class="mi">2</span> <span class="o">|</span> <span class="mi">4</span> <span class="c1"># =&gt; 6 # ビット和</span>
<span class="mi">2</span> <span class="err">$</span> <span class="mi">4</span> <span class="c1"># =&gt; 6 # ビット排他的論理和</span>
<span class="mi">2</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span> <span class="c1"># =&gt; 1 # 右論理シフト</span>
<span class="mi">2</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>  <span class="c1"># =&gt; 1 # 右算術シフト</span>
<span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>  <span class="c1"># =&gt; 4 # 左シフト</span>

<span class="c1"># bits 関数を使うことで、数の二進表現を得られます。</span>
<span class="n">bits</span><span class="p">(</span><span class="mi">12345</span><span class="p">)</span>
<span class="c1"># =&gt; "0000000000000000000000000000000000000000000000000011000000111001"</span>
<span class="n">bits</span><span class="p">(</span><span class="mf">12345.0</span><span class="p">)</span>
<span class="c1"># =&gt; "0100000011001000000111001000000000000000000000000000000000000000"</span>

<span class="c1"># ブール値が用意されています</span>
<span class="kp">true</span>
<span class="kp">false</span>

<span class="c1"># ブール代数</span>
<span class="o">!</span><span class="kp">true</span> <span class="c1"># =&gt; false</span>
<span class="o">!</span><span class="kp">false</span> <span class="c1"># =&gt; true</span>
<span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="c1"># =&gt; true</span>
<span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="c1"># =&gt; false</span>
<span class="mi">1</span> <span class="o">!=</span> <span class="mi">1</span> <span class="c1"># =&gt; false</span>
<span class="mi">2</span> <span class="o">!=</span> <span class="mi">1</span> <span class="c1"># =&gt; true</span>
<span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="c1"># =&gt; true</span>
<span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="c1"># =&gt; false</span>
<span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="c1"># =&gt; true</span>
<span class="mi">2</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="c1"># =&gt; true</span>
<span class="c1"># 比較演算子をつなげることもできます</span>
<span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="c1"># =&gt; true</span>
<span class="mi">2</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="c1"># =&gt; false</span>

<span class="c1"># 文字列は " で作れます</span>
<span class="s2">"This is a string."</span>

<span class="c1"># 文字リテラルは ' で作れます</span>
<span class="s1">'a'</span>

<span class="c1"># 文字列は文字の配列のように添字アクセスできます</span>
<span class="s2">"This is a string"</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># =&gt; 'T' # Julia では添字は 1 から始まります</span>
<span class="c1"># ただし、UTF8 文字列の場合は添字アクセスではうまくいかないので、</span>
<span class="c1"># イテレーションを行ってください(map 関数や for ループなど)</span>

<span class="c1"># $ を使うことで、文字列に変数や、任意の式を埋め込めます。</span>
<span class="s2">"2 + 2 = $(2 + 2)"</span> <span class="c1"># =&gt; "2 + 2 = 4"</span>

<span class="c1"># 他にも、printf マクロを使うことでも変数を埋め込めます。</span>
<span class="vi">@printf</span> <span class="s2">"%d is less than %f"</span> <span class="mf">4.5</span> <span class="mf">5.3</span> <span class="c1"># 5 is less than 5.300000</span>

<span class="c1"># 出力も簡単です</span>
<span class="n">println</span><span class="p">(</span><span class="s2">"I'm Julia. Nice to meet you!"</span><span class="p">)</span>

<span class="c1">####################################################</span>
<span class="c1">## 2. 変数と配列、タプル、集合、辞書</span>
<span class="c1">####################################################</span>

<span class="c1"># 変数の宣言は不要で、いきなり変数に値を代入・束縛できます。</span>
<span class="n">some_var</span> <span class="o">=</span> <span class="mi">5</span> <span class="c1"># =&gt; 5</span>
<span class="n">some_var</span> <span class="c1"># =&gt; 5</span>

<span class="c1"># 値に束縛されていない変数を使おうとするとエラーになります。</span>
<span class="n">try</span>
    <span class="n">some_other_var</span> <span class="c1"># =&gt; ERROR: some_other_var not defined</span>
<span class="kp">catch</span> <span class="n">e</span>
    <span class="n">println</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1"># 変数名は数字や記号以外の文字から始めます。</span>
<span class="c1"># その後は、数字やアンダースコア(_), 感嘆符(!)も使えます。</span>
<span class="no">SomeOtherVar123</span><span class="o">!</span> <span class="o">=</span> <span class="mi">6</span> <span class="c1"># =&gt; 6</span>

<span class="c1"># Unicode 文字も使えます。</span>
<span class="err">☃</span> <span class="o">=</span> <span class="mi">8</span> <span class="c1"># =&gt; 8</span>
<span class="c1"># ギリシャ文字などを使うことで数学的な記法が簡単にかけます。</span>
<span class="mi">2</span> <span class="o">*</span> <span class="err">π</span> <span class="c1"># =&gt; 6.283185307179586</span>

<span class="c1"># Julia における命名習慣について:</span>
<span class="c1">#</span>
<span class="c1"># * 変数名における単語の区切りにはアンダースコアを使っても良いですが、</span>
<span class="c1">#   使わないと読みにくくなる、というわけではない限り、</span>
<span class="c1">#   推奨はされません。</span>
<span class="c1">#</span>
<span class="c1"># * 型名は大文字で始め、単語の区切りにはキャメルケースを使います。</span>
<span class="c1">#</span>
<span class="c1"># * 関数やマクロの名前は小文字で書きます。</span>
<span class="c1">#   単語の分かち書きにはアンダースコアをつかわず、直接つなげます。</span>
<span class="c1">#</span>
<span class="c1"># * 内部で引数を変更する関数は、名前の最後に ! をつけます。</span>
<span class="c1">#   この手の関数は、しばしば「破壊的な関数」とか「in-place な関数」とか呼ばれます。</span>


<span class="c1"># 配列は、1 から始まる整数によって添字付けられる、値の列です。</span>
<span class="n">a</span> <span class="o">=</span> <span class="no">Int64</span><span class="p">[]</span> <span class="c1"># =&gt; 0-element Int64 Array</span>

<span class="c1"># 一次元配列（列ベクトル）は、角括弧 [] のなかにカンマ , 区切りで値を並べることで作ります。</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span> <span class="c1"># =&gt; 3-element Int64 Array: [4, 5, 6]</span>
<span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># =&gt; 4</span>
<span class="n">b</span><span class="p">[</span><span class="k">end</span><span class="p">]</span> <span class="c1"># =&gt; 6</span>

<span class="c1"># 二次元配列は、空白区切りで作った行を、セミコロンで区切ることで作ります。</span>
<span class="n">matrix</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span> <span class="c1"># =&gt; 2x2 Int64 Array: [1 2; 3 4]</span>

<span class="c1"># 配列の末尾に値を追加するには push! を、</span>
<span class="c1"># 他の配列を結合するには append! を使います。</span>
<span class="n">push!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>     <span class="c1"># =&gt; [1]</span>
<span class="n">push!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>     <span class="c1"># =&gt; [1,2]</span>
<span class="n">push!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>     <span class="c1"># =&gt; [1,2,4]</span>
<span class="n">push!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>     <span class="c1"># =&gt; [1,2,4,3]</span>
<span class="n">append!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="c1"># =&gt; [1,2,4,3,4,5,6]</span>

<span class="c1"># 配列の末尾から値を削除するには pop! を使います。</span>
<span class="n">pop!</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>        <span class="c1"># =&gt; 6 and b is now [4,5]</span>

<span class="c1"># 一旦元に戻しておきましょう。</span>
<span class="n">push!</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>   <span class="c1"># b is now [4,5,6] again.</span>

<span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># =&gt; 1 # Julia では添字は0 ではなく1 から始まること、お忘れなく!</span>

<span class="c1"># end は最後の添字を表す速記法です。</span>
<span class="c1"># 添字を書く場所ならどこにでも使えます。</span>
<span class="n">a</span><span class="p">[</span><span class="k">end</span><span class="p">]</span> <span class="c1"># =&gt; 6</span>

<span class="c1"># 先頭に対する削除・追加は shift!, unshift! です。</span>
<span class="n">shift!</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1"># =&gt; 1 and a is now [2,4,3,4,5,6]</span>
<span class="n">unshift!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span> <span class="c1"># =&gt; [7,2,4,3,4,5,6]</span>

<span class="c1"># ! で終わる関数名は、その引数を変更するということを示します。</span>
<span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span> <span class="c1"># =&gt; 3-element Int64 Array: [5,4,6]</span>
<span class="n">sort</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="c1"># =&gt; [4,5,6]; arr is still [5,4,6]</span>
<span class="n">sort!</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="c1"># =&gt; [4,5,6]; arr is now [4,5,6]</span>

<span class="c1"># 配列の範囲外アクセスをすると BoundsError が発生します。</span>
<span class="n">try</span>
    <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># =&gt; ERROR: BoundsError() in getindex at array.jl:270</span>
    <span class="n">a</span><span class="p">[</span><span class="k">end</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># =&gt; ERROR: BoundsError() in getindex at array.jl:270</span>
<span class="kp">catch</span> <span class="n">e</span>
    <span class="n">println</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1"># エラーが発生すると、どのファイルのどの行で発生したかが表示されます。</span>
<span class="c1"># 標準ライブラリで発生したものでもファイル名と行数が出ます。</span>
<span class="c1"># ソースからビルドした場合など、標準ライブラリのソースが手元にある場合は</span>
<span class="c1"># base/ ディレクトリから探し出して見てください。</span>

<span class="c1"># 配列は範囲オブジェクトから作ることもできます。</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="c1"># =&gt; 5-element Int64 Array: [1,2,3,4,5]</span>

<span class="c1"># 添字として範囲オブジェクトを渡すことで、</span>
<span class="c1"># 配列の部分列を得ることもできます。</span>
<span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="c1"># =&gt; [1, 2, 3]</span>
<span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="ss">:end</span><span class="p">]</span> <span class="c1"># =&gt; [2, 3, 4, 5]</span>

<span class="c1"># 添字を用いて配列から値の削除をしたい場合は、splice! を使います。</span>
<span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="n">splice!</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># =&gt; 4 ; arr is now [3,5]</span>

<span class="c1"># 配列の結合は append! です。</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">append!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="c1"># Now a is [1, 2, 3, 4, 5, 1, 2, 3]</span>

<span class="c1"># 配列内に指定した値があるかどうかを調べるのには in を使います。</span>
<span class="k">in</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="c1"># =&gt; true</span>

<span class="c1"># length で配列の長さを取得できます。</span>
<span class="n">length</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1"># =&gt; 8</span>

<span class="c1"># 変更不可能 (immutable) な値の組として、タプルが使えます。</span>
<span class="n">tup</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># =&gt; (1,2,3) # an (Int64,Int64,Int64) tuple.</span>
<span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># =&gt; 1</span>
<span class="ss">try:
    </span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span> <span class="c1"># =&gt; ERROR: no method setindex!((Int64,Int64,Int64),Int64,Int64)</span>
<span class="kp">catch</span> <span class="n">e</span>
    <span class="n">println</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1"># 配列に関する関数の多くが、タプルでも使えます。</span>
<span class="n">length</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span> <span class="c1"># =&gt; 3</span>
<span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># =&gt; (1,2)</span>
<span class="k">in</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">tup</span><span class="p">)</span> <span class="c1"># =&gt; true</span>

<span class="c1"># タプルから値をばらして(unpack して) 複数の変数に代入できます。</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># =&gt; (1,2,3)  # a is now 1, b is now 2 and c is now 3</span>

<span class="c1"># 丸括弧なしでもタプルになります。</span>
<span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span> <span class="c1"># =&gt; (4,5,6)</span>

<span class="c1"># ひとつの値だけからなるタプルは、その値自体とは区別されます。</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">==</span> <span class="mi">1</span> <span class="c1"># =&gt; false</span>
<span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="c1"># =&gt; true</span>

<span class="c1"># 値の交換もタプルを使えば簡単です。</span>
<span class="n">e</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span>  <span class="c1"># =&gt; (5,4) # d is now 5 and e is now 4</span>


<span class="c1"># 辞書 (Dict) は、値から値への変換の集合です。</span>
<span class="n">empty_dict</span> <span class="o">=</span> <span class="no">Dict</span><span class="p">()</span> <span class="c1"># =&gt; Dict{Any,Any}()</span>

<span class="c1"># 辞書型リテラルは次のとおりです。</span>
<span class="n">filled_dict</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"one"</span><span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">"two"</span><span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">"three"</span><span class="o">=&gt;</span> <span class="mi">3</span><span class="p">]</span>
<span class="c1"># =&gt; Dict{ASCIIString,Int64}</span>

<span class="c1"># [] を使ったアクセスができます。</span>
<span class="n">filled_dict</span><span class="p">[</span><span class="s2">"one"</span><span class="p">]</span> <span class="c1"># =&gt; 1</span>

<span class="c1"># すべての鍵（添字）は keys で得られます。</span>
<span class="n">keys</span><span class="p">(</span><span class="n">filled_dict</span><span class="p">)</span>
<span class="c1"># =&gt; KeyIterator{Dict{ASCIIString,Int64}}(["three"=&gt;3,"one"=&gt;1,"two"=&gt;2])</span>
<span class="c1"># 必ずしも辞書に追加した順番には並んでいないことに注意してください。</span>

<span class="c1"># 同様に、values はすべての値を返します。</span>
<span class="n">values</span><span class="p">(</span><span class="n">filled_dict</span><span class="p">)</span>
<span class="c1"># =&gt; ValueIterator{Dict{ASCIIString,Int64}}(["three"=&gt;3,"one"=&gt;1,"two"=&gt;2])</span>
<span class="c1"># 鍵と同様に、必ずしも辞書に追加した順番には並んでいないことに注意してください。</span>

<span class="c1"># in や haskey を使うことで、要素や鍵が辞書の中にあるかを調べられます。</span>
<span class="k">in</span><span class="p">((</span><span class="s2">"one"</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">filled_dict</span><span class="p">)</span> <span class="c1"># =&gt; true</span>
<span class="k">in</span><span class="p">((</span><span class="s2">"two"</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">filled_dict</span><span class="p">)</span> <span class="c1"># =&gt; false</span>
<span class="n">haskey</span><span class="p">(</span><span class="n">filled_dict</span><span class="p">,</span> <span class="s2">"one"</span><span class="p">)</span> <span class="c1"># =&gt; true</span>
<span class="n">haskey</span><span class="p">(</span><span class="n">filled_dict</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># =&gt; false</span>

<span class="c1"># 存在しない鍵を問い合わせると、エラーが発生します。</span>
<span class="n">try</span>
    <span class="n">filled_dict</span><span class="p">[</span><span class="s2">"four"</span><span class="p">]</span> <span class="c1"># =&gt; ERROR: key not found: four in getindex at dict.jl:489</span>
<span class="kp">catch</span> <span class="n">e</span>
    <span class="n">println</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1"># get 関数を使い、鍵がなかった場合のデフォルト値を与えておくことで、</span>
<span class="c1"># このエラーを回避できます。</span>
<span class="n">get</span><span class="p">(</span><span class="n">filled_dict</span><span class="p">,</span><span class="s2">"one"</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="c1"># =&gt; 1</span>
<span class="n">get</span><span class="p">(</span><span class="n">filled_dict</span><span class="p">,</span><span class="s2">"four"</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="c1"># =&gt; 4</span>

<span class="c1"># 集合 (Set) は一意な値の、順序付けられていない集まりです。</span>
<span class="n">empty_set</span> <span class="o">=</span> <span class="no">Set</span><span class="p">()</span> <span class="c1"># =&gt; Set{Any}()</span>
<span class="c1"># 集合の初期化</span>
<span class="n">filled_set</span> <span class="o">=</span> <span class="no">Set</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="c1"># =&gt; Set{Int64}(1,2,3,4)</span>

<span class="c1"># 集合への追加</span>
<span class="n">push!</span><span class="p">(</span><span class="n">filled_set</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span> <span class="c1"># =&gt; Set{Int64}(5,4,2,3,1)</span>

<span class="c1"># in で、値が既に存在するかを調べられます。</span>
<span class="k">in</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">filled_set</span><span class="p">)</span> <span class="c1"># =&gt; true</span>
<span class="k">in</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">filled_set</span><span class="p">)</span> <span class="c1"># =&gt; false</span>

<span class="c1"># 積集合や和集合、差集合を得る関数も用意されています。</span>
<span class="n">other_set</span> <span class="o">=</span> <span class="no">Set</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="c1"># =&gt; Set{Int64}(6,4,5,3)</span>
<span class="n">intersect</span><span class="p">(</span><span class="n">filled_set</span><span class="p">,</span> <span class="n">other_set</span><span class="p">)</span> <span class="c1"># =&gt; Set{Int64}(3,4,5)</span>
<span class="n">union</span><span class="p">(</span><span class="n">filled_set</span><span class="p">,</span> <span class="n">other_set</span><span class="p">)</span> <span class="c1"># =&gt; Set{Int64}(1,2,3,4,5,6)</span>
<span class="n">setdiff</span><span class="p">(</span><span class="no">Set</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span><span class="no">Set</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span> <span class="c1"># =&gt; Set{Int64}(1,4)</span>


<span class="c1">####################################################</span>
<span class="c1">## 3. 制御構文</span>
<span class="c1">####################################################</span>

<span class="c1"># まずは変数を作ります。</span>
<span class="n">some_var</span> <span class="o">=</span> <span class="mi">5</span>

<span class="c1"># if 構文です。Julia ではインデントに意味はありません。</span>
<span class="k">if</span> <span class="n">some_var</span> <span class="o">&gt;</span> <span class="mi">10</span>
    <span class="n">println</span><span class="p">(</span><span class="s2">"some_var is totally bigger than 10."</span><span class="p">)</span>
<span class="n">elseif</span> <span class="n">some_var</span> <span class="o">&lt;</span> <span class="mi">10</span>    <span class="c1"># elseif 節は省略可能です。</span>
    <span class="n">println</span><span class="p">(</span><span class="s2">"some_var is smaller than 10."</span><span class="p">)</span>
<span class="k">else</span>                    <span class="c1"># else 節も省略可能です。</span>
    <span class="n">println</span><span class="p">(</span><span class="s2">"some_var is indeed 10."</span><span class="p">)</span>
<span class="k">end</span>
<span class="c1"># =&gt; "some var is smaller than 10" と出力されます。</span>

<span class="c1"># for ループによって、反復可能なオブジェクトを走査できます。</span>
<span class="c1"># 反復可能なオブジェクトの型として、</span>
<span class="c1"># Range, Array, Set, Dict, String などがあります。</span>
<span class="k">for</span> <span class="n">animal</span><span class="o">=</span><span class="p">[</span><span class="s2">"dog"</span><span class="p">,</span> <span class="s2">"cat"</span><span class="p">,</span> <span class="s2">"mouse"</span><span class="p">]</span>
    <span class="n">println</span><span class="p">(</span><span class="s2">"$animal is a mammal"</span><span class="p">)</span>
    <span class="c1"># $ を使うことで文字列に変数の値を埋め込めます。</span>
    <span class="c1"># You can use $ to interpolate variables or expression into strings</span>
<span class="k">end</span>
<span class="c1"># prints:</span>
<span class="c1">#    dog is a mammal</span>
<span class="c1">#    cat is a mammal</span>
<span class="c1">#    mouse is a mammal</span>

<span class="c1"># for = の代わりに for in を使うこともできます</span>
<span class="k">for</span> <span class="n">animal</span> <span class="k">in</span> <span class="p">[</span><span class="s2">"dog"</span><span class="p">,</span> <span class="s2">"cat"</span><span class="p">,</span> <span class="s2">"mouse"</span><span class="p">]</span>
    <span class="n">println</span><span class="p">(</span><span class="s2">"$animal is a mammal"</span><span class="p">)</span>
<span class="k">end</span>
<span class="c1"># prints:</span>
<span class="c1">#    dog is a mammal</span>
<span class="c1">#    cat is a mammal</span>
<span class="c1">#    mouse is a mammal</span>

<span class="c1"># 辞書ではタプルが返ってきます。</span>
<span class="k">for</span> <span class="n">a</span> <span class="k">in</span> <span class="p">[</span><span class="s2">"dog"</span><span class="o">=&gt;</span><span class="s2">"mammal"</span><span class="p">,</span><span class="s2">"cat"</span><span class="o">=&gt;</span><span class="s2">"mammal"</span><span class="p">,</span><span class="s2">"mouse"</span><span class="o">=&gt;</span><span class="s2">"mammal"</span><span class="p">]</span>
    <span class="n">println</span><span class="p">(</span><span class="s2">"$(a[1]) is a $(a[2])"</span><span class="p">)</span>
<span class="k">end</span>
<span class="c1"># prints:</span>
<span class="c1">#    dog is a mammal</span>
<span class="c1">#    cat is a mammal</span>
<span class="c1">#    mouse is a mammal</span>

<span class="c1"># タプルのアンパック代入もできます。</span>
<span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">in</span> <span class="p">[</span><span class="s2">"dog"</span><span class="o">=&gt;</span><span class="s2">"mammal"</span><span class="p">,</span><span class="s2">"cat"</span><span class="o">=&gt;</span><span class="s2">"mammal"</span><span class="p">,</span><span class="s2">"mouse"</span><span class="o">=&gt;</span><span class="s2">"mammal"</span><span class="p">]</span>
    <span class="n">println</span><span class="p">(</span><span class="s2">"$k is a $v"</span><span class="p">)</span>
<span class="k">end</span>
<span class="c1"># prints:</span>
<span class="c1">#    dog is a mammal</span>
<span class="c1">#    cat is a mammal</span>
<span class="c1">#    mouse is a mammal</span>

<span class="c1"># while ループは、条件式がtrue となる限り実行され続けます。</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">4</span>
    <span class="n">println</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Shorthand for x = x + 1</span>
<span class="k">end</span>
<span class="c1"># prints:</span>
<span class="c1">#   0</span>
<span class="c1">#   1</span>
<span class="c1">#   2</span>
<span class="c1">#   3</span>

<span class="c1"># 例外は try/catch で捕捉できます。</span>
<span class="n">try</span>
   <span class="n">error</span><span class="p">(</span><span class="s2">"help"</span><span class="p">)</span>
<span class="kp">catch</span> <span class="n">e</span>
   <span class="n">println</span><span class="p">(</span><span class="s2">"caught it $e"</span><span class="p">)</span>
<span class="k">end</span>
<span class="c1"># =&gt; caught it ErrorException("help")</span>


<span class="c1">####################################################</span>
<span class="c1">## 4. 関数</span>
<span class="c1">####################################################</span>

<span class="c1"># function キーワードを次のように使うことで、新しい関数を定義できます。</span>
<span class="c1">#function name(arglist)</span>
<span class="c1">#  body...</span>
<span class="c1">#end</span>
<span class="n">function</span> <span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">println</span><span class="p">(</span><span class="s2">"x is $x and y is $y"</span><span class="p">)</span>

    <span class="c1"># 最後に評価された式の値が、関数全体の返り値となります。</span>
    <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="k">end</span>

<span class="n">add</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="c1"># =&gt; 11 after printing out "x is 5 and y is 6"</span>

<span class="c1"># 可変長引数関数も定義できます。</span>
<span class="n">function</span> <span class="n">varargs</span><span class="p">(</span><span class="n">args</span><span class="o">...</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">args</span>
    <span class="c1"># return キーワードを使うことで、好きな位置で関数から抜けられます。</span>
<span class="k">end</span>
<span class="c1"># =&gt; varargs (generic function with 1 method)</span>

<span class="n">varargs</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># =&gt; (1,2,3)</span>

<span class="c1"># ... はsplat と呼ばれます</span>
<span class="c1"># （訳注：「ピシャッという音（名詞）」「衝撃で平らにする（動詞）」）</span>
<span class="c1"># 今回は関数定義で使いましたが、関数呼び出しに使うこともできます。</span>
<span class="c1"># その場合、配列やタプルの要素を開いて、複数の引数へと割り当てることとなります。</span>
<span class="no">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>    <span class="c1"># =&gt; Set{Array{Int64,1}}([1,2,3]) # 「整数の配列」の集合</span>
<span class="no">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">...</span><span class="p">)</span> <span class="c1"># =&gt; Set{Int64}(1,2,3) # 整数の集合</span>

<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>     <span class="c1"># =&gt; (1,2,3)</span>
<span class="no">Set</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>          <span class="c1"># =&gt; Set{(Int64,Int64,Int64)}((1,2,3)) # タプルの集合</span>
<span class="no">Set</span><span class="p">(</span><span class="n">x</span><span class="o">...</span><span class="p">)</span>       <span class="c1"># =&gt; Set{Int64}(2,3,1)</span>


<span class="c1"># 引数に初期値を与えることで、オプション引数をもった関数を定義できます。</span>
<span class="n">function</span> <span class="n">defaults</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
    <span class="k">return</span> <span class="s2">"$a $b and $x $y"</span>
<span class="k">end</span>

<span class="n">defaults</span><span class="p">(</span><span class="s1">'h'</span><span class="p">,</span><span class="s1">'g'</span><span class="p">)</span> <span class="c1"># =&gt; "h g and 5 6"</span>
<span class="n">defaults</span><span class="p">(</span><span class="s1">'h'</span><span class="p">,</span><span class="s1">'g'</span><span class="p">,</span><span class="s1">'j'</span><span class="p">)</span> <span class="c1"># =&gt; "h g and j 6"</span>
<span class="n">defaults</span><span class="p">(</span><span class="s1">'h'</span><span class="p">,</span><span class="s1">'g'</span><span class="p">,</span><span class="s1">'j'</span><span class="p">,</span><span class="s1">'k'</span><span class="p">)</span> <span class="c1"># =&gt; "h g and j k"</span>
<span class="n">try</span>
    <span class="n">defaults</span><span class="p">(</span><span class="s1">'h'</span><span class="p">)</span> <span class="c1"># =&gt; ERROR: no method defaults(Char,)</span>
    <span class="n">defaults</span><span class="p">()</span> <span class="c1"># =&gt; ERROR: no methods defaults()</span>
<span class="kp">catch</span> <span class="n">e</span>
    <span class="n">println</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1"># キーワード引数を持った関数も作れます。</span>
<span class="n">function</span> <span class="n">keyword_args</span><span class="p">(;</span><span class="n">k1</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span><span class="n">name2</span><span class="o">=</span><span class="s2">"hello"</span><span class="p">)</span> <span class="c1"># ; が必要なことに注意</span>
    <span class="k">return</span> <span class="p">[</span><span class="s2">"k1"</span><span class="o">=&gt;</span><span class="n">k1</span><span class="p">,</span><span class="s2">"name2"</span><span class="o">=&gt;</span><span class="n">name2</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">keyword_args</span><span class="p">(</span><span class="n">name2</span><span class="o">=</span><span class="s2">"ness"</span><span class="p">)</span> <span class="c1"># =&gt; ["name2"=&gt;"ness","k1"=&gt;4]</span>
<span class="n">keyword_args</span><span class="p">(</span><span class="n">k1</span><span class="o">=</span><span class="s2">"mine"</span><span class="p">)</span> <span class="c1"># =&gt; ["k1"=&gt;"mine","name2"=&gt;"hello"]</span>
<span class="n">keyword_args</span><span class="p">()</span> <span class="c1"># =&gt; ["name2"=&gt;"hello","k1"=&gt;4]</span>

<span class="c1"># もちろん、これらを組み合わせることもできます。</span>
<span class="n">function</span> <span class="n">all_the_args</span><span class="p">(</span><span class="n">normal_arg</span><span class="p">,</span> <span class="n">optional_positional_arg</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span> <span class="n">keyword_arg</span><span class="o">=</span><span class="s2">"foo"</span><span class="p">)</span>
    <span class="n">println</span><span class="p">(</span><span class="s2">"normal arg: $normal_arg"</span><span class="p">)</span>
    <span class="n">println</span><span class="p">(</span><span class="s2">"optional arg: $optional_positional_arg"</span><span class="p">)</span>
    <span class="n">println</span><span class="p">(</span><span class="s2">"keyword arg: $keyword_arg"</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">all_the_args</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">keyword_arg</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="c1"># prints:</span>
<span class="c1">#   normal arg: 1</span>
<span class="c1">#   optional arg: 3</span>
<span class="c1">#   keyword arg: 4</span>

<span class="c1"># Julia では関数は第一級関数として、値として扱われます。</span>
<span class="n">function</span> <span class="n">create_adder</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">adder</span> <span class="o">=</span> <span class="n">function</span> <span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
    <span class="k">end</span>
    <span class="k">return</span> <span class="n">adder</span>
<span class="k">end</span>

<span class="c1"># ラムダ式によって無名関数をつくれます。</span>
<span class="p">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)(</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># =&gt; true</span>

<span class="c1"># 先ほどの create_adder と同じもの</span>
<span class="n">function</span> <span class="n">create_adder</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="k">end</span>

<span class="c1"># 中の関数に名前をつけても構いません。</span>
<span class="n">function</span> <span class="n">create_adder</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">function</span> <span class="n">adder</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
    <span class="k">end</span>
    <span class="n">adder</span>
<span class="k">end</span>

<span class="n">add_10</span> <span class="o">=</span> <span class="n">create_adder</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">add_10</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># =&gt; 13</span>


<span class="c1"># いくつかの高階関数が定義されています。</span>
<span class="n">map</span><span class="p">(</span><span class="n">add_10</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> <span class="c1"># =&gt; [11, 12, 13]</span>
<span class="n">filter</span><span class="p">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span> <span class="c1"># =&gt; [6, 7]</span>

<span class="c1"># map の代わりとしてリスト内包表記も使えます。</span>
<span class="p">[</span><span class="n">add_10</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span> <span class="c1"># =&gt; [11, 12, 13]</span>
<span class="p">[</span><span class="n">add_10</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span> <span class="c1"># =&gt; [11, 12, 13]</span>

<span class="c1">####################################################</span>
<span class="c1">## 5. 型</span>
<span class="c1">####################################################</span>

<span class="c1"># Julia ではすべての値にひとつの型がついています。</span>
<span class="c1"># 変数に、ではなくて値に、です。</span>
<span class="c1"># typeof 関数を使うことで、値が持つ型を取得できます。</span>
<span class="n">typeof</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1"># =&gt; Int64</span>

<span class="c1"># 型自身もまた、第一級の値であり、型を持っています。</span>
<span class="n">typeof</span><span class="p">(</span><span class="no">Int64</span><span class="p">)</span> <span class="c1"># =&gt; DataType</span>
<span class="n">typeof</span><span class="p">(</span><span class="no">DataType</span><span class="p">)</span> <span class="c1"># =&gt; DataType</span>
<span class="c1"># DataType は型を表現する型であり、DataType 自身もDataType 型の値です。</span>

<span class="c1"># 型はドキュメント化や最適化、関数ディスパッチのために使われます。</span>
<span class="c1"># 静的な型チェックは行われません。</span>

<span class="c1"># 自分で新しい型を定義することもできます。</span>
<span class="c1"># 他の言語で言う、構造体やレコードに近いものになっています。</span>
<span class="c1"># 型定義には type キーワードを使います。</span>
<span class="c1"># type Name</span>
<span class="c1">#   field::OptionalType</span>
<span class="c1">#   ...</span>
<span class="c1"># end</span>
<span class="n">type</span> <span class="no">Tiger</span>
  <span class="n">taillength</span><span class="o">::</span><span class="no">Float64</span>
  <span class="n">coatcolor</span> <span class="c1"># 型注釈を省略した場合、自動的に :: Any として扱われます。</span>
<span class="k">end</span>

<span class="c1"># 型を定義すると、その型のプロパティすべてを、定義した順番に</span>
<span class="c1"># 引数として持つデフォルトコンストラクタが自動的に作られます。</span>
<span class="n">tigger</span> <span class="o">=</span> <span class="no">Tiger</span><span class="p">(</span><span class="mf">3.5</span><span class="p">,</span><span class="s2">"orange"</span><span class="p">)</span> <span class="c1"># =&gt; Tiger(3.5,"orange")</span>

<span class="c1"># 型名がそのままコンストラクタ名（関数名）となります。</span>
<span class="n">sherekhan</span> <span class="o">=</span> <span class="n">typeof</span><span class="p">(</span><span class="n">tigger</span><span class="p">)(</span><span class="mf">5.6</span><span class="p">,</span><span class="s2">"fire"</span><span class="p">)</span> <span class="c1"># =&gt; Tiger(5.6,"fire")</span>

<span class="c1"># このような、構造体スタイルの型は、具体型(concrete type)と呼ばれます。</span>
<span class="c1"># 具体型はインスタンス化可能ですが、派生型(subtype)を持つことができません。</span>
<span class="c1"># 具体型の他には抽象型(abstract type)があります。</span>

<span class="c1"># abstract Name</span>
<span class="n">abstract</span> <span class="no">Cat</span> <span class="c1"># 型の階層図の途中の一点を指し示す名前となります。</span>

<span class="c1"># 抽象型はインスタンス化できませんが、派生型を持つことができます。</span>
<span class="c1"># 例えば、 Number は以下の派生型を持つ抽象型です。</span>
<span class="n">subtypes</span><span class="p">(</span><span class="no">Number</span><span class="p">)</span> <span class="c1"># =&gt; 6-element Array{Any,1}:</span>
                 <span class="c1">#     Complex{Float16}</span>
                 <span class="c1">#     Complex{Float32}</span>
                 <span class="c1">#     Complex{Float64}</span>
                 <span class="c1">#     Complex{T&lt;:Real}</span>
                 <span class="c1">#     ImaginaryUnit</span>
                 <span class="c1">#     Real</span>
<span class="n">subtypes</span><span class="p">(</span><span class="no">Cat</span><span class="p">)</span> <span class="c1"># =&gt; 0-element Array{Any,1}</span>

<span class="c1"># すべての型は、直接的にはただひとつの基本型(supertype) を持ちます。</span>
<span class="c1"># super 関数でこれを取得可能です。</span>
<span class="n">typeof</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1"># =&gt; Int64</span>
<span class="k">super</span><span class="p">(</span><span class="no">Int64</span><span class="p">)</span> <span class="c1"># =&gt; Signed</span>
<span class="k">super</span><span class="p">(</span><span class="no">Signed</span><span class="p">)</span> <span class="c1"># =&gt; Real</span>
<span class="k">super</span><span class="p">(</span><span class="no">Real</span><span class="p">)</span> <span class="c1"># =&gt; Number</span>
<span class="k">super</span><span class="p">(</span><span class="no">Number</span><span class="p">)</span> <span class="c1"># =&gt; Any</span>
<span class="k">super</span><span class="p">(</span><span class="k">super</span><span class="p">(</span><span class="no">Signed</span><span class="p">))</span> <span class="c1"># =&gt; Number</span>
<span class="k">super</span><span class="p">(</span><span class="no">Any</span><span class="p">)</span> <span class="c1"># =&gt; Any</span>
<span class="c1"># Int64 を除き、これらはすべて抽象型です。</span>

<span class="c1"># &lt;: は派生形を表す演算子です。</span>
<span class="c1"># これを使うことで派生型を定義できます。</span>
<span class="n">type</span> <span class="no">Lion</span> <span class="o">&lt;</span><span class="p">:</span> <span class="no">Cat</span> <span class="c1"># Lion は 抽象型 Cat の派生型</span>
  <span class="n">mane_color</span>
  <span class="n">roar</span><span class="o">::</span><span class="no">String</span>
<span class="k">end</span>

<span class="c1"># 型名と同じ名前の関数を定義し、既に存在するコンストラクタを呼び出して、</span>
<span class="c1"># 必要とする型の値を返すことによって、</span>
<span class="c1"># デフォルトコンストラクタ以外のコンストラクタを作ることができます。</span>

<span class="no">Lion</span><span class="p">(</span><span class="n">roar</span><span class="o">::</span><span class="no">String</span><span class="p">)</span> <span class="o">=</span> <span class="no">Lion</span><span class="p">(</span><span class="s2">"green"</span><span class="p">,</span><span class="n">roar</span><span class="p">)</span>
<span class="c1"># 型定義の外側で定義されたコンストラクタなので、外部コンストラクタと呼ばれます。</span>

<span class="n">type</span> <span class="no">Panther</span> <span class="o">&lt;</span><span class="p">:</span> <span class="no">Cat</span> <span class="c1"># Panther も Cat の派生型</span>
  <span class="n">eye_color</span>
  <span class="no">Panther</span><span class="p">()</span> <span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="s2">"green"</span><span class="p">)</span>
  <span class="c1"># Panther は内部コンストラクタとしてこれのみを持ち、</span>
  <span class="c1"># デフォルトコンストラクタを持たない</span>
<span class="k">end</span>
<span class="c1"># 内部コンストラクタを使うことで、どのような値が作られるのかをコントロールすることができます。</span>
<span class="c1"># 出来る限り、外部コンストラクタを使うべきです。</span>

<span class="c1">####################################################</span>
<span class="c1">## 6. 多重ディスパッチ</span>
<span class="c1">####################################################</span>

<span class="c1"># Julia では、すべての名前付きの関数は総称的関数(generic function) です。</span>
<span class="c1"># これは、関数はいくつかの細かいメソッドの集合である、という意味です。</span>
<span class="c1"># 例えば先の Lion 型のコンストラクタ Lion は、Lion という関数の1つのメソッドです。</span>

<span class="c1"># コンストラクタ以外の例をみるために、新たに meow 関数を作りましょう。</span>

<span class="c1"># Lion, Panther, Tiger 型それぞれに対する meow 関数のメソッド定義</span>
<span class="n">function</span> <span class="n">meow</span><span class="p">(</span><span class="n">animal</span><span class="o">::</span><span class="no">Lion</span><span class="p">)</span>
  <span class="n">animal</span><span class="p">.</span><span class="nf">roar</span> <span class="c1"># 型のプロパティには . でアクセスできます。</span>
<span class="k">end</span>

<span class="n">function</span> <span class="n">meow</span><span class="p">(</span><span class="n">animal</span><span class="o">::</span><span class="no">Panther</span><span class="p">)</span>
  <span class="s2">"grrr"</span>
<span class="k">end</span>

<span class="n">function</span> <span class="n">meow</span><span class="p">(</span><span class="n">animal</span><span class="o">::</span><span class="no">Tiger</span><span class="p">)</span>
  <span class="s2">"rawwwr"</span>
<span class="k">end</span>

<span class="c1"># meow 関数の実行</span>
<span class="n">meow</span><span class="p">(</span><span class="n">tigger</span><span class="p">)</span> <span class="c1"># =&gt; "rawwr"</span>
<span class="n">meow</span><span class="p">(</span><span class="no">Lion</span><span class="p">(</span><span class="s2">"brown"</span><span class="p">,</span><span class="s2">"ROAAR"</span><span class="p">))</span> <span class="c1"># =&gt; "ROAAR"</span>
<span class="n">meow</span><span class="p">(</span><span class="no">Panther</span><span class="p">())</span> <span class="c1"># =&gt; "grrr"</span>

<span class="c1"># 型の階層関係を見てみましょう</span>
<span class="n">issubtype</span><span class="p">(</span><span class="no">Tiger</span><span class="p">,</span><span class="no">Cat</span><span class="p">)</span> <span class="c1"># =&gt; false</span>
<span class="n">issubtype</span><span class="p">(</span><span class="no">Lion</span><span class="p">,</span><span class="no">Cat</span><span class="p">)</span> <span class="c1"># =&gt; true</span>
<span class="n">issubtype</span><span class="p">(</span><span class="no">Panther</span><span class="p">,</span><span class="no">Cat</span><span class="p">)</span> <span class="c1"># =&gt; true</span>

<span class="c1"># 抽象型 Cat の派生型を引数にとる関数</span>
<span class="n">function</span> <span class="n">pet_cat</span><span class="p">(</span><span class="n">cat</span><span class="o">::</span><span class="no">Cat</span><span class="p">)</span>
  <span class="n">println</span><span class="p">(</span><span class="s2">"The cat says $(meow(cat))"</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">pet_cat</span><span class="p">(</span><span class="no">Lion</span><span class="p">(</span><span class="s2">"42"</span><span class="p">))</span> <span class="c1"># =&gt; prints "The cat says 42"</span>
<span class="n">try</span>
    <span class="n">pet_cat</span><span class="p">(</span><span class="n">tigger</span><span class="p">)</span> <span class="c1"># =&gt; ERROR: no method pet_cat(Tiger,)</span>
<span class="kp">catch</span> <span class="n">e</span>
    <span class="n">println</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1"># オブジェクト指向言語では、一般的にシングルディスパッチが用いられます。</span>
<span class="c1"># つまり、関数に複数あるメソッドのうちにどれが呼ばれるかは、</span>
<span class="c1"># その第一引数（もしくは、 . や -&gt; の前にある値の型）によってのみ決定されます。</span>
<span class="c1"># 一方でJulia では、すべての引数の型が、このメソッド決定に寄与します。</span>

<span class="c1"># 多変数関数を定義して、この辺りを見て行きましょう。</span>
<span class="n">function</span> <span class="n">fight</span><span class="p">(</span><span class="n">t</span><span class="o">::</span><span class="no">Tiger</span><span class="p">,</span><span class="n">c</span><span class="o">::</span><span class="no">Cat</span><span class="p">)</span>
  <span class="n">println</span><span class="p">(</span><span class="s2">"The $(t.coatcolor) tiger wins!"</span><span class="p">)</span>
<span class="k">end</span>
<span class="c1"># =&gt; fight (generic function with 1 method)</span>

<span class="n">fight</span><span class="p">(</span><span class="n">tigger</span><span class="p">,</span><span class="no">Panther</span><span class="p">())</span> <span class="c1"># =&gt; prints The orange tiger wins!</span>
<span class="n">fight</span><span class="p">(</span><span class="n">tigger</span><span class="p">,</span><span class="no">Lion</span><span class="p">(</span><span class="s2">"ROAR"</span><span class="p">))</span> <span class="c1"># =&gt; prints The orange tiger wins!</span>

<span class="c1"># 第二引数の Cat が実際は Lion だった時に、挙動が変わるようにします。</span>
<span class="n">fight</span><span class="p">(</span><span class="n">t</span><span class="o">::</span><span class="no">Tiger</span><span class="p">,</span><span class="n">l</span><span class="o">::</span><span class="no">Lion</span><span class="p">)</span> <span class="o">=</span> <span class="n">println</span><span class="p">(</span><span class="s2">"The $(l.mane_color)-maned lion wins!"</span><span class="p">)</span>
<span class="c1"># =&gt; fight (generic function with 2 methods)</span>

<span class="n">fight</span><span class="p">(</span><span class="n">tigger</span><span class="p">,</span><span class="no">Panther</span><span class="p">())</span> <span class="c1"># =&gt; prints The orange tiger wins!</span>
<span class="n">fight</span><span class="p">(</span><span class="n">tigger</span><span class="p">,</span><span class="no">Lion</span><span class="p">(</span><span class="s2">"ROAR"</span><span class="p">))</span> <span class="c1"># =&gt; prints The green-maned lion wins!</span>

<span class="c1"># 別に Tiger だけが戦う必要もないですね。</span>
<span class="n">fight</span><span class="p">(</span><span class="n">l</span><span class="o">::</span><span class="no">Lion</span><span class="p">,</span><span class="n">c</span><span class="o">::</span><span class="no">Cat</span><span class="p">)</span> <span class="o">=</span> <span class="n">println</span><span class="p">(</span><span class="s2">"The victorious cat says $(meow(c))"</span><span class="p">)</span>
<span class="c1"># =&gt; fight (generic function with 3 methods)</span>

<span class="n">fight</span><span class="p">(</span><span class="no">Lion</span><span class="p">(</span><span class="s2">"balooga!"</span><span class="p">),</span><span class="no">Panther</span><span class="p">())</span> <span class="c1"># =&gt; prints The victorious cat says grrr</span>
<span class="n">try</span>
  <span class="n">fight</span><span class="p">(</span><span class="no">Panther</span><span class="p">(),</span><span class="no">Lion</span><span class="p">(</span><span class="s2">"RAWR"</span><span class="p">))</span> <span class="c1"># =&gt; ERROR: no method fight(Panther,Lion)</span>
<span class="kp">catch</span>
<span class="k">end</span>

<span class="c1"># 第一引数にも Cat を許しましょう。</span>
<span class="n">fight</span><span class="p">(</span><span class="n">c</span><span class="o">::</span><span class="no">Cat</span><span class="p">,</span><span class="n">l</span><span class="o">::</span><span class="no">Lion</span><span class="p">)</span> <span class="o">=</span> <span class="n">println</span><span class="p">(</span><span class="s2">"The cat beats the Lion"</span><span class="p">)</span>
<span class="c1"># =&gt; Warning: New definition</span>
<span class="c1">#    fight(Cat,Lion) at none:1</span>
<span class="c1"># is ambiguous with</span>
<span class="c1">#    fight(Lion,Cat) at none:2.</span>
<span class="c1"># Make sure</span>
<span class="c1">#    fight(Lion,Lion)</span>
<span class="c1"># is defined first.</span>
<span class="c1">#fight (generic function with 4 methods)</span>

<span class="c1"># 警告が出ましたが、これは次の対戦で何が起きるのかが不明瞭だからです。</span>
<span class="n">fight</span><span class="p">(</span><span class="no">Lion</span><span class="p">(</span><span class="s2">"RAR"</span><span class="p">),</span><span class="no">Lion</span><span class="p">(</span><span class="s2">"brown"</span><span class="p">,</span><span class="s2">"rarrr"</span><span class="p">))</span> <span class="c1"># =&gt; prints The victorious cat says rarrr</span>
<span class="c1"># Julia のバージョンによっては、結果が違うかもしれません。</span>

<span class="n">fight</span><span class="p">(</span><span class="n">l</span><span class="o">::</span><span class="no">Lion</span><span class="p">,</span><span class="n">l2</span><span class="o">::</span><span class="no">Lion</span><span class="p">)</span> <span class="o">=</span> <span class="n">println</span><span class="p">(</span><span class="s2">"The lions come to a tie"</span><span class="p">)</span>
<span class="n">fight</span><span class="p">(</span><span class="no">Lion</span><span class="p">(</span><span class="s2">"RAR"</span><span class="p">),</span><span class="no">Lion</span><span class="p">(</span><span class="s2">"brown"</span><span class="p">,</span><span class="s2">"rarrr"</span><span class="p">))</span> <span class="c1"># =&gt; prints The lions come to a tie</span>


<span class="c1"># Julia が生成する LLVM 内部表現や、アセンブリを調べることもできます。</span>

<span class="n">square_area</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">=</span> <span class="n">l</span> <span class="o">*</span> <span class="n">l</span>      <span class="c1"># square_area (generic function with 1 method)</span>

<span class="n">square_area</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1">#25</span>

<span class="c1"># square_area に整数を渡すと何が起きる？</span>
<span class="n">code_native</span><span class="p">(</span><span class="n">square_area</span><span class="p">,</span> <span class="p">(</span><span class="no">Int32</span><span class="p">,))</span>  
    <span class="c1">#       .section    __TEXT,__text,regular,pure_instructions</span>
    <span class="c1">#   Filename: none</span>
    <span class="c1">#   Source line: 1              # Prologue</span>
    <span class="c1">#       push    RBP</span>
    <span class="c1">#       mov RBP, RSP</span>
    <span class="c1">#   Source line: 1</span>
    <span class="c1">#       movsxd  RAX, EDI        # l を取得</span>
    <span class="c1">#       imul    RAX, RAX        # l*l を計算して RAX に入れる</span>
    <span class="c1">#       pop RBP                 # Base Pointer を元に戻す</span>
    <span class="c1">#       ret                     # 終了。RAX の中身が結果</span>

<span class="n">code_native</span><span class="p">(</span><span class="n">square_area</span><span class="p">,</span> <span class="p">(</span><span class="no">Float32</span><span class="p">,))</span>
    <span class="c1">#       .section    __TEXT,__text,regular,pure_instructions</span>
    <span class="c1">#   Filename: none</span>
    <span class="c1">#   Source line: 1</span>
    <span class="c1">#       push    RBP</span>
    <span class="c1">#       mov RBP, RSP</span>
    <span class="c1">#   Source line: 1</span>
    <span class="c1">#       vmulss  XMM0, XMM0, XMM0  # 単精度浮動小数点数演算 (AVX)</span>
    <span class="c1">#       pop RBP</span>
    <span class="c1">#       ret</span>

<span class="n">code_native</span><span class="p">(</span><span class="n">square_area</span><span class="p">,</span> <span class="p">(</span><span class="no">Float64</span><span class="p">,))</span>
    <span class="c1">#       .section    __TEXT,__text,regular,pure_instructions</span>
    <span class="c1">#   Filename: none</span>
    <span class="c1">#   Source line: 1</span>
    <span class="c1">#       push    RBP</span>
    <span class="c1">#       mov RBP, RSP</span>
    <span class="c1">#   Source line: 1</span>
    <span class="c1">#       vmulsd  XMM0, XMM0, XMM0 # 倍精度浮動小数点数演算 (AVX)</span>
    <span class="c1">#       pop RBP</span>
    <span class="c1">#       ret</span>
    <span class="c1">#   </span>

<span class="c1"># Julia では、浮動小数点数と整数との演算では</span>
<span class="c1"># 自動的に浮動小数点数用の命令が生成されることに注意してください。</span>
<span class="c1"># 円の面積を計算してみましょう。</span>
<span class="n">circle_area</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">r</span>     <span class="c1"># circle_area (generic function with 1 method)</span>
<span class="n">circle_area</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>                  <span class="c1"># 78.53981633974483</span>

<span class="n">code_native</span><span class="p">(</span><span class="n">circle_area</span><span class="p">,</span> <span class="p">(</span><span class="no">Int32</span><span class="p">,))</span>
    <span class="c1">#       .section    __TEXT,__text,regular,pure_instructions</span>
    <span class="c1">#   Filename: none</span>
    <span class="c1">#   Source line: 1</span>
    <span class="c1">#       push    RBP</span>
    <span class="c1">#       mov RBP, RSP</span>
    <span class="c1">#   Source line: 1</span>
    <span class="c1">#       vcvtsi2sd   XMM0, XMM0, EDI          # Load integer (r) from memory</span>
    <span class="c1">#       movabs  RAX, 4593140240              # Load pi</span>
    <span class="c1">#       vmulsd  XMM1, XMM0, QWORD PTR [RAX]  # pi * r</span>
    <span class="c1">#       vmulsd  XMM0, XMM0, XMM1             # (pi * r) * r</span>
    <span class="c1">#       pop RBP</span>
    <span class="c1">#       ret</span>
    <span class="c1">#</span>

<span class="n">code_native</span><span class="p">(</span><span class="n">circle_area</span><span class="p">,</span> <span class="p">(</span><span class="no">Float64</span><span class="p">,))</span>
    <span class="c1">#       .section    __TEXT,__text,regular,pure_instructions</span>
    <span class="c1">#   Filename: none</span>
    <span class="c1">#   Source line: 1</span>
    <span class="c1">#       push    RBP</span>
    <span class="c1">#       mov RBP, RSP</span>
    <span class="c1">#       movabs  RAX, 4593140496</span>
    <span class="c1">#   Source line: 1</span>
    <span class="c1">#       vmulsd  XMM1, XMM0, QWORD PTR [RAX]</span>
    <span class="c1">#       vmulsd  XMM0, XMM1, XMM0</span>
    <span class="c1">#       pop RBP</span>
    <span class="c1">#       ret</span>
    <span class="c1">#   </span>
</code></pre></div>
<h2>より勉強するために</h2>

<p><a href="http://docs.julialang.org/en/latest/manual/">公式ドキュメント</a> (英語)にはより詳細な解説が記されています。</p>

<p>Julia に関して助けが必要ならば、<a href="https://groups.google.com/forum/#!forum/julia-users">メーリングリスト</a> が役に立ちます。
みんな非常に親密に教えてくれます。</p>

    <hr>
    <p>提案がありますか？それとも修正が必要ですか？ Githubレポジトリで<a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Issueを開く</a>か自分で<a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/ja-jp/julia-jp.html.markdown">プルリクエスト</a>を作ってください。
    </p>
    <p class="contributed">
    Leah Hansonが初めて貢献し、後に<a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/ja-jp/julia-jp.html.markdown">0人の貢献者</a>が更新してきました。
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://leahhanson.us">Leah Hanson</a>
    </p>

    <p>
      Translated by:
        <a href="https://github.com/yomichi">Yuichi Motoyama</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
