<!DOCTYPE html lang="el-gr" xml:lang="el-gr" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="el-gr">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn racket in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/el-gr/racket-gr/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fel-gr%2Fracket-gr%2F&text=%CE%9C%CE%AC%CE%B8%CE%B5%CF%84%CE%B5+%CE%A7+%CF%83%CE%B5+%CE%A5+%CE%BB%CE%B5%CF%80%CF%84%CE%AC%2C+%CF%8C%CF%80%CE%BF%CF%85+X%3Dracket">
        Μοιραστείτε αυτή τη σελίδα
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Διαλέξτε θέμα:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">φωτεινό</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">σκοτεινό</button>
  </div>
  <h1><a href="/">Μάθετε Χ σε Υ λεπτά</a></h1>
  <h2>Όπου X=racket</h2>
    <p class="filelink">
    Αποκτήστε τον κώδικα:
    <a href="/docs/files/learnracket-gr.rkt">learnracket-gr.rkt</a>
    </p>
  <div id="doc">
    <p>H Racket είναι μια γενικού σκοπού, πολυ-υποδειγματική γλώσσα προγραμματισμού που ανήκει 
στην οικογένεια της Lisp/Scheme</p>
<div class="highlight"><pre class="highlight racket"><code><span class="o">#</span><span class="nv">lang</span> <span class="nv">racket</span> <span class="c1">; ορίζει την γλώσσα που χρησιμοποιόυμε</span>

<span class="c1">;;; Σχόλια</span>

<span class="c1">;; Τα σχόλια μιας γραμμής ξεκινούν με ερωτηματικό</span>

<span class="cm">#| Τα σχόλια ολόκληρου μπλόκ
   μπορούν να εκτείνονται σε πολλές γραμμές και...
    #|
       μπορούν να είναι εμφωλευμένα!
    |#
|#</span>

<span class="c1">;; Τα σχόλια S-expression (εκφράσεις S) comments απορρίπτουν την</span>
<span class="c1">;; έκφραση που ακολουθεί, δυνατότητα που είναι χρήσιμη για να</span>
<span class="c1">;; κάνουμε σχόλια κάποιες εκφράσεις κατά τη διάρκεια του debugging</span>

<span class="cm">#;</span> <span class="p">(</span><span class="nf">αυτή</span> <span class="nv">η</span> <span class="nv">έκφραση</span> <span class="nv">δεν</span> <span class="nv">θα</span> <span class="nv">εκτελεστεί</span><span class="p">)</span>

<span class="c1">;; (Αν δεν καταλαβαίνεται τι είναι οι εκφράσεις , περιμένετε... Θα το μάθουμε</span>
<span class="c1">;; πολύ σύντομα!)</span>


<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; 1. Πρωτογενείς τύποι μεταβλητών και τελεστές</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;;; Αριθμοί</span>
<span class="mi">9999999999999999999999</span> <span class="c1">; ακέραιοι</span>
<span class="mb">#b111</span>                  <span class="c1">; δυαδικοί =&gt; 7</span>
<span class="mo">#o111</span>                  <span class="c1">; οκταδικοί =&gt; 73</span>
<span class="mh">#x111</span>                  <span class="c1">; δεκαεξαδικοί =&gt; 273</span>
<span class="mf">3.14</span>                   <span class="c1">; πραγματικοί</span>
<span class="mf">6.02</span><span class="nv">e+23</span>
<span class="mi">1</span><span class="nv">/2</span>                    <span class="c1">; ρητοί</span>
<span class="mi">1</span><span class="nv">+2i</span>                   <span class="c1">; μιγαδικοί</span>

<span class="c1">;; Οι μορφή των συναρτήσεων είναι (f x y z)</span>
<span class="c1">;; όπου το f είναι η συνάρτηση και τα x y z</span>
<span class="c1">;; είναι οι όροι που η συνάρτηση δέχεται</span>
<span class="c1">;; ως ορίσματα. Αν θέλουμε να δημιουργήσουμε</span>
<span class="c1">;; μια λίστα στην κυριολεξία από δίαφορα δεδομένα,</span>
<span class="c1">;; χρησιμοποιούμε το ' για να το εμποδίσουμε από το να</span>
<span class="c1">;; αξιολογηθεί σαν έκφραση. Για παράδειγμα:</span>
<span class="o">'</span><span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">; =&gt; Παραμένει (+ 1 2) και δεν γίνεται η πράξη</span>
<span class="c1">;; Τώρα , ας κάνουμε μερικές πράξεις</span>
<span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1">; =&gt; 2</span>
<span class="p">(</span><span class="nb">-</span> <span class="mi">8</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1">; =&gt; 7</span>
<span class="p">(</span><span class="nb">*</span> <span class="mi">10</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">; =&gt; 20</span>
<span class="p">(</span><span class="nb">expt</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; =&gt; 8</span>
<span class="p">(</span><span class="nb">quotient</span> <span class="mi">5</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">; =&gt; 2</span>
<span class="p">(</span><span class="nb">remainder</span> <span class="mi">5</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">; =&gt; 1</span>
<span class="p">(</span><span class="nb">/</span> <span class="mi">35</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">; =&gt; 7</span>
<span class="p">(</span><span class="nb">/</span> <span class="mi">1</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; =&gt; 1/3</span>
<span class="p">(</span><span class="nb">exact-&gt;inexact</span> <span class="mi">1</span><span class="nv">/3</span><span class="p">)</span> <span class="c1">; =&gt; 0.3333333333333333</span>
<span class="p">(</span><span class="nb">+</span> <span class="mi">1</span><span class="nv">+2i</span>  <span class="mi">2-3</span><span class="nv">i</span><span class="p">)</span> <span class="c1">; =&gt; 3-1i</span>

<span class="c1">;;; Λογικές μεταβλητές</span>
<span class="no">#t</span> <span class="c1">; για το true (αληθής)</span>
<span class="no">#f</span> <span class="c1">; για το false (ψευδής)</span>
<span class="p">(</span><span class="nb">not</span> <span class="no">#t</span><span class="p">)</span> <span class="c1">; =&gt; #f</span>
<span class="p">(</span><span class="k">and</span> <span class="mi">0</span> <span class="no">#f</span> <span class="p">(</span><span class="nb">error</span> <span class="s">"doesn't get here"</span><span class="p">))</span> <span class="c1">; =&gt; #f</span>
<span class="p">(</span><span class="k">or</span> <span class="no">#f</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">error</span> <span class="s">"doesn't get here"</span><span class="p">))</span>  <span class="c1">; =&gt; 0</span>

<span class="c1">;;; Χαρακτήρες</span>
<span class="sc">#\A</span> <span class="c1">; =&gt; #\A</span>
<span class="o">#</span><span class="nv">\λ</span> <span class="c1">; =&gt; #\λ</span>
<span class="sc">#\u03BB</span> <span class="c1">; =&gt; #\λ</span>

<span class="c1">;;; Τα αλφαριθμητικά είναι πίνακες χαρακτήρων συγκεκριμένου μήκους</span>
<span class="s">"Hello, world!"</span>
<span class="s">"Benjamin \"Bugsy\" Siegel"</span>   <span class="c1">; Το backslash είναι χαρακτήρας διαφυγής</span>
<span class="s">"Foo\tbar\41\x21\u0021\a\r\n"</span> <span class="c1">; Συμπεριλαμβάνονται οι χαρακτήρες διαφυγής της C,</span>
                              <span class="c1">; σε Unicode</span>
<span class="s">"λx:(μα.α→α).xx"</span>              <span class="c1">; Μπορούν να υπάρχουν και Unicode χαρακτήρες</span>

<span class="c1">;; Μπορούμε να ενώσουμε αλφαριθμητικά!</span>
<span class="p">(</span><span class="nb">string-append</span> <span class="s">"Hello "</span> <span class="s">"world!"</span><span class="p">)</span> <span class="c1">; =&gt; "Hello world!"</span>

<span class="c1">;; Ένα αλφαριθμητικό μπορούμε να το χρησιμοποιήσουμε</span>
<span class="c1">;; όπως και μια λίστα από χαρακτήρες</span>
<span class="p">(</span><span class="nb">string-ref</span> <span class="s">"Apple"</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">; =&gt; #\A ;; Παίρνουμε το πρώτο στοιχείο</span>

<span class="c1">;; Η συνάρτηση format μπορεί να χρησιμοποιηθεί για</span>
<span class="c1">;; να μορφοποιήσουμε αλφαριθμητικά</span>
<span class="p">(</span><span class="nb">format</span> <span class="s">"~a can be ~a"</span> <span class="s">"strings"</span> <span class="s">"formatted"</span><span class="p">)</span> <span class="c1">;; =&gt; "strings can be formatted"</span>

<span class="c1">;; Η εκτύπωση είναι εύκολη.</span>
<span class="p">(</span><span class="nb">printf</span> <span class="s">"I'm Racket. Nice to meet you!\n"</span><span class="p">)</span>

<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; 2. Μεταβλητές</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; Μπορούμε να δημιουργήσουμε μεταβλητές</span>
<span class="c1">;; χρησιμοποιώντας το define.</span>
<span class="c1">;; Ένα όνομα μεταβλητής μπορεί να χρησιμοποιεί οποιονδήποτε </span>
<span class="c1">;; χαρακτήρα, εκτός από τους: ()[]{}",'`;#|\</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">some-var</span> <span class="mi">5</span><span class="p">)</span>
<span class="nv">some-var</span> <span class="c1">; =&gt; 5</span>

<span class="c1">;; Μπορούμε επίσης να χρησιμοποιήσουμε unicode χαρακτήρες.</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">⊆</span> <span class="nv">subset?</span><span class="p">)</span> <span class="c1">;; Εδώ ουσιαστικά δίνουμε στη ήδη υπάρχουσα συνάρτηση subset?</span>
                   <span class="c1">;; ένα νέο όνομα ⊆ , και παρακάτω την καλούμε με το νέο της όνομα.</span>
<span class="p">(</span><span class="nf">⊆</span> <span class="p">(</span><span class="nf">set</span> <span class="mi">3</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nf">set</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span> <span class="c1">; =&gt; #t</span>

<span class="c1">;; Αν ζητήσουμε μια μεταβλητή που δεν έχει οριστεί πριν π.χ.</span>
<span class="p">(</span><span class="nb">printf</span> <span class="nv">name</span><span class="p">)</span>
<span class="c1">;; θα πάρουμε το παρακάτω μήνυμα</span>
<span class="c1">;name: undefined;</span>
<span class="c1">;  cannot reference undefined identifier</span>
<span class="c1">;   context...:</span>

<span class="c1">;; Η τοπική δέσμευση : `me' δεσμεύεται με το "Bob" μόνο μέσα στο (let ...)</span>
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">me</span> <span class="s">"Bob"</span><span class="p">])</span>
  <span class="s">"Alice"</span>
  <span class="nv">me</span><span class="p">)</span> <span class="c1">; =&gt; "Bob"</span>

<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; 3. Δομές και συλλογές</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;; Δομές</span>
<span class="p">(</span><span class="nf">struct</span> <span class="nv">dog</span> <span class="p">(</span><span class="nf">name</span> <span class="nv">breed</span> <span class="nv">age</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">my-pet</span>
  <span class="p">(</span><span class="nf">dog</span> <span class="s">"lassie"</span> <span class="s">"collie"</span> <span class="mi">5</span><span class="p">))</span>
<span class="nv">my-pet</span> <span class="c1">; =&gt; #&lt;dog&gt;</span>
<span class="p">(</span><span class="nf">dog?</span> <span class="nv">my-pet</span><span class="p">)</span> <span class="c1">; =&gt; #t</span>
<span class="p">(</span><span class="nf">dog-name</span> <span class="nv">my-pet</span><span class="p">)</span> <span class="c1">; =&gt; "lassie"</span>

<span class="c1">;;; Ζεύγη (αμετάβλητα)</span>
<span class="c1">;; Η δεσμευμένη λέξη `cons' δημιουργεί ζεύγη,</span>
<span class="c1">;; και το `car' και το `cdr' εξάγουν το πρώτο και</span>
<span class="c1">;; το δεύτερο στοιχείο αντίστοιχα.</span>
<span class="p">(</span><span class="nb">cons</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">; =&gt; '(1 . 2)</span>
<span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">; =&gt; 1</span>
<span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">; =&gt; 2</span>

<span class="c1">;;; Λίστες</span>

<span class="c1">;; Οι λίστες είναι linked-list δομές δεδομένων,</span>
<span class="c1">;; που έχουν δημιουργηθεί από ζευγάρια 'cons'</span>
<span class="c1">;; και τελειώνουν με 'null' (ή αλλιώς '()) για να</span>
<span class="c1">;; δηλώσουν ότι αυτό είναι το τέλος της λίστας</span>
<span class="p">(</span><span class="nb">cons</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">2</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">3</span> <span class="nv">null</span><span class="p">)))</span> <span class="c1">; =&gt; '(1 2 3)</span>
<span class="c1">;; Η δεσμευμένη λέξη  'list' είναι ένας εναλλακτικός</span>
<span class="c1">;; (και σαφώς πιο βολικός) τρόπος για να δημιουργούμε</span>
<span class="c1">;; λίστες</span>
<span class="p">(</span><span class="nb">list</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; =&gt; '(1 2 3)</span>
<span class="c1">;; αλλά και χρησιμοποιώντας ένα μονό εισαγωγικό το</span>
<span class="c1">;; το αποτέλεσμα είναι και πάλι το ίδιο</span>
<span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; =&gt; '(1 2 3)</span>

<span class="c1">;; Μπορούμε και πάλι όμως να χρησιμοποιούμε το 'cons' για να</span>
<span class="c1">;; προσθέσουμε ένα στοιχείο στην αρχή της λίστας</span>
<span class="p">(</span><span class="nb">cons</span> <span class="mi">4</span> <span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span> <span class="c1">; =&gt; '(4 1 2 3)</span>

<span class="c1">;; Μπορούμε να χρησιμοποιούμε το 'append' για να προσθέτουμε</span>
<span class="c1">;; στοιχεία στο τέλος μιας λίστας. Το στοιχείο αυτό μπορεί</span>
<span class="c1">;; και να είναι ολόκληρη λίστα!</span>
<span class="p">(</span><span class="nb">append</span> <span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">2</span><span class="p">)</span> <span class="o">'</span><span class="p">(</span><span class="nf">3</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">; =&gt; '(1 2 3 4)</span>

<span class="c1">;; Οι λίστες στην Racket είναι πολύ βασικές , οπότε υπάρχουν πολλές</span>
<span class="c1">;; δυνατές λειτουργίες για αυτές. Παρακάτω είναι μερικά παραδείγματα:</span>
<span class="p">(</span><span class="nb">map</span> <span class="nv">add1</span> <span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>          <span class="c1">; =&gt; '(2 3 4)</span>
<span class="p">(</span><span class="nb">map</span> <span class="nv">+</span> <span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="o">'</span><span class="p">(</span><span class="nf">10</span> <span class="mi">20</span> <span class="mi">30</span><span class="p">))</span> <span class="c1">; =&gt; '(11 22 33)</span>
<span class="p">(</span><span class="nf">filter</span> <span class="nv">even?</span> <span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>    <span class="c1">; =&gt; '(2 4)</span>
<span class="p">(</span><span class="nf">count</span> <span class="nv">even?</span> <span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>     <span class="c1">; =&gt; 2</span>
<span class="p">(</span><span class="nf">take</span> <span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>          <span class="c1">; =&gt; '(1 2)</span>
<span class="p">(</span><span class="nf">drop</span> <span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>          <span class="c1">; =&gt; '(3 4)</span>

<span class="c1">;;; Διανύσματα</span>

<span class="c1">;; Τα διανύσματα είναι πίνακες σταθερού μήκους</span>
<span class="o">#</span><span class="p">(</span><span class="nf">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; =&gt; '#(1 2 3)</span>

<span class="c1">;; Χρησιμοποιούμε το `vector-append' για να προσθέσουμε διανύσματα</span>
<span class="p">(</span><span class="nf">vector-append</span> <span class="o">#</span><span class="p">(</span><span class="nf">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="o">#</span><span class="p">(</span><span class="nf">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">))</span> <span class="c1">; =&gt; #(1 2 3 4 5 6)</span>

<span class="c1">;;; Σύνολα</span>

<span class="c1">;; Δημιουργούμε ένα σύνολο από μία λίστα</span>
<span class="p">(</span><span class="nf">list-&gt;set</span> <span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">))</span> <span class="c1">; =&gt; (set 1 2 3)</span>

<span class="c1">;; Προσθέτουμε έναν αριθμό στο σύνολο χρησιμοποιώντας το `set-add'</span>
<span class="p">(</span><span class="nf">set-add</span> <span class="p">(</span><span class="nf">set</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">; =&gt; (set 1 2 3 4)</span>

<span class="c1">;; Αφαιρούμε με το `set-remove'</span>
<span class="p">(</span><span class="nf">set-remove</span> <span class="p">(</span><span class="nf">set</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">; =&gt; (set 2 3)</span>

<span class="c1">;; Βλέπουμε αν υπάρχει ένας αριθμός στο σύνολο με το `set-member?'</span>
<span class="p">(</span><span class="nf">set-member?</span> <span class="p">(</span><span class="nf">set</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">; =&gt; #t</span>
<span class="p">(</span><span class="nf">set-member?</span> <span class="p">(</span><span class="nf">set</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">; =&gt; #f</span>

<span class="c1">;;; Πίνακες κατακερματισμού (Hashes)</span>

<span class="c1">;; Δημιουργήστε ένα αμετάβλητο πίνακα κατακερματισμού</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">m</span> <span class="p">(</span><span class="nb">hash</span> <span class="ss">'a</span> <span class="mi">1</span> <span class="ss">'b</span> <span class="mi">2</span> <span class="ss">'c</span> <span class="mi">3</span><span class="p">))</span>

<span class="c1">;; Παίρνουμε μια τιμή από τον πίνακα</span>
<span class="p">(</span><span class="nf">hash-ref</span> <span class="nv">m</span> <span class="ss">'a</span><span class="p">)</span> <span class="c1">; =&gt; 1</span>

<span class="c1">;; Αν ζητήσουμε μια τιμή που δεν υπάρχει παίρνουμε μία εξαίρεση</span>
<span class="c1">; (hash-ref m 'd) =&gt; no value found for key</span>

<span class="c1">;; Μπορούμε να δώσουμε μια default τιμή για τα κλειδιά που λείπουν</span>
<span class="p">(</span><span class="nf">hash-ref</span> <span class="nv">m</span> <span class="ss">'d</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">; =&gt; 0</span>


<span class="c1">;; Χρησιμοποιούμε το 'hash-set' για να επεκτείνουμε</span>
<span class="c1">;; ένα πίνακα κατακερματισμού</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">m2</span> <span class="p">(</span><span class="nf">hash-set</span> <span class="nv">m</span> <span class="ss">'d</span> <span class="mi">4</span><span class="p">))</span>
<span class="nv">m2</span> <span class="c1">; =&gt; '#hash((b . 2) (a . 1) (d . 4) (c . 3))</span>

<span class="c1">;; Θυμηθείτε ! Αυτοί οι πίνακες κατακερματισμού</span>
<span class="c1">;; είναι αμετάβλητοι!</span>
<span class="nv">m</span> <span class="c1">; =&gt; '#hash((b . 2) (a . 1) (c . 3))  &lt;-- δεν υπάρχει `d'</span>

<span class="c1">;; Χρησιμοποιούμε το `hash-remove' για να αφαιρέσουμε</span>
<span class="c1">;; κλειδιά</span>
<span class="p">(</span><span class="nf">hash-remove</span> <span class="nv">m</span> <span class="ss">'a</span><span class="p">)</span> <span class="c1">; =&gt; '#hash((b . 2) (c . 3))</span>

<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; 3. Συναρτήσεις</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;; Χρησιμοποιούμε το `lambda' για να δημιουργήσουμε συναρτήσεις.</span>
<span class="c1">;; Μια συνάρτηση πάντα επιστρέφει την τιμή της τελευταίας της έκφρασης</span>
<span class="p">(</span><span class="k">lambda</span> <span class="p">()</span> <span class="s">"Hello World"</span><span class="p">)</span> <span class="c1">; =&gt; #&lt;procedure&gt;</span>
<span class="c1">;; Μπορούμε επίσης να χρησιμοποιήσουμε το `λ'</span>
<span class="p">(</span><span class="k">λ</span> <span class="p">()</span> <span class="s">"Hello World"</span><span class="p">)</span>     <span class="c1">; =&gt; Ίδια συνάρτηση</span>

<span class="c1">;; Χρησιμοποιούμε τις παρενθέσεις για να καλέσουμε όλες τις συναρτήσεις</span>
<span class="c1">;; συμπεριλαμβανομένων και των εκφράσεων 'λάμδα'</span>
<span class="p">((</span><span class="k">lambda</span> <span class="p">()</span> <span class="s">"Hello World"</span><span class="p">))</span> <span class="c1">; =&gt; "Hello World"</span>
<span class="p">((</span><span class="k">λ</span> <span class="p">()</span> <span class="s">"Hello World"</span><span class="p">))</span>      <span class="c1">; =&gt; "Hello World"</span>

<span class="c1">;; Εκχωρούμε σε μια μεταβλητή την συνάρτηση</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">hello-world</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">()</span> <span class="s">"Hello World"</span><span class="p">))</span>
<span class="p">(</span><span class="nf">hello-world</span><span class="p">)</span> <span class="c1">; =&gt; "Hello World"</span>

<span class="c1">;; Μπορούμε αυτό να το κάνουμε συντομότερο χρησιμοποιώντας</span>
<span class="c1">;; το λεγόμενο syntactic sugar :</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">hello-world2</span><span class="p">)</span> <span class="s">"Hello World"</span><span class="p">)</span>

<span class="c1">;; Το () στο παραπάνω είναι η λίστα από τα ορίσματα για την συνάρτηση</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">hello</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">name</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">string-append</span> <span class="s">"Hello "</span> <span class="nv">name</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">hello</span> <span class="s">"Steve"</span><span class="p">)</span> <span class="c1">; =&gt; "Hello Steve"</span>
<span class="c1">;; ... ή ισοδύναμα, χρησιμοποιώντας sugared ορισμό:</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">hello2</span> <span class="nv">name</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">string-append</span> <span class="s">"Hello "</span> <span class="nv">name</span><span class="p">))</span>

<span class="c1">;; Μπορούμε να έχουμε συναρτήσεις με πολλές μεταβλητές χρησιμοποιώντας</span>
<span class="c1">;; το `case-lambda'</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">hello3</span>
  <span class="p">(</span><span class="k">case-lambda</span>
    <span class="p">[()</span> <span class="s">"Hello World"</span><span class="p">]</span>
    <span class="p">[(</span><span class="nf">name</span><span class="p">)</span> <span class="p">(</span><span class="nb">string-append</span> <span class="s">"Hello "</span> <span class="nv">name</span><span class="p">)]))</span>
<span class="p">(</span><span class="nf">hello3</span> <span class="s">"Jake"</span><span class="p">)</span> <span class="c1">; =&gt; "Hello Jake"</span>
<span class="p">(</span><span class="nf">hello3</span><span class="p">)</span> <span class="c1">; =&gt; "Hello World"</span>
<span class="c1">;; ... ή να ορίσουμε προαιρετικά ορίσματα με μια έκφραση προκαθορισμένης τιμής</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">hello4</span> <span class="p">[</span><span class="nf">name</span> <span class="s">"World"</span><span class="p">])</span>
  <span class="p">(</span><span class="nb">string-append</span> <span class="s">"Hello "</span> <span class="nv">name</span><span class="p">))</span>

<span class="c1">;; Οι συναρτήσεις μπορούν να πακετάρουν επιπλέον</span>
<span class="c1">;; ορίσματα μέσα σε μια λίστα</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">count-args</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">format</span> <span class="s">"You passed ~a args: ~a"</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">args</span><span class="p">)</span> <span class="nv">args</span><span class="p">))</span>
<span class="p">(</span><span class="nf">count-args</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; =&gt; "You passed 3 args: (1 2 3)"</span>
<span class="c1">;; ... ή με unsugared μορφή `lambda':</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">count-args2</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="nv">args</span>
    <span class="p">(</span><span class="nb">format</span> <span class="s">"You passed ~a args: ~a"</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">args</span><span class="p">)</span> <span class="nv">args</span><span class="p">)))</span>

<span class="c1">;; Μπορούμε να εμπλέξουμε κανονικά και πακεταρισμένα ορίσματα</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">hello-count</span> <span class="nv">name</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">format</span> <span class="s">"Hello ~a, you passed ~a extra args"</span> <span class="nv">name</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">args</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">hello-count</span> <span class="s">"Finn"</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">; =&gt; "Hello Finn, you passed 3 extra args"</span>
<span class="c1">;; ... και unsugared:</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">hello-count2</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">name</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">format</span> <span class="s">"Hello ~a, you passed ~a extra args"</span> <span class="nv">name</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">args</span><span class="p">))))</span>

<span class="c1">;; Και με λέξεις κλειδιά</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">hello-k</span> <span class="nt">#:name</span> <span class="p">[</span><span class="nf">name</span> <span class="s">"World"</span><span class="p">]</span> <span class="nt">#:greeting</span> <span class="p">[</span><span class="nf">g</span> <span class="s">"Hello"</span><span class="p">]</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">format</span> <span class="s">"~a ~a, ~a extra args"</span> <span class="nv">g</span> <span class="nv">name</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">args</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">hello-k</span><span class="p">)</span>                 <span class="c1">; =&gt; "Hello World, 0 extra args"</span>
<span class="p">(</span><span class="nf">hello-k</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>           <span class="c1">; =&gt; "Hello World, 3 extra args"</span>
<span class="p">(</span><span class="nf">hello-k</span> <span class="nt">#:greeting</span> <span class="s">"Hi"</span><span class="p">)</span> <span class="c1">; =&gt; "Hi World, 0 extra args"</span>
<span class="p">(</span><span class="nf">hello-k</span> <span class="nt">#:name</span> <span class="s">"Finn"</span> <span class="nt">#:greeting</span> <span class="s">"Hey"</span><span class="p">)</span> <span class="c1">; =&gt; "Hey Finn, 0 extra args"</span>
<span class="p">(</span><span class="nf">hello-k</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="nt">#:greeting</span> <span class="s">"Hi"</span> <span class="nt">#:name</span> <span class="s">"Finn"</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">)</span>
                                         <span class="c1">; =&gt; "Hi Finn, 6 extra args"</span>

<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; 4. Ισότητα</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;; για αριθμούς χρησιμοποιούμε το `='</span>
<span class="p">(</span><span class="nb">=</span> <span class="mi">3</span> <span class="mf">3.0</span><span class="p">)</span> <span class="c1">; =&gt; #t</span>
<span class="p">(</span><span class="nb">=</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1">; =&gt; #f</span>

<span class="c1">;; Το `eq?' επιστρέφει #t αν δύο 2 ορίσματα αναφέρονται στο</span>
<span class="c1">;; ίδιο αντικείμενο (στη μνήμη),αλλιώς επιστρέφει #f.</span>
<span class="c1">;; Με άλλα λόγια, είναι απλή σύγκριση δεικτών.</span>
<span class="p">(</span><span class="nb">eq?</span> <span class="o">'</span><span class="p">()</span> <span class="o">'</span><span class="p">())</span> <span class="c1">; =&gt; #t, αφού υπάρχει μόνο μια άδεια λίστα στη μνήμη</span>
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">x</span> <span class="o">'</span><span class="p">()]</span> <span class="p">[</span><span class="nf">y</span> <span class="o">'</span><span class="p">()])</span>
  <span class="p">(</span><span class="nb">eq?</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>  <span class="c1">; =&gt; #t, το ίδιο με πάνω</span>

<span class="p">(</span><span class="nb">eq?</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">3</span><span class="p">))</span> <span class="c1">; =&gt; #f</span>
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">x</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">3</span><span class="p">)]</span> <span class="p">[</span><span class="nf">y</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">3</span><span class="p">)])</span>
  <span class="p">(</span><span class="nb">eq?</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>            <span class="c1">; =&gt; #f — δεν είναι η ίδια λίστα στην μνήμη!</span>

<span class="p">(</span><span class="k">let*</span> <span class="p">([</span><span class="nf">x</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">3</span><span class="p">)]</span> <span class="p">[</span><span class="nf">y</span> <span class="nv">x</span><span class="p">])</span>
  <span class="p">(</span><span class="nb">eq?</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span> <span class="c1">; =&gt; #t, Αφού το x και το y τώρα δείχνουν στην ίδια θέση</span>

<span class="p">(</span><span class="nb">eq?</span> <span class="ss">'yes</span> <span class="ss">'yes</span><span class="p">)</span> <span class="c1">; =&gt; #t</span>
<span class="p">(</span><span class="nb">eq?</span> <span class="ss">'yes</span> <span class="ss">'no</span><span class="p">)</span>  <span class="c1">; =&gt; #f</span>

<span class="p">(</span><span class="nb">eq?</span> <span class="mi">3</span> <span class="mi">3</span><span class="p">)</span>   <span class="c1">; =&gt; #t — να είστε προσεκτικοί εδώ</span>
            <span class="c1">; Είναι προτιμότερο να χρησιμοποιείτε `=' για την</span>
            <span class="c1">; σύγκριση αριθμών.</span>
<span class="p">(</span><span class="nb">eq?</span> <span class="mi">3</span> <span class="mf">3.0</span><span class="p">)</span> <span class="c1">; =&gt; #f</span>

<span class="p">(</span><span class="nb">eq?</span> <span class="p">(</span><span class="nb">expt</span> <span class="mi">2</span> <span class="mi">100</span><span class="p">)</span> <span class="p">(</span><span class="nb">expt</span> <span class="mi">2</span> <span class="mi">100</span><span class="p">))</span>               <span class="c1">; =&gt; #f</span>
<span class="p">(</span><span class="nb">eq?</span> <span class="p">(</span><span class="nb">integer-&gt;char</span> <span class="mi">955</span><span class="p">)</span> <span class="p">(</span><span class="nb">integer-&gt;char</span> <span class="mi">955</span><span class="p">))</span> <span class="c1">; =&gt; #f</span>

<span class="p">(</span><span class="nb">eq?</span> <span class="p">(</span><span class="nb">string-append</span> <span class="s">"foo"</span> <span class="s">"bar"</span><span class="p">)</span> <span class="p">(</span><span class="nb">string-append</span> <span class="s">"foo"</span> <span class="s">"bar"</span><span class="p">))</span> <span class="c1">; =&gt; #f</span>

<span class="c1">;; Το `eqv?' υποστηρίζει την σύγκριση αριθμών αλλά και χαρακτήρων</span>
<span class="c1">;; Για άλλα ήδη μεταβλητών το `eqv?' και το `eq?' επιστρέφουν το ίδιο.</span>
<span class="p">(</span><span class="nb">eqv?</span> <span class="mi">3</span> <span class="mf">3.0</span><span class="p">)</span>                                   <span class="c1">; =&gt; #f</span>
<span class="p">(</span><span class="nb">eqv?</span> <span class="p">(</span><span class="nb">expt</span> <span class="mi">2</span> <span class="mi">100</span><span class="p">)</span> <span class="p">(</span><span class="nb">expt</span> <span class="mi">2</span> <span class="mi">100</span><span class="p">))</span>               <span class="c1">; =&gt; #t</span>
<span class="p">(</span><span class="nb">eqv?</span> <span class="p">(</span><span class="nb">integer-&gt;char</span> <span class="mi">955</span><span class="p">)</span> <span class="p">(</span><span class="nb">integer-&gt;char</span> <span class="mi">955</span><span class="p">))</span> <span class="c1">; =&gt; #t</span>

<span class="p">(</span><span class="nb">eqv?</span> <span class="p">(</span><span class="nb">string-append</span> <span class="s">"foo"</span> <span class="s">"bar"</span><span class="p">)</span> <span class="p">(</span><span class="nb">string-append</span> <span class="s">"foo"</span> <span class="s">"bar"</span><span class="p">))</span>   <span class="c1">; =&gt; #f</span>

<span class="c1">;; Το `equal?' υποστηρίζει την σύγκριση των παρακάτω τύπων μεταβλητών:</span>
<span class="c1">;; αλφαριθμητικά, αλφαριθμητικά από bytes, μεταβλητά ζεύγη , διανύσματα,</span>
<span class="c1">;; πίνακες κατακερματισμού και δομές.</span>
<span class="c1">;; Για άλλα ήδη τύπων μεταβλητών το `equal?' και το `eqv?' επιστρέφουν το</span>
<span class="c1">;; ίδιο αποτέλεσμα.</span>
<span class="p">(</span><span class="nb">equal?</span> <span class="mi">3</span> <span class="mf">3.0</span><span class="p">)</span>                                                   <span class="c1">; =&gt; #f</span>
<span class="p">(</span><span class="nb">equal?</span> <span class="p">(</span><span class="nb">string-append</span> <span class="s">"foo"</span> <span class="s">"bar"</span><span class="p">)</span> <span class="p">(</span><span class="nb">string-append</span> <span class="s">"foo"</span> <span class="s">"bar"</span><span class="p">))</span> <span class="c1">; =&gt; #t</span>
<span class="p">(</span><span class="nb">equal?</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">3</span><span class="p">))</span>                                       <span class="c1">; =&gt; #t</span>

<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; 5. Έλεγχος Ροής</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;;; Συνθήκες (conditionals)</span>

<span class="p">(</span><span class="k">if</span> <span class="no">#t</span>               <span class="c1">; έκφραση ελέγχου</span>
    <span class="s">"this is true"</span>   <span class="c1">; έκφραση then</span>
    <span class="s">"this is false"</span><span class="p">)</span> <span class="c1">; έκφραση else</span>
<span class="c1">; =&gt; "this is true"</span>


<span class="c1">;; Στα conditionals, όλες οι μη #f τιμές θεωρούνται ως #t</span>
<span class="p">(</span><span class="nb">member</span> <span class="ss">'Groucho</span> <span class="o">'</span><span class="p">(</span><span class="nf">Harpo</span> <span class="nv">Groucho</span> <span class="nv">Zeppo</span><span class="p">))</span> <span class="c1">; =&gt; '(Groucho Zeppo)</span>
<span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">member</span> <span class="ss">'Groucho</span> <span class="o">'</span><span class="p">(</span><span class="nf">Harpo</span> <span class="nv">Groucho</span> <span class="nv">Zeppo</span><span class="p">))</span>
    <span class="ss">'yep</span>
    <span class="ss">'nope</span><span class="p">)</span>
<span class="c1">; =&gt; 'yep</span>

<span class="c1">;; Οι αλυσίδες `cond' είναι σειρές από ελέγχους για να</span>
<span class="c1">;; επιλεγεί ένα αποτέλεσμα</span>
<span class="p">(</span><span class="k">cond</span> <span class="p">[(</span><span class="nb">&gt;</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">error</span> <span class="s">"wrong!"</span><span class="p">)]</span>
      <span class="p">[(</span><span class="nb">&lt;</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">error</span> <span class="s">"wrong again!"</span><span class="p">)]</span>
      <span class="p">[</span><span class="nf">else</span> <span class="ss">'ok</span><span class="p">])</span> <span class="c1">; =&gt; 'ok</span>

<span class="c1">;;; Αντιστοίχιση μοτίβων</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">fizzbuzz?</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">match</span> <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">remainder</span> <span class="nv">n</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">remainder</span> <span class="nv">n</span> <span class="mi">5</span><span class="p">))</span>
    <span class="p">[(</span><span class="nb">list</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="ss">'fizzbuzz</span><span class="p">]</span>
    <span class="p">[(</span><span class="nb">list</span> <span class="mi">0</span> <span class="nv">_</span><span class="p">)</span> <span class="ss">'fizz</span><span class="p">]</span>
    <span class="p">[(</span><span class="nb">list</span> <span class="nv">_</span> <span class="mi">0</span><span class="p">)</span> <span class="ss">'buzz</span><span class="p">]</span>
    <span class="p">[</span><span class="nf">_</span>          <span class="no">#f</span><span class="p">]))</span>

<span class="p">(</span><span class="nf">fizzbuzz?</span> <span class="mi">15</span><span class="p">)</span> <span class="c1">; =&gt; 'fizzbuzz</span>
<span class="p">(</span><span class="nf">fizzbuzz?</span> <span class="mi">37</span><span class="p">)</span> <span class="c1">; =&gt; #f</span>

<span class="c1">;;; Βρόχοι</span>

<span class="c1">;; Οι επαναλήψεις μπορούν να γίνουν μέσω αναδρομής</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">loop</span> <span class="nv">i</span><span class="p">)</span>
  <span class="p">(</span><span class="k">when</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">i</span> <span class="mi">10</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">printf</span> <span class="s">"i=~a\n"</span> <span class="nv">i</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">add1</span> <span class="nv">i</span><span class="p">))))</span>
<span class="p">(</span><span class="nf">loop</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">; =&gt; i=5, i=6, ...</span>

<span class="c1">;; Παρομοίως με τη χρήση 'let'</span>
<span class="p">(</span><span class="k">let</span> <span class="nv">loop</span> <span class="p">((</span><span class="nf">i</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">(</span><span class="k">when</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">i</span> <span class="mi">10</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">printf</span> <span class="s">"i=~a\n"</span> <span class="nv">i</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">add1</span> <span class="nv">i</span><span class="p">))))</span> <span class="c1">; =&gt; i=0, i=1, ...</span>


<span class="c1">;; Θα δείτε παρακάτω πως να προσθέσουμε μια νέα μορφή επανάληψης</span>
<span class="c1">;; αλλά η Racket έχει ήδη πολύ ευέλικτη μορφή για τους βρόχους</span>
<span class="p">(</span><span class="nf">for</span> <span class="p">([</span><span class="nf">i</span> <span class="mi">10</span><span class="p">])</span>
  <span class="p">(</span><span class="nb">printf</span> <span class="s">"i=~a\n"</span> <span class="nv">i</span><span class="p">))</span> <span class="c1">; =&gt; i=0, i=1, ...</span>
<span class="p">(</span><span class="nf">for</span> <span class="p">([</span><span class="nf">i</span> <span class="p">(</span><span class="nf">in-range</span> <span class="mi">5</span> <span class="mi">10</span><span class="p">)])</span>
  <span class="p">(</span><span class="nb">printf</span> <span class="s">"i=~a\n"</span> <span class="nv">i</span><span class="p">))</span> <span class="c1">; =&gt; i=5, i=6, ...</span>

<span class="c1">;;;</span>
<span class="c1">;;; Επανάληψη μέσα σε ακολουθίες:</span>
<span class="c1">;; Το `for' επιτρέπει την επανάληψη μέσα σε πολλά</span>
<span class="c1">;; άλλα ήδη από ακολουθίες: Λίστες, διανύσματα,</span>
<span class="c1">;; αλφαριθμητικά, σύνολα κτλ..</span>

<span class="p">(</span><span class="nf">for</span> <span class="p">([</span><span class="nf">i</span> <span class="p">(</span><span class="nf">in-list</span> <span class="o">'</span><span class="p">(</span><span class="nf">l</span> <span class="nv">i</span> <span class="nv">s</span> <span class="nv">t</span><span class="p">))])</span>
  <span class="p">(</span><span class="nb">displayln</span> <span class="nv">i</span><span class="p">))</span>

<span class="p">(</span><span class="nf">for</span> <span class="p">([</span><span class="nf">i</span> <span class="p">(</span><span class="nf">in-vector</span> <span class="o">#</span><span class="p">(</span><span class="nf">v</span> <span class="nv">e</span> <span class="nv">c</span> <span class="nv">t</span> <span class="nv">o</span> <span class="nv">r</span><span class="p">))])</span>
  <span class="p">(</span><span class="nb">displayln</span> <span class="nv">i</span><span class="p">))</span>

<span class="p">(</span><span class="nf">for</span> <span class="p">([</span><span class="nf">i</span> <span class="p">(</span><span class="nf">in-string</span> <span class="s">"string"</span><span class="p">)])</span>
  <span class="p">(</span><span class="nb">displayln</span> <span class="nv">i</span><span class="p">))</span>

<span class="p">(</span><span class="nf">for</span> <span class="p">([</span><span class="nf">i</span> <span class="p">(</span><span class="nf">in-set</span> <span class="p">(</span><span class="nf">set</span> <span class="ss">'x</span> <span class="ss">'y</span> <span class="ss">'z</span><span class="p">))])</span>
  <span class="p">(</span><span class="nb">displayln</span> <span class="nv">i</span><span class="p">))</span>

<span class="p">(</span><span class="nf">for</span> <span class="p">([(</span><span class="nf">k</span> <span class="nv">v</span><span class="p">)</span> <span class="p">(</span><span class="nf">in-hash</span> <span class="p">(</span><span class="nb">hash</span> <span class="ss">'a</span> <span class="mi">1</span> <span class="ss">'b</span> <span class="mi">2</span> <span class="ss">'c</span> <span class="mi">3</span> <span class="p">))])</span>
  <span class="p">(</span><span class="nb">printf</span> <span class="s">"key:~a value:~a\n"</span> <span class="nv">k</span> <span class="nv">v</span><span class="p">))</span>

<span class="c1">;;; Πιο περίπλοκες επαναλήψεις</span>

<span class="c1">;; Παράλληλη σάρωση σε πολλαπλές ακολουθίες</span>
<span class="c1">;; (σταματά στην πιο σύντομη)</span>
<span class="p">(</span><span class="nf">for</span> <span class="p">([</span><span class="nf">i</span> <span class="mi">10</span><span class="p">]</span> <span class="p">[</span><span class="nf">j</span> <span class="o">'</span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)])</span> <span class="p">(</span><span class="nb">printf</span> <span class="s">"~a:~a\n"</span> <span class="nv">i</span> <span class="nv">j</span><span class="p">))</span>
<span class="c1">; =&gt; 0:x 1:y 2:z</span>

<span class="c1">;; Εμφολευμένοι βρόχοι</span>
<span class="p">(</span><span class="nf">for*</span> <span class="p">([</span><span class="nf">i</span> <span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="nf">j</span> <span class="o">'</span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)])</span> <span class="p">(</span><span class="nb">printf</span> <span class="s">"~a:~a\n"</span> <span class="nv">i</span> <span class="nv">j</span><span class="p">))</span>
<span class="c1">; =&gt; 0:x, 0:y, 0:z, 1:x, 1:y, 1:z</span>

<span class="c1">;; Συνθήκες</span>
<span class="p">(</span><span class="nf">for</span> <span class="p">([</span><span class="nf">i</span> <span class="mi">1000</span><span class="p">]</span>
      <span class="nt">#:when</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">i</span> <span class="mi">5</span><span class="p">)</span>
      <span class="nt">#:unless</span> <span class="p">(</span><span class="nb">odd?</span> <span class="nv">i</span><span class="p">)</span>
      <span class="nt">#:break</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">i</span> <span class="mi">10</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">printf</span> <span class="s">"i=~a\n"</span> <span class="nv">i</span><span class="p">))</span>
<span class="c1">; =&gt; i=6, i=8, i=10</span>

<span class="c1">;;; Σάρωση σε λίστες</span>
<span class="c1">;; Παρόμοιο με τους βρόχους 'for', απλά συλλέγουμε τα αποτελέσματα</span>

<span class="p">(</span><span class="nf">for/list</span> <span class="p">([</span><span class="nf">i</span> <span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)])</span>
  <span class="p">(</span><span class="nb">add1</span> <span class="nv">i</span><span class="p">))</span> <span class="c1">; =&gt; '(2 3 4)</span>

<span class="p">(</span><span class="nf">for/list</span> <span class="p">([</span><span class="nf">i</span> <span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)]</span> <span class="nt">#:when</span> <span class="p">(</span><span class="nb">even?</span> <span class="nv">i</span><span class="p">))</span>
  <span class="nv">i</span><span class="p">)</span> <span class="c1">; =&gt; '(2)</span>

<span class="p">(</span><span class="nf">for/list</span> <span class="p">([</span><span class="nf">i</span> <span class="mi">10</span><span class="p">]</span> <span class="p">[</span><span class="nf">j</span> <span class="o">'</span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)])</span>
  <span class="p">(</span><span class="nb">list</span> <span class="nv">i</span> <span class="nv">j</span><span class="p">))</span> <span class="c1">; =&gt; '((0 x) (1 y) (2 z))</span>

<span class="p">(</span><span class="nf">for/list</span> <span class="p">([</span><span class="nf">i</span> <span class="mi">1000</span><span class="p">]</span> <span class="nt">#:when</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">i</span> <span class="mi">5</span><span class="p">)</span> <span class="nt">#:unless</span> <span class="p">(</span><span class="nb">odd?</span> <span class="nv">i</span><span class="p">)</span> <span class="nt">#:break</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">i</span> <span class="mi">10</span><span class="p">))</span>
  <span class="nv">i</span><span class="p">)</span> <span class="c1">; =&gt; '(6 8 10)</span>

<span class="p">(</span><span class="nf">for/hash</span> <span class="p">([</span><span class="nf">i</span> <span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)])</span>
  <span class="p">(</span><span class="nb">values</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">number-&gt;string</span> <span class="nv">i</span><span class="p">)))</span>
<span class="c1">; =&gt; '#hash((1 . "1") (2 . "2") (3 . "3"))</span>

<span class="c1">;; Υπάρχουν πολλά είδη από προϋπάρχοντες τρόπους για να συλλέγουμε</span>
<span class="c1">;; τιμές από τους βρόχους</span>

<span class="p">(</span><span class="nf">for/sum</span> <span class="p">([</span><span class="nf">i</span> <span class="mi">10</span><span class="p">])</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">i</span> <span class="nv">i</span><span class="p">))</span> <span class="c1">; =&gt; 285</span>
<span class="p">(</span><span class="nf">for/product</span> <span class="p">([</span><span class="nf">i</span> <span class="p">(</span><span class="nf">in-range</span> <span class="mi">1</span> <span class="mi">11</span><span class="p">)])</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">i</span> <span class="nv">i</span><span class="p">))</span> <span class="c1">; =&gt; 13168189440000</span>
<span class="p">(</span><span class="nf">for/and</span> <span class="p">([</span><span class="nf">i</span> <span class="mi">10</span><span class="p">]</span> <span class="p">[</span><span class="nf">j</span> <span class="p">(</span><span class="nf">in-range</span> <span class="mi">10</span> <span class="mi">20</span><span class="p">)])</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">i</span> <span class="nv">j</span><span class="p">))</span> <span class="c1">; =&gt; #t</span>
<span class="p">(</span><span class="nf">for/or</span> <span class="p">([</span><span class="nf">i</span> <span class="mi">10</span><span class="p">]</span> <span class="p">[</span><span class="nf">j</span> <span class="p">(</span><span class="nf">in-range</span> <span class="mi">0</span> <span class="mi">20</span> <span class="mi">2</span><span class="p">)])</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">i</span> <span class="nv">j</span><span class="p">))</span> <span class="c1">; =&gt; #t</span>

<span class="c1">;; Και για να χρησιμοποιήσουμε ένα αυθαίρετο συνδυασμό χρησιμοποιούμε</span>
<span class="c1">;; το 'for/fold'</span>
<span class="p">(</span><span class="nf">for/fold</span> <span class="p">([</span><span class="nf">sum</span> <span class="mi">0</span><span class="p">])</span> <span class="p">([</span><span class="nf">i</span> <span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)])</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">sum</span> <span class="nv">i</span><span class="p">))</span> <span class="c1">; =&gt; 10</span>

<span class="c1">;; Αυτό συχνά μπορεί να αντικαταστήσει τους κοινούς</span>
<span class="c1">;; προστακτικούς βρόχους (imperative loops)</span>

<span class="c1">;;; Εξαιρέσεις</span>

<span class="c1">;; Για να πιάσουμε τις εξαιρέσεις χρησιμοποιούμε το</span>
<span class="c1">;; `with-handlers'</span>
<span class="p">(</span><span class="k">with-handlers</span> <span class="p">([</span><span class="nb">exn:fail?</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nb">exn</span><span class="p">)</span> <span class="mi">999</span><span class="p">)])</span>
  <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="s">"2"</span><span class="p">))</span> <span class="c1">; =&gt; 999</span>
<span class="p">(</span><span class="k">with-handlers</span> <span class="p">([</span><span class="nb">exn:break?</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nb">exn</span><span class="p">)</span> <span class="s">"no time"</span><span class="p">)])</span>
  <span class="p">(</span><span class="nb">sleep</span> <span class="mi">3</span><span class="p">)</span>
  <span class="s">"phew"</span><span class="p">)</span> <span class="c1">; =&gt; "phew", αλλά αν γίνει το break =&gt; "no time"</span>

<span class="c1">;; Χρησιμοποιούμε το 'raise' για να άρουμε μια εξαίρεση</span>
<span class="c1">;; ή οποιαδήποτε άλλη τιμή</span>
<span class="p">(</span><span class="k">with-handlers</span> <span class="p">([</span><span class="nb">number?</span>    <span class="c1">; πιάνουμε αριθμητικές τιμές</span>
                 <span class="nv">identity</span><span class="p">])</span> <span class="c1">; και τις επιστρέφουμε σαν απλές τιμές</span>
  <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">raise</span> <span class="mi">2</span><span class="p">)))</span> <span class="c1">; =&gt; 2</span>

<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; 6. Αλλαγή τιμών</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;; Χρησιμοποιούμε το 'set!' για να θέσουμε μια νέα τιμή</span>
<span class="c1">;; σε μια ήδη υπάρχουσα μεταβλητή</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">n</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="k">set!</span> <span class="nv">n</span> <span class="p">(</span><span class="nb">add1</span> <span class="nv">n</span><span class="p">))</span>
<span class="nv">n</span> <span class="c1">; =&gt; 6</span>

<span class="c1">;; Χρησιμοποιούμε τα boxes για να δηλώσουμε ρητά ότι μια μεταβλητή</span>
<span class="c1">;; θα είναι  mutable (θα μπορεί να αλλάξει η τιμή της)</span>
<span class="c1">;; Αυτό είναι παρόμοιο με τους pointers σε άλλες γλώσσες</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">n*</span> <span class="p">(</span><span class="nb">box</span> <span class="mi">5</span><span class="p">))</span>
<span class="p">(</span><span class="nb">set-box!</span> <span class="nv">n*</span> <span class="p">(</span><span class="nb">add1</span> <span class="p">(</span><span class="nb">unbox</span> <span class="nv">n*</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">unbox</span> <span class="nv">n*</span><span class="p">)</span> <span class="c1">; =&gt; 6</span>


<span class="c1">;; Πολλοί τύποι μεταβλητών στη Racket είναι αμετάβλητοι π.χ. τα ζεύγη, οι</span>
<span class="c1">;; λίστες κτλ. Άλλοι υπάρχουν και σε μεταβλητή και σε αμετάβλητη μορφή</span>
<span class="c1">;; π.χ. αλφαριθμητικά, διανύσματα κτλ.</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">vec</span> <span class="p">(</span><span class="nb">vector</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">wall</span> <span class="p">(</span><span class="nb">make-vector</span> <span class="mi">100</span> <span class="ss">'bottle-of-beer</span><span class="p">))</span>
<span class="c1">;; Χρησιμοποιούμε το 'vector-set!' για να ανεώσουμε κάποια</span>
<span class="c1">;; συγκεκριμένη θέση</span>
<span class="p">(</span><span class="nb">vector-set!</span> <span class="nv">vec</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="nb">vector-set!</span> <span class="nv">wall</span> <span class="mi">99</span> <span class="ss">'down</span><span class="p">)</span>
<span class="nv">vec</span> <span class="c1">; =&gt; #(1 2 3 4)</span>


<span class="c1">;; Έτσι δημιουργούμε ένα άδειο μεταβλητό πίνακα κατακερματισμού</span>
<span class="c1">;; και τον χειριζόμαστε κατάλληλα</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">m3</span> <span class="p">(</span><span class="nf">make-hash</span><span class="p">))</span>
<span class="p">(</span><span class="nf">hash-set!</span> <span class="nv">m3</span> <span class="ss">'a</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="nf">hash-set!</span> <span class="nv">m3</span> <span class="ss">'b</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="nf">hash-set!</span> <span class="nv">m3</span> <span class="ss">'c</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="nf">hash-ref</span> <span class="nv">m3</span> <span class="ss">'a</span><span class="p">)</span>     <span class="c1">; =&gt; 1</span>
<span class="p">(</span><span class="nf">hash-ref</span> <span class="nv">m3</span> <span class="ss">'d</span> <span class="mi">0</span><span class="p">)</span>   <span class="c1">; =&gt; 0</span>
<span class="p">(</span><span class="nf">hash-remove!</span> <span class="nv">m3</span> <span class="ss">'a</span><span class="p">)</span>

<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; 7. Ενότητες (modules)</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>


<span class="c1">;; Οι ενότητες μας επιτρέπουν να οργανώνουμε τον κώδικα σε πολλαπλά</span>
<span class="c1">;; αρχεία και επαναχρησιμοποιούμενες βιβλιοθήκες</span>
<span class="c1">;; Εδώ χρησιμοποιούμε υπο-ενότητες, εμφωλευμένες μέσα σε μια</span>
<span class="c1">;; άλλη ενότητα που δημιουργεί αυτό το κείμενο (ξεκινώντας από</span>
<span class="c1">;; την γραμμή '#lang' )</span>
<span class="p">(</span><span class="k">module</span> <span class="nv">cake</span> <span class="nv">racket/base</span> <span class="c1">; ορίζουμε μια ενότητα 'cake' βασισμένο στο</span>
                         <span class="c1">; racket/base</span>

  <span class="p">(</span><span class="k">provide</span> <span class="nv">print-cake</span><span class="p">)</span> <span class="c1">; συνάρτηση που εξάγεται από την ενότητα</span>

  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">print-cake</span> <span class="nv">n</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">show</span> <span class="s">"   ~a   "</span> <span class="nv">n</span> <span class="sc">#\.</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">show</span> <span class="s">" .-~a-. "</span> <span class="nv">n</span> <span class="o">#</span><span class="nv">\|</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">show</span> <span class="s">" | ~a | "</span> <span class="nv">n</span> <span class="sc">#\space</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">show</span> <span class="s">"---~a---"</span> <span class="nv">n</span> <span class="sc">#\-</span><span class="p">))</span>

  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">show</span> <span class="nv">fmt</span> <span class="nv">n</span> <span class="nv">ch</span><span class="p">)</span> <span class="c1">; εσωτερική συνάρτηση</span>
    <span class="p">(</span><span class="nb">printf</span> <span class="nv">fmt</span> <span class="p">(</span><span class="nb">make-string</span> <span class="nv">n</span> <span class="nv">ch</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">newline</span><span class="p">)))</span>

<span class="c1">;; Χρησιμοποιουμε το 'require' για να πάρουμε όλα τα</span>
<span class="c1">;; παρεχόμενα ονόματα από μία ενότητα</span>
<span class="p">(</span><span class="k">require</span> <span class="ss">'cake</span><span class="p">)</span> <span class="c1">; το ' είναι για τοπική υποενότητα</span>
<span class="p">(</span><span class="nf">print-cake</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">; (show "~a" 1 #\A) ; =&gt; error, το `show' δεν έχει εξαχθεί</span>

<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; 8. Κλάσεις και αντικείμενα</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;; Δημιουργούμε μια κλάση fish% (- συνήθως χρησιμοποιούμε</span>
<span class="c1">;; το % στο όνομα μιας κλάσης )</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">fish%</span>
  <span class="p">(</span><span class="nf">class</span> <span class="nv">object%</span>
    <span class="p">(</span><span class="nf">init</span> <span class="nv">size</span><span class="p">)</span> <span class="c1">; initialization argument</span>
    <span class="p">(</span><span class="nf">super-new</span><span class="p">)</span> <span class="c1">; superclass initialization</span>
    <span class="c1">;; Field</span>
    <span class="p">(</span><span class="k">define</span> <span class="nv">current-size</span> <span class="nv">size</span><span class="p">)</span>
    <span class="c1">;; Public methods</span>
    <span class="p">(</span><span class="nf">define/public</span> <span class="p">(</span><span class="nf">get-size</span><span class="p">)</span>
      <span class="nv">current-size</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">define/public</span> <span class="p">(</span><span class="nf">grow</span> <span class="nv">amt</span><span class="p">)</span>
      <span class="p">(</span><span class="k">set!</span> <span class="nv">current-size</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">amt</span> <span class="nv">current-size</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">define/public</span> <span class="p">(</span><span class="nf">eat</span> <span class="nv">other-fish</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">grow</span> <span class="p">(</span><span class="nf">send</span> <span class="nv">other-fish</span> <span class="nv">get-size</span><span class="p">)))))</span>

<span class="c1">;; Δημιουργούμε ένα instance του fish%</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">charlie</span>
  <span class="p">(</span><span class="nf">new</span> <span class="nv">fish%</span> <span class="p">[</span><span class="nf">size</span> <span class="mi">10</span><span class="p">]))</span>

<span class="c1">;; Χρησιμοποιούμε το 'send' για να καλέσουμε</span>
<span class="c1">;; τις μεθόδους ενός αντικειμένου</span>
<span class="p">(</span><span class="nf">send</span> <span class="nv">charlie</span> <span class="nv">get-size</span><span class="p">)</span> <span class="c1">; =&gt; 10</span>
<span class="p">(</span><span class="nf">send</span> <span class="nv">charlie</span> <span class="nv">grow</span> <span class="mi">6</span><span class="p">)</span>
<span class="p">(</span><span class="nf">send</span> <span class="nv">charlie</span> <span class="nv">get-size</span><span class="p">)</span> <span class="c1">; =&gt; 16</span>

<span class="c1">;; Το `fish%' είναι μία τιμή "πρώτης κλάσης"</span>
<span class="c1">;; με το οποίο μπορούμε να κάνουμε προσμείξεις</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">add-color</span> <span class="nv">c%</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">class</span> <span class="nv">c%</span>
    <span class="p">(</span><span class="nf">init</span> <span class="nv">color</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">super-new</span><span class="p">)</span>
    <span class="p">(</span><span class="k">define</span> <span class="nv">my-color</span> <span class="nv">color</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">define/public</span> <span class="p">(</span><span class="nf">get-color</span><span class="p">)</span> <span class="nv">my-color</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">colored-fish%</span> <span class="p">(</span><span class="nf">add-color</span> <span class="nv">fish%</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">charlie2</span> <span class="p">(</span><span class="nf">new</span> <span class="nv">colored-fish%</span> <span class="p">[</span><span class="nf">size</span> <span class="mi">10</span><span class="p">]</span> <span class="p">[</span><span class="nf">color</span> <span class="ss">'red</span><span class="p">]))</span>
<span class="p">(</span><span class="nf">send</span> <span class="nv">charlie2</span> <span class="nv">get-color</span><span class="p">)</span>
<span class="c1">;; ή χωρίς καθόλου ονόματα :</span>
<span class="p">(</span><span class="nf">send</span> <span class="p">(</span><span class="nf">new</span> <span class="p">(</span><span class="nf">add-color</span> <span class="nv">fish%</span><span class="p">)</span> <span class="p">[</span><span class="nf">size</span> <span class="mi">10</span><span class="p">]</span> <span class="p">[</span><span class="nf">color</span> <span class="ss">'red</span><span class="p">])</span> <span class="nv">get-color</span><span class="p">)</span>

<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; 9. Μακροεντολές</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;; Οι μακροεντολές μας επιτρέπουν να επεκτείνουμε</span>
<span class="c1">;; το συντακτικό μιας γλώσσας.</span>

<span class="c1">;; Ας προσθέσουμε έναν βρόχο while</span>
<span class="p">(</span><span class="k">define-syntax-rule</span> <span class="p">(</span><span class="nf">while</span> <span class="nv">condition</span> <span class="nv">body</span> <span class="o">...</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="nv">loop</span> <span class="p">()</span>
    <span class="p">(</span><span class="k">when</span> <span class="nv">condition</span>
      <span class="nv">body</span> <span class="o">...</span>
      <span class="p">(</span><span class="nf">loop</span><span class="p">))))</span>

<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">i</span> <span class="mi">0</span><span class="p">])</span>
  <span class="p">(</span><span class="nf">while</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">i</span>  <span class="mi">10</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">displayln</span> <span class="nv">i</span><span class="p">)</span>
    <span class="p">(</span><span class="k">set!</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">add1</span> <span class="nv">i</span><span class="p">))))</span>

<span class="c1">;; Macros are hygienic, you cannot clobber existing variables!</span>
<span class="p">(</span><span class="k">define-syntax-rule</span> <span class="p">(</span><span class="nf">swap!</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="c1">; -! is idiomatic for mutation</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">tmp</span> <span class="nv">x</span><span class="p">])</span>
    <span class="p">(</span><span class="k">set!</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
    <span class="p">(</span><span class="k">set!</span> <span class="nv">y</span> <span class="nv">tmp</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">tmp</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">other</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="nf">swap!</span> <span class="nv">tmp</span> <span class="nv">other</span><span class="p">)</span>
<span class="p">(</span><span class="nb">printf</span> <span class="s">"tmp = ~a; other = ~a\n"</span> <span class="nv">tmp</span> <span class="nv">other</span><span class="p">)</span>
<span class="c1">;; Η μεταβλητή 'tmp' μετονομάζεται σε 'tmp_1'</span>
<span class="c1">;; για να αποφευχθεί η σύγκρουση με τα ονόματα</span>
<span class="c1">;; (let ([tmp_1 tmp])</span>
<span class="c1">;;   (set! tmp other)</span>
<span class="c1">;;   (set! other tmp_1))</span>

<span class="c1">;; Αλλά ακόμα υπάρχουν ακόμη μετασχηματισμοί του κώδικα, π.χ.:</span>
<span class="p">(</span><span class="k">define-syntax-rule</span> <span class="p">(</span><span class="nf">bad-while</span> <span class="nv">condition</span> <span class="nv">body</span> <span class="o">...</span><span class="p">)</span>
  <span class="p">(</span><span class="k">when</span> <span class="nv">condition</span>
    <span class="nv">body</span> <span class="o">...</span>
    <span class="p">(</span><span class="nf">bad-while</span> <span class="nv">condition</span> <span class="nv">body</span> <span class="o">...</span><span class="p">)))</span>
<span class="c1">;; αυτή η μακροεντολή είναι χαλασμένη: δημιουργεί ατέρμονα βρόχο</span>
<span class="c1">;; και αν προσπαθήσουμε να το χρησιμοποιήσουμε, ο μεταγλωττιστής</span>
<span class="c1">;; θα μπει στον ατέρμονα βρόχο.</span>

<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; 10. Συμβόλαια (Contracts)</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;; Τα συμβόλαια βάζουν περιορισμούς σε τιμές που προέρχονται</span>
<span class="c1">;; από ενότητες (modules)</span>
<span class="p">(</span><span class="k">module</span> <span class="nv">bank-account</span> <span class="nv">racket</span>
  <span class="p">(</span><span class="k">provide</span> <span class="p">(</span><span class="nf">contract-out</span>
            <span class="p">[</span><span class="nf">deposit</span> <span class="p">(</span><span class="nf">-&gt;</span> <span class="nv">positive?</span> <span class="nv">any</span><span class="p">)]</span> <span class="c1">; οι ποσότητες είναι πάντα θετικές</span>
            <span class="p">[</span><span class="nf">balance</span> <span class="p">(</span><span class="nf">-&gt;</span> <span class="nv">positive?</span><span class="p">)]))</span>

  <span class="p">(</span><span class="k">define</span> <span class="nv">amount</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">deposit</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="k">set!</span> <span class="nv">amount</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">amount</span> <span class="nv">a</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">balance</span><span class="p">)</span> <span class="nv">amount</span><span class="p">)</span>
  <span class="p">)</span>

<span class="p">(</span><span class="k">require</span> <span class="ss">'bank-account</span><span class="p">)</span>
<span class="p">(</span><span class="nf">deposit</span> <span class="mi">5</span><span class="p">)</span>

<span class="p">(</span><span class="nf">balance</span><span class="p">)</span> <span class="c1">; =&gt; 5</span>

<span class="c1">;; Πελάτες που προσπαθούν να καταθέσουν ένα μη θετικό ποσό παίρνουν</span>
<span class="c1">;; το μήνυμα (deposit -5) ; =&gt; deposit: contract violation</span>
<span class="c1">;;                              expected: positive?</span>
<span class="c1">;;                              given: -5</span>
<span class="c1">;;                              more details....</span>

<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; 11. Είσοδος και έξοδος</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;; Η Racket έχει την έννοια του "port", που είναι παρόμοιο με τα</span>
<span class="c1">;; file descriptors σε άλλες γλώσσες.</span>

<span class="c1">;; Ανοίγουμε το "/tmp/tmp.txt" και γράφουμε μέσα "Hello World"</span>
<span class="c1">;; Αυτό θα προκαλούσε σφάλμα αν το αρχείο υπήρχε ήδη</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">out-port</span> <span class="p">(</span><span class="nb">open-output-file</span> <span class="s">"/tmp/tmp.txt"</span><span class="p">))</span>
<span class="p">(</span><span class="nb">displayln</span> <span class="s">"Hello World"</span> <span class="nv">out-port</span><span class="p">)</span>
<span class="p">(</span><span class="nb">close-output-port</span> <span class="nv">out-port</span><span class="p">)</span>

<span class="c1">;; Προσθέτουμε στο τέλος του "/tmp/tmp.txt"</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">out-port</span> <span class="p">(</span><span class="nb">open-output-file</span> <span class="s">"/tmp/tmp.txt"</span>
                                   <span class="nt">#:exists</span> <span class="ss">'append</span><span class="p">))</span>
<span class="p">(</span><span class="nb">displayln</span> <span class="s">"Hola mundo"</span> <span class="nv">out-port</span><span class="p">)</span>
<span class="p">(</span><span class="nb">close-output-port</span> <span class="nv">out-port</span><span class="p">)</span>

<span class="c1">;; Διαβάζουμε από αρχείο ξανά</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">in-port</span> <span class="p">(</span><span class="nb">open-input-file</span> <span class="s">"/tmp/tmp.txt"</span><span class="p">))</span>
<span class="p">(</span><span class="nb">displayln</span> <span class="p">(</span><span class="nb">read-line</span> <span class="nv">in-port</span><span class="p">))</span>
<span class="c1">; =&gt; "Hello World"</span>
<span class="p">(</span><span class="nb">displayln</span> <span class="p">(</span><span class="nb">read-line</span> <span class="nv">in-port</span><span class="p">))</span>
<span class="c1">; =&gt; "Hola mundo"</span>
<span class="p">(</span><span class="nb">close-input-port</span> <span class="nv">in-port</span><span class="p">)</span>

<span class="c1">;; Εναλλακτικά, με το call-with-output-file δεν χρειάζεται να κλείσουμε</span>
<span class="c1">;; ρητά το αρχείο</span>
<span class="p">(</span><span class="nb">call-with-output-file</span> <span class="s">"/tmp/tmp.txt"</span>
  <span class="nt">#:exists</span> <span class="ss">'update</span> <span class="c1">; Rewrite the content</span>
  <span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="nf">out-port</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">displayln</span> <span class="s">"World Hello!"</span> <span class="nv">out-port</span><span class="p">)))</span>

<span class="c1">;; Και το call-with-input-file κάνει το ίδιο πράγμα για την είσοδο</span>
<span class="p">(</span><span class="nb">call-with-input-file</span> <span class="s">"/tmp/tmp.txt"</span>
  <span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="nf">in-port</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">displayln</span> <span class="p">(</span><span class="nb">read-line</span> <span class="nv">in-port</span><span class="p">))))</span>
</code></pre></div>
<h2>Επιπλέον πηγές</h2>

<p>Ψάχνεις για περισσότερα ; <a href="http://docs.racket-lang.org/getting-started/">Getting Started with Racket</a></p>

    <hr>
    <p>Έχετε κάποια πρόταση; Κάποια διόρθωση, ίσως; <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Δημιουργήστε ένα Issue</a> στο Github Repo μας, ή ανοίξτε ένα <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/el-gr/racket-gr.html.markdown">pull request</a>!
    </p>
    <p class="contributed">
    Αρχική συμβολή: th3rac25, ενημερώσεις/επεξεργασία: <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/el-gr/racket-gr.html.markdown">7 contributor(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="https://github.com/voila">th3rac25</a>,
        <a href="https://github.com/elibarzilay">Eli Barzilay</a>,
        <a href="https://github.com/gustavoschmidt">Gustavo Schmidt</a>,
        <a href="https://github.com/cmpitg">Duong H. Nguyen</a>,
        <a href="https://github.com/keyanzhang">Keyan Zhang</a>
    </p>

    <p>
      Translated by:
        <a href="https://github.com/billpcs/">Vasilis Panagiotopoulos</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
