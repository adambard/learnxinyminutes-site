<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="fr-fr" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="fr-fr" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="fr-fr" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="fr-fr" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="fr-fr">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Haskell in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/fr-fr/haskell-fr/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Ffr-fr%2Fhaskell-fr%2F&text=Apprendre+X+en+Y+minutes%2C+o%C3%B9+X%3DHaskell">
        Partager cette page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Choisis un thème:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">clair</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">sombre</button>
  </div>
  <h1><a href="/">Apprendre X en Y minutes</a></h1>
  <h2>Où X=Haskell</h2>
    <p class="filelink">
    Récupérer le code:
    <a href="/docs/files/learnhaskell-fr.hs">learnhaskell-fr.hs</a>
    </p>
  <div id="doc">
    <p>Haskell a été conçu pour être un langage fonctionnel pur et maniable. Il est connu pour ses monades et son système de types, mais je n&#39;ai cesse d&#39;y revenir pour son élégance. Pour moi, Haskell fait de la programmation une joie.</p>
<div class="highlight"><pre><span></span><span class="c1">-- Un commentaire en une ligne commence avec deux tirets.</span>
<span class="cm">{- Un commentaire sur plusieurs lignes peut être contenu dans</span>
<span class="cm">un bloc de cette façon.</span>
<span class="cm">-}</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 1. Types de données primitifs et opérateurs</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Vous avez les nombres</span>
<span class="mi">3</span><span class="w"> </span><span class="c1">-- 3</span>

<span class="c1">-- Les maths sont comme vous vous y attendez</span>
<span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">-- 2</span>
<span class="mi">8</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">-- 7</span>
<span class="mi">10</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="c1">-- 20</span>
<span class="mi">35</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="c1">-- 7.0</span>

<span class="c1">-- La division n&#39;est pas entière par défaut</span>
<span class="mi">35</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="c1">-- 8.75</span>

<span class="c1">-- division entière</span>
<span class="mi">35</span><span class="w"> </span><span class="p">`</span><span class="n">div</span><span class="p">`</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="c1">-- 8</span>

<span class="c1">-- Les booléens sont primitifs</span>
<span class="kt">True</span>
<span class="kt">False</span>

<span class="c1">-- Opérations avec les booléens</span>
<span class="nf">not</span><span class="w"> </span><span class="kt">True</span><span class="w"> </span><span class="c1">-- False</span>
<span class="nf">not</span><span class="w"> </span><span class="kt">False</span><span class="w"> </span><span class="c1">-- True</span>
<span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">-- True</span>
<span class="mi">1</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">-- False</span>
<span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="c1">-- True</span>

<span class="c1">-- Dans les exemples plus hauts, `not` est une fonction qui prend une valeur.</span>
<span class="c1">-- Haskell n&#39;a pas besoin de parenthèses pour appeler une fonction... tous</span>
<span class="c1">-- les arguments sont juste listés après la fonction. Le schéma général est</span>
<span class="c1">-- donc :</span>
<span class="c1">-- func arg1 arg2 arg3...</span>
<span class="c1">-- Voyez la section sur les fonctions pour savoir comment écrire les vôtres.</span>

<span class="c1">-- Caractères et chaînes de caractère</span>
<span class="s">&quot;Ceci est une chaîne de caractère.&quot;</span>
<span class="sc">&#39;a&#39;</span><span class="w"> </span><span class="c1">-- caractère</span>
<span class="kt">&#39;Vous</span><span class="w"> </span><span class="n">ne</span><span class="w"> </span><span class="n">pouvez</span><span class="w"> </span><span class="n">pas</span><span class="w"> </span><span class="n">utiliser</span><span class="w"> </span><span class="n">des</span><span class="w"> </span><span class="n">apostrophes</span><span class="w"> </span><span class="n">pour</span><span class="w"> </span><span class="n">les</span><span class="w"> </span><span class="n">chaînes</span><span class="w"> </span><span class="n">de</span><span class="w"> </span><span class="n">caractère</span><span class="o">.</span><span class="sc">&#39;</span><span class="err"> -- erreur !</span>

<span class="c1">-- Les chaînes peuvent être concaténées</span>
<span class="s">&quot;Hello &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s">&quot;world!&quot;</span><span class="w"> </span><span class="c1">-- &quot;Hello world!&quot;</span>

<span class="c1">-- Une chaîne de caractère est *réellement* une liste</span>
<span class="s">&quot;Ceci est une chaîne.&quot;</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="c1">-- &#39;C&#39;</span>


<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 2. Listes et tuples</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Tous les éléments d&#39;une liste doit avoir le même type.</span>
<span class="c1">-- les deux lignes suivantes sont semblables</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>

<span class="c1">-- Il y a aussi des listes infinies en Haskell !</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span><span class="w"> </span><span class="c1">-- une liste de tous les nombres naturels</span>

<span class="c1">-- Les listes infinies fonctionnent parce que Haskell est « paresseux »:</span>
<span class="c1">-- ça veut dire qu&#39;il n&#39;évalue que ce qui a besoin de l&#39;être. Vous pouvez</span>
<span class="c1">-- donc vous demander le 1000e élément de votre liste et il vous le donnera :</span>

<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="mi">999</span><span class="w"> </span><span class="c1">-- 1000</span>

<span class="c1">-- Et là, Haskell a évalué les éléments 1 à 1000 de la liste... mais le reste</span>
<span class="c1">-- de cette liste « infinie » n&#39;existe pas encore ! En fait, Haskell ne va jamais </span>
<span class="c1">-- le faire à moins qu&#39;il ne le doive.</span>

<span class="c1">-- Adjoindre deux listes </span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="mi">6</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>

<span class="c1">-- ajouter au début de la liste</span>
<span class="mi">0</span><span class="kt">:</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [0, 1, 2, 3, 4, 5]</span>

<span class="c1">-- l&#39;indice d&#39;une liste</span>
<span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">]</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="c1">-- 5</span>

<span class="c1">-- d&#39;autres opérations sur les listes</span>
<span class="nf">head</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- 1</span>
<span class="nf">tail</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [2, 3, 4, 5]</span>
<span class="nf">init</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [1, 2, 3, 4]</span>
<span class="nf">last</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- 5</span>

<span class="c1">--liste en compréhension</span>
<span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]]</span><span class="w"> </span><span class="c1">-- [2, 4, 6, 8, 10]</span>

<span class="c1">--avec un conditionnel</span>
<span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [6, 8, 10]</span>

<span class="c1">-- Chaque élément d&#39;un tuple peut être d&#39;un type différent, mais un</span>
<span class="c1">-- tuple a une longueur fixée.</span>
<span class="c1">-- Un tuple :</span>
<span class="p">(</span><span class="s">&quot;haskell&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="c1">-- accéder aux éléments d&#39;un tuple</span>
<span class="nf">fst</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;haskell&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">-- &quot;haskell&quot;</span>
<span class="nf">snd</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;haskell&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">-- 1</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 3. Functions</span>
<span class="c1">----------------------------------------------------</span>
<span class="c1">-- Une simple fonction qui prend deux paramètres</span>
<span class="nf">add</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span>

<span class="c1">-- Notez que si vous utilisez ghci (l&#39;interpréteur Haskell)</span>
<span class="c1">-- vous devrez utiliser `let`. Par exemple :</span>
<span class="c1">-- let add a b = a + b</span>

<span class="c1">-- Utiliser une fonction</span>
<span class="nf">add</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="c1">-- 3</span>

<span class="c1">-- Vous pouvez également mettre le nom de la fonction entre les</span>
<span class="c1">-- deux arguments avec des accents graves :</span>
<span class="mi">1</span><span class="w"> </span><span class="p">`</span><span class="n">add</span><span class="p">`</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="c1">-- 3</span>

<span class="c1">-- Vous pouvez également définir des fonctions qui n&#39;ont pas de</span>
<span class="c1">-- lettres ! Ça vous laisse créer vos propres opérateurs ! Voilà </span>
<span class="c1">-- un opérateur qui fait une division entière :</span>
<span class="p">(</span><span class="o">//</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">`</span><span class="n">div</span><span class="p">`</span><span class="w"> </span><span class="n">b</span>
<span class="mi">35</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="c1">-- 8</span>

<span class="c1">-- Gardes : Une façon de gérer la valeur de vos arguments en amont</span>
<span class="nf">fib</span><span class="w"> </span><span class="n">x</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>

<span class="c1">-- Le filtrage par motif est similaire. Là, on a donné trois </span>
<span class="c1">-- définitions différentes de `fib`. Haskell appellera automatiquement</span>
<span class="c1">-- la première fonction qui correspond au motif de la valeur.</span>
<span class="nf">fib</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>
<span class="nf">fib</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span>
<span class="nf">fib</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>

<span class="c1">-- Filtrage par motif sur un tuple.</span>
<span class="nf">foo</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>

<span class="c1">-- Filtrage par motif sur des listes. Ici, `x` est le premier</span>
<span class="c1">-- élément de la liste, et `xs` le reste. On peut écrire notre</span>
<span class="c1">-- propre fonction `map` :</span>
<span class="nf">myMap</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span>
<span class="nf">myMap</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="n">x</span><span class="kt">:</span><span class="p">(</span><span class="n">myMap</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span>

<span class="c1">-- Les fonctions anonymes sont créées avec des barres obliques </span>
<span class="c1">-- inverses, suivies de tous les arguments.</span>
<span class="nf">myMap</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [3, 4, 5, 6, 7]</span>

<span class="c1">-- Une utilisation de fold (appelée `inject` dans quelques autres</span>
<span class="c1">-- langages) avec comme paramètre une fonction anonyme.</span>
<span class="c1">-- `foldl1` veut dire fold left -- soit littéralement pli gauche --</span>
<span class="c1">-- et utilise la première valeur de la liste comme accumulateur.</span>
<span class="nf">foldl1</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">acc</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- 15</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 4. Plus de fonctions</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- curryfication : si vous n&#39;appliquez pas tous les arguments à une</span>
<span class="c1">-- fonction, elle devient « curryfiée ». Ça veut dire qu&#39;elle retourne</span>
<span class="c1">-- une fonction qui prend le reste des arguments.</span>

<span class="nf">add</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="c1">-- foo est une fonction qui prend un nombre et y ajoute 10</span>
<span class="nf">foo</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="c1">-- 15</span>

<span class="c1">-- Une autre façon de l&#39;écrire</span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="mi">10</span><span class="p">)</span>
<span class="nf">foo</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="c1">-- 15</span>

<span class="c1">-- Composition de fonctions</span>
<span class="c1">-- la fonction (.) enchaîne deux fonctions.</span>
<span class="c1">-- Par exemple, on a foo qui est une fonction qui prend une valeur, y ajoute</span>
<span class="c1">-- 10 et multiplie ce résultat par 5, et ensuite retourne la valeur finale.</span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="mi">10</span><span class="p">)</span>

<span class="c1">-- (5 + 10) * 5 = 75</span>
<span class="nf">foo</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="c1">-- 75</span>

<span class="c1">-- fixation de priorité</span>
<span class="c1">-- Haskell a une autre fonction appelée `$`. Elle peut changer la priorité</span>
<span class="c1">-- de sorte que tout ce qu&#39;il y a à sa gauche est calculé d&#39;abord et ensuite </span>
<span class="c1">-- appliqué à tout ce qu&#39;il y a à droite. Vous pouvez utiliser `.` et `$` </span>
<span class="c1">-- pour vous débarrasser de beaucoup de parenthèses :</span>

<span class="c1">-- avant</span>
<span class="p">(</span><span class="n">even</span><span class="w"> </span><span class="p">(</span><span class="n">fib</span><span class="w"> </span><span class="mi">7</span><span class="p">))</span><span class="w"> </span><span class="c1">-- False</span>

<span class="c1">-- ensuite</span>
<span class="nf">even</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="c1">-- False</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 5. Signature de type</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Haskell a un système de types très strict : par exemple, tout a un type.</span>

<span class="c1">-- Quelques types simples :</span>
<span class="mi">5</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span>
<span class="s">&quot;hello&quot;</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">String</span>
<span class="kt">True</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Bool</span>

<span class="c1">-- Les fonctions ont également des types.</span>
<span class="c1">-- `not` prend un booléen et retourne un booléen.</span>
<span class="c1">-- not :: Bool -&gt; Bool</span>

<span class="c1">-- Voilà une fonction qui prend deux paramètres.</span>
<span class="c1">-- add :: Integer -&gt; Integer -&gt; Integer</span>

<span class="c1">-- Quand vous définissez une valeur (souvenez-vous, tout est valeur en</span>
<span class="c1">-- Haskell), une bonne pratique est d&#39;écrire son type explicitement</span>
<span class="nf">double</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span>
<span class="nf">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 6. Flux de contrôle et structures conditionnelles</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- structure conditionnelle if</span>
<span class="nf">haskell</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="s">&quot;awesome&quot;</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="s">&quot;awful&quot;</span><span class="w"> </span><span class="c1">-- haskell = &quot;awesome&quot;</span>

<span class="c1">-- les structures if peuvent être écrites sur plusieurs lignes</span>
<span class="nf">haskell</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span>
<span class="w">            </span><span class="kr">then</span><span class="w"> </span><span class="s">&quot;awesome&quot;</span>
<span class="w">            </span><span class="kr">else</span><span class="w"> </span><span class="s">&quot;awful&quot;</span>

<span class="c1">-- les structures case : voilà comment vous pourriez analyser les arguments de </span>
<span class="c1">-- ligne de commande</span>
<span class="kr">case</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="kr">of</span>
<span class="w">  </span><span class="s">&quot;help&quot;</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">printHelp</span>
<span class="w">  </span><span class="s">&quot;start&quot;</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">startProgram</span>
<span class="w">  </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;bad args&quot;</span>


<span class="c1">-- Haskell n&#39;a pas de boucles parce qu&#39;il utilise la récursion.</span>
<span class="c1">-- `map` applique une fonction sur chaque élément d&#39;une liste</span>

<span class="nf">map</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [2, 4, 6, 8, 10]</span>

<span class="c1">-- vous pouvez créer une fonction `for` en utilisant `map`</span>
<span class="nf">for</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="n">array</span>

<span class="c1">-- et l&#39;utiliser</span>
<span class="nf">for</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="nf">\</span><span class="n">i</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="n">i</span>

<span class="c1">-- nous aurions pu l&#39;écrire également ainsi</span>
<span class="nf">for</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="n">show</span>

<span class="c1">-- vous pouvez utiliser foldl et foldr pour </span>
<span class="c1">-- réduire une liste</span>
<span class="c1">-- foldl &lt;fonction&gt; &lt;valeur initiale&gt; &lt;liste&gt;</span>
<span class="nf">foldl</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="c1">-- 43</span>

<span class="c1">-- C&#39;est donc la même chose que </span>
<span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>

<span class="c1">-- foldl évalue de gauche à droite, foldr</span>
<span class="c1">-- de droite à gauche</span>
<span class="nf">foldr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="c1">-- 16</span>

<span class="c1">-- Et c&#39;est équivalent à</span>
<span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">)))</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 7. Types de données</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Vous pouvez écrire vos propres types de données en Haskell</span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Couleur</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Rouge</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Bleu</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Vert</span>

<span class="c1">-- Et maintenant l&#39;utiliser dans une fonction</span>


<span class="nf">say</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Couleur</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span>
<span class="nf">say</span><span class="w"> </span><span class="kt">Rouge</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Vous êtes Rouge !&quot;</span>
<span class="nf">say</span><span class="w"> </span><span class="kt">Bleu</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Vous êtes Bleu !&quot;</span>
<span class="nf">say</span><span class="w"> </span><span class="kt">Vert</span><span class="w"> </span><span class="ow">=</span><span class="w">  </span><span class="s">&quot;Vous êtes Vert !&quot;</span>

<span class="c1">-- Vos types peuvent également avoir des paramètres</span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Nothing</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="n">a</span>

<span class="c1">-- Tous les exemples ci-dessous sont issus du type Maybe</span>
<span class="kt">Just</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="w">    </span><span class="c1">-- of type `Maybe String`</span>
<span class="kt">Just</span><span class="w"> </span><span class="mi">1</span><span class="w">          </span><span class="c1">-- of type `Maybe Int`</span>
<span class="kt">Nothing</span><span class="w">         </span><span class="c1">-- of type `Maybe a` for any `a`</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 8. Haskell IO</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Tandis que l&#39;IO ne peut pas être totalement expliqué pleinement</span>
<span class="c1">-- sans que les monades ne le soient, il n&#39;est pas difficile</span>
<span class="c1">-- d&#39;expliquer suffisamment pour commencer.</span>

<span class="c1">-- Quand un programme en Haskell est exécuté, la fonction `main`</span>
<span class="c1">-- est appelée. Il doit retourner une valeur de type `IO ()`.</span>
<span class="c1">-- Par exemple :</span>

<span class="nf">main</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span>
<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">putStrLn</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="s">&quot;Bonjour, le ciel ! &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">(</span><span class="n">say</span><span class="w"> </span><span class="kt">Blue</span><span class="p">)</span><span class="w"> </span>
<span class="c1">-- putStrLn a comme type String -&gt; IO ()</span>

<span class="c1">-- La façon la plus simple pour faire de l&#39;IO est de faire un programme </span>
<span class="c1">-- fonction de String vers String. La fonction</span>
<span class="c1">--    interact :: (String -&gt; String) -&gt; IO ()</span>
<span class="c1">-- prend un texte, applique une fonction et affiche le résultat.</span>

<span class="nf">countLines</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span>
<span class="nf">countLines</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">lines</span>

<span class="nf">main&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">interact</span><span class="w"> </span><span class="n">countLines</span>

<span class="c1">-- Vous pouvez considérer qu&#39;une valeur de type `IO ()` représente</span>
<span class="c1">-- une séquence d&#39;actions que l&#39;ordinateur exécute, un peu comme </span>
<span class="c1">-- dans un langage impératif. On peut utiliser la structure `do` </span>
<span class="c1">-- pour enchaîner des actions. Par exemple :</span>

<span class="nf">sayHello</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span>
<span class="nf">sayHello</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span>
<span class="w">   </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;Quel est ton nom ?&quot;</span>
<span class="w">   </span><span class="n">name</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getLine</span><span class="w"> </span><span class="c1">-- prend une ligne et assigne sa valeur à `name`</span>
<span class="w">   </span><span class="n">putStrLn</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="s">&quot;Salut, &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">name</span>

<span class="c1">-- Exercice : écrire votre propre version d&#39;`interact` qui ne fait </span>
<span class="c1">--           que de lire une ligne d&#39;entrée.</span>

<span class="c1">-- Le code de `sayHello` ne sera jamais exécuté, cependant. La seule</span>
<span class="c1">-- action qui sera exécutée est la valeur de `main`.</span>
<span class="c1">-- Pour lancer `sayHello`, commentez l&#39;ancienne définition de `main`</span>
<span class="c1">-- et remplacez-le par :</span>
<span class="c1">--   main = sayHello</span>

<span class="c1">-- Essaions de mieux comprendre comment la fonction `getLine` que </span>
<span class="c1">-- nous venons d&#39;utiliser. Son type est :</span>
<span class="c1">--    getLine :: IO String</span>
<span class="c1">-- vous pouvez considérer le type `IO a` comme un programme que</span>
<span class="c1">-- le programme va générer comme une valeur de type `a` quand</span>
<span class="c1">-- il sera exécuté. On peut l&#39;enregistrer et la réutiliser en</span>
<span class="c1">-- utilisant `&lt;-`. On peut aussi faire nos propres actions</span>
<span class="c1">-- de type `IO String` :</span>

<span class="nf">action</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">String</span>
<span class="nf">action</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span>
<span class="w">   </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;C&#39;est une ligne. Heu&quot;</span>
<span class="w">   </span><span class="n">input1</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getLine</span><span class="w"> </span>
<span class="w">   </span><span class="n">input2</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getLine</span>
<span class="w">   </span><span class="c1">-- Le type de la structure `do` est celui de sa dernière ligne.</span>
<span class="w">   </span><span class="c1">-- `return` n&#39;est pas un mot clef, mais simplement une fonction.</span>
<span class="w">   </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">input1</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">input2</span><span class="p">)</span><span class="w"> </span><span class="c1">-- return :: String -&gt; IO String</span>

<span class="c1">-- On peut maintenant l&#39;utiliser comme on a utilisé `getLine`</span>
<span class="c1">-- tout à l&#39;heure</span>

<span class="nf">main&#39;&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span>
<span class="w">    </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;Je vais afficher deux lignes !&quot;</span>
<span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">action</span><span class="w"> </span>
<span class="w">    </span><span class="n">putStrLn</span><span class="w"> </span><span class="n">result</span>
<span class="w">    </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;C&#39;était tout !&quot;</span>

<span class="c1">-- Le type `IO` est un exemple de « monade ». La façon dont Haskell utilise</span>
<span class="c1">-- une monade pour faire de l&#39;IO lui permet d&#39;être purement fonctionnel. N&#39;importe</span>
<span class="c1">-- quelle fonction qui interagit avec le « monde extérieur » (c&#39;est à dire fait de l&#39;IO)</span>
<span class="c1">-- devient marqué comme `IO` dans la signature de son type. Ça nous montre</span>
<span class="c1">-- quelles fonctions sont « pures » (n&#39;interagissent pas avec le monde extérieur</span>
<span class="c1">-- ou ne changent pas d&#39;état) et quelles fonctions ne le sont pas.</span>

<span class="c1">-- C&#39;est une fonctionnalité très puissante, car il est facile d&#39;exécuter </span>
<span class="c1">-- des fonctions pures simultanément, et donc la concurrence en Haskell</span>
<span class="c1">-- est très facile.</span>


<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 9. Le REPL de Haskell</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Lancer le REPL en tapant `ghci`.</span>
<span class="c1">-- Vous pouvez maintenant taper du code Haskell.</span>
<span class="c1">-- Toutes les nouvelles valeurs peuvent être crées </span>
<span class="c1">-- avec `let` :</span>

<span class="kr">let</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">5</span>

<span class="c1">-- Vous pouvez voir le type de n&#39;importe quelle valeur avec `:t` :</span>

<span class="o">&gt;:</span><span class="n">t</span><span class="w"> </span><span class="n">foo</span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span>

<span class="c1">-- Vous pouvez également lancer des actions de type `IO ()`</span>

<span class="o">&gt;</span><span class="w"> </span><span class="n">sayHello</span>
<span class="kt">Quel</span><span class="w"> </span><span class="n">est</span><span class="w"> </span><span class="n">ton</span><span class="w"> </span><span class="n">nom</span><span class="w"> </span><span class="o">?</span>
<span class="kt">Ami</span>
<span class="kt">Salut</span><span class="p">,</span><span class="w"> </span><span class="kt">Ami</span><span class="w"> </span><span class="o">!</span>
</pre></div>
<p>Et Haskell ne se limite pas à ça, on trouve encore par exemple les classes de types et les monades. Il y a beaucoup de raisons qui font que coder en Haskell est si <em>fun</em>. Je vous laisse avec un dernier exemple : une implémentation de quicksort :</p>
<div class="highlight"><pre><span></span><span class="nf">qsort</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span>
<span class="nf">qsort</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">qsort</span><span class="w"> </span><span class="n">lesser</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">qsort</span><span class="w"> </span><span class="n">greater</span>
<span class="w">    </span><span class="kr">where</span><span class="w"> </span><span class="n">lesser</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span>
<span class="w">          </span><span class="n">greater</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="o">&gt;=</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span>
</pre></div>
<p>Haskell facile à installer. Téléchargez-le <a href="http://www.haskell.org/platform/">ici</a>.</p>

<p>Vous pouvez trouver une approche beaucoup plus douce avec les excellents
<a href="http://lyah.haskell.fr/">Learn you a Haskell</a> ou
<a href="http://book.realworldhaskell.org/">Real World Haskell (en)</a>.</p>

    <hr>
    <p>Vous avez une suggestion ? Peut-être une correction ? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Ouvrez un ticket</a> sur Github, ou faites vous-même une <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/fr-fr/haskell-fr.html.markdown">pull request</a> !
    </p>
    <p class="contributed">
    Version originale par Adit Bhargava, mis à jour par <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/fr-fr/haskell-fr.html.markdown">0 contributeur(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://adit.io">Adit Bhargava</a>
    </p>

    <p>
      Translated by:
        <a href="http://davidbaumgartner.ch">David Baumgartner</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
