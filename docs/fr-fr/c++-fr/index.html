<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="fr-fr" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="fr-fr" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="fr-fr" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="fr-fr" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="fr-fr">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn C++ in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/fr-fr/c++-fr/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Ffr-fr%2Fc%2B%2B-fr%2F&text=Apprendre+X+en+Y+minutes%2C+o%C3%B9+X%3DC%2B%2B">
        Partager cette page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Choisis un thème:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">clair</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">sombre</button>
  </div>
  <h1><a href="/">Apprendre X en Y minutes</a></h1>
  <h2>Où X=C++</h2>
    <p class="filelink">
    Récupérer le code:
    <a href="/docs/files/learncpp-fr.cpp">learncpp-fr.cpp</a>
    </p>
  <div id="doc">
    <p>C++ est un langage de programmation système qui,
<a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">selon son créateur Bjarne Stroustrup</a>,
fut créé pour</p>

<ul>
<li>être un &ldquo;C amélioré&rdquo;</li>
<li>gérer l&#39;abstraction des données</li>
<li>gérer la programmation orienté objet</li>
<li>gérer la programmation générique</li>
</ul>

<p>Bien que sa syntaxe puisse être plus difficile ou complexe que des langages
récents, il est largement utilisé car il compile en instructions natives qui
peuvent être directement exécutées par le processeur et offre un contrôle
rigoureux du matériel (comme le C) tout en fournissant des caractéristiques de
haut niveau telles que la généricité, les exceptions et les classes.
Cette combinaison de vitesse et de fonctionnalités rend le C++ un des langages
de programmation les plus utilisés au monde.</p>
<div class="highlight"><pre><span></span><span class="c1">/////////////////////////////////</span>
<span class="c1">// Comparaison avec le C</span>
<span class="c1">/////////////////////////////////</span>

<span class="c1">// C++ est _presque_ un sur-ensemble du C et partage sa syntaxe basique pour les</span>
<span class="c1">// déclarations de variables, les types primitifs et les fonctions.</span>

<span class="c1">// Tout comme en C, le point d&#39;entrée de votre programme est une fonction</span>
<span class="c1">// appelée main, avec un integer comme type de retour.</span>
<span class="c1">// Cette valeur constitue l&#39;état de fin d&#39;exécution du programme.</span>
<span class="c1">// Voir http://en.wikipedia.org/wiki/Exit_status pour plus d&#39;informations.</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Les arguments de ligne de commande sont passés avec argc et argv de la</span>
<span class="w">    </span><span class="c1">// même manière qu&#39;en C.</span>
<span class="w">    </span><span class="c1">// argc indique le nombre d&#39;arguments,</span>
<span class="w">    </span><span class="c1">// et argv est un tableau de chaînes façon C (char*)</span>
<span class="w">    </span><span class="c1">// représentant les arguments.</span>
<span class="w">    </span><span class="c1">// Le premier argument est le nom par lequel le programme est appelé.</span>
<span class="w">    </span><span class="c1">// argc et argv peuvent être omis si vous ne vous souciez pas des</span>
<span class="w">    </span><span class="c1">// arguments, nous donnant comme signature de fonction int main()</span>

<span class="w">    </span><span class="c1">// Un état de fin d&#39;exécution 0 indique le succès.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Cependant, C++ varie du C selon certains éléments:</span>

<span class="c1">// En C++, les caractères littéraux sont des chars</span>
<span class="k">sizeof</span><span class="p">(</span><span class="sc">&#39;c&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span>

<span class="c1">// En C, les caractères littéraux sont des ints</span>
<span class="k">sizeof</span><span class="p">(</span><span class="sc">&#39;c&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>

<span class="c1">// C++ a un prototypage strict</span>
<span class="kt">void</span><span class="w"> </span><span class="n">func</span><span class="p">();</span><span class="w"> </span><span class="c1">// fonction qui ne prend aucun argument</span>

<span class="c1">// En C</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">();</span><span class="w"> </span><span class="c1">// fonction qui peut prendre n&#39;importe quel nombre d&#39;arguments</span>

<span class="c1">// Utilise nullptr au lieu de NULL en C++</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="c1">// Les en-têtes standards du C sont disponibles en C++,</span>
<span class="c1">// mais sont préfixés avec &quot;c&quot; et n&#39;ont pas de suffixe .h</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdio&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Bonjour tout le monde!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/////////////////////////////////</span>
<span class="c1">// Surchage de fonctions</span>
<span class="c1">/////////////////////////////////</span>

<span class="c1">// C++ gère la surchage de fonctions</span>
<span class="c1">// Chaque fonction fournie prend différents paramètres.</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">maChaine</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Chaîne %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">maChaine</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">monEntier</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Mon entier est %d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">monEntier</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;Bonjour&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Utilise void print(const char*)</span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span><span class="w"> </span><span class="c1">// Utilise void print(int)</span>
<span class="p">}</span>

<span class="c1">/////////////////////////////////////////////</span>
<span class="c1">// Arguments par défaut de fonctions</span>
<span class="c1">/////////////////////////////////////////////</span>

<span class="c1">// Vous pouvez fournir des arguments par défaut pour une fonction s&#39;ils ne sont</span>
<span class="c1">// pas fournis par l&#39;appelant.</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">faitDesChosesAvecDesEntiers</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Do something with the ints here</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">faitDesChosesAvecDesEntiers</span><span class="p">();</span><span class="w">      </span><span class="c1">// a = 1,  b = 4</span>
<span class="w">    </span><span class="n">faitDesChosesAvecDesEntiers</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w">    </span><span class="c1">// a = 20, b = 4</span>
<span class="w">    </span><span class="n">faitDesChosesAvecDesEntiers</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// a = 20, b = 5</span>
<span class="p">}</span>

<span class="c1">// Les arguments par défaut doivent être à la fin de la liste des arguments.</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">invalidDeclaration</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="c1">// Erreur !</span>
<span class="p">{</span>
<span class="p">}</span>


<span class="c1">//////////////////////////</span>
<span class="c1">// Espaces de nom</span>
<span class="c1">//////////////////////////</span>

<span class="c1">// Les espaces de nom fournissent une séparation des portées pour les</span>
<span class="c1">// variables, fonctions, et autres déclarations.</span>
<span class="c1">// Les espaces de nom peuvent être imbriqués.</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">Premier</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Imbrique</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Ceci est le Premier::Imbrique::foo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// fin de l&#39;espace de nom Imbrique</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// fin de l&#39;espace de nom Premier</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">Second</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Ceci est le Second::foo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Ceci est un foo global</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Inclut tous les symboles de l&#39;espace de nom Second dans la portée</span>
<span class="w">    </span><span class="c1">// actuelle. Notez que le foo() simple ne marche plus, car l&#39;appel est</span>
<span class="w">    </span><span class="c1">// ambigu entre le foo de l&#39;espace de nom Second et celui de premier</span>
<span class="w">    </span><span class="c1">// niveau.</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Second</span><span class="p">;</span>

<span class="w">    </span><span class="n">Second</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// imprime &quot;Ceci est le Second::foo&quot;</span>
<span class="w">    </span><span class="n">Premier</span><span class="o">::</span><span class="n">Imbrique</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// imprime &quot;Ceci est le Premier::Imbrique::foo&quot;</span>
<span class="w">    </span><span class="o">::</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// imprime &quot;Ceci est un foo global&quot;</span>
<span class="p">}</span>

<span class="c1">/////////////////////////</span>
<span class="c1">// Entrée/Sortie</span>
<span class="c1">/////////////////////////</span>

<span class="c1">// Les entrées et sorties en C++ utilisent des flux (streams)</span>
<span class="c1">// cin, cout et cerr représentent stdin, stdout et stderr.</span>
<span class="c1">// &lt;&lt; est l&#39;opérateur d&#39;insertion et &gt;&gt; est l&#39;opérateur d&#39;extraction.</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="c1"> // Inclusion pour les flux d&#39;entrée/sortie</span>

<span class="c1">// Les flux sont dans l&#39;espace de nom std (librairie standard)</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">monEntier</span><span class="p">;</span>

<span class="w">   </span><span class="c1">// Affiche sur stdout (ou le terminal/l&#39;écran)</span>
<span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Entrez votre chiffre favori:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">   </span><span class="c1">// Prend l&#39;entrée clavier</span>
<span class="w">   </span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">monEntier</span><span class="p">;</span>

<span class="w">   </span><span class="c1">// cout peut également être formaté</span>
<span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Votre chiffre favori est &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">monEntier</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">   </span><span class="c1">// imprime &quot;Votre chiffre favori est &lt;monEntier&gt;&quot;</span>

<span class="w">    </span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Utilisé pour les messages d&#39;erreurs&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/////////////////////////////////</span>
<span class="c1">// Chaînes de caractères</span>
<span class="c1">/////////////////////////////////</span>

<span class="c1">// Les chaînes de caractères en C++ sont des objets et ont plusieurs fonctions</span>
<span class="c1">// membres</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>

<span class="c1">// Les chaînes de caractères sont aussi dans l&#39;espace de</span>
<span class="c1">// nom std (librairie standard)</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="n">string</span><span class="w"> </span><span class="n">maChaine</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Bonjour&quot;</span><span class="p">;</span>
<span class="n">string</span><span class="w"> </span><span class="n">monAutreChaine</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot; tout le monde !&quot;</span><span class="p">;</span>

<span class="c1">// + est utilisé pour la concaténation.</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">maChaine</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">monAutreChaine</span><span class="p">;</span><span class="w"> </span><span class="c1">// Bonjour tout le monde !&quot;</span>

<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">maChaine</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; toi !&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;Bonjour toi !&quot;</span>

<span class="c1">// Les chaînes de caractères C++ sont mutables.</span>
<span class="n">maChaine</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot; le chien !&quot;</span><span class="p">);</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">maChaine</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;Bonjour le chien !&quot;</span>


<span class="c1">//////////////////////</span>
<span class="c1">// Références</span>
<span class="c1">//////////////////////</span>

<span class="c1">// En plus des pointeurs comme ceux en C,</span>
<span class="c1">// C++ possède des _références_.</span>
<span class="c1">// Ce sont des types de pointeurs qui ne peuvent pas être réassignés</span>
<span class="c1">// une fois initialisés, et ne peuvent pas être nulles.</span>
<span class="c1">// Ils partagent la même syntaxe que les variables elles-mêmes:</span>
<span class="c1">// les * ne sont pas nécessaires pour les déréférencer et</span>
<span class="c1">// &amp; (addresse de) n&#39;est pas utilisé pour l&#39;assignement.</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="n">string</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Je suis foo&quot;</span><span class="p">;</span>
<span class="n">string</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Je suis bar&quot;</span><span class="p">;</span>


<span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">fooRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w"> </span><span class="c1">// Ceci créé une référence à foo</span>
<span class="n">fooRef</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;. Salut!&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Modifie foo à travers la référence</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fooRef</span><span class="p">;</span><span class="w"> </span><span class="c1">// Affiche &quot;Je suis foo. Salut!&quot;</span>

<span class="c1">// Ne réassigne pas &quot;fooRef&quot;. Ceci revient à faire &quot;foo = bar&quot;, et</span>
<span class="c1">// foo == &quot;I am bar&quot;</span>
<span class="c1">// après cette ligne.</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fooRef</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Affiche l&#39;adresse de foo</span>
<span class="n">fooRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fooRef</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Affiche toujours l&#39;adresse de foo</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fooRef</span><span class="p">;</span><span class="w">  </span><span class="c1">// Affiche &quot;Je suis bar&quot;</span>

<span class="c1">// L&#39;adresse de fooRef reste la même, c.-à-d. référence toujours foo.</span>


<span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">barRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span><span class="w"> </span><span class="c1">// Créé une référence constante de bar.</span>
<span class="c1">// Comme en C, les valeurs constantes (et pointeurs et références) ne peuvent</span>
<span class="c1">// être modifiées.</span>

<span class="c1">// Erreur, les valeurs constantes ne peuvent être modifiées.</span>
<span class="n">barRef</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;. Salut!&quot;</span><span class="p">;</span>

<span class="c1">// Parenthèse: avant de développer le sujet des références, nous devons</span>
<span class="c1">// introduire un concept appelé un objet temporaire. Supposons que nous ayons</span>
<span class="c1">// le code suivant :</span>
<span class="n">string</span><span class="w"> </span><span class="nf">objetTemporaireFun</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="n">string</span><span class="w"> </span><span class="n">valeurRetenu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">objetTemporaireFun</span><span class="p">();</span>

<span class="c1">// Les différents événements se déroulant à la seconde ligne sont :</span>
<span class="c1">//   - un objet chaîne de caractères est retourné de objetTemporaireFun</span>
<span class="c1">//   - une nouvelle chaîne de caractères est construite avec la valeur</span>
<span class="c1">//     retournée comme argument du constructeur</span>
<span class="c1">//   - l&#39;objet retourné est détruit.</span>
<span class="c1">// L&#39;objet retourné est appelé un objet temporaire. Les objets temporaires sont</span>
<span class="c1">// créés chaque fois qu&#39;une fonction retourne un objet, et sont détruits à la</span>
<span class="c1">// fin de l&#39;évaluation de l&#39;expression fermante (c&#39;est ce que le standard</span>
<span class="c1">// énonce, mais les compilateurs sont autorisés à changer ce comportement.</span>
<span class="c1">// Cherchez &quot;optimisation valeur de retour&quot; si vous êtes intéressé par ce genre</span>
<span class="c1">// de détails).</span>
<span class="c1">// Dans cette ligne de code :</span>
<span class="n">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">(</span><span class="n">objetTemporaireFun</span><span class="p">()))</span>

<span class="c1">// en supposant que foo et bar existent, l&#39;objet retourné de objetTemporaireFun</span>
<span class="c1">// est passé à bar, et est détruit avant que foo soit appelé.</span>

<span class="c1">// Revenons maintenant aux références. L&#39;exception à la règle &quot;objet détruit à</span>
<span class="c1">// la fin de l&#39;expression fermante&quot; s&#39;applique dans le cas d&#39;un objet</span>
<span class="c1">// temporaire lié à une référence constante, où sa durée de vie se voit</span>
<span class="c1">// prolongée à la portée courante :</span>

<span class="kt">void</span><span class="w"> </span><span class="n">referenceConstanteObjetTemporaireFun</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// referenceConst prend l&#39;objet temporaire, et est valide jusqu&#39;à la fin de</span>
<span class="w">  </span><span class="c1">// la fonction.</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">referenceConst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">objetTemporaireFun</span><span class="p">();</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>

<span class="c1">// Un autre type de référence introduit en C++11 est spécifiquement pour les</span>
<span class="c1">// objets temporaires. Vous ne pouvez pas avoir de variable de ce type, mais</span>
<span class="c1">// il prime dans la résolution de surcharge :</span>

<span class="kt">void</span><span class="w"> </span><span class="n">fonctionFun</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">  </span><span class="c1">// Référence régulière</span>
<span class="kt">void</span><span class="w"> </span><span class="n">fonctionFun</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">  </span><span class="c1">// Référence un objet temporaire</span>

<span class="n">string</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>
<span class="c1">// Appelle la version avec référence régulière</span>
<span class="n">fonctionFun</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>

<span class="c1">// Appelle la version avec référence temporaire</span>
<span class="n">fonctionFun</span><span class="p">(</span><span class="n">objetTemporaireFun</span><span class="p">());</span>

<span class="c1">// Par exemple, vous aurez ces deux versions de constructeurs pour</span>
<span class="c1">// std::basic_string :</span>
<span class="n">basic_string</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">basic_string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
<span class="n">basic_string</span><span class="p">(</span><span class="n">basic_string</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>

<span class="c1">// L&#39;idéal étant de construire une nouvelle chaîne de caractères avec un objet</span>
<span class="c1">// temporaire (qui sera détruit de toute façon), nous pouvons ainsi avoir un</span>
<span class="c1">// constructeur qui &quot;sauve&quot; des parties de cette chaîne de caractères</span>
<span class="c1">// temporaire. Vous verrez ce concept sous le nom de &quot;sémantique de mouvement&quot;.</span>

<span class="c1">////////////////////////</span>
<span class="c1">// Enumérations</span>
<span class="c1">////////////////////////</span>

<span class="c1">// Les énumérations sont un moyen d&#39;assigner une valeur à une constante</span>
<span class="c1">// fréquemment utilisée pour une meilleure visualisation et lecture du code.</span>
<span class="k">enum</span><span class="w"> </span><span class="nc">ETypesDeVoitures</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Berline</span><span class="p">,</span>
<span class="w">  </span><span class="n">Hayon</span><span class="p">,</span>
<span class="w">  </span><span class="mi">4</span><span class="n">x4</span><span class="p">,</span>
<span class="w">  </span><span class="n">Break</span>
<span class="p">};</span>

<span class="n">ETypesDeVoitures</span><span class="w"> </span><span class="nf">ObtenirVoiturePreferee</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ETypesDeVoitures</span><span class="o">::</span><span class="n">Hayon</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// En C++11, il existe une manière simple d&#39;assigner un type à une énumération,</span>
<span class="c1">// ce qui peut-être utile en sérialisation de données et conversion</span>
<span class="c1">// d&#39;énumérations entre le type voulu et ses constantes respectives.</span>
<span class="k">enum</span><span class="w"> </span><span class="nc">ETypesDeVoitures</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">uint8_t</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Berline</span><span class="p">,</span><span class="w"> </span><span class="c1">// 0</span>
<span class="w">  </span><span class="n">Hayon</span><span class="p">,</span><span class="w"> </span><span class="c1">// 1</span>
<span class="w">  </span><span class="mi">4</span><span class="n">x4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">254</span><span class="p">,</span><span class="w"> </span><span class="c1">// 254</span>
<span class="w">  </span><span class="n">Hybride</span><span class="w"> </span><span class="c1">// 255</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">EcrireOctetDansLeFichier</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ValeurEntree</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Sérialise la valeur d&#39;entrée dans un fichier</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">EcrireTypeVoiturePrefereDansLeFichier</span><span class="p">(</span><span class="n">ETypesDeVoitures</span><span class="w"> </span><span class="n">TypeVoitureEntree</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// L&#39;énumération est implicitement convertie en uint8_t du à la déclaration</span>
<span class="w">    </span><span class="c1">// de son type d&#39;énumération</span>
<span class="w">    </span><span class="n">EcrireOctetDansLeFichier</span><span class="p">(</span><span class="n">TypeVoitureEntree</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// D&#39;autre part, vous pourriez ne pas vouloir que des énumérations soient</span>
<span class="c1">// accidentellement converties en entiers ou en d&#39;autres énumérations. Il est</span>
<span class="c1">// donc possible de créer une classe d&#39;énumération qui ne sera pas</span>
<span class="c1">// implicitement convertie.</span>
<span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">ETypesDeVoitures</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">uint8_t</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Berline</span><span class="p">,</span><span class="w"> </span><span class="c1">// 0</span>
<span class="w">  </span><span class="n">Hayon</span><span class="p">,</span><span class="w"> </span><span class="c1">// 1</span>
<span class="w">  </span><span class="mi">4</span><span class="n">x4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">254</span><span class="p">,</span><span class="w"> </span><span class="c1">// 254</span>
<span class="w">  </span><span class="n">Hybride</span><span class="w"> </span><span class="c1">// 255</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">EcrireOctetDansLeFichier</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ValeurEntree</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Sérialise la valeur d&#39;entrée dans un fichier</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">EcrireTypeVoiturePrefereDansLeFichier</span><span class="p">(</span><span class="n">ETypesDeVoitures</span><span class="w"> </span><span class="n">TypeVoitureEntree</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Ne compilera pas même si ETypesDeVoitures est un uint8_t car</span>
<span class="w">    </span><span class="c1">// l&#39;énumération est déclarée en tant que &quot;classe d&#39;énumération&quot; !</span>
<span class="w">    </span><span class="n">EcrireOctetDansLeFichier</span><span class="p">(</span><span class="n">TypeVoitureEntree</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">///////////////////////////////////////////////////</span>
<span class="c1">// Classes et programmation orientée objet</span>
<span class="c1">///////////////////////////////////////////////////</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="c1">// Déclare une classe.</span>
<span class="c1">// Les classes sont habituellement déclarées dans les fichiers d&#39;en-tête (.h ou .hpp).</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Chien</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Les variables et fonctions membres sont privées par défaut.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">nom</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">poids</span><span class="p">;</span>

<span class="c1">// Tous les membres suivants sont publiques jusqu&#39;à ce que &quot;private:&quot; ou</span>
<span class="c1">// &quot;protected:&quot; soit trouvé</span>
<span class="k">public</span><span class="o">:</span>

<span class="w">    </span><span class="c1">// Constructeur par défaut</span>
<span class="w">    </span><span class="n">Chien</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Déclaractions de fonctions membres (implémentations à suivre)</span>
<span class="w">    </span><span class="c1">// Notez que nous utilisons std::string ici au lieu de placer</span>
<span class="w">    </span><span class="c1">// using namespace std;</span>
<span class="w">    </span><span class="c1">// au-dessus.</span>
<span class="w">    </span><span class="c1">// Ne jamais utiliser une instruction &quot;using namespace&quot; dans l&#39;en-tête.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">initialiserNom</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">nomDuChien</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">initialiserPoids</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">poidsDuChien</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Les fonctions qui ne modifient pas l&#39;état de l&#39;objet devraient être</span>
<span class="w">    </span><span class="c1">// marquées en constantes avec const.</span>
<span class="w">    </span><span class="c1">// Ceci vous permet de les appeler avec une référence constante vers l&#39;objet.</span>
<span class="w">    </span><span class="c1">// Notez aussi que les fonctions devant être surchargées dans des classes</span>
<span class="w">    </span><span class="c1">// dérivées doivent être explicitement déclarées avec _virtual_.</span>
<span class="w">    </span><span class="c1">// Les fonctions ne sont pas virtuelles par défault pour des raisons de</span>
<span class="w">    </span><span class="c1">// performances.</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">imprimer</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Les fonctions peuvent également être définies à l&#39;intérieur du corps de</span>
<span class="w">    </span><span class="c1">// la classe. Ces fonctions sont automatiquement &quot;inline&quot;.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">aboyer</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">nom</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; fait ouaf !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// En plus des constructeurs, C++ fournit des destructeurs.</span>
<span class="w">    </span><span class="c1">// Ils sont appelés quand l&#39;objet est supprimé ou dépasse le cadre de sa</span>
<span class="w">    </span><span class="c1">// portée. Ceci permet de puissants paradigmes tels que RAII</span>
<span class="w">    </span><span class="c1">// (voir plus loin)</span>
<span class="w">    </span><span class="c1">// Le destructeur devrait être virtuel si la classe est abstraite;</span>
<span class="w">    </span><span class="c1">// s&#39;il n&#39;est pas virtuel, alors le destructeur de la classe dérivée ne</span>
<span class="w">    </span><span class="c1">// sera pas appelé si l&#39;objet est détruit par le biais d&#39;une référence à la</span>
<span class="w">    </span><span class="c1">// classe de base ou d&#39;un pointeur.</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Chien</span><span class="p">();</span>

<span class="p">};</span><span class="w"> </span><span class="c1">// Un point virgule doit clôre la définition de la classe.</span>

<span class="c1">// Les fonctions membres de la classe sont habituellement implémentées dans des</span>
<span class="c1">// fichiers .cpp.</span>
<span class="n">Chien</span><span class="o">::</span><span class="n">Chien</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Un chien a été construit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Les objets (comme les chaînes de caractères) devraient être passés par</span>
<span class="c1">// référence si vous les modifiez ou par référence constante si vous ne les</span>
<span class="c1">// modifiez pas.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">Chien</span><span class="o">::</span><span class="n">initialiserNom</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">nomDuChien</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">nom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nomDuChien</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">Chien</span><span class="o">::</span><span class="n">initialiserPoids</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">poidsDuChien</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">poids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">poidsDuChien</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Notez que le mot-clé &quot;virtual&quot; est nécessaire uniquement à la déclaration,</span>
<span class="c1">// et non à la définition.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">Chien</span><span class="o">::</span><span class="n">imprimer</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Le chien s&#39;appelle &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">nom</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; et pèse &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">poids</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;kg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Chien</span><span class="o">::~</span><span class="n">Chien</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Au revoir &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">nom</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Chien</span><span class="w"> </span><span class="n">monChien</span><span class="p">;</span><span class="w"> </span><span class="c1">// imprime &quot;Un chien a été construit&quot;</span>
<span class="w">    </span><span class="n">monChien</span><span class="p">.</span><span class="n">initialiserNom</span><span class="p">(</span><span class="s">&quot;Barkley&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">monChien</span><span class="p">.</span><span class="n">initialiserPoids</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="n">monChien</span><span class="p">.</span><span class="n">imprime</span><span class="p">();</span><span class="w"> </span><span class="c1">// imprime &quot;Le chien s&#39;appelle Barkley et pèse 10 kg&quot;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// prints &quot;Au revoir Barkley !&quot;</span>

<span class="c1">// Héritage :</span>

<span class="c1">// Cette classe hérite de toutes les propriétés publiques et protégées de la</span>
<span class="c1">// classe Chien ainsi que celles privées, mais n&#39;ont pas accès direct aux</span>
<span class="c1">// membres et méthodes privés sans l&#39;aide d&#39;une méthode publique ou protégée</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ChienDomestique</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">ChienDomestique</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">definirProprietaire</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">proprietaireDuChien</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Surcharge le comportement de la fonction d&#39;impression pour tous les</span>
<span class="w">    </span><span class="c1">// ChienDomestiques.</span>
<span class="w">    </span><span class="c1">// Voir https://fr.wikipedia.org/wiki/Polymorphisme_(informatique)#Polymorphisme_par_sous-typage</span>
<span class="w">    </span><span class="c1">// pour une introduction plus générale si vous n&#39;êtes pas familier avec le</span>
<span class="w">    </span><span class="c1">// concept de polymorphisme par sous-typage (appelé aussi polymorphisme</span>
<span class="w">    </span><span class="c1">// d&#39;inclusion).</span>
<span class="w">    </span><span class="c1">// Le mot-clé &quot;override&quot; est optionnel mais assure que vous surchargez bien</span>
<span class="w">    </span><span class="c1">// la méthode de la classe de base.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">imprimer</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">proprietaire</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Pendant ce temps, dans le fichier .cpp correspondant :</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">ChienDomestique::definirProprietaire</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">proprietaireDuChien</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">proprietaire</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">proprietaireDuChien</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">ChienDomestique::imprimer</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Appelle la fonction &quot;imprimer&quot; dans la classe de base Chien</span>
<span class="w">    </span><span class="n">Chien</span><span class="o">::</span><span class="n">imprimer</span><span class="p">();</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Le chien appartient à &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">proprietaire</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Affiche &quot;Le chien est &lt;nom&gt; et pèse &lt;poids&gt;&quot;</span>
<span class="w">    </span><span class="c1">//         &quot;Le chien appartient à &lt;proprietaire&gt;&quot;</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////</span>
<span class="c1">// Initialisation et opérateur de surcharge</span>
<span class="c1">////////////////////////////////////////////////////</span>

<span class="c1">// En C++, vous pouvez surcharger le comportement d&#39;opérateurs tels</span>
<span class="c1">// que +, -, *, /, etc.</span>
<span class="c1">// La surcharge se fait en définissant une fonction qui sera appelée à chaque</span>
<span class="c1">// fois que l&#39;opérateur sera utilisé.</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Point</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// Les variables membres peuvent avoir des valeurs par défaut</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Définit un constructeur par défaut qui ne fait rien</span>
<span class="w">    </span><span class="c1">// mais initialise le Point à la valeur par défaut (0, 0)</span>
<span class="w">    </span><span class="n">Point</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// La syntaxe suivante s&#39;appelle une liste d&#39;initialisation et est</span>
<span class="w">    </span><span class="c1">// la façon correcte d&#39;initialiser les valeurs des membres d&#39;une classe.</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">        </span><span class="n">x</span><span class="p">(</span><span class="n">a</span><span class="p">),</span>
<span class="w">        </span><span class="n">y</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="cm">/* Ne fait rien à part initialiser les valeurs */</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Surcharge l&#39;opérateur +</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Surcharge l&#39;opérateur +=</span>
<span class="w">    </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Il serait également logique d&#39;ajouter les opérateurs - et -=,</span>
<span class="w">    </span><span class="c1">// mais nous les éclipsons par soucis de concision.</span>
<span class="p">};</span>

<span class="n">Point</span><span class="w"> </span><span class="n">Point</span><span class="o">::</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Créé un nouveau point qui est la somme de celui-ci de rhs.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Point</span><span class="o">::</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="nf">haut</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="nf">droite</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Appelle l&#39;opérateur + du Point</span>
<span class="w">    </span><span class="c1">// Le point &quot;haut&quot; appelle la fonction + avec &quot;droite&quot; comme paramètre</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="n">resultat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">haut</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">droite</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Affiche &quot;Le résultat est haut-droite (1,1)&quot;</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Le résultat est haut-droite (&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">resultat</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;,&#39;</span>
<span class="w">         </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">resultat</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////</span>
<span class="c1">// Patrons (templates)</span>
<span class="c1">////////////////////////////////</span>

<span class="c1">// Les templates (patrons) en C++ sont majoritairement</span>
<span class="c1">// utilisés pour la programmation générique, bien qu&#39;ils soient bien plus</span>
<span class="c1">// puissants que les constructeurs génériques dans d&#39;autres langages.</span>
<span class="c1">// Ils gèrent également la spécialisation explicite et partielle ainsi que</span>
<span class="c1">// les classes fonctionnelles; en fait, ils sont un langage fonctionnelles</span>
<span class="c1">// Turing-complete embedded in C++ !</span>

<span class="c1">// Nous commencons avec le genre de programmation générique auquel vous êtes</span>
<span class="c1">// peut-être familier. Pour définir une classe ou fonction qui prend un type de</span>
<span class="c1">// paramètre particulier :</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Boite</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// Dans cette classe, T représente n&#39;importe quel type possible.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">inserer</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Pendant la compilation, le compilateur génère des copies de chaque template</span>
<span class="c1">// avec les paramètres substitués; ainsi, la définition complète de chaque</span>
<span class="c1">// classe doit être présente à chaque appel. C&#39;est pourquoi vous verrez les</span>
<span class="c1">// classes de templates définies entièrement dans les fichiers d&#39;en-tête.</span>

<span class="c1">// Pour instancier une classe de template sur la pile (&quot;stack&quot;) :</span>
<span class="n">Boite</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">boiteDEntiers</span><span class="p">;</span>

<span class="c1">// et vous pouvez l&#39;utiliser comme prévu :</span>
<span class="n">boiteDEntiers</span><span class="p">.</span><span class="n">inserer</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>

<span class="c1">// Vous pouvez, bien sûr, imbriquer les templates :</span>
<span class="n">Boite</span><span class="o">&lt;</span><span class="n">Boite</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">boiteDeBoites</span><span class="p">;</span>
<span class="n">boiteDeBoites</span><span class="p">.</span><span class="n">inserer</span><span class="p">(</span><span class="n">boiteDEntiers</span><span class="p">);</span>

<span class="c1">// Jusqu&#39;à C++11, il était nécessaire de placer un espace entre les deux &#39;&gt;&#39;s,</span>
<span class="c1">// sinon &#39;&gt;&gt;&#39; était parsé en tant qu&#39;opérateur de décalage vers la droite.</span>

<span class="c1">// Vous croiserez peut-être cette syntaxe</span>
<span class="c1">//   template&lt;typename T&gt;</span>
<span class="c1">// à la place. Les mot-clé &#39;class&#39; et &#39;typename&#39; sont _généralement_</span>
<span class="c1">// interchangeables. Pour plus d&#39;explications, allez à</span>
<span class="c1">//   http://en.wikipedia.org/wiki/Typename</span>
<span class="c1">// ou</span>
<span class="c1">// https://fr.wikibooks.org/wiki/Programmation_C-C%2B%2B/Les_templates/Mot-cl%C3%A9_typename</span>
<span class="c1">// (oui, ce mot-clé a sa propre page Wikipedia).</span>

<span class="c1">// De manière similaire, un patron de fonction :</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">aboyerTroisFois</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">entree</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">entree</span><span class="p">.</span><span class="n">aboyer</span><span class="p">();</span>
<span class="w">    </span><span class="n">entree</span><span class="p">.</span><span class="n">aboyer</span><span class="p">();</span>
<span class="w">    </span><span class="n">entree</span><span class="p">.</span><span class="n">aboyer</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Remarquez ici que rien n&#39;est spécifié à propos du type du paramètre. Le</span>
<span class="c1">// compilateur va générer et vérifier le type à chaque appel du patron, c&#39;est</span>
<span class="c1">// pourquoi l&#39;appel de fonction suivant marche pour n&#39;importe quel type &#39;T&#39; qui</span>
<span class="c1">// a une méthode constante &#39;aboyer&#39; !</span>

<span class="n">Chien</span><span class="w"> </span><span class="n">docile</span><span class="p">;</span>
<span class="n">docile</span><span class="p">.</span><span class="n">initialiserNom</span><span class="p">(</span><span class="s">&quot;Docile&quot;</span><span class="p">)</span>
<span class="n">aboyerTroisFois</span><span class="p">(</span><span class="n">docile</span><span class="p">);</span><span class="w"> </span><span class="c1">// Affiche &quot;Docile fait ouaf !&quot; trois fois.</span>

<span class="c1">// Les paramètres génériques (ou paramètres template) ne sont pas forcément des</span>
<span class="c1">// classes :</span>
<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">Y</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">imprimerMessage</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Apprenez le C++ en &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; minutes !&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Vous pouvez explicitement spécialiser les templates pour un code plus</span>
<span class="c1">// optimisé. Bien sûr, les utilisations effectives de la spécialisation ne sont</span>
<span class="c1">// pas aussi triviales que celle-ci.</span>
<span class="c1">// Notez que vous avez toujours besoin de déclarer la fonction (ou classe)</span>
<span class="c1">// comme template, même si vous spécifiez explicitement tous les paramètres.</span>
<span class="k">template</span><span class="o">&lt;&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">imprimerMessage</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Apprenez le C++ plus vite en seulement 10 minutes !&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Affiche &quot;Apprenez le C++ en 20 minutes !&quot;</span>
<span class="n">imprimerMessage</span><span class="o">&lt;</span><span class="mi">20</span><span class="o">&gt;</span><span class="p">();</span>
<span class="c1">// Affiche &quot;Apprenez le C++ plus vite en seulement 10 minutes !&quot;</span>
<span class="n">imprimerMessage</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span><span class="p">();</span>

<span class="c1">//////////////////////////////////</span>
<span class="c1">// Gestion des exceptions</span>
<span class="c1">//////////////////////////////////</span>

<span class="c1">// La bibliothèque standard fournit quelques types d&#39;exception</span>
<span class="c1">// (voir http://en.cppreference.com/w/cpp/error/exception)</span>
<span class="c1">// mais n&#39;importe quel type peut être lancé en tant qu&#39;exception.</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exception&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdexcept&gt;</span>

<span class="c1">// Toutes les exceptions lancées à l&#39;intérieur d&#39;un block _try_ peuvent être</span>
<span class="c1">// attrapées par les blocs de traitement d&#39;erreurs (_catch_ handlers).</span>
<span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// N&#39;allouez pas des exceptions sur le tas (heap) en utilisant _new_.</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Un problème s&#39;est produit&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Attrapez les exceptions avec des références constantes si ce sont des objets</span>
<span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Attrape n&#39;importe quelle exception non attrapée par les blocs _catch_</span>
<span class="c1">// précédents</span>
<span class="k">catch</span><span class="w"> </span><span class="p">(...)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Exception inconnue attrapée&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">throw</span><span class="p">;</span><span class="w"> </span><span class="c1">// Re-lance l&#39;exception</span>
<span class="p">}</span>

<span class="c1">////////////////</span>
<span class="c1">// RAII</span>
<span class="c1">////////////////</span>

<span class="c1">// RAII signifie &quot;Resource Acquisition Is Initialization&quot;, soit l&#39;Acquisition</span>
<span class="c1">// d&#39;une Ressource est une Initialisation en français.</span>
<span class="c1">// Il est souvent considéré comme le paradigme le plus puissant en C++ et</span>
<span class="c1">// est le concept simple qu&#39;un constructeur d&#39;un objet acquiert les ressources</span>
<span class="c1">// d&#39;un objet et que le destructeur les libère.</span>

<span class="c1">// Afin de comprendre son utilité, considérons une fonction qui utilise la</span>
<span class="c1">// gestion d&#39;un fichier C :</span>
<span class="kt">void</span><span class="w"> </span><span class="n">faireQuelqueChoseAvecUnFichier</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">nomDuFichier</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Pour commencer, supposons que rien ne peut échouer.</span>

<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">nomDuFichier</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Ouvre le fichier en lecture</span>

<span class="w">    </span><span class="n">faireQuelqueChoseAvecLeFichier</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="n">faireAutreChoseAvec</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Ferme la gestion du fichier.</span>
<span class="p">}</span>

<span class="c1">// Malheureusement, les choses deviennent compliquées avec la gestion</span>
<span class="c1">// d&#39;erreurs. Supposons que fopen échoue, et que faireQuelqueChoseAvecLeFichier</span>
<span class="c1">// et faireAutreChoseAvec retournent des codes d&#39;erreur si elles échouent.</span>
<span class="c1">//  (Les exceptions sont le meilleur moyen de gérer l&#39;échec, mais des</span>
<span class="c1">//   programmeurs, surtout avec un passif en C,</span>
<span class="c1">//   sont en désaccord avec l&#39;utilité des exceptions).</span>
<span class="c1">// Nous devons maintenant vérifier chaque appel en cas d&#39;échec et fermer la</span>
<span class="c1">// gestion du fichier si un problème se produit.</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">faireQuelqueChoseAvecUnFichier</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">nomDuFichier</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">nomDuFichier</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Ouvre le fichier en mode lecture.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fh</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="c1">// Le pointeur retourné est null à un échec.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Signale cet échec à l&#39;appelant.</span>

<span class="w">    </span><span class="c1">// Suppose que chaque fonction retourne faux si elle échoue</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">faireQuelqueChoseAvecLeFichier</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Ferme le flux d&#39;entrée du fichier pour empêcher les fuites</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Propage l&#39;erreur</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">faireAutreChoseAvec</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Les programmeurs en C clarifient souvent tout cela en utilisant goto :</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">faireQuelqueChoseAvecUnFichier</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">nomDuFichier</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">nomDuFichier</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fh</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">faireQuelqueChoseAvecLeFichier</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">echec</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">faireAutreChoseAvec</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">echec</span><span class="p">;</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Ferme la gestion du fichier</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// Indique le succès</span>

<span class="nl">echec</span><span class="p">:</span>
<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Propage l&#39;erreur</span>
<span class="p">}</span>

<span class="c1">// Si les fonctions indiquent des erreurs en utilisant des exceptions,</span>
<span class="c1">// les choses sont un peu plus claires, mais toujours sous-optimales.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">faireQuelqueChoseAvecUnFichier</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">nomDuFichier</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">nomDuFichier</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Ouvre le fichier en lecture</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fh</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Ouverture du fichier impossible.&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">faireQuelqueChoseAvecLeFichier</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">        </span><span class="n">faireAutreChoseAvec</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">catch</span><span class="w"> </span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Assurez-vous de bien fermer le fichier si une erreur arrive</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">        </span><span class="k">throw</span><span class="p">;</span><span class="w"> </span><span class="c1">// Puis re-lancer l&#39;exception</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Ferme le fichier</span>
<span class="w">    </span><span class="c1">// Tout s&#39;est déroulé correctement</span>
<span class="p">}</span>

<span class="c1">// Comparez ceci à l&#39;utilisation de la classe de flux de fichier</span>
<span class="c1">// en C++ (fstream).</span>
<span class="c1">// fstream utilise son destructeur pour fermer le fichier.</span>
<span class="c1">// Pour rappel, les destructeurs sont automatiquement appelée dès qu&#39;un objet</span>
<span class="c1">// sort du cadre de sa portée.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">faireQuelqueChoseAvecUnFichier</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">nomDuFichier</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// ifstream is short for input file stream</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span><span class="w"> </span><span class="nf">fh</span><span class="p">(</span><span class="n">nomDuFichier</span><span class="p">);</span><span class="w"> </span><span class="c1">// Ouvre le fichier</span>

<span class="w">    </span><span class="c1">// Faire des choses avec le fichier</span>
<span class="w">    </span><span class="n">faireQuelqueChoseAvecLeFichier</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="n">faireAutreChoseAvec</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// Le fichier est automatiquement fermé ici par le destructeur</span>

<span class="c1">// Ceci a des avantages _énormes_ :</span>
<span class="c1">// 1. Peu importe la situation, la ressource (dans ce cas précis la gestion</span>
<span class="c1">//    de fichier) sera libérée. Si le destructeur est écrit correctement,</span>
<span class="c1">//    il est _impossible_ d&#39;oublier de fermer la gestion et d&#39;entraîner une</span>
<span class="c1">//    une fuite de ressources (si l&#39;objet est sur la pile).</span>
<span class="c1">// 2. Remarquez que le code est beaucoup plus clair.</span>
<span class="c1">//    Le destructeur gère la fermeture du fichier discrètement sans avoir</span>
<span class="c1">//    besoin de s&#39;en préoccuper.</span>
<span class="c1">// 3. Le code est fiable par rapport aux exceptions.</span>
<span class="c1">//    Une exception peut être lancée n&#39;importe où dans la fonction, le</span>
<span class="c1">//    nettoyage se fera toujours.</span>

<span class="c1">// Tout code C++ idiomatique utilise considérablement RAII pour toutes les</span>
<span class="c1">// ressources.</span>
<span class="c1">// Des exemples additionnels inclus :</span>
<span class="c1">// - La mémoire utilisant unique_ptr et shared_ptr</span>
<span class="c1">// - Des conteneurs (containers) - la liste chaînée de la librairie standard,</span>
<span class="c1">//   des vecteurs (c.-à-d. tableaux auto-redimensionnés), tables de hachage, et</span>
<span class="c1">//   ainsi de suite. Tous détruisent leur contenu quand ils sortent du cadre</span>
<span class="c1">//   de leur portée.</span>
<span class="c1">// - Les mutex utilisant lock_guard et unique_lock</span>


<span class="c1">//////////////////</span>
<span class="c1">// Divers</span>
<span class="c1">//////////////////</span>

<span class="c1">// Ici sont regroupés des aspects du C++ qui peuvent être surprenants aux</span>
<span class="c1">// novices (et même à quelques habitués).</span>
<span class="c1">// Cette section est, malheureusement, grandement incomplète; C++ est un des</span>
<span class="c1">// langages où il est très facile de se tirer soi-même dans le pied.</span>

<span class="c1">// Vous pouvez surcharger des méthodes privées !</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">();</span>
<span class="p">};</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FooSub</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">();</span><span class="w">  </span><span class="c1">// Surcharge Foo::bar!</span>
<span class="p">};</span>

<span class="c1">// 0 == false == NULL (la plupart du temps) !</span>
<span class="kt">bool</span><span class="o">*</span><span class="w"> </span><span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">bool</span><span class="p">;</span>
<span class="o">*</span><span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// Affecte false à la valeur de la variable pointée par &#39;pt&#39;.</span>
<span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// Affecte le pointeur null à &#39;pt&#39;.</span>
<span class="c1">// Les deux lignes compilent sans avertissement.</span>

<span class="c1">// nullptr est supposé régler un peu ce problème :</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">pt2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>
<span class="o">*</span><span class="n">pt2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"> </span><span class="c1">// Ne compile pas</span>
<span class="n">pt2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w">  </span><span class="c1">// Affecte null à pt2</span>

<span class="c1">// Il y a une exception faite pour les booléens.</span>
<span class="c1">// Ceci vous permet de tester les pointeurs null avec if(!ptr),</span>
<span class="c1">// mais par conséquent, vous pouvez assigner nullptr à un booléen directement !</span>
<span class="o">*</span><span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w">  </span><span class="c1">// Ceci compile toujours, même si &#39;*pt&#39; est un booléen !</span>

<span class="c1">// &#39;=&#39; != &#39;=&#39; != &#39;=&#39;!</span>
<span class="c1">// Appelle Foo::Foo(const Foo&amp;) ou une variante du (voir sémantiques de mouvement)</span>
<span class="c1">// constructeur par copie.</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span>

<span class="c1">// Appelle Foo::Foo(const Foo&amp;) ou une variante, mais copie seulement la partie</span>
<span class="c1">// &#39;Foo&#39; de &#39;fooSub&#39;. Tout membre extra de &#39;fooSub&#39; est ignoré.</span>
<span class="c1">// Ce comportement parfois horrifiant est appelé &quot;object slicing&quot;.</span>
<span class="n">FooSub</span><span class="w"> </span><span class="n">fooSub</span><span class="p">;</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fooSub</span><span class="p">;</span>

<span class="c1">// Appelle Foo::operator=(Foo&amp;) ou une variante.</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f1</span><span class="p">;</span>
<span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span>

<span class="c1">// Comment vraiment nettoyer un conteneur :</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">  </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Foo</span><span class="p">());</span>

<span class="c1">// La ligne suivante affecte la taille de v à 0, mais les destructeurs ne sont</span>
<span class="c1">// appelés et les ressources ne sont pas libérées !</span>
<span class="n">v</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
<span class="c1">// La nouvelle valeur est copiée dans le premier Foo que nous avons inséré</span>
<span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Foo</span><span class="p">());</span>

<span class="c1">// Ceci nettoie toutes les valeurs de v. Voir la section à propos des objets</span>
<span class="c1">// temporaires pour comprendre pourquoi cela fonctionne.</span>
<span class="n">v</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">());</span>
</pre></div>
<p>Lecture complémentaire:</p>

<ul>
<li>Une référence à jour du langage est disponible à <a href="http://cppreference.com/w/cpp">CPP Reference</a>.</li>
<li>Des ressources supplémentaires sont disponibles à <a href="http://cplusplus.com">CPlusPlus</a>.</li>
<li>Un tutoriel couvrant les bases du langage et la configuration d&#39;un environnement de codage est disponible à l&#39;adresse <a href="https://www.youtube.com/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb">TheChernoProject - C ++</a>.</li>
</ul>

    <hr>
    <p>Vous avez une suggestion ? Peut-être une correction ? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Ouvrez un ticket</a> sur Github, ou faites vous-même une <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/fr-fr/c++-fr.html.markdown">pull request</a> !
    </p>
    <p class="contributed">
    Version originale par Steven Basart, mis à jour par <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/fr-fr/c++-fr.html.markdown">8 contributeur(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://github.com/xksteven">Steven Basart</a>,
        <a href="https://github.com/mrkline">Matt Kline</a>,
        <a href="http://geoffliu.me">Geoff Liu</a>,
        <a href="http://github.com/connorwaters">Connor Waters</a>
    </p>

    <p>
      Translated by:
        <a href="http://github.com/mellenguyen">Xuan-thi Nguyen</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
