<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="fr-fr" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="fr-fr" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="fr-fr" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="fr-fr" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="fr-fr">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Go in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/fr-fr/go-fr/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Ffr-fr%2Fgo-fr%2F&text=Apprendre+X+en+Y+minutes%2C+o%C3%B9+X%3DGo">
        Partager cette page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Choisis un thème:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">clair</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">sombre</button>
  </div>
  <h1><a href="/">Apprendre X en Y minutes</a></h1>
  <h2>Où X=Go</h2>
    <p class="filelink">
    Récupérer le code:
    <a href="/docs/files/learngo-fr.go">learngo-fr.go</a>
    </p>
  <div id="doc">
    <p>Go a été créé dans l&#39;optique de développer de façon efficace. Ce n&#39;est pas la
dernière tendance en ce qui est au développement, mais c&#39;est la nouvelle façon
de régler des défis réels de façon rapide.</p>

<p>Le langage possède des concepts familiers à la programmation impérative avec
typage. Il est rapide à compiler et exécuter, ajoute une concurrence facile à
comprendre, pour les processeurs multi coeurs d&#39;aujourd&#39;hui et apporte des
fonctionnalités facilitant le développement à grande échelle.</p>

<p>Développer avec Go, c&#39;est bénéficier d&#39;une riche bibliothèque standard et d&#39;une
communauté active.</p>
<div class="highlight"><pre><span></span><span class="c1">// Commentaire ligne simple</span>
<span class="cm">/* Commentaire</span>
<span class="cm"> multiligne */</span>

<span class="c1">// Un paquet débute avec une clause &quot;package&quot;</span>
<span class="c1">// &quot;main&quot; est un nom spécial déclarant un paquet de type exécutable plutôt</span>
<span class="c1">// qu&#39;une bibliothèque</span>
<span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="c1">// &quot;Import&quot; déclare les paquets référencés dans ce fichier.</span>
<span class="kn">import</span><span class="w"> </span><span class="p">(</span>
<span class="w">  </span><span class="s">&quot;fmt&quot;</span><span class="w">       </span><span class="c1">// Un paquet dans la bibliothèque standard.</span>
<span class="w">  </span><span class="s">&quot;io/ioutil&quot;</span><span class="w"> </span><span class="c1">// Implémente des fonctions utilitaires I/O.</span>
<span class="w">  </span><span class="nx">m</span><span class="w"> </span><span class="s">&quot;math&quot;</span><span class="w">    </span><span class="c1">// Bibliothèque mathématique utilisant un alias local &quot;m&quot;.</span>
<span class="w">  </span><span class="s">&quot;net/http&quot;</span><span class="w">  </span><span class="c1">// Un serveur Web!</span>
<span class="w">  </span><span class="s">&quot;strconv&quot;</span><span class="w">   </span><span class="c1">// Bibliothèque pour convertir les chaînes de caractères.</span>
<span class="p">)</span>

<span class="c1">// Une définition de fonction. La fonction &quot;main&quot; est spéciale - c&#39;est le point</span>
<span class="c1">// d&#39;entrée du binaire.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Println retournera la valeur à la console.</span>
<span class="w">  </span><span class="c1">// Associez la fonction avec son paquet respectif, fmt.</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Hello world!&quot;</span><span class="p">)</span>

<span class="w">  </span><span class="c1">// Appelez une fonction différente à partir de ce paquet.</span>
<span class="w">  </span><span class="nx">beyondHello</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// Les fonctions ont des paramètres entre parenthèses.</span>
<span class="c1">// Les parenthèses sont nécessaires avec ou sans paramètre.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">beyondHello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="c1">// Déclaration de variable. Les variables doivent être déclarées</span>
<span class="w">            </span><span class="c1">// avant leur utilisation.</span>
<span class="w">  </span><span class="nx">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">3</span><span class="w">     </span><span class="c1">// Assignation de valeur.</span>
<span class="w">  </span><span class="c1">// Les déclarations courtes utilisent := pour inférer le type, déclarer et</span>
<span class="w">  </span><span class="c1">// assigner.</span>
<span class="w">  </span><span class="nx">y</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">4</span>
<span class="w">  </span><span class="nx">sum</span><span class="p">,</span><span class="w"> </span><span class="nx">prod</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">learnMultiple</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="p">)</span><span class="w">        </span><span class="c1">// La fonction retourne deux valeurs.</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;sum:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">sum</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;prod:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">prod</span><span class="p">)</span><span class="w"> </span><span class="c1">// Affichage simple.</span>
<span class="w">  </span><span class="nx">learnTypes</span><span class="p">()</span><span class="w">                            </span><span class="c1">// &lt; y minutes, en savoir plus!</span>
<span class="p">}</span>

<span class="c1">// Les fonctions peuvent avoir des paramètres et plusieurs valeurs retournées.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">learnMultiple</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">sum</span><span class="p">,</span><span class="w"> </span><span class="nx">prod</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">y</span><span class="p">,</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="c1">// Deux valeurs retournées.</span>
<span class="p">}</span>

<span class="c1">// Quelques types inclus et littéraux.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">learnTypes</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Une déclaration courte infère généralement le type désiré.</span>
<span class="w">  </span><span class="nx">str</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="s">&quot;Learn Go!&quot;</span><span class="w"> </span><span class="c1">// Type string.</span>

<span class="w">  </span><span class="nx">s2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="s">`Une chaîne de caractères peut contenir des</span>
<span class="s">sauts de ligne.`</span><span class="w"> </span><span class="c1">// Chaîne de caractère.</span>

<span class="w">  </span><span class="c1">// Littéral non-ASCII. Les sources Go utilisent le charset UTF-8.</span>
<span class="w">  </span><span class="nx">g</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="sc">&#39;Σ&#39;</span><span class="w"> </span><span class="c1">// type rune, un alias pour le type int32, contenant un caractère</span>
<span class="w">           </span><span class="c1">// unicode.</span>

<span class="w">  </span><span class="nx">f</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mf">3.14159</span><span class="w"> </span><span class="c1">// float64, un nombre flottant IEEE-754 de 64-bit.</span>
<span class="w">  </span><span class="nx">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">4i</span><span class="w">  </span><span class="c1">// complex128, considéré comme deux float64 par le compilateur.</span>

<span class="w">  </span><span class="c1">// Syntaxe &quot;var&quot; avec une valeur d&#39;initialisation.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">u</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="c1">// Non signé, mais la taille dépend selon l&#39;entier.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">pi</span><span class="w"> </span><span class="kt">float32</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">22.</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">7</span>

<span class="w">  </span><span class="c1">// Conversion avec syntaxe courte.</span>
<span class="w">  </span><span class="nx">n</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">byte</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">)</span><span class="w"> </span><span class="c1">// byte est un alias du type uint8.</span>

<span class="w">  </span><span class="c1">// Les tableaux ont une taille fixe déclarée à la compilation.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">a4</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">int</span><span class="w">           </span><span class="c1">// Un tableau de 4 ints, tous initialisés à 0.</span>
<span class="w">  </span><span class="nx">a3</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">}</span><span class="w"> </span><span class="c1">// Un tableau initialisé avec une taille fixe de 3</span>
<span class="w">  </span><span class="c1">// éléments, contenant les valeurs 3, 1 et 5.</span>

<span class="w">  </span><span class="c1">// Les slices ont des tailles dynamiques. Les tableaux et slices ont chacun</span>
<span class="w">  </span><span class="c1">// des avantages, mais les cas d&#39;utilisation des slices sont plus fréquents.</span>
<span class="w">  </span><span class="nx">s3</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">}</span><span class="w">    </span><span class="c1">// Comparable à a3.</span>
<span class="w">  </span><span class="nx">s4</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">    </span><span class="c1">// Alloue un slice de 4 ints, initialisés à 0.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">d2</span><span class="w"> </span><span class="p">[][]</span><span class="kt">float64</span><span class="w">      </span><span class="c1">// Déclaration seulement, sans allocation de mémoire.</span>
<span class="w">  </span><span class="nx">bs</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;a slice&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">// Conversion d&#39;une chaîne en slice de bytes.</span>

<span class="w">  </span><span class="c1">// Parce qu&#39;elles sont dynamiques, les slices peuvent être jointes sur</span>
<span class="w">  </span><span class="c1">// demande. Pour joindre un élément à une slice, la fonction standard append()</span>
<span class="w">  </span><span class="c1">// est utilisée. Le premier argument est la slice à utiliser. Habituellement,</span>
<span class="w">  </span><span class="c1">// la variable tableau est mise à jour sur place, voir ci-bas.</span>
<span class="w">  </span><span class="nx">s</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">     </span><span class="c1">// Le résultat est une slice de taille 3.</span>
<span class="w">  </span><span class="nx">s</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w">  </span><span class="c1">// Ajout de 3 valeurs. La taille est de 6.</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="w">          </span><span class="c1">// La valeur est de [1 2 3 4 5 6]</span>

<span class="w">  </span><span class="c1">// Pour ajouter une slice à une autre, au lieu d&#39;utiliser une liste de valeurs</span>
<span class="w">  </span><span class="c1">// atomiques, il est possible de mettre en argument une référence de</span>
<span class="w">  </span><span class="c1">// slice littérale grâce aux points de suspension.</span>
<span class="w">  </span><span class="nx">s</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">}</span><span class="o">...</span><span class="p">)</span><span class="w"> </span><span class="c1">// Le deuxième argument est une slice</span>
<span class="w">                                   </span><span class="c1">// littérale.</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="w">  </span><span class="c1">// La slice contient [1 2 3 4 5 6 7 8 9]</span>

<span class="w">  </span><span class="nx">p</span><span class="p">,</span><span class="w"> </span><span class="nx">q</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">learnMemory</span><span class="p">()</span><span class="w"> </span><span class="c1">// Déclare p, q comme étant des pointeurs de type int.</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="nx">q</span><span class="p">)</span><span class="w">   </span><span class="c1">// * suit un pointeur. Ceci retourne deux ints.</span>

<span class="w">  </span><span class="c1">// Les maps sont des tableaux associatifs de taille dynamique, comme les</span>
<span class="w">  </span><span class="c1">// hash ou les types dictionnaires de certains langages.</span>
<span class="w">  </span><span class="nx">m</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">&quot;trois&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;quatre&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">4</span><span class="p">}</span>
<span class="w">  </span><span class="nx">m</span><span class="p">[</span><span class="s">&quot;un&quot;</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span>

<span class="w">  </span><span class="c1">// Les valeurs inutilisées sont considérées comme des erreurs en Go.</span>
<span class="w">  </span><span class="c1">// Un tiret bas permet d&#39;ignorer une valeur inutilisée, évitant une erreur.</span>
<span class="w">  </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">str</span><span class="p">,</span><span class="w"> </span><span class="nx">s2</span><span class="p">,</span><span class="w"> </span><span class="nx">g</span><span class="p">,</span><span class="w"> </span><span class="nx">f</span><span class="p">,</span><span class="w"> </span><span class="nx">u</span><span class="p">,</span><span class="w"> </span><span class="nx">pi</span><span class="p">,</span><span class="w"> </span><span class="nx">n</span><span class="p">,</span><span class="w"> </span><span class="nx">a3</span><span class="p">,</span><span class="w"> </span><span class="nx">s4</span><span class="p">,</span><span class="w"> </span><span class="nx">bs</span>

<span class="w">  </span><span class="c1">// Cependant, son affichage en console est considéré comme une utilisation,</span>
<span class="w">  </span><span class="c1">// ce qui ne sera pas considéré comme une erreur à la compilation.</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">,</span><span class="w"> </span><span class="nx">a4</span><span class="p">,</span><span class="w"> </span><span class="nx">s3</span><span class="p">,</span><span class="w"> </span><span class="nx">d2</span><span class="p">,</span><span class="w"> </span><span class="nx">m</span><span class="p">)</span>

<span class="w">  </span><span class="nx">learnFlowControl</span><span class="p">()</span><span class="w"> </span><span class="c1">// De retour dans le flux.</span>
<span class="p">}</span>

<span class="c1">// Il est possible, à l&#39;opposé de plusieurs autres langages, de retourner des</span>
<span class="c1">// variables par leur nom à partir de fonctions.</span>
<span class="c1">// Assigner un nom à un type retourné par une fonction permet de retrouver sa</span>
<span class="c1">// valeur ainsi que d&#39;utiliser le mot-clé &quot;return&quot; uniquement, sans plus.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">learnNamedReturns</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">z</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">z</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">y</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="c1">// z est implicite, car la variable a été définie précédemment.</span>
<span class="p">}</span>

<span class="c1">// La récupération de la mémoire est automatique en Go. Le langage possède des</span>
<span class="c1">// pointeurs, mais aucune arithmétique des pointeurs (*(a + b) en C). Vous</span>
<span class="c1">// pouvez produire une erreur avec un pointeur nil, mais pas en incrémentant un</span>
<span class="c1">// pointeur.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">learnMemory</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="nx">p</span><span class="p">,</span><span class="w"> </span><span class="nx">q</span><span class="w"> </span><span class="o">*</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Les valeurs retournées p et q auront le type pointeur int.</span>
<span class="w">  </span><span class="nx">p</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="c1">// Fonction standard &quot;new&quot; alloue la mémoire.</span>
<span class="w">  </span><span class="c1">// Le int alloué est initialisé à 0, p n&#39;est plus nil.</span>
<span class="w">  </span><span class="nx">s</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="c1">// Alloue 20 ints en un seul bloc de mémoire.</span>
<span class="w">  </span><span class="nx">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">7</span><span class="w">             </span><span class="c1">// Assigne l&#39;un des entiers.</span>
<span class="w">  </span><span class="nx">r</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="w">              </span><span class="c1">// Déclare une autre variable locale.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">s</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">r</span><span class="w">     </span><span class="c1">// &amp; retourne l&#39;adresse d&#39;un objet.</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">expensiveComputation</span><span class="p">()</span><span class="w"> </span><span class="kt">float64</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">m</span><span class="p">.</span><span class="nx">Exp</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">learnFlowControl</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Bien que les &quot;if&quot; requièrent des accolades, les parenthèses ne sont pas</span>
<span class="w">  </span><span class="c1">// nécessaires pour contenir le test booléen.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;voilà!&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Le formatage du code est standardisé par la commande shell &quot;go fmt.&quot;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// bing.</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// bang.</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Utilisez &quot;switch&quot; au lieu des &quot;if&quot; en chaîne</span>
<span class="w">  </span><span class="nx">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mf">42.0</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">42</span><span class="p">:</span>
<span class="w">    </span><span class="c1">// Les &quot;case&quot; n&#39;ont pas besoin de &quot;break;&quot;.</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">43</span><span class="p">:</span>
<span class="w">    </span><span class="c1">// Non-exécuté.</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Comme les &quot;if&quot;, les &quot;for&quot; n&#39;utilisent pas de parenthèses.</span>
<span class="w">  </span><span class="c1">// Les variables déclarées dans les &quot;for&quot; et les &quot;if&quot; sont locales à leur</span>
<span class="w">  </span><span class="c1">// portée.</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="nx">x</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ++ est une incrémentation.</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;itération &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">x</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// x == 42 ici.</span>

<span class="w">  </span><span class="c1">// &quot;For&quot; est le seul type de boucle en Go, mais possède différentes formes.</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Boucle infinie</span>
<span class="w">    </span><span class="k">break</span><span class="w">    </span><span class="c1">// C&#39;est une farce</span>
<span class="w">    </span><span class="k">continue</span><span class="w"> </span><span class="c1">// Non atteint.</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Vous pouvez utiliser une &quot;range&quot; pour itérer dans un tableau, une slice, une</span>
<span class="w">  </span><span class="c1">// chaîne, une map ou un canal. Les &quot;range&quot; retournent un canal ou deux</span>
<span class="w">  </span><span class="c1">// valeurs (tableau, slice, chaîne et map).</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">key</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">&quot;une&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;deux&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;trois&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// pour chaque pair dans une map, affichage de la valeur et clé</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;clé=%s, valeur=%d\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">key</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// À l&#39;opposé du &quot;for&quot;, := dans un &quot;if&quot; signifie la déclaration et</span>
<span class="w">  </span><span class="c1">// l&#39;assignation y en premier, et ensuite y &gt; x</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">expensiveComputation</span><span class="p">();</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">y</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Les fonctions littérales sont des fermetures.</span>
<span class="w">  </span><span class="nx">xBig</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mi">10000</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;xBig:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">xBig</span><span class="p">())</span><span class="w"> </span><span class="c1">// true (la valeur e^10 a été assignée à x).</span>
<span class="w">  </span><span class="nx">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">1.3e3</span><span class="w">                    </span><span class="c1">// Ceci fait x == 1300</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;xBig:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">xBig</span><span class="p">())</span><span class="w"> </span><span class="c1">// Maintenant false.</span>

<span class="w">  </span><span class="c1">// De plus, les fonctions littérales peuvent être définies et appelées</span>
<span class="w">  </span><span class="c1">// sur la même ligne, agissant comme argument à cette fonction, tant que:</span>
<span class="w">  </span><span class="c1">// a) la fonction littérale est appelée suite à (),</span>
<span class="w">  </span><span class="c1">// b) le résultat correspond au type de l&#39;argument.</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Ajoute + multiplie deux nombres : &quot;</span><span class="p">,</span>
<span class="w">    </span><span class="kd">func</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">b</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span>
<span class="w">    </span><span class="p">}(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="c1">// Appelle la fonction avec les arguments 10 et 2</span>
<span class="w">  </span><span class="c1">// =&gt; Ajoute + double deux nombres : 24</span>

<span class="w">  </span><span class="c1">// Quand vous en aurez besoin, vous allez l&#39;adorer.</span>
<span class="w">  </span><span class="k">goto</span><span class="w"> </span><span class="nx">love</span>
<span class="nx">love</span><span class="p">:</span>

<span class="w">  </span><span class="nx">learnFunctionFactory</span><span class="p">()</span><span class="w"> </span><span class="c1">// func retournant func correspondant à fun(3)(3).</span>
<span class="w">  </span><span class="nx">learnDefer</span><span class="p">()</span><span class="w">           </span><span class="c1">// Un survol de cette instruction importante.</span>
<span class="w">  </span><span class="nx">learnInterfaces</span><span class="p">()</span><span class="w">      </span><span class="c1">// Incontournable !</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">learnFunctionFactory</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Les deux syntaxes sont identiques, bien que la seconde soit plus pratique.</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">sentenceFactory</span><span class="p">(</span><span class="s">&quot;été&quot;</span><span class="p">)(</span><span class="s">&quot;Une matinée d&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;agréable!&quot;</span><span class="p">))</span>

<span class="w">  </span><span class="nx">d</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">sentenceFactory</span><span class="p">(</span><span class="s">&quot;été&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">d</span><span class="p">(</span><span class="s">&quot;Une matinée d&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;agréable!&quot;</span><span class="p">))</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">d</span><span class="p">(</span><span class="s">&quot;Une soirée d&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;relaxante!&quot;</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// Le décorateur est un patron de conception commun dans d&#39;autres langages.</span>
<span class="c1">// Il est possible de faire de même en Go avec des fonctions littérales</span>
<span class="c1">// acceptant des arguments.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">sentenceFactory</span><span class="p">(</span><span class="nx">mystring</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">before</span><span class="p">,</span><span class="w"> </span><span class="nx">after</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">before</span><span class="p">,</span><span class="w"> </span><span class="nx">after</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%s %s %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">before</span><span class="p">,</span><span class="w"> </span><span class="nx">mystring</span><span class="p">,</span><span class="w"> </span><span class="nx">after</span><span class="p">)</span><span class="w"> </span><span class="c1">// nouvelle chaîne</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">learnDefer</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="nx">ok</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Les déclarations différées sont exécutées avant la sortie d&#39;une fonction.</span>
<span class="w">  </span><span class="k">defer</span><span class="w"> </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;les déclarations différées s&#39;exécutent en ordre LIFO.&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="k">defer</span><span class="w"> </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;\nCette ligne est affichée en premier parce que&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="c1">// Les déclarations différées sont utilisées fréquemment pour fermer un</span>
<span class="w">  </span><span class="c1">// fichier, afin que la fonction ferme le fichier en fin d&#39;exécution.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span>
<span class="p">}</span>

<span class="c1">// Défini Stringer comme étant une interface avec une méthode, String.</span>
<span class="kd">type</span><span class="w"> </span><span class="nx">Stringer</span><span class="w"> </span><span class="kd">interface</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">String</span><span class="p">()</span><span class="w"> </span><span class="kt">string</span>
<span class="p">}</span>

<span class="c1">// Défini pair comme étant une structure contenant deux entiers, x et y.</span>
<span class="kd">type</span><span class="w"> </span><span class="nx">pair</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="kt">int</span>
<span class="p">}</span>

<span class="c1">// Défini une méthode associée au type pair. Pair implémente maintenant Stringer</span>
<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">p</span><span class="w"> </span><span class="nx">pair</span><span class="p">)</span><span class="w"> </span><span class="nx">String</span><span class="p">()</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// p s&#39;appelle le &quot;destinataire&quot;</span>
<span class="w">  </span><span class="c1">// Sprintf est une autre fonction publique dans le paquet fmt.</span>
<span class="w">  </span><span class="c1">// La syntaxe avec point permet de faire référence aux valeurs de p.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;(%d, %d)&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">p</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">p</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">learnInterfaces</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// La syntaxe avec accolade défini une &quot;structure littérale&quot;. Celle-ci</span>
<span class="w">  </span><span class="c1">// s&#39;évalue comme étant une structure. La syntaxe := déclare et initialise p</span>
<span class="w">  </span><span class="c1">// comme étant une instance.</span>
<span class="w">  </span><span class="nx">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">pair</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">}</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span><span class="w"> </span><span class="c1">// Appelle la méthode String de p, de type pair.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="nx">Stringer</span><span class="w">          </span><span class="c1">// Déclare i instance de l&#39;interface Stringer.</span>
<span class="w">  </span><span class="nx">i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">p</span><span class="w">                   </span><span class="c1">// Valide, car pair implémente Stringer.</span>
<span class="w">  </span><span class="c1">// Appelle la méthode String de i, de type Stringer. Retourne la même valeur</span>
<span class="w">  </span><span class="c1">// que ci-haut.</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span>

<span class="w">  </span><span class="c1">// Les fonctions dans le paquet fmt appellent la méthode String, demandant</span>
<span class="w">  </span><span class="c1">// aux objets d&#39;afficher une représentation de leur structure.</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span><span class="w"> </span><span class="c1">// Affiche la même chose que ci-haut. Println appelle la</span>
<span class="w">                 </span><span class="c1">// méthode String.</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="w"> </span><span class="c1">// Affiche la même chose que ci-haut.</span>

<span class="w">  </span><span class="nx">learnVariadicParams</span><span class="p">(</span><span class="s">&quot;apprentissage&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;génial&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ici!&quot;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Les fonctions peuvent être définie de façon à accepter un ou plusieurs</span>
<span class="c1">// paramètres grâce aux points de suspension, offrant une flexibilité lors de</span>
<span class="c1">// son appel.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">learnVariadicParams</span><span class="p">(</span><span class="nx">myStrings</span><span class="w"> </span><span class="o">...</span><span class="kd">interface</span><span class="p">{})</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Itère chaque paramètre dans la range.</span>
<span class="w">  </span><span class="c1">// Le tiret bas sert à ignorer l&#39;index retourné du tableau.</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">param</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">myStrings</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;paramètre:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">param</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Passe une valeur variadique comme paramètre variadique.</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;paramètres:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintln</span><span class="p">(</span><span class="nx">myStrings</span><span class="o">...</span><span class="p">))</span>

<span class="w">  </span><span class="nx">learnErrorHandling</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">learnErrorHandling</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// &quot;, ok&quot; idiome utilisée pour définir si l&#39;opération s&#39;est déroulée avec</span>
<span class="w">  </span><span class="c1">// succès ou non</span>
<span class="w">  </span><span class="nx">m</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="mi">3</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;trois&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;quatre&quot;</span><span class="p">}</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">m</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ok sera faux, car 1 n&#39;est pas dans la map.</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;inexistant&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span><span class="w"> </span><span class="c1">// x serait la valeur, si elle se trouvait dans la map.</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Une erreur ne retourne qu&#39;un &quot;ok&quot;, mais également plus d&#39;information</span>
<span class="w">  </span><span class="c1">// par rapport à un problème survenu.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">strconv</span><span class="p">.</span><span class="nx">Atoi</span><span class="p">(</span><span class="s">&quot;non-int&quot;</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// _ discarte la valeur</span>
<span class="w">    </span><span class="c1">// retourne: &#39;strconv.ParseInt: parsing &quot;non-int&quot;: invalid syntax&#39;</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Nous réviserons les interfaces un peu plus tard. Pour l&#39;instant,</span>
<span class="w">  </span><span class="nx">learnConcurrency</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// c est un canal, un objet permettant de communiquer en simultané de façon</span>
<span class="c1">// sécurisée.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">inc</span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="kd">chan</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">c</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// &lt;- est l&#39;opérateur &quot;envoi&quot; quand un canal apparaît à</span>
<span class="w">             </span><span class="c1">// gauche.</span>
<span class="p">}</span>

<span class="c1">// Nous utiliserons inc pour incrémenter des nombres en même temps.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">learnConcurrency</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// La fonction &quot;make&quot; utilisée précédemment pour générer un slice. Elle</span>
<span class="w">  </span><span class="c1">// alloue et initialise les slices, maps et les canaux.</span>
<span class="w">  </span><span class="nx">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span>
<span class="w">  </span><span class="c1">// Démarrage de trois goroutines simultanées. Les nombres seront incrémentés</span>
<span class="w">  </span><span class="c1">// simultanément, peut-être en paralèle si la machine le permet et configurée</span>
<span class="w">  </span><span class="c1">// correctement. Les trois utilisent le même canal.</span>
<span class="w">  </span><span class="k">go</span><span class="w"> </span><span class="nx">inc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">)</span><span class="w"> </span><span class="c1">// go est une instruction démarrant une nouvelle goroutine.</span>
<span class="w">  </span><span class="k">go</span><span class="w"> </span><span class="nx">inc</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">)</span>
<span class="w">  </span><span class="k">go</span><span class="w"> </span><span class="nx">inc</span><span class="p">(</span><span class="o">-</span><span class="mi">805</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">)</span>
<span class="w">  </span><span class="c1">// Lis et affiche trois résultats du canal - impossible de savoir dans quel</span>
<span class="w">  </span><span class="c1">// ordre !</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">c</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">c</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">c</span><span class="p">)</span><span class="w"> </span><span class="c1">// Canal à droite, &lt;- est l&#39;opérateur de</span>
<span class="w">                             </span><span class="c1">// &quot;réception&quot;.</span>

<span class="w">  </span><span class="nx">cs</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w">       </span><span class="c1">// Un autre canal, celui-ci gère des chaînes.</span>
<span class="w">  </span><span class="nx">ccs</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kd">chan</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="c1">// Un canal de canaux de chaînes.</span>
<span class="w">  </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">84</span><span class="w"> </span><span class="p">}()</span><span class="w">       </span><span class="c1">// Démarre une nouvelle goroutine, pour</span>
<span class="w">                                </span><span class="c1">// envoyer une valeur.</span>
<span class="w">  </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">cs</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s">&quot;wordy&quot;</span><span class="w"> </span><span class="p">}()</span><span class="w"> </span><span class="c1">// De nouveau, pour cs cette fois-ci.</span>
<span class="w">  </span><span class="c1">// Select possède une syntaxe similaire au switch, mais chaque cas requiert</span>
<span class="w">  </span><span class="c1">// une opération impliquant un canal. Il sélectionne un cas aléatoirement</span>
<span class="w">  </span><span class="c1">// prêt à communiquer.</span>
<span class="w">  </span><span class="k">select</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">c</span><span class="p">:</span><span class="w"> </span><span class="c1">// La valeur reçue peut être assignée à une variable,</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;c&#39;est un %T&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">cs</span><span class="p">:</span><span class="w"> </span><span class="c1">// ou la valeur reçue peut être ignorée.</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;c&#39;est une chaîne&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">ccs</span><span class="p">:</span><span class="w"> </span><span class="c1">// Un canal vide, indisponible à la communication.</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;ne surviendra pas.&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// À ce point, une valeur a été prise de c ou cs. L&#39;une des deux goroutines</span>
<span class="w">  </span><span class="c1">// démarrée plus haut a complétée, la seconde restera bloquée.</span>

<span class="w">  </span><span class="nx">learnWebProgramming</span><span class="p">()</span><span class="w"> </span><span class="c1">// Go permet la programmation Web.</span>
<span class="p">}</span>

<span class="c1">// Une seule fonction du paquet http démarre un serveur Web.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">learnWebProgramming</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="c1">// Le premier paramètre de ListenAndServe est une adresse TCP à écouter.</span>
<span class="w">  </span><span class="c1">// Le second est une interface, de type http.Handler.</span>
<span class="w">  </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">http</span><span class="p">.</span><span class="nx">ListenAndServe</span><span class="p">(</span><span class="s">&quot;:8080&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">pair</span><span class="p">{})</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"> </span><span class="c1">// n&#39;ignorez pas les erreurs !</span>
<span class="w">  </span><span class="p">}()</span>

<span class="w">  </span><span class="nx">requestServer</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// Implémente la méthode ServeHTTP de http.Handler à pair, la rendant compatible</span>
<span class="c1">// avec les opérations utilisant l&#39;interface http.Handler.</span>
<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">p</span><span class="w"> </span><span class="nx">pair</span><span class="p">)</span><span class="w"> </span><span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span><span class="w"> </span><span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Répondez à une requête à l&#39;aide de la méthode http.ResponseWriter.</span>
<span class="w">  </span><span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;Vous avez appris Go en Y minutes!&quot;</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">requestServer</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">resp</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;http://localhost:8080&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="w">  </span><span class="k">defer</span><span class="w"> </span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="w">  </span><span class="nx">body</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ioutil</span><span class="p">.</span><span class="nx">ReadAll</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
<span class="w">  </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;\nLe serveur Web a dit: `%s`&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">string</span><span class="p">(</span><span class="nx">body</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
<h2>En savoir plus</h2>

<p>La référence Go se trouve sur <a href="https://go.dev/">le site officiel de Go</a>.
Vous pourrez y suivre le tutoriel interactif et en apprendre beaucoup plus.</p>

<p>Une lecture de la documentation du langage est grandement conseillée. C&#39;est
facile à lire et très court (comparé aux autres langages).</p>

<p>Vous pouvez exécuter et modifier le code sur <a href="https://go.dev/play/p/tnWMjr16Mm">Go playground</a>. Essayez de le modifier et de l&#39;exécuter à partir de votre navigateur! Prennez en note que vous pouvez utiliser <a href="https://go.dev/play/">https://go.dev/play/</a> comme un <a href="https://en.wikipedia.org/wiki/Read-eval-print_loop">REPL</a> pour tester et coder dans votre navigateur, sans même avoir à installer Go.</p>

<p>Sur la liste de lecteur des étudiants de Go se trouve le <a href="https://go.dev/src/">code source de la
librairie standard</a>. Bien documentée, elle démontre
le meilleur de la clarté de Go, le style ainsi que ses expressions. Sinon, vous
pouvez cliquer sur le nom d&#39;une fonction dans <a href="https://go.dev/pkg/">la
documentation</a> et le code source apparaît!</p>

<p>Une autre excellente ressource pour apprendre est <a href="https://gobyexample.com/">Go par l&#39;exemple</a>.</p>

    <hr>
    <p>Vous avez une suggestion ? Peut-être une correction ? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Ouvrez un ticket</a> sur Github, ou faites vous-même une <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/fr-fr/go-fr.html.markdown">pull request</a> !
    </p>
    <p class="contributed">
    Version originale par Sonia Keys, mis à jour par <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/fr-fr/go-fr.html.markdown">10 contributeur(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="https://github.com/soniakeys">Sonia Keys</a>,
        <a href="https://github.com/cbess">Christopher Bess</a>,
        <a href="https://github.com/holocronweaver">Jesse Johnson</a>,
        <a href="https://github.com/qguv">Quint Guvernator</a>,
        <a href="https://github.com/josedonizetti">Jose Donizetti</a>,
        <a href="https://github.com/heyalexej">Alexej Friesen</a>,
        <a href="http://blogue.jpmonette.net/">Jean-Philippe Monette</a>
    </p>

    <p>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
