<!DOCTYPE html lang="fr-fr" xml:lang="fr-fr" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="fr-fr">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Go in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/fr-fr/go-fr/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Ffr-fr%2Fgo-fr%2F&text=Apprendre+X+en+Y+minutes%2C+o%C3%B9+X%3DGo">
        Partager cette page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Choisis un thème:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">clair</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">sombre</button>
  </div>
  <h1><a href="/">Apprendre X en Y minutes</a></h1>
  <h2>Où X=Go</h2>
    <p class="filelink">
    Récupérer le code:
    <a href="/docs/files/learngo-fr.go">learngo-fr.go</a>
    </p>
  <div id="doc">
    <p>Go a été créé dans l&#39;optique de développer de façon efficace. Ce n&#39;est pas la
dernière tendance en ce qui est au développement, mais c&#39;est la nouvelle façon
de régler des défis réels de façon rapide.</p>

<p>Le langage possède des concepts familiers à la programmation impérative avec
typage. Il est rapide à compiler et exécuter, ajoute une concurrence facile à
comprendre, pour les processeurs multi coeurs d&#39;aujourd&#39;hui et apporte des
fonctionnalités facilitant le développement à grande échelle.</p>

<p>Développer avec Go, c&#39;est bénéficier d&#39;une riche bibliothèque standard et d&#39;une
communauté active.</p>
<div class="highlight"><pre class="highlight go"><code><span class="c">// Commentaire ligne simple</span>
<span class="c">/* Commentaire
 multiligne */</span>

<span class="c">// Un paquet débute avec une clause "package"</span>
<span class="c">// "main" est un nom spécial déclarant un paquet de type exécutable plutôt</span>
<span class="c">// qu'une bibliothèque</span>
<span class="k">package</span> <span class="n">main</span>

<span class="c">// "Import" déclare les paquets référencés dans ce fichier.</span>
<span class="k">import</span> <span class="p">(</span>
  <span class="s">"fmt"</span>       <span class="c">// Un paquet dans la bibliothèque standard.</span>
  <span class="s">"io/ioutil"</span> <span class="c">// Implémente des fonctions utilitaires I/O.</span>
  <span class="n">m</span> <span class="s">"math"</span>    <span class="c">// Bibliothèque mathématique utilisant un alias local "m".</span>
  <span class="s">"net/http"</span>  <span class="c">// Un serveur Web!</span>
  <span class="s">"strconv"</span>   <span class="c">// Bibliothèque pour convertir les chaînes de caractères.</span>
<span class="p">)</span>

<span class="c">// Une définition de fonction. La fonction "main" est spéciale - c'est le point</span>
<span class="c">// d'entrée du binaire.</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// Println retournera la valeur à la console.</span>
  <span class="c">// Associez la fonction avec son paquet respectif, fmt.</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Hello world!"</span><span class="p">)</span>

  <span class="c">// Appelez une fonction différente à partir de ce paquet.</span>
  <span class="n">beyondHello</span><span class="p">()</span>
<span class="p">}</span>

<span class="c">// Les fonctions ont des paramètres entre parenthèses.</span>
<span class="c">// Les parenthèses sont nécessaires avec ou sans paramètre.</span>
<span class="k">func</span> <span class="n">beyondHello</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">x</span> <span class="kt">int</span> <span class="c">// Déclaration de variable. Les variables doivent être déclarées</span>
            <span class="c">// avant leur utilisation.</span>
  <span class="n">x</span> <span class="o">=</span> <span class="m">3</span>     <span class="c">// Assignation de valeur.</span>
  <span class="c">// Les déclarations courtes utilisent := pour inférer le type, déclarer et</span>
  <span class="c">// assigner.</span>
  <span class="n">y</span> <span class="o">:=</span> <span class="m">4</span>
  <span class="n">sum</span><span class="p">,</span> <span class="n">prod</span> <span class="o">:=</span> <span class="n">learnMultiple</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>        <span class="c">// La fonction retourne deux valeurs.</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"sum:"</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="s">"prod:"</span><span class="p">,</span> <span class="n">prod</span><span class="p">)</span> <span class="c">// Affichage simple.</span>
  <span class="n">learnTypes</span><span class="p">()</span>                            <span class="c">// &lt; y minutes, en savoir plus!</span>
<span class="p">}</span>

<span class="c">// Les fonctions peuvent avoir des paramètres et plusieurs valeurs retournées.</span>
<span class="k">func</span> <span class="n">learnMultiple</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">sum</span><span class="p">,</span> <span class="n">prod</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="c">// Deux valeurs retournées.</span>
<span class="p">}</span>

<span class="c">// Quelques types inclus et littéraux.</span>
<span class="k">func</span> <span class="n">learnTypes</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// Une déclaration courte infère généralement le type désiré.</span>
  <span class="n">str</span> <span class="o">:=</span> <span class="s">"Learn Go!"</span> <span class="c">// Type string.</span>

  <span class="n">s2</span> <span class="o">:=</span> <span class="s">`Une chaîne de caractères peut contenir des
sauts de ligne.`</span> <span class="c">// Chaîne de caractère.</span>

  <span class="c">// Littéral non-ASCII. Les sources Go utilisent le charset UTF-8.</span>
  <span class="n">g</span> <span class="o">:=</span> <span class="sc">'Σ'</span> <span class="c">// type rune, un alias pour le type int32, contenant un caractère</span>
           <span class="c">// unicode.</span>

  <span class="n">f</span> <span class="o">:=</span> <span class="m">3.14159</span> <span class="c">// float64, un nombre flottant IEEE-754 de 64-bit.</span>
  <span class="n">c</span> <span class="o">:=</span> <span class="m">3</span> <span class="o">+</span> <span class="m">4i</span>  <span class="c">// complex128, considéré comme deux float64 par le compilateur.</span>

  <span class="c">// Syntaxe "var" avec une valeur d'initialisation.</span>
  <span class="k">var</span> <span class="n">u</span> <span class="kt">uint</span> <span class="o">=</span> <span class="m">7</span> <span class="c">// Non signé, mais la taille dépend selon l'entier.</span>
  <span class="k">var</span> <span class="n">pi</span> <span class="kt">float32</span> <span class="o">=</span> <span class="m">22.</span> <span class="o">/</span> <span class="m">7</span>

  <span class="c">// Conversion avec syntaxe courte.</span>
  <span class="n">n</span> <span class="o">:=</span> <span class="kt">byte</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">)</span> <span class="c">// byte est un alias du type uint8.</span>

  <span class="c">// Les tableaux ont une taille fixe déclarée à la compilation.</span>
  <span class="k">var</span> <span class="n">a4</span> <span class="p">[</span><span class="m">4</span><span class="p">]</span><span class="kt">int</span>           <span class="c">// Un tableau de 4 ints, tous initialisés à 0.</span>
  <span class="n">a3</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="m">3</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">5</span><span class="p">}</span> <span class="c">// Un tableau initialisé avec une taille fixe de 3</span>
  <span class="c">// éléments, contenant les valeurs 3, 1 et 5.</span>

  <span class="c">// Les slices ont des tailles dynamiques. Les tableaux et slices ont chacun</span>
  <span class="c">// des avantages, mais les cas d'utilisation des slices sont plus fréquents.</span>
  <span class="n">s3</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">9</span><span class="p">}</span>    <span class="c">// Comparable à a3.</span>
  <span class="n">s4</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">4</span><span class="p">)</span>    <span class="c">// Alloue un slice de 4 ints, initialisés à 0.</span>
  <span class="k">var</span> <span class="n">d2</span> <span class="p">[][]</span><span class="kt">float64</span>      <span class="c">// Déclaration seulement, sans allocation de mémoire.</span>
  <span class="n">bs</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"a slice"</span><span class="p">)</span> <span class="c">// Conversion d'une chaîne en slice de bytes.</span>

  <span class="c">// Parce qu'elles sont dynamiques, les slices peuvent être jointes sur</span>
  <span class="c">// demande. Pour joindre un élément à une slice, la fonction standard append()</span>
  <span class="c">// est utilisée. Le premier argument est la slice à utiliser. Habituellement,</span>
  <span class="c">// la variable tableau est mise à jour sur place, voir ci-bas.</span>
  <span class="n">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">}</span>     <span class="c">// Le résultat est une slice de taille 3.</span>
  <span class="n">s</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">6</span><span class="p">)</span>  <span class="c">// Ajout de 3 valeurs. La taille est de 6.</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>          <span class="c">// La valeur est de [1 2 3 4 5 6]</span>

  <span class="c">// Pour ajouter une slice à une autre, au lieu d'utiliser une liste de valeurs</span>
  <span class="c">// atomiques, il est possible de mettre en argument une référence de</span>
  <span class="c">// slice littérale grâce aux points de suspension.</span>
  <span class="n">s</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">7</span><span class="p">,</span> <span class="m">8</span><span class="p">,</span> <span class="m">9</span><span class="p">}</span><span class="o">...</span><span class="p">)</span> <span class="c">// Le deuxième argument est une slice</span>
                                   <span class="c">// littérale.</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c">// La slice contient [1 2 3 4 5 6 7 8 9]</span>

  <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">learnMemory</span><span class="p">()</span> <span class="c">// Déclare p, q comme étant des pointeurs de type int.</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>   <span class="c">// * suit un pointeur. Ceci retourne deux ints.</span>

  <span class="c">// Les maps sont des tableaux associatifs de taille dynamique, comme les</span>
  <span class="c">// hash ou les types dictionnaires de certains langages.</span>
  <span class="n">m</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">"trois"</span><span class="o">:</span> <span class="m">3</span><span class="p">,</span> <span class="s">"quatre"</span><span class="o">:</span> <span class="m">4</span><span class="p">}</span>
  <span class="n">m</span><span class="p">[</span><span class="s">"un"</span><span class="p">]</span> <span class="o">=</span> <span class="m">1</span>

  <span class="c">// Les valeurs inutilisées sont considérées comme des erreurs en Go.</span>
  <span class="c">// Un tiret bas permet d'ignorer une valeur inutilisée, évitant une erreur.</span>
  <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">str</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">s4</span><span class="p">,</span> <span class="n">bs</span>

  <span class="c">// Cependant, son affichage en console est considéré comme une utilisation,</span>
  <span class="c">// ce qui ne sera pas considéré comme une erreur à la compilation.</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">a4</span><span class="p">,</span> <span class="n">s3</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

  <span class="n">learnFlowControl</span><span class="p">()</span> <span class="c">// De retour dans le flux.</span>
<span class="p">}</span>

<span class="c">// Il est possible, à l'opposé de plusieurs autres langages, de retourner des</span>
<span class="c">// variables par leur nom à partir de fonctions.</span>
<span class="c">// Assigner un nom à un type retourné par une fonction permet de retrouver sa</span>
<span class="c">// valeur ainsi que d'utiliser le mot-clé "return" uniquement, sans plus.</span>
<span class="k">func</span> <span class="n">learnNamedReturns</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">z</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
  <span class="k">return</span> <span class="c">// z est implicite, car la variable a été définie précédemment.</span>
<span class="p">}</span>

<span class="c">// La récupération de la mémoire est automatique en Go. Le langage possède des</span>
<span class="c">// pointeurs, mais aucune arithmétique des pointeurs (*(a + b) en C). Vous</span>
<span class="c">// pouvez produire une erreur avec un pointeur nil, mais pas en incrémentant un</span>
<span class="c">// pointeur.</span>
<span class="k">func</span> <span class="n">learnMemory</span><span class="p">()</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">*</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="c">// Les valeurs retournées p et q auront le type pointeur int.</span>
  <span class="n">p</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="c">// Fonction standard "new" alloue la mémoire.</span>
  <span class="c">// Le int alloué est initialisé à 0, p n'est plus nil.</span>
  <span class="n">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">20</span><span class="p">)</span> <span class="c">// Alloue 20 ints en un seul bloc de mémoire.</span>
  <span class="n">s</span><span class="p">[</span><span class="m">3</span><span class="p">]</span> <span class="o">=</span> <span class="m">7</span>             <span class="c">// Assigne l'un des entiers.</span>
  <span class="n">r</span> <span class="o">:=</span> <span class="o">-</span><span class="m">2</span>              <span class="c">// Déclare une autre variable locale.</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="m">3</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">r</span>     <span class="c">// &amp; retourne l'adresse d'un objet.</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">expensiveComputation</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">Exp</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">learnFlowControl</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// Bien que les "if" requièrent des accolades, les parenthèses ne sont pas</span>
  <span class="c">// nécessaires pour contenir le test booléen.</span>
  <span class="k">if</span> <span class="no">true</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"voilà!"</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="c">// Le formatage du code est standardisé par la commande shell "go fmt."</span>
  <span class="k">if</span> <span class="no">false</span> <span class="p">{</span>
    <span class="c">// bing.</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c">// bang.</span>
  <span class="p">}</span>
  <span class="c">// Utilisez "switch" au lieu des "if" en chaîne</span>
  <span class="n">x</span> <span class="o">:=</span> <span class="m">42.0</span>
  <span class="k">switch</span> <span class="n">x</span> <span class="p">{</span>
  <span class="k">case</span> <span class="m">0</span><span class="o">:</span>
  <span class="k">case</span> <span class="m">1</span><span class="o">:</span>
  <span class="k">case</span> <span class="m">42</span><span class="o">:</span>
    <span class="c">// Les "case" n'ont pas besoin de "break;".</span>
  <span class="k">case</span> <span class="m">43</span><span class="o">:</span>
    <span class="c">// Non-exécuté.</span>
  <span class="p">}</span>
  <span class="c">// Comme les "if", les "for" n'utilisent pas de parenthèses.</span>
  <span class="c">// Les variables déclarées dans les "for" et les "if" sont locales à leur</span>
  <span class="c">// portée.</span>
  <span class="k">for</span> <span class="n">x</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span> <span class="p">{</span> <span class="c">// ++ est une incrémentation.</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"itération "</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="c">// x == 42 ici.</span>

  <span class="c">// "For" est le seul type de boucle en Go, mais possède différentes formes.</span>
  <span class="k">for</span> <span class="p">{</span> <span class="c">// Boucle infinie</span>
    <span class="k">break</span>    <span class="c">// C'est une farce</span>
    <span class="k">continue</span> <span class="c">// Non atteint.</span>
  <span class="p">}</span>

  <span class="c">// Vous pouvez utiliser une "range" pour itérer dans un tableau, une slice, une</span>
  <span class="c">// chaîne, une map ou un canal. Les "range" retournent un canal ou deux</span>
  <span class="c">// valeurs (tableau, slice, chaîne et map).</span>
  <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">"une"</span><span class="o">:</span> <span class="m">1</span><span class="p">,</span> <span class="s">"deux"</span><span class="o">:</span> <span class="m">2</span><span class="p">,</span> <span class="s">"trois"</span><span class="o">:</span> <span class="m">3</span><span class="p">}</span> <span class="p">{</span>
    <span class="c">// pour chaque pair dans une map, affichage de la valeur et clé</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"clé=%s, valeur=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c">// À l'opposé du "for", := dans un "if" signifie la déclaration et</span>
  <span class="c">// l'assignation y en premier, et ensuite y &gt; x</span>
  <span class="k">if</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">expensiveComputation</span><span class="p">();</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">y</span>
  <span class="p">}</span>
  <span class="c">// Les fonctions littérales sont des fermetures.</span>
  <span class="n">xBig</span> <span class="o">:=</span> <span class="k">func</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="m">10000</span>
  <span class="p">}</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"xBig:"</span><span class="p">,</span> <span class="n">xBig</span><span class="p">())</span> <span class="c">// true (la valeur e^10 a été assignée à x).</span>
  <span class="n">x</span> <span class="o">=</span> <span class="m">1.3e3</span>                    <span class="c">// Ceci fait x == 1300</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"xBig:"</span><span class="p">,</span> <span class="n">xBig</span><span class="p">())</span> <span class="c">// Maintenant false.</span>

  <span class="c">// De plus, les fonctions littérales peuvent être définies et appelées</span>
  <span class="c">// sur la même ligne, agissant comme argument à cette fonction, tant que:</span>
  <span class="c">// a) la fonction littérale est appelée suite à (),</span>
  <span class="c">// b) le résultat correspond au type de l'argument.</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Ajoute + multiplie deux nombres : "</span><span class="p">,</span>
    <span class="k">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="m">2</span>
    <span class="p">}(</span><span class="m">10</span><span class="p">,</span> <span class="m">2</span><span class="p">))</span> <span class="c">// Appelle la fonction avec les arguments 10 et 2</span>
  <span class="c">// =&gt; Ajoute + double deux nombres : 24</span>

  <span class="c">// Quand vous en aurez besoin, vous allez l'adorer.</span>
  <span class="k">goto</span> <span class="n">love</span>
<span class="n">love</span><span class="o">:</span>

  <span class="n">learnFunctionFactory</span><span class="p">()</span> <span class="c">// func retournant func correspondant à fun(3)(3).</span>
  <span class="n">learnDefer</span><span class="p">()</span>           <span class="c">// Un survol de cette instruction importante.</span>
  <span class="n">learnInterfaces</span><span class="p">()</span>      <span class="c">// Incontournable !</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">learnFunctionFactory</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// Les deux syntaxes sont identiques, bien que la seconde soit plus pratique.</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">sentenceFactory</span><span class="p">(</span><span class="s">"été"</span><span class="p">)(</span><span class="s">"Une matinée d'"</span><span class="p">,</span> <span class="s">"agréable!"</span><span class="p">))</span>

  <span class="n">d</span> <span class="o">:=</span> <span class="n">sentenceFactory</span><span class="p">(</span><span class="s">"été"</span><span class="p">)</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">d</span><span class="p">(</span><span class="s">"Une matinée d'"</span><span class="p">,</span> <span class="s">"agréable!"</span><span class="p">))</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">d</span><span class="p">(</span><span class="s">"Une soirée d'"</span><span class="p">,</span> <span class="s">"relaxante!"</span><span class="p">))</span>
<span class="p">}</span>

<span class="c">// Le décorateur est un patron de conception commun dans d'autres langages.</span>
<span class="c">// Il est possible de faire de même en Go avec des fonctions littérales</span>
<span class="c">// acceptant des arguments.</span>
<span class="k">func</span> <span class="n">sentenceFactory</span><span class="p">(</span><span class="n">mystring</span> <span class="kt">string</span><span class="p">)</span> <span class="k">func</span><span class="p">(</span><span class="n">before</span><span class="p">,</span> <span class="n">after</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">before</span><span class="p">,</span> <span class="n">after</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"%s %s %s"</span><span class="p">,</span> <span class="n">before</span><span class="p">,</span> <span class="n">mystring</span><span class="p">,</span> <span class="n">after</span><span class="p">)</span> <span class="c">// nouvelle chaîne</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">learnDefer</span><span class="p">()</span> <span class="p">(</span><span class="n">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="c">// Les déclarations différées sont exécutées avant la sortie d'une fonction.</span>
  <span class="k">defer</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"les déclarations différées s'exécutent en ordre LIFO."</span><span class="p">)</span>
  <span class="k">defer</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Cette ligne est affichée en premier parce que"</span><span class="p">)</span>
  <span class="c">// Les déclarations différées sont utilisées fréquemment pour fermer un</span>
  <span class="c">// fichier, afin que la fonction ferme le fichier en fin d'exécution.</span>
  <span class="k">return</span> <span class="no">true</span>
<span class="p">}</span>

<span class="c">// Défini Stringer comme étant une interface avec une méthode, String.</span>
<span class="k">type</span> <span class="n">Stringer</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c">// Défini pair comme étant une structure contenant deux entiers, x et y.</span>
<span class="k">type</span> <span class="n">pair</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="c">// Défini une méthode associée au type pair. Pair implémente maintenant Stringer</span>
<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="n">pair</span><span class="p">)</span> <span class="n">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="c">// p s'appelle le "destinataire"</span>
  <span class="c">// Sprintf est une autre fonction publique dans le paquet fmt.</span>
  <span class="c">// La syntaxe avec point permet de faire référence aux valeurs de p.</span>
  <span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"(%d, %d)"</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">learnInterfaces</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// La syntaxe avec accolade défini une "structure littérale". Celle-ci</span>
  <span class="c">// s'évalue comme étant une structure. La syntaxe := déclare et initialise p</span>
  <span class="c">// comme étant une instance.</span>
  <span class="n">p</span> <span class="o">:=</span> <span class="n">pair</span><span class="p">{</span><span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">}</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">String</span><span class="p">())</span> <span class="c">// Appelle la méthode String de p, de type pair.</span>
  <span class="k">var</span> <span class="n">i</span> <span class="n">Stringer</span>          <span class="c">// Déclare i instance de l'interface Stringer.</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">p</span>                   <span class="c">// Valide, car pair implémente Stringer.</span>
  <span class="c">// Appelle la méthode String de i, de type Stringer. Retourne la même valeur</span>
  <span class="c">// que ci-haut.</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">String</span><span class="p">())</span>

  <span class="c">// Les fonctions dans le paquet fmt appellent la méthode String, demandant</span>
  <span class="c">// aux objets d'afficher une représentation de leur structure.</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="c">// Affiche la même chose que ci-haut. Println appelle la</span>
                 <span class="c">// méthode String.</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c">// Affiche la même chose que ci-haut.</span>

  <span class="n">learnVariadicParams</span><span class="p">(</span><span class="s">"apprentissage"</span><span class="p">,</span> <span class="s">"génial"</span><span class="p">,</span> <span class="s">"ici!"</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// Les fonctions peuvent être définie de façon à accepter un ou plusieurs</span>
<span class="c">// paramètres grâce aux points de suspension, offrant une flexibilité lors de</span>
<span class="c">// son appel.</span>
<span class="k">func</span> <span class="n">learnVariadicParams</span><span class="p">(</span><span class="n">myStrings</span> <span class="o">...</span><span class="k">interface</span><span class="p">{})</span> <span class="p">{</span>
  <span class="c">// Itère chaque paramètre dans la range.</span>
  <span class="c">// Le tiret bas sert à ignorer l'index retourné du tableau.</span>
  <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">param</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">myStrings</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"paramètre:"</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c">// Passe une valeur variadique comme paramètre variadique.</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"paramètres:"</span><span class="p">,</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintln</span><span class="p">(</span><span class="n">myStrings</span><span class="o">...</span><span class="p">))</span>

  <span class="n">learnErrorHandling</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">learnErrorHandling</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// ", ok" idiome utilisée pour définir si l'opération s'est déroulée avec</span>
  <span class="c">// succès ou non</span>
  <span class="n">m</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="m">3</span><span class="o">:</span> <span class="s">"trois"</span><span class="p">,</span> <span class="m">4</span><span class="o">:</span> <span class="s">"quatre"</span><span class="p">}</span>
  <span class="k">if</span> <span class="n">x</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">m</span><span class="p">[</span><span class="m">1</span><span class="p">];</span> <span class="o">!</span><span class="n">ok</span> <span class="p">{</span> <span class="c">// ok sera faux, car 1 n'est pas dans la map.</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"inexistant"</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c">// x serait la valeur, si elle se trouvait dans la map.</span>
  <span class="p">}</span>
  <span class="c">// Une erreur ne retourne qu'un "ok", mais également plus d'information</span>
  <span class="c">// par rapport à un problème survenu.</span>
  <span class="k">if</span> <span class="n">_</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">strconv</span><span class="o">.</span><span class="n">Atoi</span><span class="p">(</span><span class="s">"non-int"</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span> <span class="c">// _ discarte la valeur</span>
    <span class="c">// retourne: 'strconv.ParseInt: parsing "non-int": invalid syntax'</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="c">// Nous réviserons les interfaces un peu plus tard. Pour l'instant,</span>
  <span class="n">learnConcurrency</span><span class="p">()</span>
<span class="p">}</span>

<span class="c">// c est un canal, un objet permettant de communiquer en simultané de façon</span>
<span class="c">// sécurisée.</span>
<span class="k">func</span> <span class="n">inc</span><span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">,</span> <span class="n">c</span> <span class="k">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">c</span> <span class="o">&lt;-</span> <span class="n">i</span> <span class="o">+</span> <span class="m">1</span> <span class="c">// &lt;- est l'opérateur "envoi" quand un canal apparaît à</span>
             <span class="c">// gauche.</span>
<span class="p">}</span>

<span class="c">// Nous utiliserons inc pour incrémenter des nombres en même temps.</span>
<span class="k">func</span> <span class="n">learnConcurrency</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// La fonction "make" utilisée précédemment pour générer un slice. Elle</span>
  <span class="c">// alloue et initialise les slices, maps et les canaux.</span>
  <span class="n">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
  <span class="c">// Démarrage de trois goroutines simultanées. Les nombres seront incrémentés</span>
  <span class="c">// simultanément, peut-être en paralèle si la machine le permet et configurée</span>
  <span class="c">// correctement. Les trois utilisent le même canal.</span>
  <span class="k">go</span> <span class="n">inc</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="c">// go est une instruction démarrant une nouvelle goroutine.</span>
  <span class="k">go</span> <span class="n">inc</span><span class="p">(</span><span class="m">10</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
  <span class="k">go</span> <span class="n">inc</span><span class="p">(</span><span class="o">-</span><span class="m">805</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
  <span class="c">// Lis et affiche trois résultats du canal - impossible de savoir dans quel</span>
  <span class="c">// ordre !</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="n">c</span><span class="p">,</span> <span class="o">&lt;-</span><span class="n">c</span><span class="p">,</span> <span class="o">&lt;-</span><span class="n">c</span><span class="p">)</span> <span class="c">// Canal à droite, &lt;- est l'opérateur de</span>
                             <span class="c">// "réception".</span>

  <span class="n">cs</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">string</span><span class="p">)</span>       <span class="c">// Un autre canal, celui-ci gère des chaînes.</span>
  <span class="n">ccs</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="c">// Un canal de canaux de chaînes.</span>
  <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">c</span> <span class="o">&lt;-</span> <span class="m">84</span> <span class="p">}()</span>       <span class="c">// Démarre une nouvelle goroutine, pour</span>
                                <span class="c">// envoyer une valeur.</span>
  <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">cs</span> <span class="o">&lt;-</span> <span class="s">"wordy"</span> <span class="p">}()</span> <span class="c">// De nouveau, pour cs cette fois-ci.</span>
  <span class="c">// Select possède une syntaxe similaire au switch, mais chaque cas requiert</span>
  <span class="c">// une opération impliquant un canal. Il sélectionne un cas aléatoirement</span>
  <span class="c">// prêt à communiquer.</span>
  <span class="k">select</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">i</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">c</span><span class="o">:</span> <span class="c">// La valeur reçue peut être assignée à une variable,</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"c'est un %T"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
  <span class="k">case</span> <span class="o">&lt;-</span><span class="n">cs</span><span class="o">:</span> <span class="c">// ou la valeur reçue peut être ignorée.</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"c'est une chaîne"</span><span class="p">)</span>
  <span class="k">case</span> <span class="o">&lt;-</span><span class="n">ccs</span><span class="o">:</span> <span class="c">// Un canal vide, indisponible à la communication.</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"ne surviendra pas."</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="c">// À ce point, une valeur a été prise de c ou cs. L'une des deux goroutines</span>
  <span class="c">// démarrée plus haut a complétée, la seconde restera bloquée.</span>

  <span class="n">learnWebProgramming</span><span class="p">()</span> <span class="c">// Go permet la programmation Web.</span>
<span class="p">}</span>

<span class="c">// Une seule fonction du paquet http démarre un serveur Web.</span>
<span class="k">func</span> <span class="n">learnWebProgramming</span><span class="p">()</span> <span class="p">{</span>

  <span class="c">// Le premier paramètre de ListenAndServe est une adresse TCP à écouter.</span>
  <span class="c">// Le second est une interface, de type http.Handler.</span>
  <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">err</span> <span class="o">:=</span> <span class="n">http</span><span class="o">.</span><span class="n">ListenAndServe</span><span class="p">(</span><span class="s">":8080"</span><span class="p">,</span> <span class="n">pair</span><span class="p">{})</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="c">// n'ignorez pas les erreurs !</span>
  <span class="p">}()</span>

  <span class="n">requestServer</span><span class="p">()</span>
<span class="p">}</span>

<span class="c">// Implémente la méthode ServeHTTP de http.Handler à pair, la rendant compatible</span>
<span class="c">// avec les opérations utilisant l'interface http.Handler.</span>
<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="n">pair</span><span class="p">)</span> <span class="n">ServeHTTP</span><span class="p">(</span><span class="n">w</span> <span class="n">http</span><span class="o">.</span><span class="n">ResponseWriter</span><span class="p">,</span> <span class="n">r</span> <span class="o">*</span><span class="n">http</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="c">// Répondez à une requête à l'aide de la méthode http.ResponseWriter.</span>
  <span class="n">w</span><span class="o">.</span><span class="n">Write</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"Vous avez appris Go en Y minutes!"</span><span class="p">))</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">requestServer</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">resp</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">http</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="s">"http://localhost:8080"</span><span class="p">)</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
  <span class="k">defer</span> <span class="n">resp</span><span class="o">.</span><span class="n">Body</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
  <span class="n">body</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">ioutil</span><span class="o">.</span><span class="n">ReadAll</span><span class="p">(</span><span class="n">resp</span><span class="o">.</span><span class="n">Body</span><span class="p">)</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Le serveur Web a dit: `%s`"</span><span class="p">,</span> <span class="kt">string</span><span class="p">(</span><span class="n">body</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>
<h2>En savoir plus</h2>

<p>La référence Go se trouve sur <a href="https://go.dev/">le site officiel de Go</a>.
Vous pourrez y suivre le tutoriel interactif et en apprendre beaucoup plus.</p>

<p>Une lecture de la documentation du langage est grandement conseillée. C&#39;est
facile à lire et très court (comparé aux autres langages).</p>

<p>Vous pouvez exécuter et modifier le code sur <a href="https://go.dev/play/p/tnWMjr16Mm">Go playground</a>. Essayez de le modifier et de l&#39;exécuter à partir de votre navigateur! Prennez en note que vous pouvez utiliser <a href="https://go.dev/play/">https://go.dev/play/</a> comme un <a href="https://en.wikipedia.org/wiki/Read-eval-print_loop">REPL</a> pour tester et coder dans votre navigateur, sans même avoir à installer Go.</p>

<p>Sur la liste de lecteur des étudiants de Go se trouve le <a href="https://go.dev/src/">code source de la
librairie standard</a>. Bien documentée, elle démontre
le meilleur de la clarté de Go, le style ainsi que ses expressions. Sinon, vous
pouvez cliquer sur le nom d&#39;une fonction dans <a href="https://go.dev/pkg/">la
documentation</a> et le code source apparaît!</p>

<p>Une autre excellente ressource pour apprendre est <a href="https://gobyexample.com/">Go par l&#39;exemple</a>.</p>

    <hr>
    <p>Vous avez une suggestion ? Peut-être une correction ? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Ouvrez un ticket</a> sur Github, ou faites vous-même une <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/fr-fr/go-fr.html.markdown">pull request</a> !
    </p>
    <p class="contributed">
    Version originale par Sonia Keys, mis à jour par <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/fr-fr/go-fr.html.markdown">10 contributeur(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="https://github.com/soniakeys">Sonia Keys</a>,
        <a href="https://github.com/cbess">Christopher Bess</a>,
        <a href="https://github.com/holocronweaver">Jesse Johnson</a>,
        <a href="https://github.com/qguv">Quint Guvernator</a>,
        <a href="https://github.com/josedonizetti">Jose Donizetti</a>,
        <a href="https://github.com/heyalexej">Alexej Friesen</a>,
        <a href="http://blogue.jpmonette.net/">Jean-Philippe Monette</a>
    </p>

    <p>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
