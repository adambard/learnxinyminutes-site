<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="fr-fr" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="fr-fr" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="fr-fr" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="fr-fr" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="fr-fr">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn c in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/fr-fr/c-fr/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Ffr-fr%2Fc-fr%2F&text=Apprendre+X+en+Y+minutes%2C+o%C3%B9+X%3Dc">
        Partager cette page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Choisis un thème:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">clair</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">sombre</button>
  </div>
  <h1><a href="/">Apprendre X en Y minutes</a></h1>
  <h2>Où X=c</h2>
    <p class="filelink">
    Récupérer le code:
    <a href="/docs/files/learnc.c">learnc.c</a>
    </p>
  <div id="doc">
    <p>Le C est le langage de plus bas niveau que la plupart des programmeurs seront
amenés à utiliser, mais ceci est largement conpensé par sa vitesse brute.</p>

<blockquote>
<p><strong>À propos des options de compilation</strong></p>

<p>Par défaut, gcc et clang sont assez silencieux sur les avertissements et
les erreurs de compilation, qui peuvent être des informations très utiles.
L&#39;utilisation explicite d&#39;options de compilation plus strictes est recommandée.
Voici quelques valeurs par défaut recommandées:</p>

<p><code>-Wall -Wextra -Werror -O2 -std=c99 -pedantic</code></p>

<p>Pour plus d&#39;informations sur ce que font ces options ainsi que sur d&#39;autres,
vous pouvez consulter la page du manuel de votre compilateur C (par exemple <code>man 1 gcc</code>)
ou recherchez simplement en ligne.</p>
</blockquote>
<div class="highlight"><pre><span></span><span class="c1">// Les commentaires sur une ligne commencent par // - valable seulement pour C99 et plus tard.</span>

<span class="cm">/*</span>
<span class="cm">Les commentaires multilignes resemblent à ceci. Ils restent valables en C89.</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">Les commentaires multilignes ne s&#39;emboîtent pas /* Attention */</span><span class="w">  </span><span class="c1">// Le commentaire se termine sur cette ligne...</span>
<span class="o">*/</span><span class="w"> </span><span class="c1">// ...pas ici !</span>

<span class="c1">// Constante : #define &lt;nom&gt;</span>
<span class="c1">// Les constantes sont écrites en majuscules par convention, pas d&#39;obligation</span>
<span class="cp">#define DAYS_IN_YEAR 365</span>

<span class="c1">// Les constantes d&#39;énumeration sont aussi une façon de déclarer des valeurs.</span>
<span class="c1">// Toutes les instructions doivent se terminer par un point-virgule.</span>
<span class="k">enum</span><span class="w"> </span><span class="n">days</span><span class="w"> </span><span class="p">{</span><span class="n">SUN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">MON</span><span class="p">,</span><span class="w"> </span><span class="n">TUE</span><span class="p">,</span><span class="w"> </span><span class="n">WED</span><span class="p">,</span><span class="w"> </span><span class="n">THU</span><span class="p">,</span><span class="w"> </span><span class="n">FRI</span><span class="p">,</span><span class="w"> </span><span class="n">SAT</span><span class="p">};</span>
<span class="c1">// MON vaut 2 automatiquement, TUE vaut 3, etc.</span>

<span class="c1">// Import de fichiers d&#39;en-tête avec #include</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>

<span class="c1">// Pour vos propres fichiers d&#39;en-tête, utilisez les doubles quotes au lieu des crochets sup. et inf.:</span>
<span class="c1">//#include &quot;my_header.h&quot;</span>

<span class="c1">// Declarez les signatures des fonctions auparavant dans un fichier .h, ou en haut de votre</span>
<span class="c1">// fichier .c.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">function_1</span><span class="p">();</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">function_2</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="c1">// Si vous voulez appeler une fonction avant de la définir,</span>
<span class="c1">// vous pouvez déclarer son prototype</span>
<span class="c1">// (types des arguments et de la valeur renvoyée)</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">add_two_ints</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x2</span><span class="p">);</span><span class="w"> </span><span class="c1">// prototype de la fonction</span>
<span class="c1">// bien que `int add_two_ints (int, int);` soit également valide (pas besoin de nommer les arguments),</span>
<span class="c1">// il est recommandé de nommer les arguments dans le prototype pour faciliter l&#39;inspection.</span>

<span class="c1">// Le point d&#39;entrée de votre programme est une fonction appélée</span>
<span class="c1">// main avec une sortie de type entier.</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// votre programme</span>
<span class="p">}</span>

<span class="c1">// Les arguments de la ligne de commande utilisés pour exécuter votre programme sont également passés à la fonction main</span>
<span class="c1">// argc étant le nombre d&#39;arguments - le nom de votre programme compte pour 1</span>
<span class="c1">// argv est un tableau de tableaux de caractères - contenant les arguments eux-mêmes</span>
<span class="c1">// argv[0] = nom de votre programme, argv[1] = premier argument, etc.</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// écriture en sortie à l&#39;aide de printf, pour &quot;print formatted&quot;</span>
<span class="w">  </span><span class="c1">// %d est un entier, \n est une nouvelle ligne</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Prints 0</span>

<span class="w">  </span><span class="c1">///////////////////////////////////////</span>
<span class="w">  </span><span class="c1">// Types</span>
<span class="w">  </span><span class="c1">///////////////////////////////////////</span>

<span class="w">  </span><span class="c1">// Les compilateurs qui ne sont pas conformes C99 nécessitent de déclarer</span>
<span class="w">  </span><span class="c1">// les variables en début de portée du bloc de code courant.</span>
<span class="w">  </span><span class="c1">// Les compilateurs qui SONT conformes C99 acceptent les déclarations</span>
<span class="w">  </span><span class="c1">// plus tard dans les fonctions.</span>

<span class="w">  </span><span class="c1">// Les entiers font généralement de 4 octets</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x_int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Les entiers courts font généralement 2 octets</span>
<span class="w">  </span><span class="kt">short</span><span class="w"> </span><span class="n">x_short</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Les caractères ont une taille fixée à 1 octet</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">x_char</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">y_char</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;y&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// les caractères littéraux sont entre apostrophes &#39;&#39;</span>

<span class="w">  </span><span class="c1">// Les entiers longs font généralement 4 à 8 octets; les entiers longs de type long font</span>
<span class="w">  </span><span class="c1">// 8 octets</span>
<span class="w">  </span><span class="kt">long</span><span class="w"> </span><span class="n">x_long</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x_long_long</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// les nombres à virgule sont généralement des nombres à virgule flottantes de 32 bits</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">x_float</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span><span class="w"> </span><span class="c1">// &#39;f&#39; est le suffixe qui indique ici le littéral à virgule flottante</span>

<span class="w">  </span><span class="c1">// les nombres de type double sont généralement des nombres à virgule flottante de 64 bits</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">x_double</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"> </span><span class="c1">// les nombres réels sans suffixe sont de type double</span>

<span class="w">  </span><span class="c1">// Les types entier peuvent être non signés (plus grand ou égal à zero)</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">ux_short</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ux_int</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">ux_long_long</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Les caractères entre guillemets simples sont des entiers d&#39;un jeu de caractères machine.</span>
<span class="w">  </span><span class="sc">&#39;0&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 48 dans le jeu de caractères ASCII.</span>
<span class="w">  </span><span class="sc">&#39;A&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 65 dans le jeu de caractères ASCII.</span>

<span class="w">  </span><span class="c1">// sizeof(T) vous rend la taille d&#39;une variable de type T en octets.</span>
<span class="w">  </span><span class="c1">// sizeof obj revoie la taille en sortie de l&#39;expression (variable, littéral, etc.).</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"> </span><span class="c1">// =&gt; 4 (sur la plupart des machines les mots font 4 octets)</span>

<span class="w">  </span><span class="c1">// Si l&#39;argument de l&#39;opérateur `sizeof` est une expression, alors son argument</span>
<span class="w">  </span><span class="c1">// n&#39;est pas évalué (sauf les VLA - voir ci-dessous).</span>
<span class="w">  </span><span class="c1">// La valeur qu&#39;elle donne dans ce cas est une constante évaluée à la compilation.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// size_t est un type entier non signé d&#39;au moins 2 octets utilisé pour représenter</span>
<span class="w">  </span><span class="c1">// la taille d&#39;un objet.</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="o">++</span><span class="p">);</span><span class="w"> </span><span class="c1">// a++ n&#39;est pas évalué</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(a++) = %zu où a = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// affiche &quot;sizeof(a++) = 4 où a = 1&quot; (sur une architecture 32 bits)</span>

<span class="w">  </span><span class="c1">// Si l&#39;argument de l&#39;opérateur `sizeof` est une expression, alors son argument</span>
<span class="w">  </span><span class="c1">// n&#39;est pas évalué (sauf les VLAs (voir ci-dessous)).</span>
<span class="w">  </span><span class="c1">// La valeur qu&#39;elle donne dans ce cas est une constante évaluée au moment de la compilation.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// size_t est un nombre de type entier non signé dont au moins 2 octets sont utilisés pour représenter</span>
<span class="w">  </span><span class="c1">// la taille d&#39;un objet.</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="o">++</span><span class="p">);</span><span class="w"> </span><span class="c1">// a++ n&#39;est pas évalué</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(a++) = %zu where a = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// affiche &quot;sizeof(a++) = 4 where a = 1&quot; (sur une architecture 32-bit)</span>

<span class="w">  </span><span class="c1">// Les tableaux doivent être initialisés avec une taille concrète.</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">my_char_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span><span class="w"> </span><span class="c1">// Ce tableau occupe 1 * 20 = 20 octets</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">my_int_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span><span class="w"> </span><span class="c1">// Ce tableau occupe 4 * 20 = 80 octets</span>
<span class="w">  </span><span class="c1">// (en considérant des mots de 4 octets)</span>

<span class="w">  </span><span class="c1">// Vous pouvez ainsi initialiser un tableau à 0:</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">my_array</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="w">  </span><span class="c1">// où la partie &quot;{0}&quot; est appelée &quot;initialiseur de tableau&quot;.</span>
<span class="w">  </span><span class="c1">// NOTEZ que vous vous en sortez sans déclarer explicitement la taille du tableau,</span>
<span class="w">  </span><span class="c1">// SI vous initialisez le tableau sur la même ligne. Ainsi, la déclaration suivante</span>
<span class="w">  </span><span class="c1">// est équivalent:</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">my_array</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="w">  </span><span class="c1">// MAIS, alors vous devez évaluer la taille du tableau au moment de l&#39;exécution, comme ceci:</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">my_array_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">my_array</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">my_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">  </span><span class="c1">// ATTENTION Si vous adoptez cette approche, vous devez évaluer la taille *avant*</span>
<span class="w">  </span><span class="c1">// qui vous commenciez à transmettre le tableau à la fonction (voir la discussion ultérieure), car</span>
<span class="w">  </span><span class="c1">// les tableaux sont &quot;rétrogradés&quot; en pointeurs bruts lorsqu&#39;ils sont passés à des fonctions</span>
<span class="w">  </span><span class="c1">// (donc l&#39;instruction ci-dessus produira le mauvais résultat à l&#39;intérieur de la fonction).</span>

<span class="w">  </span><span class="c1">// L&#39;indexation commence à zero et utilise []</span>
<span class="w">  </span><span class="n">my_array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="c1">// =&gt; 0</span>

<span class="w">  </span><span class="c1">// Les tableaux sont modifiables ; c&#39;est juste de la mémoire!</span>
<span class="w">  </span><span class="n">my_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">my_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"> </span><span class="c1">// =&gt; 2</span>

<span class="w">  </span><span class="c1">// En C99 (et optionnellement en C11), des tableaux à taille variable (VLAs)</span>
<span class="w">  </span><span class="c1">// peuvent également être déclarés. La taille d&#39;un tel tableau n&#39;a pas besoin d&#39;être</span>
<span class="w">  </span><span class="c1">// une constante définie lors de la compilation:</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Enter the array size: &quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// demande à l&#39;utilisateur la taille du tableau</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">array_size</span><span class="p">;</span>
<span class="w">  </span><span class="n">fscanf</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">array_size</span><span class="p">);</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">var_length_array</span><span class="p">[</span><span class="n">array_size</span><span class="p">];</span><span class="w"> </span><span class="c1">// déclare le VLA</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof array = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="n">var_length_array</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Exemple:</span>
<span class="w">  </span><span class="c1">// &gt; Enter the array size: 10</span>
<span class="w">  </span><span class="c1">// &gt; sizeof array = 40</span>

<span class="w">  </span><span class="c1">// Les chaînes de caractères sont juste des tableaux de caractères de terminant par octet NULL (0x00),</span>
<span class="w">  </span><span class="c1">// représenté dans les chaînes de caractères par le caractère spécial &#39;\0&#39;.</span>
<span class="w">  </span><span class="c1">// (Nous n&#39;avons pas besoin d&#39;ajouter l&#39;octet NULL dans les chaînes de caractères littérales; le compilateur</span>
<span class="w">  </span><span class="c1">// l&#39;ajoute à la fin du tableau pour nous.)</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">a_string</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;This is a string&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a_string</span><span class="p">);</span><span class="w"> </span><span class="c1">// %s insère une chaîne de caractères</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a_string</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span><span class="w"> </span><span class="c1">// =&gt; 0</span>
<span class="w">  </span><span class="c1">// i.e., l&#39;octet #17 est 0 (comme le sont 18, 19, et 20)</span>

<span class="w">  </span><span class="c1">// Si nous avons un caractère entre apostrophes, c&#39;est un caractère littéral.</span>
<span class="w">  </span><span class="c1">// Ils sont de types `int`, et *non* `char` (pour des raisons historiques).</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">cha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// bon</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">chb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// bon aussi (conversion implicite de int vers char)</span>

<span class="w">  </span><span class="c1">// Tableaux dimension multiple:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">multi_array</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>
<span class="w">  </span><span class="c1">// Accés au éléments:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">array_int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">multi_array</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="c1">// =&gt; 3</span>

<span class="w">  </span><span class="c1">///////////////////////////////////////</span>
<span class="w">  </span><span class="c1">// Operateurs</span>
<span class="w">  </span><span class="c1">///////////////////////////////////////</span>

<span class="w">  </span><span class="c1">// Raccourcis pour plusieurs déclarations:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">i2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="n">f2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">  </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Arithmétique</span>
<span class="w">  </span><span class="n">i1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 3</span>
<span class="w">  </span><span class="n">i2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">i1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>
<span class="w">  </span><span class="n">i2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 2</span>
<span class="w">  </span><span class="n">i1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">i2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0 (0.5, mais tronqué après 0)</span>

<span class="w">  </span><span class="c1">// Vous devez convertir un entier en type &#39;float&#39; pour obtenir un résultat en virgule flottante</span>
<span class="w">  </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">i1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">i2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0.5f</span>
<span class="w">  </span><span class="n">i1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">i2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0.5 // Pareil avec double</span>
<span class="w">  </span><span class="n">f1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0.5, plus ou moins epsilon</span>
<span class="w">  </span><span class="c1">// Les nombres à virgule flottante et leurs calculs ne sont pas exacts</span>

<span class="w">  </span><span class="c1">// Modulo est aussi là</span>
<span class="w">  </span><span class="mi">11</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 2</span>

<span class="w">  </span><span class="c1">// Les opérateurs de comparaison sont probablement familiers, mais</span>
<span class="w">  </span><span class="c1">// il n&#39;y a pas de type booléen en C. On utilise plutôt des entiers</span>
<span class="w">  </span><span class="c1">// (C99 introduit _Bool ou bool).</span>
<span class="w">  </span><span class="c1">// 0 est faux, tout le reste est vrai.</span>
<span class="w">  </span><span class="c1">// (La comparaison les opérateurs donnent toujours 0 ou 1)</span>
<span class="w">  </span><span class="mi">3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0 (faux)</span>
<span class="w">  </span><span class="mi">3</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1 (vrai)</span>
<span class="w">  </span><span class="mi">3</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>
<span class="w">  </span><span class="mi">3</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0</span>
<span class="w">  </span><span class="mi">2</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>
<span class="w">  </span><span class="mi">2</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>

<span class="w">  </span><span class="c1">// C n&#39;est pas Python - les comparaisons ne s&#39;enchaînent pas.</span>
<span class="w">  </span><span class="c1">// Attention : la ligne ci-dessous se compilera, mais cela signifie `(0 &lt; a) &lt;2`.</span>
<span class="w">  </span><span class="c1">// Cette expression est toujours vraie, car (0 &lt; a) peut être 1 ou 0.</span>
<span class="w">  </span><span class="c1">// Dans ce cas, c&#39;est 1, car (0 &lt; 1).</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">between_0_and_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Utilisez plutôt:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">between_0_and_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// La logique fonctionne avec les entiers</span>
<span class="w">  </span><span class="o">!</span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0 (non logique)</span>
<span class="w">  </span><span class="o">!</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>
<span class="w">  </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1 (et logique)</span>
<span class="w">  </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0</span>
<span class="w">  </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1 (ou logique)</span>
<span class="w">  </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0</span>

<span class="w">  </span><span class="c1">// Expression conditionnelle ternaire ( ? : )</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="w">  </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 10 &quot;if e &gt; f return e, else return f.&quot;</span>

<span class="w">  </span><span class="c1">// Opérateurs d&#39;incrémentation et de décrémentation :</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">// Renvoi j PUIS augmente j. (s = 0, j = 1)</span>
<span class="w">  </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">;</span><span class="w"> </span><span class="c1">// Augmente j PUIS revoi j. (s = 2, j = 2)</span>
<span class="w">  </span><span class="c1">// pareil avec j-- et --j</span>

<span class="w">  </span><span class="c1">// Opérateurs de manipulation des bits !</span>
<span class="w">  </span><span class="o">~</span><span class="mh">0x0F</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0xFFFFFFF0 (opérateur de négation, &quot;complémentaire de 1&quot;, exemple d&#39;un résultat pour un entier 32-bit)</span>
<span class="w">  </span><span class="mh">0x0F</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xF0</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0x00 (opérateur AND)</span>
<span class="w">  </span><span class="mh">0x0F</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0xF0</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0xFF (opérateur OR)</span>
<span class="w">  </span><span class="mh">0x04</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="mh">0x0F</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0x0B (opérateur XOR)</span>
<span class="w">  </span><span class="mh">0x01</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0x02 (opérateur de décalage à gauche - de 1)</span>
<span class="w">  </span><span class="mh">0x02</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0x01 (opérateur de décalage à droite - de 1)</span>

<span class="w">  </span><span class="c1">// Soyez prudent lorsque vous effectuez un décalage sur des entiers signés - les éléments suivants ne sont pas définis:</span>
<span class="w">  </span><span class="c1">// - décalage du bit de signe d&#39;un entier signé (int a = 1 &lt;&lt; 31)</span>
<span class="w">  </span><span class="c1">// - décalage à gauche d&#39;un nombre négatif (int a = -1 &lt;&lt; 2)</span>
<span class="w">  </span><span class="c1">// - décalage par un offset qui est &gt;= à la largeur du type LHS (partie de gauche de l&#39;affectation):</span>
<span class="w">  </span><span class="c1">// int a = 1 &lt;&lt; 32; // UB (comportement indéfini) si int a une taille de 32 bits</span>

<span class="w">  </span><span class="c1">///////////////////////////////////////</span>
<span class="w">  </span><span class="c1">// Structures de contrôle</span>
<span class="w">  </span><span class="c1">///////////////////////////////////////</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Je ne serai jamais exécuté</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Moi aussi, je ne serai jamais exécuté</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Je suis affiché</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Les boucles while</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">ii</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// TOUTE valeur plus petite que dix est vraie.</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ii</span><span class="o">++</span><span class="p">);</span><span class="w"> </span><span class="c1">// ii++ augmente ii APRES avoir utilisé sa valeur actuelle.</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="c1">// =&gt; affiche &quot;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">kk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">kk</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">++</span><span class="n">kk</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="c1">// ++kk augmente kk AVANT d&#39;utiliser sa valeur actuelle.</span>
<span class="w">  </span><span class="c1">// =&gt; affiche &quot;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Les boucles for</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">jj</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">jj</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">jj</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">jj</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">jj</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="c1">// =&gt; affiche &quot;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// *NOTES* :</span>
<span class="w">  </span><span class="c1">// Les boucles et les fonctions DOIVENT posséder un corps.</span>
<span class="w">  </span><span class="c1">// Vous pouvez toutefois utiliser un bloc vide ({}) ou un point-virgule.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Ou</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">);</span><span class="w"> </span><span class="c1">// Déconseillé, car facilement confondable</span>

<span class="w">  </span><span class="c1">// condition à choix multiples : switch()</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span><span class="w"> </span><span class="c1">// les options doivent être des expressions intégrales *constantes* (telles que des énumérations)</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hey, &#39;a&#39; equals 0!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"> </span><span class="c1">// si vous ne mettez pas &#39;break&#39;, le cas d&#39;après est exécuté sans tester le `case`</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Huh, &#39;a&#39; equals 1!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Attention - sans le &quot;break&quot;, l&#39;execution se poursuit jusqu&#39;au</span>
<span class="w">    </span><span class="c1">// prochain &quot;break&quot; atteint.</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">3</span><span class="p">:</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">4</span><span class="p">:</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Look at that.. &#39;a&#39; is either 3, or 4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="k">default</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// si `a` ne correspond à aucune option</span>
<span class="w">    </span><span class="n">fputs</span><span class="p">(</span><span class="s">&quot;Erreur !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">stderr</span><span class="p">);</span>
<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="mi">-1</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Utilisation de &quot;goto&quot; en C</span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kt">bool</span><span class="p">;</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">disaster</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">150</span><span class="p">)</span>
<span class="w">        </span><span class="n">disaster</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">disaster</span><span class="p">)</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">error</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nl">error</span><span class="p">:</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Error occurred at i = %d &amp; j = %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// Ceci affichera &quot;Error occurred at i = 51 &amp; j = 99.&quot;</span>

<span class="w">  </span><span class="c1">///////////////////////////////////////</span>
<span class="w">  </span><span class="c1">// Transtypage</span>
<span class="w">  </span><span class="c1">///////////////////////////////////////</span>

<span class="w">  </span><span class="c1">// Chaque valeur de C a un type, mais vous pouvez convertir le type d&#39;une valeur en un autre type</span>
<span class="w">  </span><span class="c1">// si vous le souhaitez (avec quelques contraintes).</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x_hex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x01</span><span class="p">;</span><span class="w"> </span><span class="c1">// Vous pouvez définir des variables avec des littéraux hexadécimaux</span>

<span class="w">  </span><span class="c1">// La conversion entre les types tentera de conserver leurs valeurs numériques</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x_hex</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Affiche 1</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">short</span><span class="p">)</span><span class="w"> </span><span class="n">x_hex</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Affiche 1</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="n">x_hex</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Affiche 1</span>

<span class="w">  </span><span class="c1">// Les types déborderont sans avertissement</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="mi">257</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; 1 (max = 255 si le caractère mesure 8 bits)</span>

<span class="w">  </span><span class="c1">// Pour déterminer la valeur maximale d&#39;un `char`, d&#39;un `signed char` et d&#39;un `unsigned char`,</span>
<span class="w">  </span><span class="c1">// respectivement, utilisez les macros CHAR_MAX, SCHAR_MAX et UCHAR_MAX de &lt;limits.h&gt;</span>

<span class="w">  </span><span class="c1">// Les types entiers peuvent être convertis en types à virgule flottante et vice versa.</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span><span class="w"> </span><span class="c1">// %f toujours utilisé pour un type double...</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w">  </span><span class="mi">100</span><span class="p">);</span><span class="w"> </span><span class="c1">// ...même avec un float.</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mf">100.0</span><span class="p">);</span>

<span class="w">  </span><span class="c1">///////////////////////////////////////</span>
<span class="w">  </span><span class="c1">// Pointeurs</span>
<span class="w">  </span><span class="c1">///////////////////////////////////////</span>

<span class="w">  </span><span class="c1">// Un pointeur est une variable déclarée pour stocker une adresse mémoire. Sa déclaration</span>
<span class="w">  </span><span class="c1">// vous indique également le type de données vers lequel il pointe. Vous pouvez récupérer l&#39;adresse mémoire</span>
<span class="w">  </span><span class="c1">// de vos variables, puis jouer avec.</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// Utilisez le caractère &amp; pour récupérer l&#39;adresse d&#39;une variable</span>
<span class="w">  </span><span class="c1">// (%p met en forme un objet pointeur de type void *)</span>
<span class="w">  </span><span class="c1">// =&gt; Affiche une adresse en mémoire;</span>

<span class="w">  </span><span class="c1">// Les pointeurs sont préfixés du caractère * lors de la déclaration</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">px</span><span class="p">,</span><span class="w"> </span><span class="n">not_a_pointer</span><span class="p">;</span><span class="w"> </span><span class="c1">// px est un pointeur sur un entier</span>
<span class="w">  </span><span class="n">px</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// Sauvegarde de l&#39;adressse mémoire de x dans px</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">px</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Affiche une adresse mémoire</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%zu, %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">px</span><span class="p">),</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">not_a_pointer</span><span class="p">));</span>
<span class="w">  </span><span class="c1">// =&gt; Affiche &quot;8, 4&quot; sur un système classique 64-bit</span>

<span class="w">  </span><span class="c1">// Pour avoir la valeur située à l&#39;adresse du pointeur,</span>
<span class="w">  </span><span class="c1">// on met * devant pour le déréférencer.</span>
<span class="w">  </span><span class="c1">// Remarque: oui, il peut être déroutant que &#39;*&#39; soit utilisé pour _les deux_ déclarer un</span>
<span class="w">  </span><span class="c1">// pointeur et le déréférencement.</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">px</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Affiche 0, la valeur de x</span>

<span class="w">  </span><span class="c1">// Vous pouvez également modifier la valeur vers laquelle pointe le pointeur.</span>
<span class="w">  </span><span class="c1">// Nous devons mettre la déréférence entre parenthèses car</span>
<span class="w">  </span><span class="c1">// ++ a une priorité plus élevée que *.</span>
<span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">px</span><span class="p">)</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">// Augmente de 1 la valeur pointée par px</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">px</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Affiche 1</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Affiche 1</span>

<span class="w">  </span><span class="c1">// Les tableaux sont un bon moyen d&#39;allouer un bloc de mémoire contigu</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span><span class="w"> </span><span class="c1">//déclare un tableau de taille 20 (la taille ne pourra être changée)</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">xx</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">xx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">xx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"> </span><span class="n">xx</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x_array</span><span class="p">[</span><span class="n">xx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">xx</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="c1">// Initialise x_array à 20, 19, 18,... 2, 1</span>

<span class="w">  </span><span class="c1">// Declare un pointeur sur un type entier et l&#39;initialise pour pointer sur x_array</span>
<span class="w">  </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">x_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x_array</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// x_ptr pointe maintenant vers le premier élément du tableau (l&#39;entier 20).</span>
<span class="w">  </span><span class="c1">// Cela fonctionne car les tableaux s&#39;interprètent souvent comme pointeurs vers leur premier élément.</span>
<span class="w">  </span><span class="c1">// Par exemple, lorsqu&#39;un tableau est transmis à une fonction ou affecté à un pointeur,</span>
<span class="w">  </span><span class="c1">// il est converti implicitement en pointeur.</span>
<span class="w">  </span><span class="c1">// Exceptions : lorsque le tableau est l&#39;argument de l&#39;opérateur `&amp;` (adresse de):</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">ptr_to_arr</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arr</span><span class="p">;</span><span class="w"> </span><span class="c1">// &amp;arr n&#39;est PAS de type `int *`!</span>
<span class="w">  </span><span class="c1">// Il est de type &quot;pointeur sur tableau&quot; (de dix entiers).</span>
<span class="w">  </span><span class="c1">// ou losqu&#39;une chaine de caractères littérale est utilisée pour initialiser un tableau de caractères:</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">otherarr</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foobarbazquirk&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// ou lorsqu&#39;il est l&#39;argument de l&#39;opérateur `sizeof` ou `alignof`:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">arraythethird</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arraythethird</span><span class="p">;</span><span class="w"> </span><span class="c1">// équivalent à int *ptr = &amp;arr[0];</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%zu, %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">arraythethird</span><span class="p">),</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">ptr</span><span class="p">));</span>
<span class="w">  </span><span class="c1">// affiche probablement &quot;40, 4&quot; ou &quot;40, 8&quot;</span>

<span class="w">  </span><span class="c1">// L&#39;augmentation ou la diminution d&#39;un pointeur se fait suivant son type</span>
<span class="w">  </span><span class="c1">// (c&#39;est ce qu&#39;on appelle l&#39;arithmétique du pointeur)</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">x_ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w"> </span><span class="c1">// =&gt; Affiche 19</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"> </span><span class="c1">// =&gt; Affiche 19</span>

<span class="w">  </span><span class="c1">// You can also dynamically allocate contiguous blocks of memory with the</span>
<span class="w">  </span><span class="c1">// standard library function malloc, which takes one argument of type size_t</span>
<span class="w">  </span><span class="c1">// representing the number of bytes to allocate (usually from the heap, although this</span>
<span class="w">  </span><span class="c1">// may not be true on e.g. embedded systems - the C standard says nothing about it).</span>
<span class="w">  </span><span class="c1">// Vous pouvez également allouer dynamiquement des blocs de mémoire contigus avec la</span>
<span class="w">  </span><span class="c1">// fonction malloc de la bibliothèque standard, qui prend un argument de type size_t</span>
<span class="w">  </span><span class="c1">// représentant le nombre d&#39;octets à allouer (généralement à partir du tas, bien que cela</span>
<span class="w">  </span><span class="c1">// peut ne pas être vrai par exemple dans les systèmes embarqués - la norme C ne dit rien à ce sujet).</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">my_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">my_ptr</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">20</span><span class="p">);</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">xx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">xx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"> </span><span class="n">xx</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">*</span><span class="p">(</span><span class="n">my_ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">xx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">xx</span><span class="p">;</span><span class="w"> </span><span class="c1">// my_ptr[xx] = 20-xx</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="c1">// Initialise la mémoire à 20, 19, 18, 17... 2, 1 (comme entiers)</span>

<span class="w">  </span><span class="c1">// Soyez prudent en passant des valeurs fournies par l&#39;utilisateur à malloc! Si vous le souhaitez</span>
<span class="w">  </span><span class="c1">// pour plus de sécurité, vous pouvez utiliser calloc à la place (qui, contrairement à malloc, met également à zéro la mémoire)</span>
<span class="w">  </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">my_other_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calloc</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// Notez qu&#39;il n&#39;y a pas de méthode standard pour obtenir la longueur d&#39;un</span>
<span class="w">  </span><span class="c1">// tableau alloué dynamiquement en C. Pour cette raison, si vos tableaux sont</span>
<span class="w">  </span><span class="c1">// manipulés par votre programme, vous avez besoin d&#39;une autre variable</span>
<span class="w">  </span><span class="c1">// pour garder une trace du nombre d&#39;éléments (taille) d&#39;un tableau. Voir la</span>
<span class="w">  </span><span class="c1">// section fonctions pour plus d&#39;informations.</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">my_arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="w">  </span><span class="c1">// Add an element to the array</span>
<span class="w">  </span><span class="n">size</span><span class="o">++</span><span class="p">;</span>
<span class="w">  </span><span class="n">my_arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">realloc</span><span class="p">(</span><span class="n">my_arr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">my_arr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">//N&#39;oubliez pas de vérifier l&#39;échec de la fonction realloc!</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">my_arr</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Déréférencer de la mémoire que vous n&#39;avez pas allouée donne des</span>
<span class="w">  </span><span class="c1">// UBs &quot;undefined behaviors&quot; ou &quot;comportement imprévisibles&quot;,</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">my_ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">21</span><span class="p">));</span><span class="w"> </span><span class="c1">// =&gt; Peut crash, afficher n&#39;importe quoi, ou autre</span>

<span class="w">  </span><span class="c1">// Lorsque vous avez terminé avec un bloc de mémoire alloué via malloc, vous devez le libérer,</span>
<span class="w">  </span><span class="c1">// ou bien personne d&#39;autre ne pourra l&#39;utiliser jusqu&#39;à la fin de votre programme :</span>
<span class="w">  </span><span class="c1">// (cela s&#39;appelle une &quot;fuite de mémoire&quot;)</span>
<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">my_ptr</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Les chaînes de caractères sont des tableaux de caractères, mais ils sont généralement représentés comme</span>
<span class="w">  </span><span class="c1">// pointeur-vers-caractère (qui est un pointeur vers le premier élément du tableau).</span>
<span class="w">  </span><span class="c1">// Il est recommandé d&#39;utiliser un `const char *&#39; pour référencer une chaîne littérale de caractères,</span>
<span class="w">  </span><span class="c1">// car les chaînes de caractères littérales ne doivent pas être modifiées (i.e. &quot;foo&quot;[0] = &#39;a&#39; est INCORRECT.)</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">my_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;This is my very own string literal&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">my_str</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; &#39;T&#39;</span>

<span class="w">  </span><span class="c1">// Ce n&#39;est pas le cas si la chaîne de caractères est un tableau</span>
<span class="w">  </span><span class="c1">// (potentiellement initialisée avec une chaîne littérale)</span>
<span class="w">  </span><span class="c1">// qui réside dans la mémoire réinscriptible, comme dans:</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">foo</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foo&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">foo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// ceci est correct, foo contient maintenant &quot;aoo&quot;</span>

<span class="w">  </span><span class="n">function_1</span><span class="p">();</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// fin de la fonction main</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Fonctions</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// Sytaxe pour déclarer une fonction:</span>
<span class="c1">// &lt;type de sortie&gt; &lt;nom de la fonstion&gt;(&lt;arguments&gt;)</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">add_two_ints</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x2</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x2</span><span class="p">;</span><span class="w"> </span><span class="c1">// Utilisez return pour retourner une valeur de sortie</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">Les fonctions sont appelées par valeur. Lorsqu&#39;une fonction est appelée, les arguments passés à</span>
<span class="cm">à la fonction sont une copie des arguments originaux (sauf pour les tableaux). Tout ce que vous</span>
<span class="cm">allez faire aux arguments de la fonction ne changera pas la valeur des arguments</span>
<span class="cm">originaux avant appel de la fonction.</span>

<span class="cm">Utilisez les pointeurs si vous avez besoin de modifier la valeur d&#39;origine des arguments.</span>

<span class="cm">Exemple : inversion sur place d&#39;une chaîne de caractères</span>
<span class="cm">*/</span>

<span class="c1">// Une fonction void ne retourne aucune valeur</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">str_reverse</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str_in</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">str_in</span><span class="p">);</span><span class="w"> </span><span class="c1">// `strlen()` fait partie de la bibliothèque standard c</span>
<span class="w">                               </span><span class="c1">// REMARQUE : la longueur renvoyée par `strlen` N&#39;INCLUT PAS</span>
<span class="w">                               </span><span class="c1">//            l&#39;octet NULL de fin (&#39;\0&#39;).</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">ii</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// en C99 vous pouvez déclarer directement le type de `ii` ici</span>
<span class="w">    </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str_in</span><span class="p">[</span><span class="n">ii</span><span class="p">];</span>
<span class="w">    </span><span class="n">str_in</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str_in</span><span class="p">[</span><span class="n">len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="c1">// ii-ème caractère depuis la fin</span>
<span class="w">    </span><span class="n">str_in</span><span class="p">[</span><span class="n">len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">// REMARQUE : le fichier d&#39;entête string.h a besoin d&#39;être inclus pour utiliser strlen()</span>

<span class="cm">/*</span>
<span class="cm">char c[] = &quot;This is a test.&quot;;</span>
<span class="cm">str_reverse(c);</span>
<span class="cm">printf(&quot;%s\n&quot;, c); // =&gt; &quot;.tset a si sihT&quot;</span>
<span class="cm">*/</span>
<span class="cm">/*</span>
<span class="cm">car nous ne pouvons renvoyer qu&#39;une seule variable</span>
<span class="cm">pour changer les valeurs de plusieurs variables, nous passons des pointeurs</span>
<span class="cm">*/</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">swapTwoNumbers</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm">int first = 10;</span>
<span class="cm">int second = 20;</span>
<span class="cm">printf(&quot;first: %d\nsecond: %d\n&quot;, first, second);</span>
<span class="cm">swapTwoNumbers(&amp;first, &amp;second);</span>
<span class="cm">printf(&quot;first: %d\nsecond: %d\n&quot;, first, second);</span>
<span class="cm">// les valeurs seront échangées</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">En ce qui concerne les tableaux, ils seront toujours transmis aux fonctions</span>
<span class="cm">comme pointeurs. Même si vous allouez statiquement un tableau comme `arr[10]`,</span>
<span class="cm">il est toujours passé en tant que pointeur vers le premier élément de tout appel de fonction.</span>
<span class="cm">Encore une fois, il n&#39;y a pas de moyen standard pour connaître la taille d&#39;un tableau</span>
<span class="cm">alloué dynamiquement en C.</span>
<span class="cm">*/</span>
<span class="c1">// La taille doit être transmise!</span>
<span class="c1">// Sinon, cette fonction n&#39;a aucun moyen de connaître la taille du tableau.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">printIntArray</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;arr[%d] is: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm">int my_arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</span>
<span class="cm">int size = 10;</span>
<span class="cm">printIntArray(my_arr, size);</span>
<span class="cm">// affichera &quot;arr[0] is: 1&quot; etc</span>
<span class="cm">*/</span>

<span class="c1">// si vous faites référence à des variables externes en dehors de la fonction, vous devez utiliser le mot clé extern.</span>
<span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">testFunc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">extern</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="c1">//i ici utilise la variable externe i</span>
<span class="p">}</span>

<span class="c1">// rendre les variables external privées au fichier source avec static:</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">//les autres fichiers utilisant testFunc2() n&#39;auront pas accés à la variable j</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">testFunc2</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">extern</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Le mot clé static rend une variable inaccessible au code en dehors de</span>
<span class="c1">// l&#39;unité de compilation. (Sur presque tous les systèmes, une &quot;unité de compilation&quot; est un</span>
<span class="c1">// fichier .c.) static peut être appliqué aussi bien aux variables globales (à l&#39;unité de compilation),</span>
<span class="c1">// aux fonctions et aux variables locales aux fonctions. Lorsque vous utilisez static avec</span>
<span class="c1">// une variable locale à une fonction, la variable est effectivement globale et conserve sa</span>
<span class="c1">// valeur sur les appels de la fonction, mais n&#39;est accessible que dans la fonction où</span>
<span class="c1">// elle a été déclarée. De plus, les variables statiques sont initialisées à 0 si pas</span>
<span class="c1">// déjà déclaré avec une autre valeur de départ.</span>
<span class="c1">// ** Vous pouvez également déclarer des fonctions statiques pour les rendre privées **</span>

<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// Types et structures définis par l&#39;utilisateur</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Typedef peuvent être utilisé pour créer un alias de type</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">my_type</span><span class="p">;</span>
<span class="n">my_type</span><span class="w"> </span><span class="n">my_type_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// Struct est juste une collection de données, dont les membres sont positionnés séquentiellement,</span>
<span class="c1">// dans l&#39;ordre où ils sont écrits::</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">height</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Il n&#39;est généralement aps vrai que</span>
<span class="c1">// sizeof(struct rectangle) == sizeof(int) + sizeof(int)</span>
<span class="c1">// en raison du remplissage potentiel entre les membres de la structure (c&#39;est pour des raisons</span>
<span class="c1">// d&#39;alignement). [1]</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">function_1</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="n">my_rec</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// L&#39;accés aux membres de la structure se fait avec .</span>
<span class="w">  </span><span class="n">my_rec</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">  </span><span class="n">my_rec</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Vous pouvez déclarer un pointeur vers une structure</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="o">*</span><span class="n">my_rec_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">my_rec</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Utiliser le déréférencement pour définir les membres du pointeur de structure...</span>
<span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">my_rec_ptr</span><span class="p">).</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// préférez le raccourci -&gt; par souci de lisibilité</span>
<span class="w">  </span><span class="n">my_rec_ptr</span><span class="o">-&gt;</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="c1">// Identique à (*my_rec_ptr).height = 10;</span>
<span class="p">}</span>

<span class="c1">// Vous pouvez appliquer un typedef à une structure pour plus de commodité</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="n">rect</span><span class="p">;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">area</span><span class="p">(</span><span class="n">rect</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// si vous avez de grandes structures, vous pouvez les passer &quot;par pointeur&quot; afin d&#39;éviter la copie</span>
<span class="c1">// de toute la structure:</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">areaptr</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">rect</span><span class="w"> </span><span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Pointeurs sur fonction</span>
<span class="c1">///////////////////////////////////////</span>
<span class="cm">/*</span>
<span class="cm">Au moment de l&#39;exécution, les fonctions sont situées à des adresses de mémoire connues. Les pointeurs de fonction sont</span>
<span class="cm">un peu comme n&#39;importe quel autre pointeur (ils stockent juste une adresse mémoire), mais peuvent être utilisés</span>
<span class="cm">pour appeler directement des fonctions et pour transmettre des gestionnaires de fonctions (ou des fonctions de rappel).</span>
<span class="cm">Cependant, la syntaxe de définition peut être source de confusion au départ.</span>

<span class="cm">Exemple: Utilisation de str_reverse à partir d&#39;un pointeur</span>
<span class="cm">*/</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">str_reverse_through_pointer</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str_in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Définit une variable pointeur sur fonction, nommée f.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"> </span><span class="c1">// La signature doit être la même que la fonction cible.</span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">str_reverse</span><span class="p">;</span><span class="w"> </span><span class="c1">// Assigne l&#39;adresse de la fonction réelle (déterminé au runtime)</span>
<span class="w">  </span><span class="c1">// f = str_reverse; marcherait aussi - les fonctions s&#39;interprètent en pointeurs, comme les tableaux</span>
<span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="n">str_in</span><span class="p">);</span><span class="w"> </span><span class="c1">// Il suffit d&#39;appeler la fonction via le pointeur</span>
<span class="w">  </span><span class="c1">// f(str_in); // C&#39;est une syntaxe alternative mais tout aussi valide pour l&#39;appel.</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">Tant que les signatures de fonction correspondent, vous pouvez affecter n&#39;importe quelle fonction au même pointeur.</span>
<span class="cm">Les pointeurs de fonction sont généralement typés via typedef pour plus de simplicité et de lisibilité, comme suit:</span>
<span class="cm">*/</span>

<span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">my_fnp_type</span><span class="p">)(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>

<span class="c1">// Puis utilisé lors de la déclaration de la variable réelle de pointeur:</span>
<span class="c1">// ...</span>
<span class="c1">// my_fnp_type f;</span>


<span class="c1">//Caractères spéciaux:</span>
<span class="cm">/*</span>
<span class="cm">&#39;\a&#39;; // caractère d&#39;alerte (cloche)</span>
<span class="cm">&#39;\n&#39;; // caractère de nouvelle ligne</span>
<span class="cm">&#39;\t&#39;; // caractère de tabulation (texte justifié à gauche)</span>
<span class="cm">&#39;\v&#39;; // tabulation verticale</span>
<span class="cm">&#39;\f&#39;; // nouvelle page (flux de formulaire)</span>
<span class="cm">&#39;\r&#39;; // retour chariot</span>
<span class="cm">&#39;\b&#39;; // caractère de retour arrière</span>
<span class="cm">&#39;\0&#39;; // Caractère NULL. Habituellement mis à la fin des chaînes en C.</span>
<span class="cm">// bonjour\n\0. \0 utilisé par convention pour marquer la fin de la chaîne.</span>
<span class="cm">&#39;\\&#39;; // barre oblique inverse</span>
<span class="cm">&#39;\?&#39;; // point d&#39;interrogation</span>
<span class="cm">&#39;\&#39; &#39;; // simple guillemet</span>
<span class="cm">&#39;\&quot;&#39;; // double quillemets</span>
<span class="cm">&#39;\xhh&#39;; // nombre hexadécimal. Exemple: &#39;\xb&#39; = caractère de tabulation verticale</span>
<span class="cm">&#39;\0oo&#39;; // nombre octal. Exemple: &#39;\013&#39; = caractère de tabulation verticale</span>

<span class="cm">//Format d&#39;affichage:</span>
<span class="cm">&quot;%d&quot;;    // entier</span>
<span class="cm">&quot;%3d&quot;;   // entier avec une taille minimum de 3 digits (texte justifié à droite)</span>
<span class="cm">&quot;%s&quot;;    // chaîne de caractères</span>
<span class="cm">&quot;%f&quot;;    // nombre à virgule flottante</span>
<span class="cm">&quot;%ld&quot;;   // nombre long</span>
<span class="cm">&quot;%3.2f&quot;; // minimum de 3 digits à gauche et 2 digits à droite nombre décimal à virgule flottante</span>
<span class="cm">&quot;%7.4s&quot;; // (peut être fait aussi avec une chaîne de caractères)</span>
<span class="cm">&quot;%c&quot;;    // caratère</span>
<span class="cm">&quot;%p&quot;;    // pointeur. REMARQUE: il est nécessaire de caster en (void *) le pointeur, avant de la passer</span>
<span class="cm">         //                comme argument à `printf`.</span>
<span class="cm">&quot;%x&quot;;    // hexadecimal</span>
<span class="cm">&quot;%o&quot;;    // octal</span>
<span class="cm">&quot;%%&quot;;    // affiche %</span>
<span class="cm">*/</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Ordre des évaluations</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">//--------------------------------------------------------//</span>
<span class="c1">//        Operateurs                 | Associativité      //</span>
<span class="c1">//--------------------------------------------------------//</span>
<span class="c1">// () [] -&gt; .                        | de gauche à droite //</span>
<span class="c1">// ! ~ ++ -- + = *(type)sizeof       | de droite à gauche //</span>
<span class="c1">// * / %                             | de gauche à droite //</span>
<span class="c1">// + -                               | de gauche à droite //</span>
<span class="c1">// &lt;&lt; &gt;&gt;                             | de gauche à droite //</span>
<span class="c1">// &lt; &lt;= &gt; &gt;=                         | de gauche à droite //</span>
<span class="c1">// == !=                             | de gauche à droite //</span>
<span class="c1">// &amp;                                 | de gauche à droite //</span>
<span class="c1">// ^                                 | de gauche à droite //</span>
<span class="c1">// |                                 | de gauche à droite //</span>
<span class="c1">// &amp;&amp;                                | de gauche à droite //</span>
<span class="c1">// ||                                | de gauche à droite //</span>
<span class="c1">// ?:                                | de droite à gauche //</span>
<span class="c1">// = += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;= | de droite à gauche //</span>
<span class="c1">// ,                                 | de gauche à droite //</span>
<span class="c1">//--------------------------------------------------------//</span>

<span class="cm">/******************************* Fichiers en-têtes **********************************</span>

<span class="cm">Les fichiers d&#39;en-tête sont une partie importante de C car ils permettent l&#39;interconnexion</span>
<span class="cm">des fichiers source C ce qui permet de simplifier le code et les définitions en les séparant</span>
<span class="cm">dans des fichiers séparés.</span>

<span class="cm">Les fichiers d&#39;en-tête sont syntaxiquement similaires aux fichiers source C mais résident dans</span>
<span class="cm">des fichiers &quot;.h&quot;. Ils peuvent être inclus dans votre fichier source C en utilisant la commande</span>
<span class="cm">du précompilateur #include &quot;example.h&quot;, avec example.h existant dans le même répertoire</span>
<span class="cm">que le fichier C.</span>
<span class="cm">*/</span>

<span class="cm">/* Un garde-fou pour éviter que l&#39;en-tête ne soit défini trop de fois. Ce          */</span>
<span class="cm">/* qui se produit dans le cas de dépendance cyclique, et que le contenu du fichier */</span>
<span class="cm">/* d&#39;en-tête est déjà défini.                                                      */</span>
<span class="cp">#ifndef EXAMPLE_H </span><span class="cm">/* si EXAMPLE_H n&#39;est pas déjà défini. */</span>
<span class="cp">#define EXAMPLE_H </span><span class="cm">/* Definit la macro EXAMPLE_H. */</span>

<span class="cm">/* Des en-têtes peuvent être inclus dans d&#39;autres en-têtes et donc par transitivité */</span>
<span class="cm">/* être inclus dans des fichiers qui incluent un en-tête.                           */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>

<span class="cm">/* Les macros de fichiers source c peuvent être définies dans les en-têtes et utilisées dans les fichiers */</span>
<span class="cm">/* qui incluent ce fichier d&#39;en-tête.                                                                     */</span>
<span class="cp">#define EXAMPLE_NAME &quot;Dennis Ritchie&quot;</span>

<span class="cm">/* Les macros de fonction peuvent aussi être définies.  */</span>
<span class="cp">#define ADD(a, b) ((a) + (b))</span>

<span class="cm">/* Remarquez les parenthèses entourant les arguments - c&#39;est important pour                 */</span>
<span class="cm">/* assurer que a et b ne soient pas développés de manière inattendue (par exemple, pensez à */</span>
<span class="cm">/* MUL (x, y) (x * y); MUL (1 + 2, 3) s&#39;étendrait à (1 + 2 * 3), produisant un              */</span>
<span class="cm">/* résultat incorrect)                                                                      */</span>

<span class="cm">/* Les structures et les typedefs peuvent être utilisés pour la cohérence entre les fichiers. */</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Node</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Node</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">Node</span><span class="p">;</span>

<span class="cm">/* Il en va de même pour les énumérations. */</span>
<span class="k">enum</span><span class="w"> </span><span class="n">traffic_light_state</span><span class="w"> </span><span class="p">{</span><span class="n">GREEN</span><span class="p">,</span><span class="w"> </span><span class="n">YELLOW</span><span class="p">,</span><span class="w"> </span><span class="n">RED</span><span class="p">};</span>

<span class="cm">/* Les prototypes de fonctions peuvent également être définis ici pour une utilisation dans plusieurs fichiers, */</span>
<span class="cm">/* mais c&#39;est une mauvaise pratique de définir la fonction dans l&#39;en-tête. Les définitions                      */</span>
<span class="cm">/* devraient plutôt être placées dans un fichier C.                                                             */</span>
<span class="n">Node</span><span class="w"> </span><span class="nf">createLinkedList</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">vals</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>

<span class="cm">/* Au-delà des éléments ci-dessus, les autres définitions devraient être placées dans un fichier source C */</span>
<span class="cm">/* Les inclusions ou définitions excessives ne devraient pas non plus figurer dans                        */</span>
<span class="cm">/* un fichier d&#39;en-tête mais placées plutôt dans des en-têtes séparés ou un fichier C.                    */</span>

<span class="cp">#endif </span><span class="cm">/* Fin de la directive if du precompilateur. */</span>
</pre></div>
<h2>Lectures complémentaires</h2>

<ul>
<li><a href="http://learncodethehardway.org/c/">Learn C The Hard Way</a>.</li>
<li>Si vous avez une question, lisez le <a href="http://c-faq.com">compl.lang.c Frequently Asked Questions</a>.</li>
</ul>

<p>Il est très important d&#39;utiliser un espacement et une indentation appropriés et d&#39;être cohérent avec votre style de codage en général.
Un code lisible est meilleur qu&#39;un code intelligent et un code rapide. Pour un bon style de codage sain à adopter, consultez le
<a href="https://www.kernel.org/doc/Documentation/process/coding-style.rst">Linux kernel coding style</a>.</p>

<p>[1] <a href="http://stackoverflow.com/questions/119123/why-isnt-sizeof-for-a-struct-equal-to-the-sum-of-sizeof-of-each-member">Why isn&rsquo;t sizeof for a struct equal to the sum of sizeof of each member?</a></p>

    <hr>
    <p>Vous avez une suggestion ? Peut-être une correction ? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Ouvrez un ticket</a> sur Github, ou faites vous-même une <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/fr-fr/c-fr.html.markdown">pull request</a> !
    </p>
    <p class="contributed">
    Version originale par Adam Bard, mis à jour par <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/fr-fr/c-fr.html.markdown">8 contributeur(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://adambard.com/">Adam Bard</a>,
        <a href="http://twitter.com/H2CO3_iOS">Árpád Goretity</a>,
        <a href="http://cbs.stgn.pl">Jakub Trzebiatowski</a>,
        <a href="https://marcoms.github.io">Marco Scannadinari</a>,
        <a href="https://github.io/zfergus2">Zachary Ferguson</a>,
        <a href="https://github.com/himanshu81494">himanshu</a>,
        <a href="https://github.com/JoshuaRLi">Joshua Li</a>,
        <a href="https://github.com/dchirila">Dragos B. Chirila</a>,
        <a href="https://github.com/heitorPB/">Heitor P. de Bittencourt</a>
    </p>

    <p>
      Translated by:
        <a href="https://twitter.com/CyrilJovet">Cyril Jovet</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
