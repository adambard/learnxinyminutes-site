<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="zh-cn" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="zh-cn" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="zh-cn" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="zh-cn" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="zh-cn">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn X in Y Minutes: Scenic Programming Language Tours</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/zh-cn/lambda-calculus-cn/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fzh-cn%2Flambda-calculus-cn%2F&text=Y%E5%88%86%E9%92%9F%E9%80%9F%E6%88%90X%2C+%E5%85%B6%E4%B8%AD+X%3DLambda+Calculus">
        分享此页
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">选择主题：</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">亮</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">暗</button>
  </div>
  <h1><a href="/">Y分钟速成X</a></h1>
  <h2>其中 X=Lambda Calculus</h2>
  <div id="doc">
    <h1>Lambda 演算</h1>

<p>Lambda 演算(lambda calculus, λ-calculus),
最初由<a href="https://zh.wikipedia.org/wiki/%E9%98%BF%E9%9A%86%E4%BD%90%C2%B7%E9%82%B1%E5%A5%87">阿隆佐·邱奇</a>(<a href="https://en.wikipedia.org/wiki/Alonzo_Church">Alonzo Church</a>)提出,
是世界上最小的编程语言.
尽管没有数字, 字符串, 布尔或者任何非函数的数据类型,
lambda 演算仍可以表示任何图灵机.</p>

<p>Lambda 演算由三种元素组成: <strong>变量</strong>(variables)、<strong>函数</strong>(functions)和<strong>应用</strong>(applications)。</p>

<table><thead>
<tr>
<th>名称</th>
<th>语法</th>
<th>示例</th>
<th>解释</th>
</tr>
</thead><tbody>
<tr>
<td>变量</td>
<td><code>&lt;变量名&gt;</code></td>
<td><code>x</code></td>
<td>一个名为&quot;x&quot;的变量</td>
</tr>
<tr>
<td>函数</td>
<td><code>λ&lt;参数&gt;.&lt;函数体&gt;</code></td>
<td><code>λx.x</code></td>
<td>一个以&quot;x&quot;(前者)为参数、以&quot;x&quot;(后者)为函数体的函数</td>
</tr>
<tr>
<td>应用</td>
<td><code>&lt;函数&gt;&lt;变量或函数&gt;</code></td>
<td><code>(λx.x)a</code></td>
<td>以&quot;a&quot;为参数调用函数&quot;λx.x&quot;</td>
</tr>
</tbody></table>

<p>最基本的函数为恒等函数: <code>λx.x</code>, 它等价于<code>f(x) = x</code>.
第一个&quot;x&quot;为函数的参数, 第二个为函数体.</p>

<h2>自由变量和约束变量:</h2>

<ul>
<li>在函数<code>λx.x</code>中, &ldquo;x&quot;被称作约束变量因为它同时出现在函数体和函数参数中.</li>
<li>在<code>λx.y</code>中, &quot;y&quot;被称作自由变量因为它没有被预先声明.</li>
</ul>

<h2>求值:</h2>

<p>求值操作是通过<a href="https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97#'%22%60UNIQ--postMath-0000006F-QINU%60%22'-%E6%AD%B8%E7%B4%84">β-归约</a>(<a href="https://en.wikipedia.org/wiki/Lambda_calculus#Beta_reduction">β-Reduction</a>)完成的,
它本质上是词法层面上的替换.</p>

<p>当对表达式<code>(λx.x)a</code>求值时, 我们将函数体中所有出现的&quot;x&quot;替换为&quot;a&rdquo;.</p>

<ul>
<li><code>(λx.x)a</code>计算结果为: <code>a</code></li>
<li><code>(λx.y)a</code>计算结果为: <code>y</code></li>
</ul>

<p>你甚至可以创建高阶函数:</p>

<ul>
<li><code>(λx.(λy.x))a</code>计算结果为: <code>λy.a</code></li>
</ul>

<p>尽管 lambda 演算传统上仅支持单个参数的函数,
但我们可以通过一种叫作<a href="https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96">柯里化</a>(<a href="https://en.wikipedia.org/wiki/Currying">Currying</a>)的技巧创建多个参数的函数.</p>

<ul>
<li><code>(λx.λy.λz.xyz)</code>等价于<code>f(x, y, z) = ((x y) z)</code></li>
</ul>

<p>有时<code>λxy.&lt;body&gt;</code>与<code>λx.λy.&lt;body&gt;</code>可以互换使用.</p>

<hr>

<p>认识到传统的 <strong>lambda 演算没有数字, 字符或者任何非函数的数据类型</strong>很重要.</p>

<h2>布尔逻辑:</h2>

<p>在 lambda 演算中没有&quot;真&quot;或&quot;假&quot;. 甚至没有 1 或 0.</p>

<p>作为替换:</p>

<p><code>T</code>表示为: <code>λx.λy.x</code></p>

<p><code>F</code>表示为: <code>λx.λy.y</code></p>

<p>首先, 我们可以定义一个&quot;if&quot;函数<code>λbtf</code>, 它当<code>b</code>为真时返回<code>t</code>,
<code>b</code>为假时返回<code>f</code></p>

<p><code>IF</code>等价于: <code>λb.λt.λf.b t f</code></p>

<p>通过<code>IF</code>, 我们可以定义基本的布尔逻辑运算符:</p>

<p><code>a AND b</code>等价于: <code>λab.IF a b F</code></p>

<p><code>a OR b</code>等价于: <code>λab.IF a T b</code></p>

<p><code>NOT a</code>等价于: <code>λa.IF a F T</code></p>

<p><em>注意: <code>IF a b c</code>本质上指: <code>IF((a b) c)</code></em></p>

<h2>数字：</h2>

<p>尽管 lambda 演算中没有数字,
我们还可以用<a href="https://zh.wikipedia.org/wiki/%E9%82%B1%E5%A5%87%E7%BC%96%E7%A0%81">邱奇编码</a>(<a href="https://en.wikipedia.org/wiki/Church_encoding">Church numerals</a>)将数字嵌入到 lambda 演算中.</p>

<p>对于任意数字 n: <code>n = λf.f<sup>n</sup></code> 所以:</p>

<p><code>0 = λf.λx.x</code></p>

<p><code>1 = λf.λx.f x</code></p>

<p><code>2 = λf.λx.f(f x)</code></p>

<p><code>3 = λf.λx.f(f(f x))</code></p>

<p>要增加一个邱奇数, 我们使用后继函数<code>S(n) = n + 1</code>:</p>

<p><code>S = λn.λf.λx.f((n f) x)</code></p>

<p>使用后继函数, 我们可以定义加法:</p>

<p><code>ADD = λab.(a S)b</code></p>

<p><strong>挑战</strong>: 试定义乘法函数!</p>

<h2>变得更小: SKI, SK 和 Iota</h2>

<h3>SKI 组合子演算</h3>

<p>令 S, K, I 为下列函数:</p>

<p><code>I x = x</code></p>

<p><code>K x y =  x</code></p>

<p><code>S x y z = x z (y z)</code></p>

<p>我们可以将 lambda 演算中的表达式转换为 SKI 组合子演算中的表达式:</p>

<ol>
<li><code>λx.x = I</code></li>
<li><code>λx.c = Kc</code></li>
<li><code>λx.(y z) = S (λx.y) (λx.z)</code></li>
</ol>

<p>以邱奇数 2 为例:</p>

<p><code>2 = λf.λx.f(f x)</code></p>

<p>对于里面的部分 <code>λx.f(f x)</code>:</p>
<div class="highlight"><pre><span></span>  λx.f(f x)
= S (λx.f) (λx.(f x))          (case 3)
= S (K f)  (S (λx.f) (λx.x))   (case 2, 3)
= S (K f)  (S (K f) I)         (case 2, 1)
</pre></div>
<p>所以:</p>
<div class="highlight"><pre><span></span>  2
= λf.λx.f(f x)
= λf.(S (K f) (S (K f) I))
= λf.((S (K f)) (S (K f) I))
= S (λf.(S (K f))) (λf.(S (K f) I)) (case 3)
</pre></div>
<p>对于第一个参数<code>λf.(S (K f))</code>有:</p>
<div class="highlight"><pre><span></span>  λf.(S (K f))
= S (λf.S) (λf.(K f))       (case 3)
= S (K S) (S (λf.K) (λf.f)) (case 2, 3)
= S (K S) (S (K K) I)       (case 2, 3)
</pre></div>
<p>对于第二个参数<code>λf.(S (K f) I)</code>有：</p>
<div class="highlight"><pre><span></span>  λf.(S (K f) I)
= λf.((S (K f)) I)
= S (λf.(S (K f))) (λf.I)             (case 3)
= S (S (λf.S) (λf.(K f))) (K I)       (case 2, 3)
= S (S (K S) (S (λf.K) (λf.f))) (K I) (case 1, 3)
= S (S (K S) (S (K K) I)) (K I)       (case 1, 2)
</pre></div>
<p>综上:</p>
<div class="highlight"><pre><span></span>  2
= S (λf.(S (K f))) (λf.(S (K f) I))
= S (S (K S) (S (K K) I)) (S (S (K S) (S (K K) I)) (K I))
</pre></div>
<p>如果展开这个表达式, 我们最终又会得到邱奇数 2 的相同的表达式.</p>

<h3>SK 组合子演算</h3>

<p>SKI 组合子演算还可以进一步简化. 我们可以通过<code>I = SKK</code>移除 I 组合子.
我们可以将所有的 <code>I</code> 替换为 <code>SKK</code>.</p>

<h3>ι 组合子</h3>

<p>SK 组合子仍不是最简的. 定义:</p>
<div class="highlight"><pre><span></span>ι = λf.((f S) K)
</pre></div>
<p>我们有:</p>
<div class="highlight"><pre><span></span>I = ιι
K = ι(ιI) = ι(ι(ιι))
S = ι(K) = ι(ι(ι(ιι)))
</pre></div>
<h2>更多阅读:</h2>

<ol>
<li><a href="http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf">A Tutorial Introduction to the Lambda Calculus</a>(英文)</li>
<li><a href="https://courses.cs.cornell.edu/cs312/2008sp/recitations/rec26.html">Cornell CS 312 Recitation 26: The Lambda Calculus</a>(英文)</li>
<li><a href="https://en.wikipedia.org/wiki/Lambda_calculus">Wikipedia - Lambda Calculus</a>(英文)</li>
<li><a href="https://en.wikipedia.org/wiki/SKI_combinator_calculus">Wikipedia - SKI combinator calculus</a>(英文)</li>
<li><a href="https://en.wikipedia.org/wiki/Iota_and_Jot">Wikipedia - Iota and Jot</a>(英文)</li>
<li><a href="https://zh.wikipedia.org/wiki/SKI%E7%BB%84%E5%90%88%E5%AD%90%E6%BC%94%E7%AE%97">λ演算 - 维基百科，自由的百科全书</a></li>
<li><a href="https://zh.wikipedia.org/wiki/SKI%E7%BB%84%E5%90%88%E5%AD%90%E6%BC%94%E7%AE%97">SKI组合子演算 - 维基百科，自由的百科全书</a></li>
</ol>

    <hr>
    <p>有建议？或者发现什么错误？在Github上<a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">开一个issue</a>，或者发起<a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/zh-cn/lambda-calculus-cn.html.markdown">pull request</a>！
    </p>
    <p class="contributed">
    原著Max Sun，并由<a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/zh-cn/lambda-calculus-cn.html.markdown">1个好心人</a>修改。
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://github.com/maxsun">Max Sun</a>,
        <a href="http://github.com/yanhh0">Yan Hui Hang</a>
    </p>

    <p>
      Translated by:
        <a href="https://github.com/simonmysun">Maoyin Sun</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
