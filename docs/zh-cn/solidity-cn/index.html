<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="zh-cn" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="zh-cn" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="zh-cn" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="zh-cn" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="zh-cn">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Solidity in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/zh-cn/solidity-cn/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fzh-cn%2Fsolidity-cn%2F&text=Y%E5%88%86%E9%92%9F%E9%80%9F%E6%88%90X%2C+%E5%85%B6%E4%B8%AD+X%3DSolidity">
        分享此页
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">选择主题：</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">亮</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">暗</button>
  </div>
  <h1><a href="/">Y分钟速成X</a></h1>
  <h2>其中 X=Solidity</h2>
    <p class="filelink">
    源代码下载：
    <a href="/docs/files/learnSolidity-cn.sol">learnSolidity-cn.sol</a>
    </p>
  <div id="doc">
    <p>Solidity 使你在<a href="https://www.ethereum.org/">以太坊</a>上编程，一个基于区块链的虚拟机，
允许创建和执行智能合约，无需中心化的或可信的一方。</p>

<p>Solidity 是一种与 Javascript 和 C 的相似的、静态类型的合约编程语言。与OOP（面向对象）中
的对象一样，每个合约都包含状态变量、函数和公共数据类型。合约特定功能包括修饰符（guard）子句，
事件通知的侦听器及自定义的全局变量。</p>

<p>以太坊合约的例子包括众筹、投票以及盲拍（私密拍卖）。</p>

<p>Solidity 代码中存在高风险和高成本的错误，因此你必须非常小心地进行测试并慢慢地发布。<strong>随着
以太坊的快速变化，本文档不可能是最新的，所以你应该关注最新的的 solidity 聊天室和以太网博客。
照搬这里的代码，会存在重大错误或弃用代码模式的风险。（说人话&ndash;别照抄例子中的代码）</strong></p>

<p>与其他代码不同，可能还需要添加如暂停、弃用和限制使用的设计模式，来降低风险。本文档主要讨论语法，
因此排除了许多流行的设计模式。</p>

<p>由于 Solidity 和以太坊正在积极开发，通常会标记为实验或 beta 特性，并很可能会更改。因此欢迎
提交更改请求。</p>
<div class="highlight"><pre><span></span><span class="c1">// 首先，一个简单的银行合约</span>
<span class="c1">// 允许存款、取款、以及检查余额</span>

<span class="c1">// simple_bank.sol (注意 .sol 后缀)</span>
<span class="cm">/* **** 例子开始 **** */</span>

<span class="c1">// 声明源文件的编译器版本</span>
<span class="nx">pragma</span><span class="w"> </span><span class="nx">solidity</span><span class="w"> </span><span class="o">^</span><span class="mf">0.4.19</span><span class="p">;</span>

<span class="c1">// 开始 Natspec 注释（三个斜杠）</span>
<span class="c1">// 用作文档 - 及UI元素、动作的描述性数据</span>

<span class="c1">/// @title SimpleBank</span>
<span class="c1">/// @author nemild</span>

<span class="cm">/* &#39;contract&#39; 和其他语言的 &#39;class&#39; 类似 (类变量、继承等) */</span>
<span class="nx">contract</span><span class="w"> </span><span class="nx">SimpleBank</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 单词首字母大写</span>
<span class="w">    </span><span class="c1">// 声明函数外的状态变量，合约生命周期内可用</span>

<span class="w">    </span><span class="c1">// 地址映射到余额的字典，总是要小心数字的溢出攻击</span>
<span class="w">    </span><span class="nx">mapping</span><span class="w"> </span><span class="p">(</span><span class="nx">address</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">uint</span><span class="p">)</span><span class="w"> </span><span class="kr">private</span><span class="w"> </span><span class="nx">balances</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// &quot;private&quot; 的意思是其他合约不能直接查询余额，但对于区块链上的其他方来说，数据仍然是可见的。</span>

<span class="w">    </span><span class="nx">address</span><span class="w"> </span><span class="kr">public</span><span class="w"> </span><span class="nx">owner</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// &#39;public&#39; 使用户或合约可以从外部读取（不可写）</span>

<span class="w">    </span><span class="c1">// Events（事件） - 向外部监听器发布动作</span>
<span class="w">    </span><span class="nx">event</span><span class="w"> </span><span class="nx">LogDepositMade</span><span class="p">(</span><span class="nx">address</span><span class="w"> </span><span class="nx">accountAddress</span><span class="p">,</span><span class="w"> </span><span class="nx">uint</span><span class="w"> </span><span class="nx">amount</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Constructor（构造函数）（译者注：solidity 从0.4.22开始使用 constructor() 作为构造函数）</span>
<span class="w">    </span><span class="kd">function</span><span class="w"> </span><span class="nx">SimpleBank</span><span class="p">()</span><span class="w"> </span><span class="kr">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// msg 提供了发送给合约的消息详情</span>
<span class="w">        </span><span class="c1">// msg.sender 是合约的调用者（这里是合约创建者的地址）</span>
<span class="w">        </span><span class="nx">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// @notice 存款 ether (以太币)</span>
<span class="w">    </span><span class="c1">/// @return 存款后用户的余额</span>
<span class="w">    </span><span class="kd">function</span><span class="w"> </span><span class="nx">deposit</span><span class="p">()</span><span class="w"> </span><span class="kr">public</span><span class="w"> </span><span class="nx">payable</span><span class="w"> </span><span class="nx">returns</span><span class="w"> </span><span class="p">(</span><span class="nx">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 使用 &#39;require&#39; 来检测用户的输入，&#39;assert&#39; 是内部常量</span>
<span class="w">        </span><span class="c1">// 我们要确保不会发生溢出问题（上溢）</span>
<span class="w">        </span><span class="nx">require</span><span class="p">((</span><span class="nx">balances</span><span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">msg</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nx">balances</span><span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]);</span>

<span class="w">        </span><span class="nx">balances</span><span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">msg</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// 状态变量不需要 &quot;this.&quot; 或 &quot;self.&quot;</span>
<span class="w">        </span><span class="c1">// 默认情况下，所有值都设置为数据类型的初始值</span>

<span class="w">        </span><span class="nx">LogDepositMade</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">,</span><span class="w"> </span><span class="nx">msg</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span><span class="w"> </span><span class="c1">// 触发事件</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">balances</span><span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// @notice 从银行取款以太币 （ether）</span>
<span class="w">    </span><span class="c1">/// @dev 不会返回任何多余的以太币（ether）</span>
<span class="w">    </span><span class="c1">/// @param withdrawAmount 取款的数量</span>
<span class="w">    </span><span class="c1">/// @return 用户还剩下的余额</span>
<span class="w">    </span><span class="kd">function</span><span class="w"> </span><span class="nx">withdraw</span><span class="p">(</span><span class="nx">uint</span><span class="w"> </span><span class="nx">withdrawAmount</span><span class="p">)</span><span class="w"> </span><span class="kr">public</span><span class="w"> </span><span class="nx">returns</span><span class="w"> </span><span class="p">(</span><span class="nx">uint</span><span class="w"> </span><span class="nx">remainingBal</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">require</span><span class="p">(</span><span class="nx">withdrawAmount</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">balances</span><span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]);</span>

<span class="w">        </span><span class="c1">// 注意在发送任何交易，即通过 .transfer .send 调用外部函数之前，马上减掉取款数量</span>
<span class="w">        </span><span class="c1">// 这可以允许调用者使用递归请求大于其余额的金额。目标是在调用外部函数之前提交状态，</span>
<span class="w">        </span><span class="c1">// 包括.transfer / .send</span>
<span class="w">        </span><span class="nx">balances</span><span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="nx">withdrawAmount</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// 这会自动引发失败，也就是说还原了更新的余额</span>
<span class="w">        </span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">.</span><span class="nx">transfer</span><span class="p">(</span><span class="nx">withdrawAmount</span><span class="p">);</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">balances</span><span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// @notice 获取余额</span>
<span class="w">    </span><span class="c1">/// @return 用户的余额</span>
<span class="w">    </span><span class="c1">// &#39;view&#39; 防止函数编辑状态变量；允许函数本地运行或链下运行</span>
<span class="w">    </span><span class="kd">function</span><span class="w"> </span><span class="nx">balance</span><span class="p">()</span><span class="w"> </span><span class="nx">view</span><span class="w"> </span><span class="kr">public</span><span class="w"> </span><span class="nx">returns</span><span class="w"> </span><span class="p">(</span><span class="nx">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">balances</span><span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">// ** 例子结束 **</span>


<span class="c1">// 下面， solidity 基础</span>

<span class="c1">// 1. 数据类型与关联的方法</span>
<span class="c1">// uint 类型用作现金数量（没有双浮点型或单浮点型）及日期（用 unix 时间）</span>
<span class="nx">uint</span><span class="w"> </span><span class="nx">x</span><span class="p">;</span>

<span class="c1">// 256字节的 int， 实例化后不能改变</span>
<span class="kr">int</span><span class="w"> </span><span class="nx">constant</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">8</span><span class="p">;</span>
<span class="nx">int256</span><span class="w"> </span><span class="nx">constant</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">8</span><span class="p">;</span><span class="w"> </span><span class="c1">// 和上一行一样，这里256字节显性化了</span>
<span class="nx">uint</span><span class="w"> </span><span class="nx">constant</span><span class="w"> </span><span class="nx">VERSION_ID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x123A1</span><span class="p">;</span><span class="w"> </span><span class="c1">// 16进制常量</span>
<span class="c1">// &#39;constant&#39; 关键字, 编译器在每个出现的地方替换为实际的值</span>

<span class="c1">// 所有的状态变量（函数之外的那些），默认是 &#39;internal&#39; 的，只能在合约及所有继承的合约内</span>
<span class="c1">// 可以访问。需要显性的设置为 &#39;public&#39; 才能允许外部合约访问。</span>
<span class="nx">int256</span><span class="w"> </span><span class="kr">public</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">8</span><span class="p">;</span>

<span class="c1">// 对于 int 和 uint，可以显性的设置位数（从8位到256位，8位跳跃），如int8, int16, int24</span>
<span class="nx">uint8</span><span class="w"> </span><span class="nx">b</span><span class="p">;</span>
<span class="nx">int64</span><span class="w"> </span><span class="nx">c</span><span class="p">;</span>
<span class="nx">uint248</span><span class="w"> </span><span class="nx">e</span><span class="p">;</span>

<span class="c1">// 当心不要溢出以及免收此类攻击，例如，对于加法最好这么做：</span>
<span class="nx">uint256</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">b</span><span class="p">;</span>
<span class="nx">assert</span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nx">a</span><span class="p">);</span><span class="w"> </span><span class="c1">// assert 测试内部不变的值；require 用来测试用户输入</span>
<span class="c1">// 更多通用算法问题的例子，参考 Zeppelin&#39;s SafeMath library</span>
<span class="c1">// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol</span>


<span class="c1">// 没有内建的随机函数，使用其他合约获得随机数</span>

<span class="c1">// 类型转换</span>
<span class="kr">int</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kr">int</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span>

<span class="nx">bool</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// 或 &#39;var b = true;&#39; 隐含的类型</span>

<span class="c1">// 地址 - 20个字节或160位以太坊地址（16进制数字），不允许进行运算</span>
<span class="nx">address</span><span class="w"> </span><span class="kr">public</span><span class="w"> </span><span class="nx">owner</span><span class="p">;</span>

<span class="c1">// 账户类型：</span>
<span class="c1">// 合约账户：在创建时设置地址（创建者地址函数，交易发送）</span>
<span class="c1">// 外部账户：（个人账户）从公钥创建的地址</span>

<span class="c1">// &#39;public&#39; 的含义是自动创建的 getter 方法，而不是 setter 方法可以公开的、外部访问。</span>

<span class="c1">// 所有地址都可以进行转账</span>
<span class="nx">owner</span><span class="p">.</span><span class="nx">transfer</span><span class="p">(</span><span class="nx">SOME_BALANCE</span><span class="p">);</span><span class="w"> </span><span class="c1">// 失败后还原</span>

<span class="c1">// 还可以调用较低级别的 .send ， 转账失败会返回 false</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">owner</span><span class="p">.</span><span class="nx">send</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="c1">// 记住：用 &#39;if&#39; 包着 send 函数，因为合约地址执行这些函数转账时，可能会失败</span>
<span class="c1">// 另外，确保转账前先减掉余额，因为存在递归调用的风险。</span>

<span class="c1">// 检查余额</span>
<span class="nx">owner</span><span class="p">.</span><span class="nx">balance</span><span class="p">;</span><span class="w"> </span><span class="c1">// 所有者的余额（用户或合约）</span>


<span class="c1">// 字符类型，从1到32位可用</span>
<span class="kr">byte</span><span class="w"> </span><span class="nx">a</span><span class="p">;</span><span class="w"> </span><span class="c1">// byte 等同于 byte1</span>
<span class="nx">bytes2</span><span class="w"> </span><span class="nx">b</span><span class="p">;</span>
<span class="nx">bytes32</span><span class="w"> </span><span class="nx">c</span><span class="p">;</span>

<span class="c1">// 动态大小的字符</span>
<span class="nx">bytes</span><span class="w"> </span><span class="nx">m</span><span class="p">;</span><span class="w"> </span><span class="c1">// 特殊的数组，等同于 byte[]，比 byte1 到 byte32 更贵</span>
<span class="c1">// 尽可能不用 bytes</span>

<span class="c1">// 等同于 bytes，但不允许长度或索引的访问</span>
<span class="nx">string</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;hello&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// UTF8存储，注意双引号而不是单引号</span>
<span class="c1">// 字符功能未来会增加，推荐使用 bytes32 或 bytes</span>

<span class="c1">// 推断类型</span>
<span class="c1">// var 会根据第一次赋值决定类型，不能用来作为函数的参数</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="c1">// 小心使用，推断可能带来错误的类型，例如，int8，而计数器需要的是 int16</span>

<span class="c1">// 函数可以用 var 类型赋值给变量</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">a</span><span class="p">(</span><span class="nx">uint</span><span class="w"> </span><span class="nx">x</span><span class="p">)</span><span class="w"> </span><span class="nx">returns</span><span class="w"> </span><span class="p">(</span><span class="nx">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">2</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">a</span><span class="p">;</span>
<span class="nx">f</span><span class="p">(</span><span class="mf">22</span><span class="p">);</span><span class="w"> </span><span class="c1">// 调用</span>

<span class="c1">// 默认的，所有值实例化后都设为 0</span>

<span class="c1">// 大多数类型上可以调用删除（不会销毁值，而是设置为0，初始值）</span>
<span class="nx">uint</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5</span><span class="p">;</span>


<span class="c1">// 集合</span>
<span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">7</span><span class="p">);</span><span class="w"> </span><span class="c1">// 多值的赋值</span>


<span class="c1">// 2. 数据结构</span>
<span class="c1">// 数组</span>
<span class="nx">bytes32</span><span class="p">[</span><span class="mf">5</span><span class="p">]</span><span class="w"> </span><span class="nx">nicknames</span><span class="p">;</span><span class="w"> </span><span class="c1">// 静态数组</span>
<span class="nx">bytes32</span><span class="p">[]</span><span class="w"> </span><span class="nx">names</span><span class="p">;</span><span class="w"> </span><span class="c1">// 动态数组</span>
<span class="nx">uint</span><span class="w"> </span><span class="nx">newLength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">names</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&quot;John&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// 添加返回数组的新长度</span>
<span class="c1">// 长度</span>
<span class="nx">names</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="w"> </span><span class="c1">// 获得数组长度</span>
<span class="nx">names</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// 可以设定长度（仅针对 storage 中的动态数组）</span>

<span class="c1">// 多维数组</span>
<span class="nx">uint</span><span class="p">[][</span><span class="mf">5</span><span class="p">]</span><span class="w"> </span><span class="nx">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// 5个动态数组元素的数组(和多数语言的顺序相反)</span>

<span class="c1">// 字典类型 (任一类型到其他类型的映射)</span>
<span class="nx">mapping</span><span class="w"> </span><span class="p">(</span><span class="nx">string</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">uint</span><span class="p">)</span><span class="w"> </span><span class="kr">public</span><span class="w"> </span><span class="nx">balances</span><span class="p">;</span>
<span class="nx">balances</span><span class="p">[</span><span class="s2">&quot;charles&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1</span><span class="p">;</span>
<span class="c1">// balances[&quot;ada&quot;]得到 0, 所有没有设定key值的，返回0</span>
<span class="c1">// &#39;public&#39; 允许跟着（调用）另一份合约</span>
<span class="nx">contractName</span><span class="p">.</span><span class="nx">balances</span><span class="p">(</span><span class="s2">&quot;charles&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// returns 1</span>
<span class="c1">// &#39;public&#39; 创建 getter （而不是 setter ）如下：</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">balances</span><span class="p">(</span><span class="nx">string</span><span class="w"> </span><span class="nx">_account</span><span class="p">)</span><span class="w"> </span><span class="nx">returns</span><span class="w"> </span><span class="p">(</span><span class="nx">uint</span><span class="w"> </span><span class="nx">balance</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">balances</span><span class="p">[</span><span class="nx">_account</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// 内嵌的 mapping</span>
<span class="nx">mapping</span><span class="w"> </span><span class="p">(</span><span class="nx">address</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">mapping</span><span class="w"> </span><span class="p">(</span><span class="nx">address</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">uint</span><span class="p">))</span><span class="w"> </span><span class="kr">public</span><span class="w"> </span><span class="nx">custodians</span><span class="p">;</span>

<span class="c1">// 删除</span>
<span class="ow">delete</span><span class="w"> </span><span class="nx">balances</span><span class="p">[</span><span class="s2">&quot;John&quot;</span><span class="p">];</span>
<span class="ow">delete</span><span class="w"> </span><span class="nx">balances</span><span class="p">;</span><span class="w"> </span><span class="c1">// 所有元素设为 0</span>

<span class="c1">// 不像其他语言，不知道 keys 的话不能列出 mapping 中的所有元素 - 可以在这之上构建数据结构</span>

<span class="c1">// 结构</span>
<span class="nx">struct</span><span class="w"> </span><span class="nx">Bank</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">address</span><span class="w"> </span><span class="nx">owner</span><span class="p">;</span>
<span class="w">    </span><span class="nx">uint</span><span class="w"> </span><span class="nx">balance</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">Bank</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">Bank</span><span class="p">({</span>
<span class="w">    </span><span class="nx">owner</span><span class="o">:</span><span class="w"> </span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">,</span>
<span class="w">    </span><span class="nx">balance</span><span class="o">:</span><span class="w"> </span><span class="mf">5</span>
<span class="p">});</span>
<span class="c1">// 或</span>
<span class="nx">Bank</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">Bank</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">,</span><span class="w"> </span><span class="mf">5</span><span class="p">);</span>

<span class="nx">c</span><span class="p">.</span><span class="nx">balance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// 设为新值</span>
<span class="ow">delete</span><span class="w"> </span><span class="nx">b</span><span class="p">;</span>
<span class="c1">// 设为初始值，结构内所有变量设为0，除了 mapping</span>

<span class="c1">// 枚举</span>
<span class="kr">enum</span><span class="w"> </span><span class="nx">State</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">Created</span><span class="p">,</span><span class="w"> </span><span class="nx">Locked</span><span class="p">,</span><span class="w"> </span><span class="nx">Inactive</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// 常常作为状态机</span>
<span class="nx">State</span><span class="w"> </span><span class="kr">public</span><span class="w"> </span><span class="nx">state</span><span class="p">;</span><span class="w"> </span><span class="c1">// 声明枚举变量</span>
<span class="nx">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">State</span><span class="p">.</span><span class="nx">Created</span><span class="p">;</span>
<span class="c1">// 枚举类型可以显性化的转换为 ints</span>
<span class="nx">uint</span><span class="w"> </span><span class="nx">createdState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">uint</span><span class="p">(</span><span class="nx">State</span><span class="p">.</span><span class="nx">Created</span><span class="p">);</span><span class="w"> </span><span class="c1">//  0</span>

<span class="c1">// 数据位置：内存（Memory） vs. 存储（storage） vs. 调用数据（calldata）</span>
<span class="c1">// 所有复杂类型（数据、结构）都有一个数据位置，内存数据不持久，而存储的数据是持久的。</span>
<span class="c1">// 本地变量和状态变量默认是存储，函数参数默认是内存。堆栈存放较小的本地变量</span>

<span class="c1">// 多数类型，可以显性化的设定使用的数据位置</span>


<span class="c1">// 3. 简单操作符</span>
<span class="c1">// solidity 提供了比较、位运算及数学运算的功能</span>
<span class="c1">// 指数运算: **</span>
<span class="c1">// 异或运算: ^</span>
<span class="c1">// 按位取反: ~</span>


<span class="c1">// 4. 值得注意的全局变量</span>
<span class="c1">// ** this **</span>
<span class="k">this</span><span class="p">;</span><span class="w"> </span><span class="c1">// 合约的地址</span>
<span class="c1">// 常常用在合约生命周期结束前，转走剩下的余额</span>
<span class="k">this</span><span class="p">.</span><span class="nx">balance</span><span class="p">;</span>
<span class="k">this</span><span class="p">.</span><span class="nx">someFunction</span><span class="p">();</span><span class="w"> </span><span class="c1">// 通过 call 的方式而不是内部跳转的方式，从外部调用函数</span>

<span class="c1">// ** msg - 合约收到的当前消息 ** **</span>
<span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">;</span><span class="w"> </span><span class="c1">// 发送者的地址</span>
<span class="nx">msg</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span><span class="w"> </span><span class="c1">// 该合约内的以太币数量（单位 wei），该函数应该标记为 &quot;payable&quot;</span>
<span class="nx">msg</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span><span class="w"> </span><span class="c1">// 字符，完整的调用数据</span>
<span class="nx">msg</span><span class="p">.</span><span class="nx">gas</span><span class="p">;</span><span class="w"> </span><span class="c1">// 剩余 gas</span>

<span class="c1">// ** tx - 交易信息 **</span>
<span class="nx">tx</span><span class="p">.</span><span class="nx">origin</span><span class="p">;</span><span class="w"> </span><span class="c1">// 本次交易的发送者地址</span>
<span class="nx">tx</span><span class="p">.</span><span class="nx">gasprice</span><span class="p">;</span><span class="w"> </span><span class="c1">// 本次交易的 gas price</span>

<span class="c1">// ** block - 当前区块信息 **</span>
<span class="nx">now</span><span class="p">;</span><span class="w"> </span><span class="c1">// 当前时间（大概）block.timestamp的别名 (采用的 Unix 时间)</span>
<span class="c1">// 注意这个可能被矿工操纵，因此请小心使用</span>

<span class="nx">block</span><span class="p">.</span><span class="nx">number</span><span class="p">;</span><span class="w"> </span><span class="c1">// 当前区块号</span>
<span class="nx">block</span><span class="p">.</span><span class="nx">difficulty</span><span class="p">;</span><span class="w"> </span><span class="c1">// 当前区块难度</span>
<span class="nx">block</span><span class="p">.</span><span class="nx">blockhash</span><span class="p">(</span><span class="mf">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// 返回 bytes32，只对最近 256 个区块有效</span>
<span class="nx">block</span><span class="p">.</span><span class="nx">gasLimit</span><span class="p">();</span>

<span class="c1">// ** 存储 - 持久化存储哈希 **</span>
<span class="nx">storage</span><span class="p">[</span><span class="s1">&#39;abc&#39;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;def&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 256 位单词 到 256 位单词的映射</span>


<span class="c1">// 4. 函数及更多</span>
<span class="c1">// A. 函数</span>
<span class="c1">// 简单函数</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">increment</span><span class="p">(</span><span class="nx">uint</span><span class="w"> </span><span class="nx">x</span><span class="p">)</span><span class="w"> </span><span class="nx">returns</span><span class="w"> </span><span class="p">(</span><span class="nx">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 函数可以通过指定返回的参数名，来返回多个参数</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">increment</span><span class="p">(</span><span class="nx">uint</span><span class="w"> </span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">uint</span><span class="w"> </span><span class="nx">y</span><span class="p">)</span><span class="w"> </span><span class="nx">returns</span><span class="w"> </span><span class="p">(</span><span class="nx">uint</span><span class="w"> </span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">uint</span><span class="w"> </span><span class="nx">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">1</span><span class="p">;</span>
<span class="w">    </span><span class="nx">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 调用前一个函数</span>
<span class="nx">uint</span><span class="w"> </span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">increment</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">);</span>

<span class="c1">// &#39;view&#39; (&#39;constant&#39;的别名)</span>
<span class="c1">// 表明函数不会改变持久化的变量，View函数会本地执行，而不是链上运行。</span>
<span class="c1">// 注意：constant 关键字很快会废弃。</span>
<span class="nx">uint</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1</span><span class="p">;</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">increment</span><span class="p">(</span><span class="nx">uint</span><span class="w"> </span><span class="nx">x</span><span class="p">)</span><span class="w"> </span><span class="nx">view</span><span class="w"> </span><span class="nx">returns</span><span class="w"> </span><span class="p">(</span><span class="nx">uint</span><span class="w"> </span><span class="nx">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">1</span><span class="p">;</span>
<span class="w">    </span><span class="nx">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// 这一行会失败</span>
<span class="w">    </span><span class="c1">// y 是一个状态变量，不能在 view 的函数里改变 y</span>
<span class="p">}</span>

<span class="c1">// &#39;pure&#39; 比 &#39;view&#39; 或 &#39;constant&#39; 更加严格，甚至不允许读取状态变量</span>
<span class="c1">// 具体的规则很复杂，请参考</span>
<span class="c1">// view/pure:</span>
<span class="c1">// http://solidity.readthedocs.io/en/develop/contracts.html#view-functions</span>

<span class="c1">// &#39;函数可见性指示器&#39;</span>
<span class="c1">// &#39;view&#39;可以有以下修饰符，包括：</span>
<span class="c1">// public - 内部及外部可见（函数的默认值）</span>
<span class="c1">// external - 仅外部可见(包括 this 发起的调用)</span>
<span class="c1">// private - 仅当前合约可见</span>
<span class="c1">// internal - 仅当前合约及继承的合约可见</span>

<span class="c1">// 通常，显性的标记每个函数是个好主意</span>

<span class="c1">// 函数的挂起 - 可以将函数赋值给变量</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">a</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">b</span><span class="p">;</span>
<span class="w">    </span><span class="nx">b</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">b</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="p">}</span>

<span class="c1">// 所有接收 ether 的函数必须标记为 &#39;payable&#39;</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">depositEther</span><span class="p">()</span><span class="w"> </span><span class="kr">public</span><span class="w"> </span><span class="nx">payable</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">balances</span><span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">msg</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// 首选循环来递归（最大的调用堆栈深度是 1024），另外不要设置没有限制的循环，</span>
<span class="c1">// 因为这可能会达到 gas limit</span>

<span class="c1">// B. 事件</span>
<span class="c1">// 事件通知外部各方; 易于搜索和访问来自外部区块链（使用轻客户端）的事件</span>
<span class="c1">// 通常在合约参数之后声明</span>

<span class="c1">// 通常，首字母大写并在前面加上 Log ，防止与函数混淆</span>

<span class="c1">// 声明</span>
<span class="nx">event</span><span class="w"> </span><span class="nx">LogSent</span><span class="p">(</span><span class="nx">address</span><span class="w"> </span><span class="nx">indexed</span><span class="w"> </span><span class="kr">from</span><span class="p">,</span><span class="w"> </span><span class="nx">address</span><span class="w"> </span><span class="nx">indexed</span><span class="w"> </span><span class="nx">to</span><span class="p">,</span><span class="w"> </span><span class="nx">uint</span><span class="w"> </span><span class="nx">amount</span><span class="p">);</span><span class="w"> </span><span class="c1">// 注意 capital first letter</span>

<span class="c1">// 调用</span>
<span class="nx">LogSent</span><span class="p">(</span><span class="kr">from</span><span class="p">,</span><span class="w"> </span><span class="nx">to</span><span class="p">,</span><span class="w"> </span><span class="nx">amount</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">    // 对于外部方（合约或外部实体），使用 Web3 Javascript 库来监听</span>
<span class="cm">    // 以下是javascript代码,不是solidity代码</span>
<span class="cm">    Coin.LogSent().watch({}, &#39;&#39;, function(error, result) {</span>
<span class="cm">        if (!error) {</span>
<span class="cm">            console.log(&quot;Coin transfer: &quot; + result.args.amount +</span>
<span class="cm">                &quot; coins were sent from &quot; + result.args.from +</span>
<span class="cm">                &quot; to &quot; + result.args.to + &quot;.&quot;);</span>
<span class="cm">            console.log(&quot;Balances now:\n&quot; +</span>
<span class="cm">                &quot;Sender: &quot; + Coin.balances.call(result.args.from) +</span>
<span class="cm">                &quot;Receiver: &quot; + Coin.balances.call(result.args.to));</span>
<span class="cm">        }</span>
<span class="cm">    }</span>

<span class="cm">*/</span>

<span class="c1">// 一个合约依赖另一个合约的共同范例（例如，合约取决于另一个合约提供的当前汇率）</span>

<span class="c1">// C. 修饰器</span>
<span class="c1">// 修饰器验证函数的输入，例如最小余额或用户身份验证; 类似于其他语言的保护子句</span>

<span class="c1">// &#39;_&#39; （下划线）经常用在代码的最后一行，表明被调用的函数放在那里</span>
<span class="nx">modifier</span><span class="w"> </span><span class="nx">onlyAfter</span><span class="p">(</span><span class="nx">uint</span><span class="w"> </span><span class="nx">_time</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">require</span><span class="w"> </span><span class="p">(</span><span class="nx">now</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nx">_time</span><span class="p">);</span><span class="w"> </span><span class="nx">_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="nx">modifier</span><span class="w"> </span><span class="nx">onlyOwner</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">require</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">owner</span><span class="p">)</span><span class="w"> </span><span class="nx">_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="c1">// 常用于状态机</span>
<span class="nx">modifier</span><span class="w"> </span><span class="nx">onlyIfStateA</span><span class="w"> </span><span class="p">(</span><span class="nx">State</span><span class="w"> </span><span class="nx">currState</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">require</span><span class="p">(</span><span class="nx">currState</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">State</span><span class="p">.</span><span class="nx">A</span><span class="p">)</span><span class="w"> </span><span class="nx">_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="c1">// 修饰器紧跟在函数声明之后</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">changeOwner</span><span class="p">(</span><span class="nx">newOwner</span><span class="p">)</span>
<span class="nx">onlyAfter</span><span class="p">(</span><span class="nx">someTime</span><span class="p">)</span>
<span class="nx">onlyOwner</span><span class="p">()</span>
<span class="nx">onlyIfState</span><span class="p">(</span><span class="nx">State</span><span class="p">.</span><span class="nx">A</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="nx">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">newOwner</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 下划线可以包含在代码结束之前，但明显地返回将跳过后面的代码，因此谨慎使用</span>
<span class="nx">modifier</span><span class="w"> </span><span class="nx">checkValue</span><span class="p">(</span><span class="nx">uint</span><span class="w"> </span><span class="nx">amount</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">_</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nx">amount</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">uint</span><span class="w"> </span><span class="nx">amountToRefund</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">amount</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">msg</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
<span class="w">        </span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">.</span><span class="nx">transfer</span><span class="p">(</span><span class="nx">amountToRefund</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>


<span class="c1">// 6. 判断和循环</span>

<span class="c1">// 所有基本的逻辑判断都有效 - 包括 if else, for, while, break, continue</span>
<span class="c1">// return - 但不跳转</span>

<span class="c1">// 语法同 javascript, 但没有从非布尔值到布尔值的类型转换</span>
<span class="c1">// (必须使用比较操作符获得布尔变量值)</span>

<span class="c1">// 请注意由用户行为决定的循环 - 因为合约对于代码块具有最大量的 gas 限制 -</span>
<span class="c1">// 如果超过限制该代码则将失败</span>
<span class="c1">// 例如：</span>
<span class="k">for</span><span class="p">(</span><span class="nx">uint</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">refundAddressList</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="w"> </span><span class="nx">x</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">refundAddressList</span><span class="p">[</span><span class="nx">x</span><span class="p">].</span><span class="nx">transfer</span><span class="p">(</span><span class="nx">SOME_AMOUNT</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 上述两个错误:</span>
<span class="c1">// 1. 转账失败会阻塞循环完成，钱被占用</span>
<span class="c1">// 2. 该循环可能会很长（根据需要赔偿的用户数量而定），并且也可能由于超过一个区块最大 gas 限制</span>
<span class="c1">// 而总是失败。你应该让人们自己从他们的子账户取款并标记取款完成</span>
<span class="c1">// 例如，首选拉动式的付款，而不是推动式的付款</span>


<span class="c1">// 7. 对象与合约</span>

<span class="c1">// A. 调用外部合约</span>
<span class="nx">contract</span><span class="w"> </span><span class="nx">InfoFeed</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">function</span><span class="w"> </span><span class="nx">info</span><span class="p">()</span><span class="w"> </span><span class="nx">returns</span><span class="w"> </span><span class="p">(</span><span class="nx">uint</span><span class="w"> </span><span class="nx">ret</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mf">42</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="nx">contract</span><span class="w"> </span><span class="nx">Consumer</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">InfoFeed</span><span class="w"> </span><span class="nx">feed</span><span class="p">;</span><span class="w"> </span><span class="c1">// 指向区块链上的一个合约</span>

<span class="w">    </span><span class="c1">// 设置 feed 为已存在的合约实例</span>
<span class="w">    </span><span class="kd">function</span><span class="w"> </span><span class="nx">setFeed</span><span class="p">(</span><span class="nx">address</span><span class="w"> </span><span class="nx">addr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 当心类型自动转换；不会调用构造函数</span>
<span class="w">        </span><span class="nx">feed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">InfoFeed</span><span class="p">(</span><span class="nx">addr</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 设置 feed 为一个合约的新实例</span>
<span class="w">    </span><span class="kd">function</span><span class="w"> </span><span class="nx">createNewFeed</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">feed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">InfoFeed</span><span class="p">();</span><span class="w"> </span><span class="c1">// 创建新实例，调用构造函数</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">function</span><span class="w"> </span><span class="nx">callFeed</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 最后的括号调用合约，可选择的增加自定义的 ether 或 gas 价格</span>
<span class="w">        </span><span class="nx">feed</span><span class="p">.</span><span class="nx">info</span><span class="p">.</span><span class="nx">value</span><span class="p">(</span><span class="mf">10</span><span class="p">).</span><span class="nx">gas</span><span class="p">(</span><span class="mf">800</span><span class="p">)();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// B. 继承</span>

<span class="c1">// 和顺序有关，最后继承的合约（如 &#39;def&#39;）可以覆盖之前已继承合约的部分</span>
<span class="nx">contract</span><span class="w"> </span><span class="nx">MyContract</span><span class="w"> </span><span class="nx">is</span><span class="w"> </span><span class="nx">abc</span><span class="p">,</span><span class="w"> </span><span class="nx">def</span><span class="p">(</span><span class="s2">&quot;a custom argument to def&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="c1">// 覆盖函数</span>
<span class="w">    </span><span class="kd">function</span><span class="w"> </span><span class="nx">z</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">owner</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">def</span><span class="p">.</span><span class="nx">z</span><span class="p">();</span><span class="w"> </span><span class="c1">// 调用覆盖的函数</span>
<span class="w">            </span><span class="k">super</span><span class="p">.</span><span class="nx">z</span><span class="p">();</span><span class="w"> </span><span class="c1">// 调用继承的上层合约的函数</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 抽象函数</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">someAbstractFunction</span><span class="p">(</span><span class="nx">uint</span><span class="w"> </span><span class="nx">x</span><span class="p">);</span>
<span class="c1">// 不可以编译，因此用在基础或抽象合约中，等待实现</span>

<span class="c1">// C. 导入</span>

<span class="k">import</span><span class="w"> </span><span class="s2">&quot;filename&quot;</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="s2">&quot;github.com/ethereum/dapp-bin/library/iterable_mapping.sol&quot;</span><span class="p">;</span>


<span class="c1">// 8. 其他关键字</span>

<span class="c1">// A. 自毁</span>
<span class="c1">// 自毁当前的合约，转账资金到一个地址（常常是创建者的地址）</span>
<span class="nx">selfdestruct</span><span class="p">(</span><span class="nx">SOME_ADDRESS</span><span class="p">);</span>

<span class="c1">// 从当前或以后的区块中移除存储或代码，会帮助客户端瘦身，但之前的数据会永久在区块链中</span>

<span class="c1">// 常见模式，让所有者结束合约并收回剩余的资金</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">remove</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">creator</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 只有合约的创建者可以这么做</span>
<span class="w">        </span><span class="nx">selfdestruct</span><span class="p">(</span><span class="nx">creator</span><span class="p">);</span><span class="w"> </span><span class="c1">// 自毁合约，返还资金</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 可能希望手动停用合约，而不是自毁</span>
<span class="c1">// (发送到自毁合约的 ether 会丢失掉)</span>


<span class="c1">// 9. 注意合约的设计</span>

<span class="c1">// A. 困惑</span>
<span class="c1">// 区块链上所有变量都是公开可见的，因此任何私有的需求变得很困惑。(好比哈希的秘密)</span>

<span class="c1">// 步骤: 1. 承诺某事, 2. 揭示承诺</span>
<span class="nx">keccak256</span><span class="p">(</span><span class="s2">&quot;some_bid_amount&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;some secret&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// commit</span>

<span class="c1">// 以后调用合约的 reveal 函数，展示出用 SHA3 哈希的 bid 加 secret</span>
<span class="nx">reveal</span><span class="p">(</span><span class="mf">100</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;mySecret&quot;</span><span class="p">);</span>

<span class="c1">// B. 存储优化</span>
<span class="c1">// 写入区块链可能很昂贵，因为数据是永久存储的；鼓励用巧妙的方法使用内存</span>
<span class="c1">//（最终，编译会更好，但现在有利于规划数据结构 - 并将最小数量存储在区块链中）</span>

<span class="c1">// 多维数组这样的变量可能会成本很高</span>
<span class="c1">// (成本用于存储数据 - 而不是声明未填充的变量)</span>

<span class="c1">// C. 区块链中的数据访问</span>
<span class="c1">// 不能限制人或计算机读取交易或交易状态的内容</span>

<span class="c1">// 然而 &#39;private&#39; 可以防止其他*合约*直接读取数据 - 任意其他方仍然可以从区块链读取数据</span>

<span class="c1">// 从开始的所有数据都存在区块链上，因此任何人都可以查看之前的所有数据和变化</span>

<span class="c1">// D. 定时任务</span>
<span class="c1">// 必须手动调用合约来处理时间相关的调度；也可以创建外部代码来定期的ping，</span>
<span class="c1">// 或为其他人提供激励（以太）</span>

<span class="c1">// E. 观察者模式</span>
<span class="c1">//观察者模式允许您注册为订阅者，然后注册一个由oracle调用的函数</span>
<span class="c1">//（注意，oracle 需要付费来运行此操作）。与 Pub / sub 中的订阅有些相似之处</span>

<span class="c1">// 这是一个抽象合约，包括客户端和服务器端的类的导入，客户端应该要实现</span>
<span class="nx">contract</span><span class="w"> </span><span class="nx">SomeOracleCallback</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">function</span><span class="w"> </span><span class="nx">oracleCallback</span><span class="p">(</span><span class="kr">int</span><span class="w"> </span><span class="nx">_value</span><span class="p">,</span><span class="w"> </span><span class="nx">uint</span><span class="w"> </span><span class="nx">_time</span><span class="p">,</span><span class="w"> </span><span class="nx">bytes32</span><span class="w"> </span><span class="nx">info</span><span class="p">)</span><span class="w"> </span><span class="nx">external</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">contract</span><span class="w"> </span><span class="nx">SomeOracle</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">SomeOracleCallback</span><span class="p">[]</span><span class="w"> </span><span class="nx">callbacks</span><span class="p">;</span><span class="w"> </span><span class="c1">// 所有订阅者的数组</span>

<span class="w">    </span><span class="c1">// 注册订阅者</span>
<span class="w">    </span><span class="kd">function</span><span class="w"> </span><span class="nx">addSubscriber</span><span class="p">(</span><span class="nx">SomeOracleCallback</span><span class="w"> </span><span class="nx">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">callbacks</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">function</span><span class="w"> </span><span class="nx">notify</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="nx">time</span><span class="p">,</span><span class="w"> </span><span class="nx">info</span><span class="p">)</span><span class="w"> </span><span class="kr">private</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="nx">uint</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">callbacks</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 所有调用的订阅者必须实现 oracleCallback</span>
<span class="w">            </span><span class="nx">callbacks</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">oracleCallback</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="nx">time</span><span class="p">,</span><span class="w"> </span><span class="nx">info</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">function</span><span class="w"> </span><span class="nx">doSomething</span><span class="p">()</span><span class="w"> </span><span class="kr">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 实现的代码</span>

<span class="w">        </span><span class="c1">// 通知所有的订阅者</span>
<span class="w">        </span><span class="nx">notify</span><span class="p">(</span><span class="nx">_value</span><span class="p">,</span><span class="w"> </span><span class="nx">_time</span><span class="p">,</span><span class="w"> </span><span class="nx">_info</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 现在你的客户端合约可以通过 importing SomeOracleCallback 和注册某些 Oracle 来</span>
<span class="c1">// addSubscriber 添加订阅者</span>

<span class="c1">// F. 状态机</span>
<span class="c1">// 参见如下的例子，枚举类型的 State 和 修饰器 inState</span>


<span class="c1">// *** 例子: 众筹的例子（与 Kickstarter 大致相似）***</span>
<span class="c1">// ** 开始例子 **</span>

<span class="c1">// CrowdFunder.sol</span>
<span class="nx">pragma</span><span class="w"> </span><span class="nx">solidity</span><span class="w"> </span><span class="o">^</span><span class="mf">0.4.19</span><span class="p">;</span>

<span class="c1">/// @title CrowdFunder</span>
<span class="c1">/// @author nemild</span>
<span class="c1">/// @translator bobjiang</span>
<span class="nx">contract</span><span class="w"> </span><span class="nx">CrowdFunder</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 由创建者创建的变量</span>
<span class="w">    </span><span class="nx">address</span><span class="w"> </span><span class="kr">public</span><span class="w"> </span><span class="nx">creator</span><span class="p">;</span>
<span class="w">    </span><span class="nx">address</span><span class="w"> </span><span class="kr">public</span><span class="w"> </span><span class="nx">fundRecipient</span><span class="p">;</span><span class="w"> </span><span class="c1">// 创建者可能和收件人不同</span>
<span class="w">    </span><span class="nx">uint</span><span class="w"> </span><span class="kr">public</span><span class="w"> </span><span class="nx">minimumToRaise</span><span class="p">;</span><span class="w"> </span><span class="c1">// 需要提示，否则每个人都会得到退款</span>
<span class="w">    </span><span class="nx">string</span><span class="w"> </span><span class="nx">campaignUrl</span><span class="p">;</span>
<span class="w">    </span><span class="kr">byte</span><span class="w"> </span><span class="nx">constant</span><span class="w"> </span><span class="nx">version</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 数据结构</span>
<span class="w">    </span><span class="kr">enum</span><span class="w"> </span><span class="nx">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">Fundraising</span><span class="p">,</span>
<span class="w">        </span><span class="nx">ExpiredRefund</span><span class="p">,</span>
<span class="w">        </span><span class="nx">Successful</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">struct</span><span class="w"> </span><span class="nx">Contribution</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">uint</span><span class="w"> </span><span class="nx">amount</span><span class="p">;</span>
<span class="w">        </span><span class="nx">address</span><span class="w"> </span><span class="nx">contributor</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 状态变量State variables</span>
<span class="w">    </span><span class="nx">State</span><span class="w"> </span><span class="kr">public</span><span class="w"> </span><span class="nx">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">State</span><span class="p">.</span><span class="nx">Fundraising</span><span class="p">;</span><span class="w"> </span><span class="c1">// 创建时实例化</span>
<span class="w">    </span><span class="nx">uint</span><span class="w"> </span><span class="kr">public</span><span class="w"> </span><span class="nx">totalRaised</span><span class="p">;</span>
<span class="w">    </span><span class="nx">uint</span><span class="w"> </span><span class="kr">public</span><span class="w"> </span><span class="nx">raiseBy</span><span class="p">;</span>
<span class="w">    </span><span class="nx">uint</span><span class="w"> </span><span class="kr">public</span><span class="w"> </span><span class="nx">completeAt</span><span class="p">;</span>
<span class="w">    </span><span class="nx">Contribution</span><span class="p">[]</span><span class="w"> </span><span class="nx">contributions</span><span class="p">;</span>

<span class="w">    </span><span class="nx">event</span><span class="w"> </span><span class="nx">LogFundingReceived</span><span class="p">(</span><span class="nx">address</span><span class="w"> </span><span class="nx">addr</span><span class="p">,</span><span class="w"> </span><span class="nx">uint</span><span class="w"> </span><span class="nx">amount</span><span class="p">,</span><span class="w"> </span><span class="nx">uint</span><span class="w"> </span><span class="nx">currentTotal</span><span class="p">);</span>
<span class="w">    </span><span class="nx">event</span><span class="w"> </span><span class="nx">LogWinnerPaid</span><span class="p">(</span><span class="nx">address</span><span class="w"> </span><span class="nx">winnerAddress</span><span class="p">);</span>

<span class="w">    </span><span class="nx">modifier</span><span class="w"> </span><span class="nx">inState</span><span class="p">(</span><span class="nx">State</span><span class="w"> </span><span class="nx">_state</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">require</span><span class="p">(</span><span class="nx">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">_state</span><span class="p">);</span>
<span class="w">        </span><span class="nx">_</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">modifier</span><span class="w"> </span><span class="nx">isCreator</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">require</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">creator</span><span class="p">);</span>
<span class="w">        </span><span class="nx">_</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 允许合约销毁之前，最终合约状态后要等待24周</span>
<span class="w">    </span><span class="nx">modifier</span><span class="w"> </span><span class="nx">atEndOfLifecycle</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">require</span><span class="p">(((</span><span class="nx">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">State</span><span class="p">.</span><span class="nx">ExpiredRefund</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">State</span><span class="p">.</span><span class="nx">Successful</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">        </span><span class="nx">completeAt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">24</span><span class="w"> </span><span class="nx">weeks</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">now</span><span class="p">));</span>
<span class="w">        </span><span class="nx">_</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">function</span><span class="w"> </span><span class="nx">CrowdFunder</span><span class="p">(</span>
<span class="w">        </span><span class="nx">uint</span><span class="w"> </span><span class="nx">timeInHoursForFundraising</span><span class="p">,</span>
<span class="w">        </span><span class="nx">string</span><span class="w"> </span><span class="nx">_campaignUrl</span><span class="p">,</span>
<span class="w">        </span><span class="nx">address</span><span class="w"> </span><span class="nx">_fundRecipient</span><span class="p">,</span>
<span class="w">        </span><span class="nx">uint</span><span class="w"> </span><span class="nx">_minimumToRaise</span><span class="p">)</span>
<span class="w">        </span><span class="kr">public</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="nx">creator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">;</span>
<span class="w">        </span><span class="nx">fundRecipient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">_fundRecipient</span><span class="p">;</span>
<span class="w">        </span><span class="nx">campaignUrl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">_campaignUrl</span><span class="p">;</span>
<span class="w">        </span><span class="nx">minimumToRaise</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">_minimumToRaise</span><span class="p">;</span>
<span class="w">        </span><span class="nx">raiseBy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">now</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="nx">timeInHoursForFundraising</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="nx">hours</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">function</span><span class="w"> </span><span class="nx">contribute</span><span class="p">()</span>
<span class="w">    </span><span class="kr">public</span>
<span class="w">    </span><span class="nx">payable</span>
<span class="w">    </span><span class="nx">inState</span><span class="p">(</span><span class="nx">State</span><span class="p">.</span><span class="nx">Fundraising</span><span class="p">)</span>
<span class="w">    </span><span class="nx">returns</span><span class="p">(</span><span class="nx">uint256</span><span class="w"> </span><span class="nx">id</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="nx">contributions</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span>
<span class="w">            </span><span class="nx">Contribution</span><span class="p">({</span>
<span class="w">                </span><span class="nx">amount</span><span class="o">:</span><span class="w"> </span><span class="nx">msg</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span>
<span class="w">                </span><span class="nx">contributor</span><span class="o">:</span><span class="w"> </span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span>
<span class="w">            </span><span class="p">})</span><span class="w"> </span><span class="c1">// 采用数组，因此可以遍历</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">        </span><span class="nx">totalRaised</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">msg</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>

<span class="w">        </span><span class="nx">LogFundingReceived</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">,</span><span class="w"> </span><span class="nx">msg</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="nx">totalRaised</span><span class="p">);</span>

<span class="w">        </span><span class="nx">checkIfFundingCompleteOrExpired</span><span class="p">();</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">contributions</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// 返回 id</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">function</span><span class="w"> </span><span class="nx">checkIfFundingCompleteOrExpired</span><span class="p">()</span>
<span class="w">    </span><span class="kr">public</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">totalRaised</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nx">minimumToRaise</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">State</span><span class="p">.</span><span class="nx">Successful</span><span class="p">;</span>
<span class="w">            </span><span class="nx">payOut</span><span class="p">();</span>

<span class="w">            </span><span class="c1">// 可以激励在这里发起状态改变的人</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nx">now</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nx">raiseBy</span><span class="w"> </span><span class="p">)</span><span class="w">  </span><span class="p">{</span>
<span class="w">            </span><span class="nx">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">State</span><span class="p">.</span><span class="nx">ExpiredRefund</span><span class="p">;</span><span class="w"> </span><span class="c1">// 支持者可以通过调用 getRefund(id) 收取退款</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="nx">completeAt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">now</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">function</span><span class="w"> </span><span class="nx">payOut</span><span class="p">()</span>
<span class="w">    </span><span class="kr">public</span>
<span class="w">    </span><span class="nx">inState</span><span class="p">(</span><span class="nx">State</span><span class="p">.</span><span class="nx">Successful</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="nx">fundRecipient</span><span class="p">.</span><span class="nx">transfer</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">balance</span><span class="p">);</span>
<span class="w">        </span><span class="nx">LogWinnerPaid</span><span class="p">(</span><span class="nx">fundRecipient</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">function</span><span class="w"> </span><span class="nx">getRefund</span><span class="p">(</span><span class="nx">uint256</span><span class="w"> </span><span class="nx">id</span><span class="p">)</span>
<span class="w">    </span><span class="nx">inState</span><span class="p">(</span><span class="nx">State</span><span class="p">.</span><span class="nx">ExpiredRefund</span><span class="p">)</span>
<span class="w">    </span><span class="kr">public</span>
<span class="w">    </span><span class="nx">returns</span><span class="p">(</span><span class="nx">bool</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="nx">require</span><span class="p">(</span><span class="nx">contributions</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nx">id</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">id</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">contributions</span><span class="p">[</span><span class="nx">id</span><span class="p">].</span><span class="nx">amount</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="nx">uint256</span><span class="w"> </span><span class="nx">amountToRefund</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">contributions</span><span class="p">[</span><span class="nx">id</span><span class="p">].</span><span class="nx">amount</span><span class="p">;</span>
<span class="w">        </span><span class="nx">contributions</span><span class="p">[</span><span class="nx">id</span><span class="p">].</span><span class="nx">amount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span>

<span class="w">        </span><span class="nx">contributions</span><span class="p">[</span><span class="nx">id</span><span class="p">].</span><span class="nx">contributor</span><span class="p">.</span><span class="nx">transfer</span><span class="p">(</span><span class="nx">amountToRefund</span><span class="p">);</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">function</span><span class="w"> </span><span class="nx">removeContract</span><span class="p">()</span>
<span class="w">    </span><span class="kr">public</span>
<span class="w">    </span><span class="nx">isCreator</span><span class="p">()</span>
<span class="w">    </span><span class="nx">atEndOfLifecycle</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="nx">selfdestruct</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// 创建者获得所有未被声明的钱</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">// ** 结束例子 **</span>

<span class="c1">// 10. 其他原生的函数</span>

<span class="c1">// 货币单位</span>
<span class="c1">// 货币使用 wei 来定义，以太币的最小单位 = 1 wei;</span>
<span class="nx">uint</span><span class="w"> </span><span class="nx">minAmount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="nx">wei</span><span class="p">;</span>
<span class="nx">uint</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="nx">finney</span><span class="p">;</span><span class="w"> </span><span class="c1">// 1 ether == 1000 finney</span>
<span class="c1">// 其他单位，请参阅: http://ether.fund/tool/converter</span>

<span class="c1">// 时间单位</span>
<span class="mf">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="nx">second</span>
<span class="mf">1</span><span class="w"> </span><span class="nx">minutes</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">60</span><span class="w"> </span><span class="nx">seconds</span>

<span class="c1">// 可以乘以带时间单位的变量，因为单位不会存储在变量中</span>
<span class="nx">uint</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5</span><span class="p">;</span>
<span class="p">(</span><span class="nx">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="nx">days</span><span class="p">);</span><span class="w"> </span><span class="c1">// 5 天</span>

<span class="c1">// 小心闰秒闰年与平等声明的时间</span>
<span class="c1">// (相反，首选大于或小于)</span>

<span class="c1">// 加密算法</span>
<span class="c1">// 传递的所有字符串在哈希操作之前需要连接在一起</span>
<span class="nx">sha3</span><span class="p">(</span><span class="s2">&quot;ab&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;cd&quot;</span><span class="p">);</span>
<span class="nx">ripemd160</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">);</span>
<span class="nx">sha256</span><span class="p">(</span><span class="s2">&quot;def&quot;</span><span class="p">);</span>

<span class="c1">// 11. 安全</span>

<span class="c1">// 以太坊的合约中，错误可能是灾难性的 - 即使在 solidity 中是流行的模式，也可能发现是反模式的</span>

<span class="c1">// 参见文档底部的安全链接</span>

<span class="c1">// 12. 较低层次的函数</span>
<span class="c1">// call - 较低层次，不会经常使用，不提供类型安全性</span>
<span class="nx">successBoolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">someContractAddress</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="s1">&#39;function_name&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;arg1&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;arg2&#39;</span><span class="p">);</span>

<span class="c1">// callcode - 在调用合约的*上下文*中执行的目标地址上的代码</span>
<span class="c1">// 提供库功能</span>
<span class="nx">someContractAddress</span><span class="p">.</span><span class="nx">callcode</span><span class="p">(</span><span class="s1">&#39;function_name&#39;</span><span class="p">);</span>


<span class="c1">// 13. 注意风格</span>
<span class="c1">// 基于 Python 的 PEP8 风格指南</span>
<span class="c1">// 全部风格指南: http://solidity.readthedocs.io/en/develop/style-guide.html</span>

<span class="c1">// 快速总结:</span>
<span class="c1">// 4个空格缩进</span>
<span class="c1">// 两行隔开合约声明（和其他高级别的声明）</span>
<span class="c1">// 避免括号内留出多余的空格</span>
<span class="c1">// 可以省略一行语句的花括号 (if, for, 等)</span>
<span class="c1">// else 应该单独一行</span>


<span class="c1">// 14. NATSPEC 注释</span>
<span class="c1">// 用于文档、注释和外部UI</span>

<span class="c1">// 合约的 natspec - 总是在合约定义的上面</span>
<span class="c1">/// @title 合约标题</span>
<span class="c1">/// @author 作者名字</span>

<span class="c1">// 函数的 natspec</span>
<span class="c1">/// @notice 函数做什么的相关信息；展示什么时候执行该函数、</span>
<span class="c1">/// @dev 开发者使用的函数文档</span>

<span class="c1">// 函数参数、返回值的 natspec</span>
<span class="c1">/// @param 有关参数用途的描述</span>
<span class="c1">/// @return 返回值的描述</span>
</pre></div>
<h2>更多资源</h2>

<ul>
<li><a href="https://solidity.readthedocs.org/en/latest/">Solidity Docs</a></li>
<li><a href="https://github.com/ConsenSys/smart-contract-best-practices">Smart Contract Best Practices</a></li>
<li><a href="https://ethfiddle.com/">EthFiddle - The JsFiddle for Solidity</a></li>
<li><a href="https://remix.ethereum.org/">Browser-based Solidity Editor</a></li>
<li><a href="https://gitter.im/ethereum/solidity">Gitter Solidity Chat room</a></li>
<li><a href="https://docs.erisindustries.com/tutorials/solidity/">Modular design strategies for Ethereum Contracts</a></li>
</ul>

<h2>重要的库文件</h2>

<ul>
<li><a href="https://github.com/OpenZeppelin/zeppelin-solidity/">Zeppelin</a>: Libraries that provide common contract patterns (crowdfuding, safemath, etc)</li>
</ul>

<h2>示例合约</h2>

<ul>
<li><a href="https://github.com/ethereum/dapp-bin">Dapp Bin</a></li>
<li><a href="https://github.com/fivedogit/solidity-baby-steps/tree/master/contracts">Solidity Baby Step Contracts</a></li>
<li><a href="https://github.com/ConsenSys/dapp-store-contracts">ConsenSys Contracts</a></li>
<li><a href="http://dapps.ethercasts.com/">State of Dapps</a></li>
</ul>

<h2>安全</h2>

<ul>
<li><a href="https://blog.ethereum.org/2016/06/19/thinking-smart-contract-security/">Thinking About Smart Contract Security</a></li>
<li><a href="https://blog.ethereum.org/2016/06/10/smart-contract-security/">Smart Contract Security</a></li>
<li><a href="http://hackingdistributed.com/">Hacking Distributed Blog</a></li>
</ul>

<h2>风格</h2>

<ul>
<li><a href="http://solidity.readthedocs.io/en/latest/style-guide.html">Solidity Style Guide</a>: Ethereum&rsquo;s style guide is heavily derived from Python&rsquo;s <a href="https://www.python.org/dev/peps/pep-0008/">PEP 8</a> style guide.</li>
</ul>

<h2>编辑器</h2>

<ul>
<li><a href="https://github.com/ethereum/emacs-solidity">Emacs Solidity Mode</a></li>
<li><a href="https://github.com/tomlion/vim-solidity">Vim Solidity</a></li>
<li>Editor Snippets (<a href="https://gist.github.com/nemild/98343ce6b16b747788bc">Ultisnips format</a>)</li>
</ul>

<h2>Future to Dos</h2>

<ul>
<li>新关键字: protected, inheritable</li>
<li>常见设计模式列表 (throttling, RNG, version upgrade)</li>
<li>常见的安全反模式</li>
</ul>

<p>请随意发送 pull request 或者发邮件给作者  nemild -/at-/ gmail</p>

<p>或者发邮件给译者 jiangxb -/at-/ gmail.com</p>

    <hr>
    <p>有建议？或者发现什么错误？在Github上<a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">开一个issue</a>，或者发起<a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/zh-cn/solidity-cn.html.markdown">pull request</a>！
    </p>
    <p class="contributed">
    原著Nemil Dalal，并由<a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/zh-cn/solidity-cn.html.markdown">4个好心人</a>修改。
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="https://www.nemil.com">Nemil Dalal</a>,
        <a href="">Joseph Chow</a>,
        <a href="https://github.com/varshard">Bhoomtawath Plinsut</a>,
        <a href="https://github.com/liushooter">Shooter</a>
    </p>

    <p>
      Translated by:
        <a href="https://github.com/bobjiang">Bob Jiang</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
