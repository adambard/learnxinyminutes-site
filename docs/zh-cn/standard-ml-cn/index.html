<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="zh-cn" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="zh-cn" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="zh-cn" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="zh-cn" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="zh-cn">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Standard ML in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/zh-cn/standard-ml-cn/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fzh-cn%2Fstandard-ml-cn%2F&text=Y%E5%88%86%E9%92%9F%E9%80%9F%E6%88%90X%2C+%E5%85%B6%E4%B8%AD+X%3DStandard+ML">
        分享此页
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">选择主题：</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">亮</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">暗</button>
  </div>
  <h1><a href="/">Y分钟速成X</a></h1>
  <h2>其中 X=Standard ML</h2>
    <p class="filelink">
    源代码下载：
    <a href="/docs/files/standard-ml-cn.html">standard-ml-cn.html</a>
    </p>
  <div id="doc">
    <p>Standard ML是一门拥有类型推断和一些副作用的函数式编程语言。学习Standard ML的一些
难点在于：递归、模式匹配和类型推断（猜测正确的类型但是决不允许隐式类型转换）。与Haskell的
不同之处在于Standard ML拥有引用，允许对变量进行更新。</p>
<div class="highlight"><pre><span></span><span class="c">(* Standard ML的注释以 (* 开头，以 *) 结束。注释可以嵌套，也就意味着所有的 (* 标签都</span>
<span class="c">   需要由一个 *) 结束。这条注释就是两个嵌套的注释的例子。*)</span>

<span class="c">(* 一个Standard ML程序包括声明，例如值声明： *)</span>
<span class="k">val</span> <span class="n">rent</span> <span class="o">=</span> <span class="mi">1200</span>
<span class="k">val</span> <span class="n">phone_no</span> <span class="o">=</span> <span class="mi">5551337</span>
<span class="k">val</span> <span class="n">pi</span> <span class="o">=</span> <span class="mi">3</span><span class="o">.</span><span class="mi">14159</span>
<span class="k">val</span> <span class="n">negative_number</span> <span class="o">=</span> <span class="o">~</span><span class="mi">15</span>  <span class="c">(* 是的，一元运算符用波浪符号`~`表示 *)</span>

<span class="c">(* 你当然也可以显示的声明类型，但这并不是必须的，因为ML会自动推断出值的类型。*)</span>
<span class="k">val</span> <span class="n">diameter</span> <span class="o">=</span> <span class="mi">7926</span> <span class="o">:</span> <span class="kt">int</span>
<span class="k">val</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">2</span><span class="o">.</span><span class="mi">718</span> <span class="o">:</span> <span class="n">real</span>
<span class="k">val</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Bobby&quot;</span> <span class="o">:</span> <span class="kt">string</span>

<span class="c">(* 同样重要的还有函数： *)</span>
<span class="k">fun</span> <span class="n">is_large</span><span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="kt">int</span><span class="o">)</span> <span class="o">=</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">37</span> <span class="k">then</span> <span class="bp">true</span> <span class="k">else</span> <span class="bp">false</span>

<span class="c">(* 浮点数被叫做实数： &quot;real&quot;. *)</span>
<span class="k">val</span> <span class="n">tau</span> <span class="o">=</span> <span class="mi">2</span><span class="o">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">pi</span>         <span class="c">(* 两个real可以相乘 *)</span>
<span class="k">val</span> <span class="n">twice_rent</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">rent</span>  <span class="c">(* 两个int也可以相乘 *)</span>
<span class="c">(* val meh = 1.25 * 10 *)</span>  <span class="c">(* 但是你不能让int和real相乘。 *)</span>
<span class="k">val</span> <span class="n">yeh</span> <span class="o">=</span> <span class="mi">1</span><span class="o">.</span><span class="mi">25</span> <span class="o">*</span> <span class="o">(</span><span class="nn">Real</span><span class="p">.</span><span class="n">fromInt</span> <span class="mi">10</span><span class="o">)</span> <span class="c">(* ...除非你显示的把一个转换为另一个*)</span>

<span class="c">(* +, - 和 * 被重载过，所以可以作用于int和real。*)</span>
<span class="c">(* 但是除法有单独的运算符： *)</span>
<span class="k">val</span> <span class="n">real_division</span> <span class="o">=</span> <span class="mi">14</span><span class="o">.</span><span class="mi">0</span> <span class="o">/</span> <span class="mi">4</span><span class="o">.</span><span class="mi">0</span>  <span class="c">(* 结果是 3.5 *)</span>
<span class="k">val</span> <span class="n">int_division</span>  <span class="o">=</span> <span class="mi">14</span> <span class="n">div</span> <span class="mi">4</span>    <span class="c">(* 结果是 3， 向下取整 *)</span>
<span class="k">val</span> <span class="n">int_remainder</span> <span class="o">=</span> <span class="mi">14</span> <span class="ow">mod</span> <span class="mi">4</span>    <span class="c">(* 结果是 2， 因为 3*4 = 12 *)</span>

<span class="c">(* ~ 有时其实是函数 (比如被放在变量前面的时候) *)</span>
<span class="k">val</span> <span class="n">negative_rent</span> <span class="o">=</span> <span class="o">~(</span><span class="n">rent</span><span class="o">)</span>  <span class="c">(* 即使rent是&quot;real&quot;也正确 *)</span>

<span class="c">(* 当然也有布尔值和相关的运算符 *)</span>
<span class="k">val</span> <span class="n">got_milk</span> <span class="o">=</span> <span class="bp">true</span>
<span class="k">val</span> <span class="n">got_bread</span> <span class="o">=</span> <span class="bp">false</span>
<span class="k">val</span> <span class="n">has_breakfast</span> <span class="o">=</span> <span class="n">got_milk</span> <span class="n">andalso</span> <span class="n">got_bread</span>  <span class="c">(* &#39;andalso&#39; 是运算符 *)</span>
<span class="k">val</span> <span class="n">has_something</span> <span class="o">=</span> <span class="n">got_milk</span> <span class="n">orelse</span> <span class="n">got_bread</span>   <span class="c">(* &#39;orelse&#39; 是运算符 *)</span>
<span class="k">val</span> <span class="n">is_sad</span> <span class="o">=</span> <span class="n">not</span><span class="o">(</span><span class="n">has_something</span><span class="o">)</span>                 <span class="c">(* not 是一个函数 *)</span>

<span class="c">(* 很多值都可以用判等性运算符进行比较： = 和 &lt;&gt; *)</span>
<span class="k">val</span> <span class="n">pays_same_rent</span> <span class="o">=</span> <span class="o">(</span><span class="n">rent</span> <span class="o">=</span> <span class="mi">1300</span><span class="o">)</span>  <span class="c">(* false *)</span>
<span class="k">val</span> <span class="n">is_wrong_phone_no</span> <span class="o">=</span> <span class="o">(</span><span class="n">phone_no</span> <span class="o">&lt;&gt;</span> <span class="mi">5551337</span><span class="o">)</span>  <span class="c">(* false *)</span>

<span class="c">(* &lt;&gt; 运算符就是其他大部分语言里的 != 。 *)</span>
<span class="c">(* &#39;andalso&#39; 和 &#39;orelse&#39; 在很多其他语言里被叫做 &amp;&amp; 和 || 。 *)</span>

<span class="c">(* 实际上，上面大部分的圆括号都是不需要的。比如表达上面内容的一些不同的方式： *)</span>
<span class="k">fun</span> <span class="n">is_large</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">37</span>  
<span class="k">val</span> <span class="n">is_sad</span> <span class="o">=</span> <span class="n">not</span> <span class="n">has_something</span>
<span class="k">val</span> <span class="n">pays_same_rent</span> <span class="o">=</span> <span class="n">rent</span> <span class="o">=</span> <span class="mi">1300</span>  <span class="c">(* 看起来很奇怪，但是就是这样的。 *)</span>
<span class="k">val</span> <span class="n">is_wrong_phone_no</span> <span class="o">=</span> <span class="n">phone_no</span> <span class="o">&lt;&gt;</span> <span class="mi">5551337</span>
<span class="k">val</span> <span class="n">negative_rent</span> <span class="o">=</span> <span class="o">~</span><span class="n">rent</span>  <span class="c">(* ~ rent (注意空格) 也正确 *)</span>

<span class="c">(* 圆括号大部分时候用来把东西们组合在一起 *)</span>
<span class="k">val</span> <span class="n">some_answer</span> <span class="o">=</span> <span class="n">is_large</span> <span class="o">(</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">5</span><span class="o">)</span>      <span class="c">(* 没有圆括号的话会出错！ *)</span>
<span class="c">(* val some_answer = is_large 5 + 5 *)</span>  <span class="c">(* 会被理解为： (is_large 5) + 5. 错了！ *)</span>

<span class="c">(* 除了boolean, int, real，Standard ML也有char和string *)</span>
<span class="k">val</span> <span class="n">foo</span> <span class="o">=</span> <span class="s2">&quot;Hello, World!</span><span class="se">\n</span><span class="s2">&quot;</span>  <span class="c">(* \n是换行的转移字符 *)</span>
<span class="k">val</span> <span class="n">one_letter</span> <span class="o">=</span> <span class="o">#</span><span class="s2">&quot;a&quot;</span>        <span class="c">(* 这种酷炫的语法表示一个字符a *)</span>

<span class="k">val</span> <span class="n">combined</span> <span class="o">=</span> <span class="s2">&quot;Hello &quot;</span> <span class="o">^</span> <span class="s2">&quot;there, &quot;</span> <span class="o">^</span> <span class="s2">&quot;fellow!</span><span class="se">\n</span><span class="s2">&quot;</span>  <span class="c">(* 拼接字符串 *)</span>

<span class="k">val</span> <span class="o">_</span> <span class="o">=</span> <span class="n">print</span> <span class="n">foo</span>       <span class="c">(* 你可以打印一些东西，这儿我们队打印的结果并不感兴趣，因此 *)</span>
<span class="k">val</span> <span class="o">_</span> <span class="o">=</span> <span class="n">print</span> <span class="n">combined</span>  <span class="c">(* 用 _ 把结果丢掉了 *)</span>
<span class="c">(* val _ = print one_letter *)</span>  <span class="c">(* 只有字符串才能被这样打印 *)</span>


<span class="k">val</span> <span class="n">bar</span> <span class="o">=</span> <span class="o">[</span> <span class="o">#</span><span class="s2">&quot;H&quot;</span><span class="o">,</span> <span class="o">#</span><span class="s2">&quot;e&quot;</span><span class="o">,</span> <span class="o">#</span><span class="s2">&quot;l&quot;</span><span class="o">,</span> <span class="o">#</span><span class="s2">&quot;l&quot;</span><span class="o">,</span> <span class="o">#</span><span class="s2">&quot;o&quot;</span> <span class="o">]</span>  <span class="c">(* SML 也有列表！ *)</span>
<span class="c">(* val _ = print bar *)</span>  <span class="c">(* 然而列表和string是不同的 *)</span>

<span class="c">(* 当然这二者可以相互转换。String是一个库，implode和size是这个库里接受string作为</span>
<span class="c">   参数的函数。*)</span>
<span class="k">val</span> <span class="n">bob</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">implode</span> <span class="n">bar</span>          <span class="c">(* 结果是 &quot;Hello&quot; *)</span>
<span class="k">val</span> <span class="n">bob_char_count</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">size</span> <span class="n">bob</span>  <span class="c">(* 结果是 5 *)</span>
<span class="k">val</span> <span class="o">_</span> <span class="o">=</span> <span class="n">print</span> <span class="o">(</span><span class="n">bob</span> <span class="o">^</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">)</span>            <span class="c">(* 为了好看加了个换行符 *)</span>

<span class="c">(* 列表可以包含任意类型的元素 *)</span>
<span class="k">val</span> <span class="n">numbers</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">229</span><span class="o">,</span> <span class="mi">230</span><span class="o">,</span> <span class="mi">248</span><span class="o">]</span>  <span class="c">(* : int list *)</span>
<span class="k">val</span> <span class="n">names</span> <span class="o">=</span> <span class="o">[</span> <span class="s2">&quot;Fred&quot;</span><span class="o">,</span> <span class="s2">&quot;Jane&quot;</span><span class="o">,</span> <span class="s2">&quot;Alice&quot;</span> <span class="o">]</span>    <span class="c">(* : string list *)</span>

<span class="c">(* 列表甚至可以包含列表！ *)</span>
<span class="k">val</span> <span class="n">groups</span> <span class="o">=</span> <span class="o">[</span> <span class="o">[</span> <span class="s2">&quot;Alice&quot;</span><span class="o">,</span> <span class="s2">&quot;Bob&quot;</span> <span class="o">],</span>
               <span class="o">[</span> <span class="s2">&quot;Huey&quot;</span><span class="o">,</span> <span class="s2">&quot;Dewey&quot;</span><span class="o">,</span> <span class="s2">&quot;Louie&quot;</span> <span class="o">],</span>
               <span class="o">[</span> <span class="s2">&quot;Bonnie&quot;</span><span class="o">,</span> <span class="s2">&quot;Clyde&quot;</span> <span class="o">]</span> <span class="o">]</span>     <span class="c">(* : string list list *)</span>

<span class="k">val</span> <span class="n">number_count</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">numbers</span>     <span class="c">(* 结果是 7 *)</span>

<span class="c">(* 你可以使用 :: 操作符把单个值放到同样类型列表的最前面。</span>
<span class="c">   :: 叫做con操作符（名字来自Lisp） *)</span>
<span class="k">val</span> <span class="n">more_numbers</span> <span class="o">=</span> <span class="mi">13</span> <span class="o">::</span> <span class="n">numbers</span>  <span class="c">(* 结果是 [13, 1, 3, 3, 7, ...] *)</span>
<span class="k">val</span> <span class="n">more_groups</span>  <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;Batman&quot;</span><span class="o">,</span><span class="s2">&quot;Superman&quot;</span><span class="o">]</span> <span class="o">::</span> <span class="n">groups</span>

<span class="c">(* 拥有同样类型元素的列表可以使用 @ 操作符连接起来 *)</span>
<span class="k">val</span> <span class="n">guest_list</span> <span class="o">=</span> <span class="o">[</span> <span class="s2">&quot;Mom&quot;</span><span class="o">,</span> <span class="s2">&quot;Dad&quot;</span> <span class="o">]</span> <span class="o">@</span> <span class="o">[</span> <span class="s2">&quot;Aunt&quot;</span><span class="o">,</span> <span class="s2">&quot;Uncle&quot;</span> <span class="o">]</span>

<span class="c">(* 使用 :: 操作符也能完成这项工作。但是这有点绕，因为左手边必须是单个元素</span>
<span class="c">   而右边必须是这种元素的列表 *)</span>
<span class="k">val</span> <span class="n">guest_list</span> <span class="o">=</span> <span class="s2">&quot;Mom&quot;</span> <span class="o">::</span> <span class="s2">&quot;Dad&quot;</span> <span class="o">::</span> <span class="o">[</span> <span class="s2">&quot;Aunt&quot;</span><span class="o">,</span> <span class="s2">&quot;Uncle&quot;</span> <span class="o">]</span>
<span class="k">val</span> <span class="n">guest_list</span> <span class="o">=</span> <span class="s2">&quot;Mom&quot;</span> <span class="o">::</span> <span class="o">(</span><span class="s2">&quot;Dad&quot;</span> <span class="o">::</span> <span class="o">(</span><span class="s2">&quot;Aunt&quot;</span> <span class="o">::</span> <span class="o">(</span><span class="s2">&quot;Uncle&quot;</span> <span class="o">::</span> <span class="bp">[]</span><span class="o">)))</span>

<span class="c">(* 如果你有很多同样类型的列表，也可以整个拼接成一个。 *)</span>
<span class="k">val</span> <span class="n">everyone</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">concat</span> <span class="n">groups</span>  <span class="c">(* [ &quot;Alice&quot;, &quot;Bob&quot;, &quot;Huey&quot;, ... ] *)</span>

<span class="c">(* 列表可以包含任意（无限）数量的元素 *)</span>
<span class="k">val</span> <span class="n">lots</span> <span class="o">=</span> <span class="o">[</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">3</span> <span class="o">]</span>  <span class="c">(* still just an int list *)</span>

<span class="c">(* 但是列表只能包含一种类型的元素 *)</span>
<span class="c">(* val bad_list = [ 1, &quot;Hello&quot;, 3.14159 ] : ??? list *)</span>

<span class="c">(* 而元组Tuples则可以包含有限固定数量的不同类型的元素 *)</span>
<span class="k">val</span> <span class="n">person1</span> <span class="o">=</span> <span class="o">(</span><span class="s2">&quot;Simon&quot;</span><span class="o">,</span> <span class="mi">28</span><span class="o">,</span> <span class="mi">3</span><span class="o">.</span><span class="mi">14159</span><span class="o">)</span>  <span class="c">(* : string * int * real *)</span>

<span class="c">(* 你甚至可以让列表和元组相互嵌套 *)</span>
<span class="k">val</span> <span class="n">likes</span> <span class="o">=</span> <span class="o">[</span> <span class="o">(</span><span class="s2">&quot;Alice&quot;</span><span class="o">,</span> <span class="s2">&quot;ice cream&quot;</span><span class="o">),</span>
              <span class="o">(</span><span class="s2">&quot;Bob&quot;</span><span class="o">,</span>   <span class="s2">&quot;hot dogs&quot;</span><span class="o">),</span>
              <span class="o">(</span><span class="s2">&quot;Bob&quot;</span><span class="o">,</span>   <span class="s2">&quot;Alice&quot;</span><span class="o">)</span> <span class="o">]</span>     <span class="c">(* : (string * string) list *)</span>

<span class="k">val</span> <span class="n">mixup</span> <span class="o">=</span> <span class="o">[</span> <span class="o">(</span><span class="s2">&quot;Alice&quot;</span><span class="o">,</span> <span class="mi">39</span><span class="o">),</span>
              <span class="o">(</span><span class="s2">&quot;Bob&quot;</span><span class="o">,</span>   <span class="mi">37</span><span class="o">),</span>
              <span class="o">(</span><span class="s2">&quot;Eve&quot;</span><span class="o">,</span>   <span class="mi">41</span><span class="o">)</span> <span class="o">]</span>  <span class="c">(* : (string * int) list *)</span>

<span class="k">val</span> <span class="n">good_bad_stuff</span> <span class="o">=</span>
  <span class="o">([</span><span class="s2">&quot;ice cream&quot;</span><span class="o">,</span> <span class="s2">&quot;hot dogs&quot;</span><span class="o">,</span> <span class="s2">&quot;chocolate&quot;</span><span class="o">],</span>
   <span class="o">[</span><span class="s2">&quot;liver&quot;</span><span class="o">,</span> <span class="s2">&quot;paying the rent&quot;</span> <span class="o">])</span>           <span class="c">(* : string list * string list *)</span>

<span class="c">(* 记录Record是每个位置带名字的元组 *)</span>

<span class="k">val</span> <span class="n">rgb</span> <span class="o">=</span> <span class="o">{</span> <span class="n">r</span><span class="o">=</span><span class="mi">0</span><span class="o">.</span><span class="mi">23</span><span class="o">,</span> <span class="n">g</span><span class="o">=</span><span class="mi">0</span><span class="o">.</span><span class="mi">56</span><span class="o">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">0</span><span class="o">.</span><span class="mi">91</span> <span class="o">}</span> <span class="c">(* : {b:real, g:real, r:real} *)</span>

<span class="c">(* 使用Record时不需要提前声明每个位置的名字。 有不同名字的Record属于不同的类型</span>
<span class="c">   即使他们的值的类型是相同的。比如说：*)</span>
<span class="k">val</span> <span class="nc">Hsl</span> <span class="o">=</span> <span class="o">{</span> <span class="nc">H</span><span class="o">=</span><span class="mi">310</span><span class="o">.</span><span class="mi">3</span><span class="o">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="o">.</span><span class="mi">51</span><span class="o">,</span> <span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="o">.</span><span class="mi">23</span> <span class="o">}</span> <span class="c">(* : {H:real, l:real, s:real} *)</span>
<span class="k">val</span> <span class="nc">Hsv</span> <span class="o">=</span> <span class="o">{</span> <span class="nc">H</span><span class="o">=</span><span class="mi">310</span><span class="o">.</span><span class="mi">3</span><span class="o">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="o">.</span><span class="mi">51</span><span class="o">,</span> <span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="o">.</span><span class="mi">23</span> <span class="o">}</span> <span class="c">(* : {H:real, s:real, v:real} *)</span>

<span class="c">(* ...如果你想判断 `Hsv = Hsl` 或者 `rgb = Hsl` 的话，会得到一个类型错误。虽然他们都包含3个</span>
<span class="c">   real，但是由于名字不同，其类型也不同。 *)</span>

<span class="c">(* 可以使用 # 符号取出元组的值 *)</span>

<span class="k">val</span> <span class="nc">H</span> <span class="o">=</span> <span class="o">#</span><span class="nc">H</span> <span class="nc">Hsv</span> <span class="c">(* : real *)</span>
<span class="k">val</span> <span class="n">s</span> <span class="o">=</span> <span class="o">#</span><span class="n">s</span> <span class="nc">Hsl</span> <span class="c">(* : real *)</span>

<span class="c">(* 函数！ *)</span>
<span class="k">fun</span> <span class="n">add_them</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>    <span class="c">(* 一个简单的加法函数 *)</span>
<span class="k">val</span> <span class="n">test_it</span> <span class="o">=</span> <span class="n">add_them</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>  <span class="c">(* 结果是 7 *)</span>

<span class="c">(* 复杂函数通常会为了可读性写成多行 *)</span>
<span class="k">fun</span> <span class="n">thermometer</span> <span class="n">temp</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">temp</span> <span class="o">&lt;</span> <span class="mi">37</span>
    <span class="k">then</span> <span class="s2">&quot;Cold&quot;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">temp</span> <span class="o">&gt;</span> <span class="mi">37</span>
         <span class="k">then</span> <span class="s2">&quot;Warm&quot;</span>
         <span class="k">else</span> <span class="s2">&quot;Normal&quot;</span>

<span class="k">val</span> <span class="n">test_thermo</span> <span class="o">=</span> <span class="n">thermometer</span> <span class="mi">40</span>  <span class="c">(* 结果是 &quot;Warm&quot; *)</span>

<span class="c">(* if 实际上是表达式而不是声明。一个函数体只可以包含一个表达式。但是还是有一些小技巧</span>
<span class="c">   让一个函数做更多的事。 *)</span>

<span class="c">(* 函数也可以使用调用自己的结果 (递归！) *)</span>
<span class="k">fun</span> <span class="n">fibonacci</span> <span class="n">n</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span>                   <span class="c">(* 终止条件 *)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span>                   <span class="c">(* 终止条件 *)</span>
    <span class="n">fibonacci</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">fibonacci</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span>  <span class="c">(* 递归 *)</span>

<span class="c">(* 有的时候，手写出递归函数的执行过程能帮助理解递归概念：</span>

<span class="c"> fibonacci 4</span>
<span class="c">   ~&gt; fibonacci (4 - 1) + fibonacci (4 - 2)</span>
<span class="c">   ~&gt; fibonacci 3 + fibonacci 2</span>
<span class="c">   ~&gt; (fibonacci (3 - 1) + fibonacci (3 - 2)) + fibonacci 2</span>
<span class="c">   ~&gt; (fibonacci 2 + fibonacci 1) + fibonacci 2</span>
<span class="c">   ~&gt; ((fibonacci (2 - 1) + fibonacci (2 - 2)) + fibonacci 1) + fibonacci 2</span>
<span class="c">   ~&gt; ((fibonacci 1 + fibonacci 0) + fibonacci 1) + fibonacci 2</span>
<span class="c">   ~&gt; ((1 + fibonacci 0) + fibonacci 1) + fibonacci 2</span>
<span class="c">   ~&gt; ((1 + 0) + fibonacci 1) + fibonacci 2</span>
<span class="c">   ~&gt; (1 + fibonacci 1) + fibonacci 2</span>
<span class="c">   ~&gt; (1 + 1) + fibonacci 2</span>
<span class="c">   ~&gt; 2 + fibonacci 2</span>
<span class="c">   ~&gt; 2 + (fibonacci (2 - 1) + fibonacci (2 - 2))</span>
<span class="c">   ~&gt; 2 + (fibonacci (2 - 1) + fibonacci (2 - 2))</span>
<span class="c">   ~&gt; 2 + (fibonacci 1 + fibonacci 0)</span>
<span class="c">   ~&gt; 2 + (1 + fibonacci 0)</span>
<span class="c">   ~&gt; 2 + (1 + 0)</span>
<span class="c">   ~&gt; 2 + 1</span>
<span class="c">   ~&gt; 3  第四个斐波那契数</span>

<span class="c"> *)</span>

<span class="c">(* 函数不能改变它引用的值。它只能暂时的使用同名的新变量来覆盖这个值。也就是说，变量其实是</span>
<span class="c">   常数，只有在递归的时候才表现的比较像变量。因此，变量也被叫做值绑定。举个例子： *)</span>

<span class="k">val</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">42</span>
<span class="k">fun</span> <span class="n">answer</span><span class="o">(</span><span class="n">question</span><span class="o">)</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">question</span> <span class="o">=</span> <span class="s2">&quot;What is the meaning of life, the universe and everything?&quot;</span>
    <span class="k">then</span> <span class="n">x</span>
    <span class="k">else</span> <span class="k">raise</span> <span class="nc">Fail</span> <span class="s2">&quot;I&#39;m an exception. Also, I don&#39;t know what the answer is.&quot;</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">43</span>
<span class="k">val</span> <span class="n">hmm</span> <span class="o">=</span> <span class="n">answer</span> <span class="s2">&quot;What is the meaning of life, the universe and everything?&quot;</span>
<span class="c">(* 现在 hmm 的值是 42。  这是因为函数 answer 引用的x是函数定义之前的x。 *)</span>

<span class="c">(* 函数通过接受一个元组来接受多个参数。 *)</span>
<span class="k">fun</span> <span class="n">solve2</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">real</span><span class="o">,</span> <span class="n">b</span> <span class="o">:</span> <span class="n">real</span><span class="o">,</span> <span class="n">c</span> <span class="o">:</span> <span class="n">real</span><span class="o">)</span> <span class="o">=</span>
    <span class="o">((~</span><span class="n">b</span> <span class="o">+</span> <span class="nn">Math</span><span class="p">.</span><span class="n">sqrt</span><span class="o">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">4</span><span class="o">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span><span class="o">))</span> <span class="o">/</span> <span class="o">(</span><span class="mi">2</span><span class="o">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">a</span><span class="o">),</span>
     <span class="o">(~</span><span class="n">b</span> <span class="o">-</span> <span class="nn">Math</span><span class="p">.</span><span class="n">sqrt</span><span class="o">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">4</span><span class="o">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span><span class="o">))</span> <span class="o">/</span> <span class="o">(</span><span class="mi">2</span><span class="o">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">a</span><span class="o">))</span>

<span class="c">(* 有时候同样的计算会被计算多次，因此把结果保存下来以重复使用是很有必要的。</span>
<span class="c">   这时可以使用 let 绑定。 *)</span>
<span class="k">fun</span> <span class="n">solve2</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">real</span><span class="o">,</span> <span class="n">b</span> <span class="o">:</span> <span class="n">real</span><span class="o">,</span> <span class="n">c</span> <span class="o">:</span> <span class="n">real</span><span class="o">)</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">val</span> <span class="n">discr</span>  <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">4</span><span class="o">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span>
        <span class="k">val</span> <span class="n">sqr</span> <span class="o">=</span> <span class="nn">Math</span><span class="p">.</span><span class="n">sqrt</span> <span class="n">discr</span>
        <span class="k">val</span> <span class="n">denom</span> <span class="o">=</span> <span class="mi">2</span><span class="o">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">a</span>
    <span class="k">in</span> <span class="o">((~</span><span class="n">b</span> <span class="o">+</span> <span class="n">sqr</span><span class="o">)</span> <span class="o">/</span> <span class="n">denom</span><span class="o">,</span>
        <span class="o">(~</span><span class="n">b</span> <span class="o">-</span> <span class="n">sqr</span><span class="o">)</span> <span class="o">/</span> <span class="n">denom</span><span class="o">)</span>
    <span class="k">end</span>

<span class="c">(* 模式匹配是函数式编程的一个精巧的部分，它是实现 if 的另一种方式。  </span>
<span class="c">   斐波那契函数可以被重写为如下方式： *)</span>
<span class="k">fun</span> <span class="n">fibonacci</span> <span class="mi">0</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c">(* 终止条件 *)</span>
  <span class="o">|</span> <span class="n">fibonacci</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c">(* 终止条件 *)</span>
  <span class="o">|</span> <span class="n">fibonacci</span> <span class="n">n</span> <span class="o">=</span> <span class="n">fibonacci</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">fibonacci</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span>  <span class="c">(* 递归 *)</span>

<span class="c">(* 模式匹配也可以用于比如元组、列表和记录的复合类型。&quot;fun solve2 (a, b, c) = ...&quot;</span>
<span class="c">   的写法实际上也是对于一个三元素元组的模式匹配。类似但是比较不直观的是你也可以从列表的开头</span>
<span class="c">   对列表元素进行匹配。 *)</span>
<span class="k">fun</span> <span class="n">first_elem</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">)</span> <span class="o">=</span> <span class="n">x</span>
<span class="k">fun</span> <span class="n">second_elem</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">y</span><span class="o">::</span><span class="n">xs</span><span class="o">)</span> <span class="o">=</span> <span class="n">y</span>
<span class="k">fun</span> <span class="n">evenly_positioned_elems</span> <span class="o">(</span><span class="n">odd</span><span class="o">::</span><span class="n">even</span><span class="o">::</span><span class="n">xs</span><span class="o">)</span> <span class="o">=</span> <span class="n">even</span><span class="o">::</span><span class="n">evenly_positioned_elems</span> <span class="n">xs</span>
  <span class="o">|</span> <span class="n">evenly_positioned_elems</span> <span class="o">[</span><span class="n">odd</span><span class="o">]</span> <span class="o">=</span> <span class="bp">[]</span>  <span class="c">(* 终止条件：丢弃结果 *)</span>
  <span class="o">|</span> <span class="n">evenly_positioned_elems</span> <span class="bp">[]</span>    <span class="o">=</span> <span class="bp">[]</span>  <span class="c">(* 终止条件 *)</span>

<span class="c">(* 匹配记录的时候，比如使用每个位置的名字，每个位置的值都需要绑定，但是顺序并不重要。 *)</span>

<span class="k">fun</span> <span class="n">rgbToTup</span> <span class="o">{</span><span class="n">r</span><span class="o">,</span> <span class="n">g</span><span class="o">,</span> <span class="n">b</span><span class="o">}</span> <span class="o">=</span> <span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="n">g</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>    <span class="c">(* fn : {b:&#39;a, g:&#39;b, r:&#39;c} -&gt; &#39;c * &#39;b * &#39;a *)</span>
<span class="k">fun</span> <span class="n">mixRgbToTup</span> <span class="o">{</span><span class="n">g</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">r</span><span class="o">}</span> <span class="o">=</span> <span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="n">g</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="c">(* fn : {b:&#39;a, g:&#39;b, r:&#39;c} -&gt; &#39;c * &#39;b * &#39;a *)</span>

<span class="c">(* 如果传入参数 {r=0.1, g=0.2, b=0.3}，上面的两个函数都会返回 (0.1, 0.2, 0.3)。</span>
<span class="c">   但是传入参数 {r=0.1, g=0.2, b=0.3, a=0.4} 的话则会得到类型错误 *)</span>

<span class="c">(* 高阶函数： 可以接受其他函数作为参数的函数</span>
<span class="c">   函数只不过是另一种类型的值，不需要依附与一个名字而存在。</span>
<span class="c">   没有名字的函数被叫做匿名函数或者lambda表达式或者闭包（因为匿名函数也依赖于词法作用域）*)</span>
<span class="k">val</span> <span class="n">is_large</span> <span class="o">=</span> <span class="o">(</span><span class="n">fn</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">37</span><span class="o">)</span>
<span class="k">val</span> <span class="n">add_them</span> <span class="o">=</span> <span class="n">fn</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="k">val</span> <span class="n">thermometer</span> <span class="o">=</span>
    <span class="n">fn</span> <span class="n">temp</span> <span class="o">=&gt;</span> <span class="k">if</span> <span class="n">temp</span> <span class="o">&lt;</span> <span class="mi">37</span>
               <span class="k">then</span> <span class="s2">&quot;Cold&quot;</span>
               <span class="k">else</span> <span class="k">if</span> <span class="n">temp</span> <span class="o">&gt;</span> <span class="mi">37</span>
                    <span class="k">then</span> <span class="s2">&quot;Warm&quot;</span>
                    <span class="k">else</span> <span class="s2">&quot;Normal&quot;</span>

<span class="c">(* 下面的代码就是用了匿名函数，结果是 &quot;ColdWarm&quot; *)</span>
<span class="k">val</span> <span class="n">some_result</span> <span class="o">=</span> <span class="o">(</span><span class="n">fn</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">thermometer</span> <span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">5</span><span class="o">)</span> <span class="o">^</span> <span class="n">thermometer</span> <span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">5</span><span class="o">))</span> <span class="mi">37</span>

<span class="c">(* 这是一个作用于列表的高阶函数 *)</span>
<span class="c">(* map f l</span>
<span class="c">       把f从左至右作用于l的每一个元素，并返回结果组成的列表。 *)</span>
<span class="k">val</span> <span class="n">readings</span> <span class="o">=</span> <span class="o">[</span> <span class="mi">34</span><span class="o">,</span> <span class="mi">39</span><span class="o">,</span> <span class="mi">37</span><span class="o">,</span> <span class="mi">38</span><span class="o">,</span> <span class="mi">35</span><span class="o">,</span> <span class="mi">36</span><span class="o">,</span> <span class="mi">37</span><span class="o">,</span> <span class="mi">37</span><span class="o">,</span> <span class="mi">37</span> <span class="o">]</span>  <span class="c">(* 先定义一个列表 *)</span>
<span class="k">val</span> <span class="n">opinions</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">thermometer</span> <span class="n">readings</span> <span class="c">(* 结果是 [ &quot;Cold&quot;, &quot;Warm&quot;, ... ] *)</span>

<span class="c">(* filter 函数用于筛选列表 *)</span>
<span class="k">val</span> <span class="n">warm_readings</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="n">is_large</span> <span class="n">readings</span>  <span class="c">(* 结果是 [39, 38] *)</span>

<span class="c">(* 你也可以创建自己的高阶函数。函数也可以通过 curry 来接受多个参数。</span>
<span class="c">   从语法上来说，curry就是使用空格来分隔参数，而不是逗号和括号。 *)</span>
<span class="k">fun</span> <span class="n">map</span> <span class="n">f</span> <span class="bp">[]</span> <span class="o">=</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="n">map</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">)</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">::</span> <span class="n">map</span> <span class="n">f</span> <span class="n">xs</span>

<span class="c">(* map 的类型是 (&#39;a -&gt; &#39;b) -&gt; &#39;a list -&gt; &#39;b list ，这就是多态。 *)</span>
<span class="c">(* &#39;a 被叫做类型变量 *)</span>


<span class="c">(* 函数可以被声明为中缀的。 *)</span>
<span class="k">val</span> <span class="n">plus</span> <span class="o">=</span> <span class="n">add_them</span>   <span class="c">(* plus 现在和 add_them 是同一个函数。 *)</span>
<span class="n">infix</span> <span class="n">plus</span>            <span class="c">(* plus 现在是一个中缀操作符。 *)</span>
<span class="k">val</span> <span class="n">seven</span> <span class="o">=</span> <span class="mi">2</span> <span class="n">plus</span> <span class="mi">5</span>  <span class="c">(* seven 现在被绑定上了 7 *)</span>

<span class="c">(* 函数也可以在声明之前就声明为中缀 *)</span>
<span class="n">infix</span> <span class="n">minus</span>
<span class="k">fun</span> <span class="n">x</span> <span class="n">minus</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="c">(* 这样有点不容易判断哪个是参数。 *)</span>
<span class="k">val</span> <span class="n">four</span> <span class="o">=</span> <span class="mi">8</span> <span class="n">minus</span> <span class="mi">4</span>  <span class="c">(* four 现在被绑定上了 4 *)</span>

<span class="c">(* 中缀函数/操作符也可以使用 &#39;op&#39; 函数变回前缀函数。 *)</span>
<span class="k">val</span> <span class="n">n</span> <span class="o">=</span> <span class="n">op</span> <span class="o">+</span> <span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>   <span class="c">(* n is now 10 *)</span>

<span class="c">(* &#39;op&#39; 在结合高阶函数的时候非常有用，因为高阶函数接受的是函数而不是操作符作为参数。</span>
<span class="c">   大部分的操作符其实都是中缀函数。 *)</span>
<span class="c">(* foldl f init [x1, x2, ..., xn]</span>
<span class="c">       返回</span>
<span class="c">       f(xn, ...f(x2, f(x1, init))...)</span>
<span class="c">       或者如果列表为空时返回 init *)</span>
<span class="k">val</span> <span class="n">sum_of_numbers</span> <span class="o">=</span> <span class="n">foldl</span> <span class="n">op</span><span class="o">+</span> <span class="mi">0</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">]</span>


<span class="c">(* 可以很方便的使用 datatype 定义或简单或复杂的数据结构。 *)</span>
<span class="n">datatype</span> <span class="n">color</span> <span class="o">=</span> <span class="nc">Red</span> <span class="o">|</span> <span class="nc">Green</span> <span class="o">|</span> <span class="nc">Blue</span>

<span class="c">(* 这个函数接受 color 之一作为参数。 *)</span>
<span class="k">fun</span> <span class="n">say</span><span class="o">(</span><span class="n">col</span><span class="o">)</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">col</span> <span class="o">=</span> <span class="nc">Red</span> <span class="k">then</span> <span class="s2">&quot;You are red!&quot;</span> <span class="k">else</span>
    <span class="k">if</span> <span class="n">col</span> <span class="o">=</span> <span class="nc">Green</span> <span class="k">then</span> <span class="s2">&quot;You are green!&quot;</span> <span class="k">else</span>
    <span class="k">if</span> <span class="n">col</span> <span class="o">=</span> <span class="nc">Blue</span> <span class="k">then</span> <span class="s2">&quot;You are blue!&quot;</span> <span class="k">else</span>
    <span class="k">raise</span> <span class="nc">Fail</span> <span class="s2">&quot;Unknown color&quot;</span>

<span class="k">val</span> <span class="o">_</span> <span class="o">=</span> <span class="n">print</span> <span class="o">(</span><span class="n">say</span><span class="o">(</span><span class="nc">Red</span><span class="o">)</span> <span class="o">^</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">)</span>

<span class="c">(* datatype 经常和模式匹配一起使用。 *)</span>
<span class="k">fun</span> <span class="n">say</span> <span class="nc">Red</span>   <span class="o">=</span> <span class="s2">&quot;You are red!&quot;</span>
  <span class="o">|</span> <span class="n">say</span> <span class="nc">Green</span> <span class="o">=</span> <span class="s2">&quot;You are green!&quot;</span>
  <span class="o">|</span> <span class="n">say</span> <span class="nc">Blue</span>  <span class="o">=</span> <span class="s2">&quot;You are blue!&quot;</span>
  <span class="o">|</span> <span class="n">say</span> <span class="o">_</span>     <span class="o">=</span> <span class="k">raise</span> <span class="nc">Fail</span> <span class="s2">&quot;Unknown color&quot;</span>


<span class="c">(* 一个二叉树 datatype *)</span>
<span class="n">datatype</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">btree</span> <span class="o">=</span> <span class="nc">Leaf</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span>
                  <span class="o">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">btree</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">btree</span> <span class="c">(* 三个参数的构造器 *)</span>

<span class="c">(* 一颗二叉树： *)</span>
<span class="k">val</span> <span class="n">myTree</span> <span class="o">=</span> <span class="nc">Node</span> <span class="o">(</span><span class="nc">Leaf</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="nc">Node</span> <span class="o">(</span><span class="nc">Leaf</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="nc">Leaf</span> <span class="mi">7</span><span class="o">))</span>

<span class="c">(* 画出来应该是这个样子：</span>

<span class="c">           8</span>
<span class="c">          / \</span>
<span class="c"> leaf -&gt; 9   5</span>
<span class="c">            / \</span>
<span class="c">   leaf -&gt; 3   7 &lt;- leaf</span>
<span class="c"> *)</span>

<span class="c">(* 这个函数计算所有节点值的和。 *)</span>
<span class="k">fun</span> <span class="n">count</span> <span class="o">(</span><span class="nc">Leaf</span> <span class="n">n</span><span class="o">)</span> <span class="o">=</span> <span class="n">n</span>
  <span class="o">|</span> <span class="n">count</span> <span class="o">(</span><span class="nc">Node</span> <span class="o">(</span><span class="n">leftTree</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">rightTree</span><span class="o">))</span> <span class="o">=</span> <span class="n">count</span> <span class="n">leftTree</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="n">count</span> <span class="n">rightTree</span>

<span class="k">val</span> <span class="n">myTreeCount</span> <span class="o">=</span> <span class="n">count</span> <span class="n">myTree</span>  <span class="c">(* myTreeCount is now bound to 32 *)</span>


<span class="c">(* 异常！ *)</span>
<span class="c">(* 使用关键字 &#39;raise&#39; 来抛出异常： *)</span>
<span class="k">fun</span> <span class="n">calculate_interest</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">=</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span>
                            <span class="k">then</span> <span class="k">raise</span> <span class="nc">Domain</span>
                            <span class="k">else</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">1</span><span class="o">.</span><span class="mi">04</span>

<span class="c">(* 使用 &quot;handle&quot; 关键字来处理异常 *)</span>
<span class="k">val</span> <span class="n">balance</span> <span class="o">=</span> <span class="n">calculate_interest</span> <span class="o">~</span><span class="mi">180</span><span class="o">.</span><span class="mi">0</span>
              <span class="n">handle</span> <span class="nc">Domain</span> <span class="o">=&gt;</span> <span class="o">~</span><span class="mi">180</span><span class="o">.</span><span class="mi">0</span>    <span class="c">(* x 现在的值是 ~180.0 *)</span>

<span class="c">(* 某些异常还包含额外信息 *)</span>
<span class="c">(* 一些内建异常的例子： *)</span>
<span class="k">fun</span> <span class="n">failing_function</span> <span class="bp">[]</span>    <span class="o">=</span> <span class="k">raise</span> <span class="nc">Empty</span>  <span class="c">(* 空列表异常 *)</span>
  <span class="o">|</span> <span class="n">failing_function</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span>   <span class="o">=</span> <span class="k">raise</span> <span class="nc">Fail</span> <span class="s2">&quot;This list is too short!&quot;</span>
  <span class="o">|</span> <span class="n">failing_function</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="k">raise</span> <span class="nc">Overflow</span>  <span class="c">(* 用作计算 *)</span>
  <span class="o">|</span> <span class="n">failing_function</span> <span class="n">xs</span>    <span class="o">=</span> <span class="k">raise</span> <span class="nc">Fail</span> <span class="s2">&quot;This list is too long!&quot;</span>

<span class="c">(* 使用 &#39;handle&#39; 时也可以使用模式匹配来保证异常都被处理。 *)</span>
<span class="k">val</span> <span class="n">err_msg</span> <span class="o">=</span> <span class="n">failing_function</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="n">handle</span> <span class="nc">Fail</span> <span class="o">_</span> <span class="o">=&gt;</span> <span class="s2">&quot;Fail was raised&quot;</span>
                                          <span class="o">|</span> <span class="nc">Domain</span> <span class="o">=&gt;</span> <span class="s2">&quot;Domain was raised&quot;</span>
                                          <span class="o">|</span> <span class="nc">Empty</span>  <span class="o">=&gt;</span> <span class="s2">&quot;Empty was raised&quot;</span>
                                          <span class="o">|</span> <span class="o">_</span>      <span class="o">=&gt;</span> <span class="s2">&quot;Unknown exception&quot;</span>

<span class="c">(* err_msg 的值会是 &quot;Unknown exception&quot; </span>
<span class="c">   因为 Overflow 没有在模式中列出，因此匹配到了通配符_。 *)</span>

<span class="c">(* 我们也可以定义自己的异常 *)</span>
<span class="k">exception</span> <span class="nc">MyException</span>
<span class="k">exception</span> <span class="nc">MyExceptionWithMessage</span> <span class="k">of</span> <span class="kt">string</span>
<span class="k">exception</span> <span class="nc">SyntaxError</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">*</span> <span class="o">(</span><span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>

<span class="c">(* 文件读写！ *)</span>
<span class="c">(* 把一首诗写进文件： *)</span>
<span class="k">fun</span> <span class="n">writePoem</span><span class="o">(</span><span class="n">filename</span><span class="o">)</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">val</span> <span class="n">file</span> <span class="o">=</span> <span class="nn">TextIO</span><span class="p">.</span><span class="n">openOut</span><span class="o">(</span><span class="n">filename</span><span class="o">)</span>
        <span class="k">val</span> <span class="o">_</span> <span class="o">=</span> <span class="nn">TextIO</span><span class="p">.</span><span class="n">output</span><span class="o">(</span><span class="n">file</span><span class="o">,</span> <span class="s2">&quot;Roses are red,</span><span class="se">\n</span><span class="s2">Violets are blue.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">)</span>
        <span class="k">val</span> <span class="o">_</span> <span class="o">=</span> <span class="nn">TextIO</span><span class="p">.</span><span class="n">output</span><span class="o">(</span><span class="n">file</span><span class="o">,</span> <span class="s2">&quot;I have a gun.</span><span class="se">\n</span><span class="s2">Get in the van.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">)</span>
    <span class="k">in</span> <span class="nn">TextIO</span><span class="p">.</span><span class="n">closeOut</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
    <span class="k">end</span>

<span class="c">(* 把一首诗读进一个字符串列表： *)</span>
<span class="k">fun</span> <span class="n">readPoem</span><span class="o">(</span><span class="n">filename</span><span class="o">)</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">val</span> <span class="n">file</span> <span class="o">=</span> <span class="nn">TextIO</span><span class="p">.</span><span class="n">openIn</span> <span class="n">filename</span>
        <span class="k">val</span> <span class="n">poem</span> <span class="o">=</span> <span class="nn">TextIO</span><span class="p">.</span><span class="n">inputAll</span> <span class="n">file</span>
        <span class="k">val</span> <span class="o">_</span> <span class="o">=</span> <span class="nn">TextIO</span><span class="p">.</span><span class="n">closeIn</span> <span class="n">file</span>
    <span class="k">in</span> <span class="nn">String</span><span class="p">.</span><span class="n">tokens</span> <span class="o">(</span><span class="n">fn</span> <span class="n">c</span> <span class="o">=&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="o">#</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">)</span> <span class="n">poem</span>
    <span class="k">end</span>

<span class="k">val</span> <span class="o">_</span> <span class="o">=</span> <span class="n">writePoem</span> <span class="s2">&quot;roses.txt&quot;</span>
<span class="k">val</span> <span class="n">test_poem</span> <span class="o">=</span> <span class="n">readPoem</span> <span class="s2">&quot;roses.txt&quot;</span>  <span class="c">(* gives [ &quot;Roses are red,&quot;,</span>
<span class="c">                                                 &quot;Violets are blue.&quot;,</span>
<span class="c">                                                 &quot;I have a gun.&quot;,</span>
<span class="c">                                                 &quot;Get in the van.&quot; ] *)</span>

<span class="c">(* 我们还可以创建指向值的引用，引用可以被更新。 *)</span>
<span class="k">val</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="c">(* 使用 ref 函数创建一个引用。 *)</span>

<span class="c">(* 使用赋值运算符给引用复制 *)</span>
<span class="k">fun</span> <span class="n">set_five</span> <span class="n">reference</span> <span class="o">=</span> <span class="n">reference</span> <span class="o">:=</span> <span class="mi">5</span>

<span class="c">(* 使用解引用运算符得到引用的值 *)</span>
<span class="k">fun</span> <span class="n">equals_five</span> <span class="n">reference</span> <span class="o">=</span> <span class="o">!</span><span class="n">reference</span> <span class="o">=</span> <span class="mi">5</span>

<span class="c">(* 递归很复杂的时候，也可以使用 while 循环 *)</span>
<span class="k">fun</span> <span class="n">decrement_to_zero</span> <span class="n">r</span> <span class="o">=</span> <span class="k">if</span> <span class="o">!</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span>
                          <span class="k">then</span> <span class="n">r</span> <span class="o">:=</span> <span class="mi">0</span>
                          <span class="k">else</span> <span class="k">while</span> <span class="o">!</span><span class="n">r</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">do</span> <span class="n">r</span> <span class="o">:=</span> <span class="o">!</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span>

<span class="c">(* 这将会返回 unit （也就是什么都没有，一个0元素的元组） *)</span>

<span class="c">(* 要返回值，可以使用分号来分开表达式。 *)</span>
<span class="k">fun</span> <span class="n">decrement_ret</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="o">(</span><span class="n">x</span> <span class="o">:=</span> <span class="o">!</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">y</span><span class="o">)</span>
</pre></div>
<h2>阅读更多</h2>

<ul>
<li>安装交互式编译器 (REPL)，如：
<a href="http://www.polyml.org/">Poly/ML</a>,
<a href="http://mosml.org">Moscow ML</a>,
<a href="http://smlnj.org/">SML/NJ</a>.</li>
<li>上Coursera上的课程 <a href="https://www.coursera.org/course/proglang">Programming Languages</a>.</li>
<li>购买 Larry C. Paulson 写的 <em>ML for the Working Programmer</em> 书。</li>
<li>使用 <a href="http://stackoverflow.com/questions/tagged/sml">StackOverflow&rsquo;s sml 标签</a>.</li>
</ul>

    <hr>
    <p>有建议？或者发现什么错误？在Github上<a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">开一个issue</a>，或者发起<a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/zh-cn/standard-ml-cn.html.markdown">pull request</a>！
    </p>
    <p class="contributed">
    原著Simon Shine，并由<a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/zh-cn/standard-ml-cn.html.markdown">3个好心人</a>修改。
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://shine.eu.org/">Simon Shine</a>,
        <a href="http://lonelyproton.com/">David Pedersen</a>,
        <a href="http://www.jbaker.io/">James Baker</a>,
        <a href="http://langnostic.inaimathi.ca/">Leo Zovic</a>
    </p>

    <p>
      Translated by:
        <a href="https://github.com/zhengbuqian">Buqian Zheng</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
