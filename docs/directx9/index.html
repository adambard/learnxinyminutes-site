<!DOCTYPE html lang="en-us" xml:lang="en-us" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="en-us">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn X in Y Minutes: Scenic Programming Language Tours</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/directx9/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fdirectx9%2F&text=Learn+X+in+Y+minutes%2C+where+X%3DDirectX+9">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="/">Learn X in Y minutes</a></h1>
  <h2>Where X=DirectX 9</h2>
    <p class="filelink">
    Get the code:
    <a href="/docs/files/learndirectx9.cpp">learndirectx9.cpp</a>
    </p>
  <div id="doc">
    <p><strong>Microsoft DirectX</strong> is a collection of application programming interfaces (APIs) for handling tasks related to
multimedia, especially game programming and video, on Microsoft platforms. Originally, the names of these APIs
all began with Direct, such as Direct3D, DirectDraw, DirectMusic, DirectPlay, DirectSound, and so forth. [&hellip;]
Direct3D (the 3D graphics API within DirectX) is widely used in the development of video games for Microsoft
Windows and the Xbox line of consoles.<sup>[1]</sup></p>

<p>In this tutorial we will be focusing on DirectX 9, which is not as low-level as it&rsquo;s successors, which are aimed at programmers very familiar with how graphics hardware works. It makes a great starting point for learning Direct3D. In this tutorial I will be using the Win32-API for window handling and the DirectX 2010 SDK.</p>

<h2>Window creation</h2>
<div class="highlight"><pre class="highlight cpp"><code><span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
</span>
<span class="kt">bool</span> <span class="n">_running</span><span class="p">{</span> <span class="nb">false</span> <span class="p">};</span>

<span class="n">LRESULT</span> <span class="n">CALLBACK</span> <span class="n">WndProc</span><span class="p">(</span><span class="n">HWND</span> <span class="n">hWnd</span><span class="p">,</span> <span class="n">UINT</span> <span class="n">msg</span><span class="p">,</span> <span class="n">WPARAM</span> <span class="n">wParam</span><span class="p">,</span> <span class="n">LPARAM</span> <span class="n">lParam</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Handle incoming message.</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Set running to false if the user tries to close the window.</span>
        <span class="k">case</span> <span class="n">WM_DESTROY</span><span class="p">:</span>
            <span class="n">_running</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="n">PostQuitMessage</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Return the handled event.</span>
    <span class="k">return</span> <span class="n">DefWindowProc</span><span class="p">(</span><span class="n">hWnd</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">wParam</span><span class="p">,</span> <span class="n">lParam</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">WINAPI</span> <span class="n">WinMain</span><span class="p">(</span><span class="n">HINSTANCE</span> <span class="n">hInstance</span><span class="p">,</span> <span class="n">HINSTANCE</span> <span class="n">hPrevInstance</span><span class="p">,</span>
                   <span class="n">LPSTR</span> <span class="n">lpCmdLine</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nCmdShow</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Set window properties we want to use.</span>
    <span class="n">WNDCLASSEX</span> <span class="n">wndEx</span><span class="p">{</span> <span class="p">};</span>
    <span class="n">wndEx</span><span class="p">.</span><span class="n">cbSize</span>        <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">WNDCLASSEX</span><span class="p">);</span>        <span class="c1">// structure size</span>
    <span class="n">wndEx</span><span class="p">.</span><span class="n">style</span>         <span class="o">=</span> <span class="n">CS_VREDRAW</span> <span class="o">|</span> <span class="n">CS_HREDRAW</span><span class="p">;</span>   <span class="c1">// class styles</span>
    <span class="n">wndEx</span><span class="p">.</span><span class="n">lpfnWndProc</span>   <span class="o">=</span> <span class="n">WndProc</span><span class="p">;</span>                   <span class="c1">// window procedure</span>
    <span class="n">wndEx</span><span class="p">.</span><span class="n">cbClsExtra</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                         <span class="c1">// extra memory (struct)</span>
    <span class="n">wndEx</span><span class="p">.</span><span class="n">cbWndExtra</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                         <span class="c1">// extra memory (window)</span>
    <span class="n">wndEx</span><span class="p">.</span><span class="n">hInstance</span>     <span class="o">=</span> <span class="n">hInstance</span><span class="p">;</span>                 <span class="c1">// module instance</span>
    <span class="n">wndEx</span><span class="p">.</span><span class="n">hIcon</span>         <span class="o">=</span> <span class="n">LoadIcon</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">,</span> <span class="n">IDI_APPLICATION</span><span class="p">);</span> <span class="c1">// icon</span>
    <span class="n">wndEx</span><span class="p">.</span><span class="n">hCursor</span>       <span class="o">=</span> <span class="n">LoadCursor</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">,</span> <span class="n">IDC_ARROW</span><span class="p">);</span>     <span class="c1">// cursor</span>
    <span class="n">wndEx</span><span class="p">.</span><span class="n">hbrBackground</span> <span class="o">=</span> <span class="p">(</span><span class="n">HBRUSH</span><span class="p">)</span> <span class="n">COLOR_WINDOW</span><span class="p">;</span>     <span class="c1">// background color</span>
    <span class="n">wndEx</span><span class="p">.</span><span class="n">lpszMenuName</span>  <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>                   <span class="c1">// menu name</span>
    <span class="n">wndEx</span><span class="p">.</span><span class="n">lpszClassName</span> <span class="o">=</span> <span class="s">"DirectXClass"</span><span class="p">;</span>            <span class="c1">// register class name</span>
    <span class="n">wndEx</span><span class="p">.</span><span class="n">hIconSm</span>       <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>                   <span class="c1">// small icon (taskbar)</span>
    <span class="c1">// Register created class for window creation.</span>
    <span class="n">RegisterClassEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wndEx</span><span class="p">);</span>
    <span class="c1">// Create a new window handle.</span>
    <span class="n">HWND</span> <span class="n">hWnd</span><span class="p">{</span> <span class="nb">nullptr</span> <span class="p">};</span>
    <span class="c1">// Create a new window handle using the registered class.</span>
    <span class="n">hWnd</span> <span class="o">=</span> <span class="n">CreateWindow</span><span class="p">(</span><span class="s">"DirectXClass"</span><span class="p">,</span>      <span class="c1">// registered class</span>
                        <span class="s">"directx window"</span><span class="p">,</span>    <span class="c1">// window title</span>
                        <span class="n">WS_OVERLAPPEDWINDOW</span><span class="p">,</span> <span class="c1">// window style</span>
                        <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span>              <span class="c1">// x, y (position)</span>
                        <span class="mi">1024</span><span class="p">,</span> <span class="mi">768</span><span class="p">,</span>           <span class="c1">// width, height (size)</span>
                        <span class="nb">nullptr</span><span class="p">,</span>             <span class="c1">// parent window</span>
                        <span class="nb">nullptr</span><span class="p">,</span>             <span class="c1">// menu</span>
                        <span class="n">hInstance</span><span class="p">,</span>           <span class="c1">// module instance</span>
                        <span class="nb">nullptr</span><span class="p">);</span>            <span class="c1">// struct for infos</span>
    <span class="c1">// Check if a window handle has been created.</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hWnd</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>   
    <span class="c1">// Show and update the new window.</span>
    <span class="n">ShowWindow</span><span class="p">(</span><span class="n">hWnd</span><span class="p">,</span> <span class="n">nCmdShow</span><span class="p">);</span>
    <span class="n">UpdateWindow</span><span class="p">(</span><span class="n">hWnd</span><span class="p">);</span>
    <span class="c1">// Start the game loop and send incoming messages to the window procedure.</span>
    <span class="n">_running</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">MSG</span> <span class="n">msg</span><span class="p">{</span> <span class="p">};</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">_running</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">PeekMessage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="n">hWnd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PM_REMOVE</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">TranslateMessage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>
            <span class="n">DispatchMessage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>  
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>This should create a window, that can the moved, resized and closed.</p>

<h2>Direct3D initialization</h2>
<div class="highlight"><pre class="highlight cpp"><code><span class="c1">// Includes DirectX 9 structures and functions.</span>
<span class="c1">// Remember to link "d3d9.lib" and "d3dx9.lib".</span>
<span class="c1">// For "d3dx9.lib" the DirectX SDK (June 2010) is needed.</span>
<span class="c1">// Don't forget to set your subsystem to Windows.</span>
<span class="cp">#include</span> <span class="cpf">&lt;d3d9.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;d3dx9.h&gt;</span><span class="cp">
</span><span class="c1">// Includes the ComPtr, a smart pointer automatically releasing COM objects.</span>
<span class="cp">#include</span> <span class="cpf">&lt;wrl.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">Microsoft</span><span class="o">::</span><span class="n">WRL</span><span class="p">;</span>
<span class="c1">// Next we define some Direct3D9 interface structs we need.</span>
<span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">IDirect3D9</span><span class="o">&gt;</span> <span class="n">_d3d</span><span class="p">{</span> <span class="p">};</span>
<span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">IDirect3DDevice9</span><span class="o">&gt;</span> <span class="n">_device</span><span class="p">{</span> <span class="p">};</span>
</code></pre></div>
<p>With all interfaces declared we can now initialize Direct3D.</p>
<div class="highlight"><pre class="highlight cpp"><code><span class="kt">bool</span> <span class="nf">InitD3D</span><span class="p">(</span><span class="n">HWND</span> <span class="n">hWnd</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Store the size of the window rectangle.</span>
    <span class="n">RECT</span> <span class="n">clientRect</span><span class="p">{</span> <span class="p">};</span>
    <span class="n">GetClientRect</span><span class="p">(</span><span class="n">hWnd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clientRect</span><span class="p">);</span>
    <span class="c1">// Initialize Direct3D</span>
    <span class="n">_d3d</span> <span class="o">=</span> <span class="n">Direct3DCreate9</span><span class="p">(</span><span class="n">D3D_SDK_VERSION</span><span class="p">);</span>
    <span class="c1">// Get the display mode which format will be the window format.</span>
    <span class="n">D3DDISPLAYMODE</span> <span class="n">displayMode</span><span class="p">{</span> <span class="p">};</span>
    <span class="n">_d3d</span><span class="o">-&gt;</span><span class="n">GetAdapterDisplayMode</span><span class="p">(</span><span class="n">D3DADAPTER_DEFAULT</span><span class="p">,</span> <span class="c1">// use default graphics card</span>
                                <span class="o">&amp;</span><span class="n">displayMode</span><span class="p">);</span>      <span class="c1">// display mode pointer</span>
    <span class="c1">// Next we have to set some presentation parameters.</span>
    <span class="n">D3DPRESENT_PARAMETERS</span> <span class="n">pp</span><span class="p">{</span> <span class="p">};</span>
    <span class="n">pp</span><span class="p">.</span><span class="n">BackBufferWidth</span> <span class="o">=</span> <span class="n">clientRect</span><span class="p">.</span><span class="n">right</span><span class="p">;</span>    <span class="c1">// width is window width</span>
    <span class="n">pp</span><span class="p">.</span><span class="n">BackBufferHeight</span> <span class="o">=</span> <span class="n">clientRect</span><span class="p">.</span><span class="n">bottom</span><span class="p">;</span>  <span class="c1">// height is window height</span>
    <span class="n">pp</span><span class="p">.</span><span class="n">BackBufferFormat</span> <span class="o">=</span> <span class="n">displayMode</span><span class="p">.</span><span class="n">Format</span><span class="p">;</span> <span class="c1">// use adapter format</span>
    <span class="n">pp</span><span class="p">.</span><span class="n">BackBufferCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>                   <span class="c1">// 1 back buffer (default)</span>
    <span class="n">pp</span><span class="p">.</span><span class="n">SwapEffect</span> <span class="o">=</span> <span class="n">D3DSWAPEFFECT_DISCARD</span><span class="p">;</span>    <span class="c1">// discard after presentation</span>
    <span class="n">pp</span><span class="p">.</span><span class="n">hDeviceWindow</span> <span class="o">=</span> <span class="n">hWnd</span><span class="p">;</span>                  <span class="c1">// associated window handle</span>
    <span class="n">pp</span><span class="p">.</span><span class="n">Windowed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>                       <span class="c1">// display in window mode</span>
    <span class="n">pp</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                             <span class="c1">// no special flags</span>
    <span class="c1">// Variable to store results of methods to check if everything succeeded.</span>
    <span class="n">HRESULT</span> <span class="n">result</span><span class="p">{</span> <span class="p">};</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_d3d</span><span class="o">-&gt;</span><span class="n">CreateDevice</span><span class="p">(</span><span class="n">D3DADAPTER_DEFAULT</span><span class="p">,</span> <span class="c1">// use default graphics card</span>
                                <span class="n">D3DDEVTYPE_HAL</span><span class="p">,</span>     <span class="c1">// use hardware acceleration</span>
                                <span class="n">hWnd</span><span class="p">,</span>               <span class="c1">// the window handle</span>
                                <span class="n">D3DCREATE_HARDWARE_VERTEXPROCESSING</span><span class="p">,</span>
                                    <span class="c1">// vertices are processed by the hardware</span>
                                <span class="o">&amp;</span><span class="n">pp</span><span class="p">,</span>       <span class="c1">// the present parameters</span>
                                <span class="o">&amp;</span><span class="n">_device</span><span class="p">);</span> <span class="c1">// struct to store the device</span>
    <span class="c1">// Return false if the device creation failed.</span>
    <span class="c1">// It is helpful to set breakpoints at the return line.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="c1">// Create a viewport which hold information about which region to draw to.</span>
    <span class="n">D3DVIEWPORT9</span> <span class="n">viewport</span><span class="p">{</span> <span class="p">};</span>
    <span class="n">viewport</span><span class="p">.</span><span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>         <span class="c1">// start at top left corner</span>
    <span class="n">viewport</span><span class="p">.</span><span class="n">Y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>         <span class="c1">// ..</span>
    <span class="n">viewport</span><span class="p">.</span><span class="n">Width</span> <span class="o">=</span> <span class="n">clientRect</span><span class="p">.</span><span class="n">right</span><span class="p">;</span>   <span class="c1">// use the entire window</span>
    <span class="n">viewport</span><span class="p">.</span><span class="n">Height</span> <span class="o">=</span> <span class="n">clientRect</span><span class="p">.</span><span class="n">bottom</span><span class="p">;</span> <span class="c1">// ..</span>
    <span class="n">viewport</span><span class="p">.</span><span class="n">MinZ</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>   <span class="c1">// minimum view distance</span>
    <span class="n">viewport</span><span class="p">.</span><span class="n">MaxZ</span> <span class="o">=</span> <span class="mf">100.0</span><span class="n">f</span><span class="p">;</span> <span class="c1">// maximum view distance</span>
    <span class="c1">// Apply the created viewport.</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_device</span><span class="o">-&gt;</span><span class="n">SetViewport</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viewport</span><span class="p">);</span>
    <span class="c1">// Always check if something failed.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="c1">// Everything was successful, return true.</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// ...</span>
<span class="c1">// Back in our WinMain function we call our initialization function.</span>
<span class="c1">// ...</span>
<span class="c1">// Check if Direct3D initialization succeeded, else exit the application.</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">InitD3D</span><span class="p">(</span><span class="n">hWnd</span><span class="p">))</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="n">MSG</span> <span class="n">msg</span><span class="p">{</span> <span class="p">};</span>
<span class="k">while</span> <span class="p">(</span><span class="n">_running</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">PeekMessage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="n">hWnd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PM_REMOVE</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">TranslateMessage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>
        <span class="n">DispatchMessage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// Clear to render target to a specified color.</span>
    <span class="n">_device</span><span class="o">-&gt;</span><span class="n">Clear</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>               <span class="c1">// number of rects to clear</span>
                   <span class="nb">nullptr</span><span class="p">,</span>         <span class="c1">// indicates to clear the entire window</span>
                   <span class="n">D3DCLEAR_TARGET</span><span class="p">,</span> <span class="c1">// clear all render targets</span>
                   <span class="n">D3DXCOLOR</span><span class="p">{</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span> <span class="p">},</span> <span class="c1">// color (red)</span>
                   <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>            <span class="c1">// depth buffer clear value</span>
                   <span class="mi">0</span><span class="p">);</span>              <span class="c1">// stencil buffer clear value</span>
    <span class="c1">// ...</span>
    <span class="c1">// Drawing operations go here.</span>
    <span class="c1">// ...</span>
    <span class="c1">// Flip the front- and backbuffer.</span>
    <span class="n">_device</span><span class="o">-&gt;</span><span class="n">Present</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">,</span>  <span class="c1">// no source rectangle</span>
                     <span class="nb">nullptr</span><span class="p">,</span>  <span class="c1">// no destination rectangle</span>
                     <span class="nb">nullptr</span><span class="p">,</span>  <span class="c1">// don't change the current window handle</span>
                     <span class="nb">nullptr</span><span class="p">);</span> <span class="c1">// pretty much always nullptr</span>
<span class="p">}</span>
<span class="c1">// ...</span>
</code></pre></div>
<p>Now the window should be displayed in a bright red color.</p>

<h2>Vertex Buffer</h2>

<p>Let&rsquo;s create a vertex buffer to store the vertices for our triangle</p>
<div class="highlight"><pre class="highlight cpp"><code><span class="c1">// At the top of the file we need to add a include.</span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="c1">// First we declare a new ComPtr holding a vertex buffer.</span>
<span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">IDirect3DVertexBuffer9</span><span class="o">&gt;</span> <span class="n">_vertexBuffer</span><span class="p">{</span> <span class="p">};</span>
<span class="c1">// Lets define a function to calculate the byte size of a std::vector</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">GetByteSize</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">// Define "flexible vertex format" describing the content of our vertex struct.</span>
<span class="c1">// Use the defined color as diffuse color.</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">VertexStructFVF</span> <span class="o">=</span> <span class="n">D3DFVF_XYZ</span> <span class="o">|</span> <span class="n">D3DFVF_DIFFUSE</span><span class="p">;</span>
<span class="c1">// Define a struct representing the vertex data the buffer will hold.</span>
<span class="k">struct</span> <span class="nc">VStruct</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span>   <span class="c1">// store the 3D position</span>
    <span class="n">D3DCOLOR</span> <span class="n">color</span><span class="p">;</span>  <span class="c1">// store a color</span>
<span class="p">};</span>
<span class="c1">// Declare a new function to create a vertex buffer.</span>
<span class="n">IDirect3DVertexBuffer9</span><span class="o">*</span> <span class="n">CreateBuffer</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VStruct</span><span class="o">&gt;&amp;</span> <span class="n">vertices</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Declare the buffer to be returned.</span>
    <span class="n">IDirect3DVertexBuffer9</span><span class="o">*</span> <span class="n">buffer</span><span class="p">{</span> <span class="p">};</span>
    <span class="n">HRESULT</span> <span class="n">result</span><span class="p">{</span> <span class="p">};</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_device</span><span class="o">-&gt;</span><span class="n">CreateVertexBuffer</span><span class="p">(</span>
                 <span class="n">GetByteSize</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="c1">// vector size in bytes</span>
                 <span class="mi">0</span><span class="p">,</span>                     <span class="c1">// data usage</span>
                 <span class="n">VertexStructFVF</span><span class="p">,</span>       <span class="c1">// FVF of the struct</span>
                 <span class="n">D3DPOOL_DEFAULT</span><span class="p">,</span>       <span class="c1">// use default pool for the buffer</span>
                 <span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span>               <span class="c1">// receiving buffer</span>
                 <span class="nb">nullptr</span><span class="p">);</span>              <span class="c1">// special shared handle</span>
    <span class="c1">// Check if buffer was created successfully.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="c1">// Create a data pointer for copying the vertex data</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">{</span> <span class="p">};</span>
    <span class="c1">// Lock the buffer to get a buffer for data storage.</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">Lock</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>                     <span class="c1">// byte offset</span>
                          <span class="n">GetByteSize</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="c1">// size to lock</span>
                          <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span>                 <span class="c1">// receiving data pointer</span>
                          <span class="mi">0</span><span class="p">);</span>                    <span class="c1">// special lock flags</span>
    <span class="c1">// Check if buffer was locked successfully.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="c1">// Copy the vertex data using C standard libraries memcpy.</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">vertices</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">GetByteSize</span><span class="p">(</span><span class="n">vertices</span><span class="p">));</span>
    <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">Unlock</span><span class="p">();</span>
    <span class="c1">// Set the FVF Direct3D uses for rendering.</span>
    <span class="n">_device</span><span class="o">-&gt;</span><span class="n">SetFVF</span><span class="p">(</span><span class="n">VertexStructFVF</span><span class="p">);</span>
    <span class="c1">// If everything was successful return the filled vertex buffer.</span>
    <span class="k">return</span> <span class="n">buffer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>In our <strong>WinMain</strong> we can now call the new function after the Direct3D initialization.</p>
<div class="highlight"><pre class="highlight cpp"><code><span class="c1">// ...</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">InitD3D</span><span class="p">(</span><span class="n">hWnd</span><span class="p">))</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="c1">// Define the vertices we need to draw a triangle.</span>
<span class="c1">// Values are declared in a clockwise direction else Direct3D would cull them.</span>
<span class="c1">// If you want to disable culling just call:</span>
<span class="c1">// _device-&gt;SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VStruct</span><span class="o">&gt;</span> <span class="n">vertices</span> <span class="p">{</span>
    <span class="c1">// Bottom left</span>
    <span class="n">VStruct</span><span class="p">{</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="n">D3DXCOLOR</span><span class="p">{</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span> <span class="p">}</span> <span class="p">},</span>
    <span class="c1">// Top left</span>
    <span class="n">VStruct</span><span class="p">{</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span>  <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="n">D3DXCOLOR</span><span class="p">{</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span> <span class="p">}</span> <span class="p">},</span>
    <span class="c1">// Top right</span>
    <span class="n">VStruct</span><span class="p">{</span>  <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span>  <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="n">D3DXCOLOR</span><span class="p">{</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span> <span class="p">}</span> <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// Try to create the vertex buffer else exit the application.</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">_vertexBuffer</span> <span class="o">=</span> <span class="n">CreateBuffer</span><span class="p">(</span><span class="n">vertices</span><span class="p">)))</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="c1">// ...</span>
</code></pre></div>
<h2>Transformations</h2>

<p>Before we can use the vertex buffer to draw our primitives, we first need to set up the matrices.</p>
<div class="highlight"><pre class="highlight cpp"><code><span class="c1">// Lets create a new functions for the matrix transformations.</span>
<span class="kt">bool</span> <span class="nf">SetupTransform</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Create a view matrix that transforms world space to</span>
    <span class="c1">// view space.</span>
    <span class="n">D3DXMATRIX</span> <span class="n">view</span><span class="p">{</span> <span class="p">};</span>
    <span class="c1">// Use a left-handed coordinate system.</span>
    <span class="n">D3DXMatrixLookAtLH</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="n">view</span><span class="p">,</span>                              <span class="c1">// receiving matrix</span>
        <span class="o">&amp;</span><span class="n">D3DXVECTOR3</span><span class="p">{</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">20.0</span><span class="n">f</span> <span class="p">},</span> <span class="c1">// "camera" position</span>
        <span class="o">&amp;</span><span class="n">D3DXVECTOR3</span><span class="p">{</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span> <span class="p">},</span>   <span class="c1">// position where to look at</span>
        <span class="o">&amp;</span><span class="n">D3DXVECTOR3</span><span class="p">{</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span> <span class="p">});</span>  <span class="c1">// positive y-axis is up</span>
    <span class="n">HRESULT</span> <span class="n">result</span><span class="p">{</span> <span class="p">};</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_device</span><span class="o">-&gt;</span><span class="n">SetTransform</span><span class="p">(</span><span class="n">D3DTS_VIEW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">view</span><span class="p">);</span> <span class="c1">// apply the view matrix</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="c1">// Create a projection matrix that defines the view frustrum.</span>
    <span class="c1">// It transforms the view space to projection space.</span>
    <span class="n">D3DXMATRIX</span> <span class="n">projection</span><span class="p">{</span> <span class="p">};</span>
    <span class="c1">// Create a perspective projection using a left-handed coordinate system.</span>
    <span class="n">D3DXMatrixPerspectiveFovLH</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="n">projection</span><span class="p">,</span>         <span class="c1">// receiving matrix</span>
        <span class="n">D3DXToRadian</span><span class="p">(</span><span class="mf">60.0</span><span class="n">f</span><span class="p">),</span> <span class="c1">// field of view in radians</span>
        <span class="mf">1024.0</span><span class="n">f</span> <span class="o">/</span> <span class="mf">768.0</span><span class="n">f</span><span class="p">,</span>    <span class="c1">// aspect ratio (width / height)</span>
        <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>                <span class="c1">// minimum view distance</span>
        <span class="mf">100.0</span><span class="n">f</span><span class="p">);</span>             <span class="c1">// maximum view distance</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_device</span><span class="o">-&gt;</span><span class="n">SetTransform</span><span class="p">(</span><span class="n">D3DTS_PROJECTION</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">projection</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="c1">// Disable lighting for now so we can see what we want to render.</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_device</span><span class="o">-&gt;</span><span class="n">SetRenderState</span><span class="p">(</span><span class="n">D3DRS_LIGHTING</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="c1">// View and projection matrix are successfully applied, return true.</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// ...</span>
<span class="c1">// Back in the WinMain function we can now call the transformation function.</span>
<span class="c1">// ...</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">_vertexBuffer</span> <span class="o">=</span> <span class="n">CreateVertexBuffer</span><span class="p">(</span><span class="n">vertices</span><span class="p">)))</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="c1">// Call the transformation setup function.</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SetupTransform</span><span class="p">())</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="c1">// ...</span>
</code></pre></div>
<h2>Rendering</h2>

<p>Now that everything is setup we can start drawing our first 2D triangle in 3D space.</p>
<div class="highlight"><pre class="highlight cpp"><code><span class="c1">// ...</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SetupTransform</span><span class="p">())</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="c1">// First we have to bind our vertex buffer to the data stream.</span>
<span class="n">HRESULT</span> <span class="n">result</span><span class="p">{</span> <span class="p">};</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">_device</span><span class="o">-&gt;</span><span class="n">SetStreamSource</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>                   <span class="c1">// use the default stream</span>
                                  <span class="n">_vertexBuffer</span><span class="p">.</span><span class="n">Get</span><span class="p">(),</span> <span class="c1">// pass the vertex buffer</span>
                                  <span class="mi">0</span><span class="p">,</span>                   <span class="c1">// no offset</span>
                                  <span class="k">sizeof</span><span class="p">(</span><span class="n">VStruct</span><span class="p">));</span>    <span class="c1">// size of vertex struct</span>
<span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="c1">// Create a world transformation matrix and set it to an identity matrix.</span>
<span class="n">D3DXMATRIX</span> <span class="n">world</span><span class="p">{</span> <span class="p">};</span>
<span class="n">D3DXMatrixIdentity</span><span class="p">(</span><span class="o">&amp;</span><span class="n">world</span><span class="p">);</span>
<span class="c1">// Create a scalation matrix scaling our primitive by 10 in the x,</span>
<span class="c1">// 10 in the y and keeping the z direction.</span>
<span class="n">D3DXMATRIX</span> <span class="n">scaling</span><span class="p">{</span> <span class="p">};</span>
<span class="n">D3DXMatrixScaling</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scaling</span><span class="p">,</span> <span class="c1">// matrix to scale</span>
                  <span class="mi">10</span><span class="p">,</span>       <span class="c1">// x scaling</span>
                  <span class="mi">10</span><span class="p">,</span>       <span class="c1">// y scaling</span>
                  <span class="mi">1</span><span class="p">);</span>       <span class="c1">// z scaling</span>
<span class="c1">// Create a rotation matrix storing the current rotation of our primitive.</span>
<span class="c1">// We set the current rotation matrix to an identity matrix for now.</span>
<span class="n">D3DXMATRIX</span> <span class="n">rotation</span><span class="p">{</span> <span class="p">};</span>
<span class="n">D3DXMatrixIdentity</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rotation</span><span class="p">);</span>
<span class="c1">// Now we multiply the scalation and rotation matrix and store the result</span>
<span class="c1">// in the world matrix.</span>
<span class="n">D3DXMatrixMultiply</span><span class="p">(</span><span class="o">&amp;</span><span class="n">world</span><span class="p">,</span>     <span class="c1">// destination matrix</span>
                   <span class="o">&amp;</span><span class="n">scaling</span><span class="p">,</span>   <span class="c1">// matrix 1</span>
                   <span class="o">&amp;</span><span class="n">rotation</span><span class="p">);</span> <span class="c1">// matrix 2</span>
<span class="c1">// Apply the current world matrix.</span>
<span class="n">_device</span><span class="o">-&gt;</span><span class="n">SetTransform</span><span class="p">(</span><span class="n">D3DTS_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">world</span><span class="p">);</span>
<span class="c1">// Disable culling so we can see the back of our primitive when it rotates.</span>
<span class="n">_device</span><span class="o">-&gt;</span><span class="n">SetRenderState</span><span class="p">(</span><span class="n">D3DRS_CULLMODE</span><span class="p">,</span> <span class="n">D3DCULL_NONE</span><span class="p">);</span>
<span class="c1">// The default cullmode is D3DCULL_CW.</span>
<span class="c1">// After we used our the rotation matrix for multiplication we can set it</span>
<span class="c1">// to rotate a small amount.</span>
<span class="c1">// D3DXToRadian() function converts degree to radians.</span>
<span class="n">D3DXMatrixRotationY</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rotation</span><span class="p">,</span>           <span class="c1">// matrix to rotate</span>
                    <span class="n">D3DXToRadian</span><span class="p">(</span><span class="mf">0.5</span><span class="n">f</span><span class="p">));</span> <span class="c1">// rotation angle in radians</span>

<span class="n">MSG</span> <span class="n">msg</span><span class="p">{</span> <span class="p">};</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">_running</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
        <span class="n">_device</span><span class="o">-&gt;</span><span class="n">Clear</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="n">D3DCLEAR_TARGET</span><span class="p">,</span>
                       <span class="n">D3DXCOLOR</span><span class="p">{</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span> <span class="p">},</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="c1">// With everything setup we can call the draw function.</span>
        <span class="n">_device</span><span class="o">-&gt;</span><span class="n">BeginScene</span><span class="p">();</span>
        <span class="n">_device</span><span class="o">-&gt;</span><span class="n">DrawPrimitive</span><span class="p">(</span><span class="n">D3DPT_TRIANGLELIST</span><span class="p">,</span> <span class="c1">// primitive type</span>
                               <span class="mi">0</span><span class="p">,</span>                  <span class="c1">// start vertex</span>
                               <span class="mi">1</span><span class="p">);</span>                 <span class="c1">// primitive count</span>
        <span class="n">_device</span><span class="o">-&gt;</span><span class="n">EndScene</span><span class="p">();</span>

        <span class="n">_device</span><span class="o">-&gt;</span><span class="n">Present</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span>
        <span class="c1">// We can keep multiplying the world matrix with our rotation matrix</span>
        <span class="c1">// to add it's rotation to the world matrix.</span>
        <span class="n">D3DXMatrixMultiply</span><span class="p">(</span><span class="o">&amp;</span><span class="n">world</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">world</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rotation</span><span class="p">);</span>
        <span class="c1">// Update the modified world matrix.</span>
        <span class="n">_device</span><span class="o">-&gt;</span><span class="n">SetTransform</span><span class="p">(</span><span class="n">D3DTS_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">world</span><span class="p">);</span>
    <span class="c1">// ...</span>
</code></pre></div>
<p>You should now be viewing a 10x10 units colored triangle from 20 units away, rotating around its origin.<br>
You can find the complete working code here: <a href="https://pastebin.com/YkSF2rkk">DirectX - 1</a></p>

<h2>Indexing</h2>

<p>To make it easier to draw primitives sharing a lot of vertices we can use indexing, so we only have to declare the unique vertices and put the order they are called in another array.</p>
<div class="highlight"><pre class="highlight cpp"><code><span class="c1">// First we declare a new ComPtr for our index buffer.</span>
<span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">IDirect3DIndexBuffer9</span><span class="o">&gt;</span> <span class="n">_indexBuffer</span><span class="p">{</span> <span class="p">};</span>
<span class="c1">// ...</span>
<span class="c1">// Declare a function creating a index buffer from a std::vector</span>
<span class="n">IDirect3DIndexBuffer9</span><span class="o">*</span> <span class="n">CreateIBuffer</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">indices</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">IDirect3DIndexBuffer9</span><span class="o">*</span> <span class="n">buffer</span><span class="p">{</span> <span class="p">};</span>
    <span class="n">HRESULT</span> <span class="n">result</span><span class="p">{</span> <span class="p">};</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_device</span><span class="o">-&gt;</span><span class="n">CreateIndexBuffer</span><span class="p">(</span>
                 <span class="n">GetByteSize</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="c1">// vector size in bytes</span>
                 <span class="mi">0</span><span class="p">,</span>                    <span class="c1">// data usage </span>
                 <span class="n">D3DFMT_INDEX32</span><span class="p">,</span>       <span class="c1">// format is 32 bit int</span>
                 <span class="n">D3DPOOL_DEFAULT</span><span class="p">,</span>      <span class="c1">// default pool</span>
                 <span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span>              <span class="c1">// receiving buffer</span>
                 <span class="nb">nullptr</span><span class="p">);</span>             <span class="c1">// special shared handle</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="c1">// Create a data pointer pointing to the buffer data.</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">{</span> <span class="p">};</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">Lock</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>                    <span class="c1">// byte offset</span>
                          <span class="n">GetByteSize</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="c1">// byte size</span>
                          <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span>                <span class="c1">// receiving data pointer</span>
                          <span class="mi">0</span><span class="p">);</span>                   <span class="c1">// special lock flag</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="c1">// Copy the index data and unlock after copying.</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">indices</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">GetByteSize</span><span class="p">(</span><span class="n">indices</span><span class="p">));</span>
    <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">Unlock</span><span class="p">();</span>
    <span class="c1">// Return the filled index buffer.</span>
    <span class="k">return</span> <span class="n">buffer</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// ...</span>
<span class="c1">// In our WinMain we can now change the vertex data and create new index data.</span>
<span class="c1">// ...</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VStruct</span><span class="o">&gt;</span> <span class="n">vertices</span> <span class="p">{</span>
    <span class="n">VStruct</span><span class="p">{</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="n">D3DXCOLOR</span><span class="p">{</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span> <span class="p">}</span> <span class="p">},</span>
    <span class="n">VStruct</span><span class="p">{</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span>  <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="n">D3DXCOLOR</span><span class="p">{</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span> <span class="p">}</span> <span class="p">},</span>
    <span class="n">VStruct</span><span class="p">{</span>  <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span>  <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="n">D3DXCOLOR</span><span class="p">{</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span> <span class="p">}</span> <span class="p">},</span>
    <span class="c1">// Add a vertex for the bottom right.</span>
    <span class="n">VStruct</span><span class="p">{</span>  <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="n">D3DXCOLOR</span><span class="p">{</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span> <span class="p">}</span> <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// Declare the index data, here we build a rectangle from two triangles.</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">indices</span> <span class="p">{</span>
    <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="c1">// the first triangle (b,left -&gt; t,left -&gt; t,right)</span>
    <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>  <span class="c1">// the second triangle (b,left -&gt; t,right -&gt; b,right)</span>
<span class="p">};</span>
<span class="c1">// ...</span>
<span class="c1">// Now we call the "CreateIBuffer" function to create a index buffer.</span>
<span class="c1">// ...</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">_indexBuffer</span> <span class="o">=</span> <span class="n">CreateIBuffer</span><span class="p">(</span><span class="n">indices</span><span class="p">)))</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="c1">// ...</span>
<span class="c1">// After binding the vertex buffer we have to bind the index buffer to</span>
<span class="c1">// use indexed rendering.</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">_device</span><span class="o">-&gt;</span><span class="n">SetStreamSource</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_vertexBuffer</span><span class="p">.</span><span class="n">Get</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">VStruct</span><span class="p">));</span>
<span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="c1">// Bind the index data to the default data stream.</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">_device</span><span class="o">-&gt;</span><span class="n">SetIndices</span><span class="p">(</span><span class="n">_indexBuffer</span><span class="p">.</span><span class="n">Get</span><span class="p">())</span>
<span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="c1">// ...</span>
<span class="c1">// Now we replace the "DrawPrimitive" function with an indexed version.</span>
<span class="n">_device</span><span class="o">-&gt;</span><span class="n">DrawIndexedPrimitive</span><span class="p">(</span><span class="n">D3DPT_TRIANGLELIST</span><span class="p">,</span> <span class="c1">// primitive type</span>
                              <span class="mi">0</span><span class="p">,</span>                  <span class="c1">// base vertex index</span>
                              <span class="mi">0</span><span class="p">,</span>                  <span class="c1">// minimum index</span>
                              <span class="n">indices</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span>     <span class="c1">// amount of vertices</span>
                              <span class="mi">0</span><span class="p">,</span>                  <span class="c1">// start in index buffer</span>
                              <span class="mi">2</span><span class="p">);</span>                 <span class="c1">// primitive count</span>
<span class="c1">// ...</span>
</code></pre></div>
<p>Now you should see a colored rectangle made up of 2 triangles. If you set the primitive count in the &ldquo;DrawIndexedPrimitive&rdquo; method to 1 only the first triangle should be rendered and if you set the start of the index buffer to 3 and the primitive count to 1 only the second triangle should be rendered.<br>
You can find the complete working code here: <a href="https://pastebin.com/yWBPWPRG">DirectX - 2</a></p>

<h2>Vertex declaration</h2>

<p>Instead of using the old &ldquo;flexible vertex format&rdquo; we should use vertex declarations instead, as the FVF declarations get converted to vertex declarations internally anyway.</p>
<div class="highlight"><pre class="highlight cpp"><code><span class="c1">// First we have to REMOVE the following lines:</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">VertexStructFVF</span> <span class="o">=</span> <span class="n">D3DFVF_XYZ</span> <span class="o">|</span> <span class="n">D3DFVF_DIFFUSE</span><span class="p">;</span>
<span class="c1">// and</span>
<span class="n">_device</span><span class="o">-&gt;</span><span class="n">SetFVF</span><span class="p">(</span><span class="n">VertexStructFVF</span><span class="p">);</span>
<span class="c1">// ...</span>
<span class="c1">// We also have to change the vertex buffer creation FVF-flag.</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">_device</span><span class="o">-&gt;</span><span class="n">CreateVertexBuffer</span><span class="p">(</span>
                      <span class="n">GetByteSize</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span>
                      <span class="mi">0</span><span class="p">,</span>
                      <span class="mi">0</span><span class="p">,</span>        <span class="c1">// &lt;- 0 indicates we use vertex declarations</span>
                      <span class="n">D3DPOOL_DEFAULT</span><span class="p">,</span>
                      <span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span>
                      <span class="nb">nullptr</span><span class="p">);</span> 
<span class="c1">// Next we have to declare a new ComPtr.</span>
<span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">IDirect3DVertexDeclaration9</span><span class="o">&gt;</span> <span class="n">_vertexDecl</span><span class="p">{</span> <span class="p">};</span>
<span class="c1">// ...</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">_device</span><span class="o">-&gt;</span><span class="n">SetIndices</span><span class="p">(</span><span class="n">_indexBuffer</span><span class="p">.</span><span class="n">Get</span><span class="p">());</span>
<span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="c1">// Now we have to declare and apply the vertex declaration.</span>
<span class="c1">// Create a vector of vertex elements making up the vertex declaration.</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">D3DVERTEXELEMENT9</span><span class="o">&gt;</span> <span class="n">vertexDeclDesc</span> <span class="p">{</span>
    <span class="p">{</span> <span class="mi">0</span><span class="p">,</span>                     <span class="c1">// stream index</span>
      <span class="mi">0</span><span class="p">,</span>                     <span class="c1">// byte offset from the struct beginning</span>
      <span class="n">D3DDECLTYPE_FLOAT3</span><span class="p">,</span>    <span class="c1">// data type (3d float vector)</span>
      <span class="n">D3DDECLMETHOD_DEFAULT</span><span class="p">,</span> <span class="c1">// tessellator operation</span>
      <span class="n">D3DDECLUSAGE_POSITION</span><span class="p">,</span>  <span class="c1">// usage of the data</span>
      <span class="mi">0</span> <span class="p">},</span>                   <span class="c1">// index (multiples usage of the same type)</span>
    <span class="p">{</span> <span class="mi">0</span><span class="p">,</span>
      <span class="mi">12</span><span class="p">,</span>                    <span class="c1">// byte offset (3 * sizeof(float) bytes)</span>
      <span class="n">D3DDECLTYPE_D3DCOLOR</span><span class="p">,</span>
      <span class="n">D3DDECLMETHOD_DEFAULT</span><span class="p">,</span>
      <span class="n">D3DDECLUSAGE_COLOR</span><span class="p">,</span>
      <span class="mi">0</span> <span class="p">},</span>
    <span class="n">D3DDECL_END</span><span class="p">()</span>            <span class="c1">// marks the end of the vertex declaration</span>
<span class="p">};</span>
<span class="c1">// After having defined the vector we can create a vertex declaration from it.</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">_device</span><span class="o">-&gt;</span><span class="n">CreateVertexDeclaration</span><span class="p">(</span>
                      <span class="n">vertexDeclDesc</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="c1">// the vertex element array</span>
                      <span class="o">&amp;</span><span class="n">_vertexDecl</span><span class="p">);</span>         <span class="c1">// receiving pointer</span>
<span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">result</span><span class="p">))</span> 
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="c1">// Apply the created vertex declaration.</span>
<span class="n">_device</span><span class="o">-&gt;</span><span class="n">SetVertexDeclaration</span><span class="p">(</span><span class="n">_vertexDecl</span><span class="p">.</span><span class="n">Get</span><span class="p">());</span>
<span class="c1">// ...</span>
</code></pre></div>
<h2>Shader</h2>

<p>The maximum shader model for Direct3D 9 is shader model 3.0. Even though every modern graphics card should support it, it is best to check for capabilities.</p>
<div class="highlight"><pre class="highlight cpp"><code><span class="c1">// ...</span>
<span class="n">_device</span><span class="o">-&gt;</span><span class="n">SetVertexDeclaration</span><span class="p">(</span><span class="n">_vertexDecl</span><span class="p">.</span><span class="n">Get</span><span class="p">());</span>
<span class="c1">// First we have to request the device capabilities.</span>
<span class="n">D3DCAPS9</span> <span class="n">deviceCaps</span><span class="p">{</span> <span class="p">};</span>
<span class="n">_device</span><span class="o">-&gt;</span><span class="n">GetDeviceCaps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deviceCaps</span><span class="p">);</span>
<span class="c1">// Now we check if shader model 3.0 is supported for the vertex shader.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">deviceCaps</span><span class="p">.</span><span class="n">VertexShaderVersion</span> <span class="o">&lt;</span> <span class="n">D3DVS_VERSION</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="c1">// And the same for the pixel shader.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">deviceCaps</span><span class="p">.</span><span class="n">PixelShaderVersion</span> <span class="o">&lt;</span> <span class="n">D3DPS_VERSION</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</code></pre></div>
<p>Now that we are sure shader model 3.0 is supported let&rsquo;s create the vertex and pixel shader files.
DirectX 9 introduced the HLSL (<strong>High Level Shading Language</strong>), a C-like shader language, which
simplified the shader programming a lot, as you could only write shaders in shader assembly in DirectX 8.
Let&rsquo;s create a simple vertex- and pixel shader. </p>

<p><strong>Vertex Shader</strong></p>
<div class="highlight"><pre class="highlight cpp"><code><span class="c1">// 3 4x4 float matrices representing the matrices we set in the fixed-function</span>
<span class="c1">// pipeline by using the SetTransform() method.</span>
<span class="n">float4x4</span> <span class="n">projectionMatrix</span><span class="p">;</span>
<span class="n">float4x4</span> <span class="n">viewMatrix</span><span class="p">;</span>
<span class="n">float4x4</span> <span class="n">worldMatrix</span><span class="p">;</span>
<span class="c1">// The input struct to the vertex shader.</span>
<span class="c1">// It holds a 3d float vector for the position and a 4d float vector</span>
<span class="c1">// for the color.</span>
<span class="k">struct</span> <span class="nc">VS_INPUT</span> <span class="p">{</span>
    <span class="n">float3</span> <span class="n">position</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
    <span class="n">float4</span> <span class="n">color</span> <span class="o">:</span> <span class="n">COLOR</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// The output struct of the vertex shader, that is passed to the pixel shader.</span>
<span class="k">struct</span> <span class="nc">VS_OUTPUT</span> <span class="p">{</span>
    <span class="n">float4</span> <span class="n">position</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
    <span class="n">float4</span> <span class="n">color</span> <span class="o">:</span> <span class="n">COLOR</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// The main function of the vertex shader returns the output it sends to the</span>
<span class="c1">// pixel shader and receives it's input as a parameter.</span>
<span class="n">VS_OUTPUT</span> <span class="n">main</span><span class="p">(</span><span class="n">VS_INPUT</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Declare a empty struct, that the vertex shader returns.</span>
    <span class="n">VS_OUTPUT</span> <span class="n">output</span><span class="p">;</span>
    <span class="c1">// Set the output position to the input position and set</span>
    <span class="c1">// the w-component to 1, as the input position is a 3d vector and</span>
    <span class="c1">// the output position a 4d vector.</span>
    <span class="n">output</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">float4</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
    <span class="c1">// Multiply the output position step by step with the world, view and</span>
    <span class="c1">// projection matrices.</span>
    <span class="n">output</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="n">worldMatrix</span><span class="p">);</span>    
    <span class="n">output</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="n">viewMatrix</span><span class="p">);</span>
    <span class="n">output</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="n">projectionMatrix</span><span class="p">);</span>
    <span class="c1">// Pass the input color unchanged to the pixel shader.</span>
    <span class="n">output</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="n">color</span><span class="p">;</span>
    <span class="c1">// Return the output struct to the pixel shader.</span>
    <span class="c1">// The position value is automatically used as the vertex position.</span>
    <span class="k">return</span> <span class="n">output</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>Pixel Shader</strong></p>
<div class="highlight"><pre class="highlight cpp"><code><span class="c1">// The pixel shader input struct must be the same as the vertex shader output!</span>
<span class="k">struct</span> <span class="nc">PS_INPUT</span> <span class="p">{</span>
    <span class="n">float4</span> <span class="n">position</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
    <span class="n">float4</span> <span class="n">color</span> <span class="o">:</span> <span class="n">COLOR</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// The pixel shader simply returns a 4d vector representing the vertex color.</span>
<span class="c1">// It receives it's input as a parameter just like the vertex shader.</span>
<span class="c1">// We have to declare the output semantic as color to it gets interpreted</span>
<span class="c1">// correctly.</span>
<span class="n">float4</span> <span class="n">main</span><span class="p">(</span><span class="n">PS_INPUT</span> <span class="n">input</span><span class="p">)</span> <span class="o">:</span> <span class="n">COLOR</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">input</span><span class="p">.</span><span class="n">color</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>For more on semantics: <a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-semantics#vertex-shader-semantics">DirectX - Semantics</a></p>

<p>Now we have to do quite some changes to the code.</p>
<div class="highlight"><pre class="highlight cpp"><code><span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">IDirect3DDevice9</span><span class="o">&gt;</span> <span class="n">_device</span><span class="p">{</span> <span class="p">};</span>
<span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">IDirect3DVertexBuffer9</span><span class="o">&gt;</span> <span class="n">_vertexBuffer</span><span class="p">{</span> <span class="p">};</span>
<span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">IDirect3DIndexBuffer9</span><span class="o">&gt;</span> <span class="n">_indexBuffer</span><span class="p">{</span> <span class="p">};</span>
<span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">IDirect3DVertexDeclaration9</span><span class="o">&gt;</span> <span class="n">_vertexDecl</span><span class="p">{</span> <span class="p">};</span>
<span class="c1">// We have to add a ComPtr for the vertex- and pixel shader, aswell as one</span>
<span class="c1">// for the constants (matrices) in our vertex shader.</span>
<span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">IDirect3DVertexShader9</span><span class="o">&gt;</span> <span class="n">_vertexShader</span><span class="p">{</span> <span class="p">};</span>
<span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">IDirect3DPixelShader9</span><span class="o">&gt;</span> <span class="n">_pixelShader</span><span class="p">{</span> <span class="p">};</span>
<span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">ID3DXConstantTable</span><span class="o">&gt;</span> <span class="n">_vertexTable</span><span class="p">{</span> <span class="p">};</span>
<span class="c1">// Declare the world and rotation matrix as global, because we use them in</span>
<span class="c1">// WinMain and SetupTransform now.</span>
<span class="n">D3DXMATRIX</span> <span class="n">_worldMatrix</span><span class="p">{</span> <span class="p">};</span>
<span class="n">D3DXMATRIX</span> <span class="n">_rotationMatrix</span><span class="p">{</span> <span class="p">};</span>
<span class="c1">// ...</span>
<span class="kt">bool</span> <span class="n">SetupTransform</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Set the world and rotation matrix to an identity matrix.</span>
    <span class="n">D3DXMatrixIdentity</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_worldMatrix</span><span class="p">);</span>
    <span class="n">D3DXMatrixIdentity</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_rotationMatrix</span><span class="p">);</span>

    <span class="n">D3DXMATRIX</span> <span class="n">scaling</span><span class="p">{</span> <span class="p">};</span>
    <span class="n">D3DXMatrixScaling</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scaling</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">D3DXMatrixMultiply</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_worldMatrix</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scaling</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">_rotationMatrix</span><span class="p">);</span>
    <span class="c1">// After multiplying the scalation and rotation matrix the have to pass</span>
    <span class="c1">// them to the shader, by using a method from the constant table</span>
    <span class="c1">// of the vertex shader.</span>
    <span class="n">HRESULT</span> <span class="n">result</span><span class="p">{</span> <span class="p">};</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_vertexTable</span><span class="o">-&gt;</span><span class="n">SetMatrix</span><span class="p">(</span>
                         <span class="n">_device</span><span class="p">.</span><span class="n">Get</span><span class="p">(),</span>   <span class="c1">// direct3d device</span>
                         <span class="s">"worldMatrix"</span><span class="p">,</span>   <span class="c1">// matrix name in the shader</span>
                          <span class="o">&amp;</span><span class="n">_worldMatrix</span><span class="p">);</span> <span class="c1">// pointer to the matrix</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="n">D3DXMATRIX</span> <span class="n">view</span><span class="p">{</span> <span class="p">};</span>
    <span class="n">D3DXMatrixLookAtLH</span><span class="p">(</span><span class="o">&amp;</span><span class="n">view</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">D3DXVECTOR3</span><span class="p">{</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">20.0</span><span class="n">f</span> <span class="p">},</span>
           <span class="o">&amp;</span><span class="n">D3DXVECTOR3</span><span class="p">{</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span> <span class="p">},</span> <span class="o">&amp;</span><span class="n">D3DXVECTOR3</span><span class="p">{</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span> <span class="p">});</span>
    <span class="c1">// Do the same for the view matrix.</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_vertexTable</span><span class="o">-&gt;</span><span class="n">SetMatrix</span><span class="p">(</span>
                           <span class="n">_device</span><span class="p">.</span><span class="n">Get</span><span class="p">(),</span> <span class="c1">// direct 3d device</span>
                           <span class="s">"viewMatrix"</span><span class="p">,</span>  <span class="c1">// matrix name</span>
                           <span class="o">&amp;</span><span class="n">view</span><span class="p">);</span>        <span class="c1">// matrix</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="n">D3DXMATRIX</span> <span class="n">projection</span><span class="p">{</span> <span class="p">};</span>
    <span class="n">D3DXMatrixPerspectiveFovLH</span><span class="p">(</span><span class="o">&amp;</span><span class="n">projection</span><span class="p">,</span> <span class="n">D3DXToRadian</span><span class="p">(</span><span class="mf">60.0</span><span class="n">f</span><span class="p">),</span>
        <span class="mf">1024.0</span><span class="n">f</span> <span class="o">/</span> <span class="mf">768.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">100.0</span><span class="n">f</span><span class="p">);</span>
    <span class="c1">// And also for the projection matrix.</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_vertexTable</span><span class="o">-&gt;</span><span class="n">SetMatrix</span><span class="p">(</span>
                           <span class="n">_device</span><span class="p">.</span><span class="n">Get</span><span class="p">(),</span>
                           <span class="s">"projectionMatrix"</span><span class="p">,</span>
                           <span class="o">&amp;</span><span class="n">projection</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="n">D3DXMatrixRotationY</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_rotationMatrix</span><span class="p">,</span> <span class="n">D3DXToRadian</span><span class="p">(</span><span class="mf">0.5</span><span class="n">f</span><span class="p">));</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// ...</span>
<span class="c1">// Vertex and index buffer creation aswell as initialization stay unchanged.</span>
<span class="c1">// ...</span>
<span class="c1">// After checking that shader model 3.0 is available we have to compile and</span>
<span class="c1">// create the shaders.</span>
<span class="c1">// Declare two temporary buffers storing the compiled shader code.</span>
<span class="n">ID3DXBuffer</span><span class="o">*</span> <span class="n">vertexShaderBuffer</span><span class="p">{</span> <span class="p">};</span>
<span class="n">ID3DXBuffer</span><span class="o">*</span> <span class="n">pixelShaderBuffer</span><span class="p">{</span> <span class="p">};</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">D3DXCompileShaderFromFile</span><span class="p">(</span><span class="s">"vertex.hlsl"</span><span class="p">,</span>  <span class="c1">// shader name</span>
                                   <span class="nb">nullptr</span><span class="p">,</span>        <span class="c1">// macro definitions</span>
                                   <span class="nb">nullptr</span><span class="p">,</span>        <span class="c1">// special includes</span>
                                   <span class="s">"main"</span><span class="p">,</span>         <span class="c1">// entry point name</span>
                                   <span class="s">"vs_3_0"</span><span class="p">,</span>       <span class="c1">// shader model version</span>
                                   <span class="mi">0</span><span class="p">,</span>              <span class="c1">// special flags</span>
                                   <span class="o">&amp;</span><span class="n">vertexShaderBuffer</span><span class="p">,</span> <span class="c1">// code buffer</span>
                                   <span class="nb">nullptr</span><span class="p">,</span>        <span class="c1">// error message</span>
                                   <span class="o">&amp;</span><span class="n">_vertexTable</span><span class="p">);</span> <span class="c1">// constant table</span>
<span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="c1">// After the vertex shader compile the pixel shader.</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">D3DXCompileShaderFromFile</span><span class="p">(</span><span class="s">"pixel.hlsl"</span><span class="p">,</span>
                                   <span class="nb">nullptr</span><span class="p">,</span>
                                   <span class="nb">nullptr</span><span class="p">,</span>
                                   <span class="s">"main"</span><span class="p">,</span>
                                   <span class="s">"ps_3_0"</span><span class="p">,</span> <span class="c1">// pixel shader model 3.0</span>
                                   <span class="mi">0</span><span class="p">,</span>
                                   <span class="o">&amp;</span><span class="n">pixelShaderBuffer</span><span class="p">,</span>
                                   <span class="nb">nullptr</span><span class="p">,</span>
                                   <span class="nb">nullptr</span><span class="p">);</span> <span class="c1">// no need for a constant table</span>
<span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="c1">// Create the vertex shader from the code buffer.</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">_device</span><span class="o">-&gt;</span><span class="n">CreateVertexShader</span><span class="p">(</span>
             <span class="p">(</span><span class="n">DWORD</span><span class="o">*</span><span class="p">)</span><span class="n">vertexShaderBuffer</span><span class="o">-&gt;</span><span class="n">GetBufferPointer</span><span class="p">(),</span> <span class="c1">// code buffer</span>
             <span class="o">&amp;</span><span class="n">_vertexShader</span><span class="p">);</span> <span class="c1">// vertex shader pointer</span>
<span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">_device</span><span class="o">-&gt;</span><span class="n">CreatePixelShader</span><span class="p">(</span>
             <span class="p">(</span><span class="n">DWORD</span><span class="o">*</span><span class="p">)</span><span class="n">pixelShaderBuffer</span><span class="o">-&gt;</span><span class="n">GetBufferPointer</span><span class="p">(),</span>
             <span class="o">&amp;</span><span class="n">_pixelShader</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="c1">// Release the temporary code buffers after the shaders are created.</span>
<span class="n">vertexShaderBuffer</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span>
<span class="n">pixelShaderBuffer</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span>
<span class="c1">// Apply the vertex- and pixel shader.</span>
<span class="n">_device</span><span class="o">-&gt;</span><span class="n">SetVertexShader</span><span class="p">(</span><span class="n">_vertexShader</span><span class="p">.</span><span class="n">Get</span><span class="p">());</span>
<span class="n">_device</span><span class="o">-&gt;</span><span class="n">SetPixelShader</span><span class="p">(</span><span class="n">_pixelShader</span><span class="p">.</span><span class="n">Get</span><span class="p">());</span>
<span class="c1">// Apply the transform after the shaders have been set.</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SetupTransform</span><span class="p">())</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="c1">// You can also REMOVE the call so set the lighting render state.</span>
<span class="n">_device</span><span class="o">-&gt;</span><span class="n">SetRenderState</span><span class="p">(</span><span class="n">D3DRS_LIGHTING</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>
<p>You can find the complete code here: <a href="https://pastebin.com/y4NrvawY">DirectX - 3</a></p>

<h2>Texturing</h2>
<div class="highlight"><pre class="highlight cpp"><code><span class="c1">// First we need to declare a ComPtr for the texture.</span>
<span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">IDirect3DTexture9</span><span class="o">&gt;</span> <span class="n">_texture</span><span class="p">{</span> <span class="p">};</span>
<span class="c1">// Then we have to change the vertex struct.</span>
<span class="k">struct</span> <span class="nc">VStruct</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span>      <span class="c1">// Add texture u and v coordinates</span>
    <span class="n">D3DCOLOR</span> <span class="n">color</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// In the vertex declaration we have to add the texture coordinates.</span>
<span class="c1">// the top left of the texture is u: 0, v: 0.</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VStruct</span><span class="o">&gt;</span> <span class="n">vertices</span> <span class="p">{</span>
    <span class="n">VStruct</span><span class="p">{</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="p">...</span> <span class="p">},</span> <span class="c1">// bottom left</span>
    <span class="n">VStruct</span><span class="p">{</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span>  <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="p">...</span> <span class="p">},</span> <span class="c1">// top left</span>
    <span class="n">VStruct</span><span class="p">{</span>  <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span>  <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="p">...</span> <span class="p">},</span> <span class="c1">// top right</span>
    <span class="n">VStruct</span><span class="p">{</span>  <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="p">...</span> <span class="p">}</span>  <span class="c1">// bottom right</span>
<span class="p">};</span>
<span class="c1">// Next is the vertex declaration.</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">D3DVERTEXELEMENT9</span><span class="o">&gt;</span> <span class="n">vertexDecl</span><span class="p">{</span>
    <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">D3DDECLTYPE_FLOAT3</span><span class="p">,</span> <span class="n">D3DDECLMETHOD_DEFAULT</span><span class="p">,</span> <span class="n">D3DDECLUSAGE_POSITION</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
    <span class="c1">// Add a 2d float vector used for texture coordinates.</span>
    <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="n">D3DDECLTYPE_FLOAT2</span><span class="p">,</span> <span class="n">D3DDECLMETHOD_DEFAULT</span><span class="p">,</span> <span class="n">D3DDECLUSAGE_TEXCOORD</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
    <span class="c1">// The color offset is not (3 + 2) * sizeof(float) = 20 bytes</span>
    <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">D3DDECLTYPE_D3DCOLOR</span><span class="p">,</span> <span class="n">D3DDECLMETHOD_DEFAULT</span><span class="p">,</span> <span class="n">D3DDECLUSAGE_COLOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
    <span class="n">D3DDECL_END</span><span class="p">()</span>
<span class="p">};</span>
<span class="c1">// Now we have to load the texture and pass its to the shader.</span>
<span class="c1">// ...</span>
<span class="n">_device</span><span class="o">-&gt;</span><span class="n">SetRenderState</span><span class="p">(</span><span class="n">D3DRS_CULLMODE</span><span class="p">,</span> <span class="n">D3DCULL_NONE</span><span class="p">);</span>
<span class="c1">// Create a Direct3D texture from a png file.</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">D3DXCreateTextureFromFile</span><span class="p">(</span><span class="n">_device</span><span class="p">.</span><span class="n">Get</span><span class="p">(),</span> <span class="c1">// direct3d device</span>
                                   <span class="s">"texture.png"</span><span class="p">,</span> <span class="c1">// texture path</span>
                                   <span class="o">&amp;</span><span class="n">_texture</span><span class="p">);</span>    <span class="c1">// receiving texture pointer</span>
<span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="c1">// Attach the texture to shader stage 0, which is equal to texture register 0</span>
<span class="c1">// in the pixel shader.</span>
<span class="n">_device</span><span class="o">-&gt;</span><span class="n">SetTexture</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_texture</span><span class="p">.</span><span class="n">Get</span><span class="p">());</span>
</code></pre></div>
<p>With the main code ready we now have to adjust the shaders to these changes.</p>

<p><strong>Vertex Shader</strong></p>
<div class="highlight"><pre class="highlight cpp"><code><span class="n">float4x4</span> <span class="n">projectionMatrix</span><span class="p">;</span>
<span class="n">float4x4</span> <span class="n">viewMatrix</span><span class="p">;</span>
<span class="n">float4x4</span> <span class="n">worldMatrix</span><span class="p">;</span>
<span class="c1">// Add the texture coordinates to the vertex shader in- and output.</span>
<span class="k">struct</span> <span class="nc">VS_INPUT</span> <span class="p">{</span>
    <span class="n">float3</span> <span class="n">position</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">texcoord</span> <span class="o">:</span> <span class="n">TEXCOORD</span><span class="p">;</span>
    <span class="n">float4</span> <span class="n">color</span> <span class="o">:</span> <span class="n">COLOR</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">VS_OUTPUT</span> <span class="p">{</span>
    <span class="n">float4</span> <span class="n">position</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">texcoord</span> <span class="o">:</span> <span class="n">TEXCOORD</span><span class="p">;</span>
    <span class="n">float4</span> <span class="n">color</span> <span class="o">:</span> <span class="n">COLOR</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">VS_OUTPUT</span> <span class="n">main</span><span class="p">(</span><span class="n">VS_INPUT</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">VS_OUTPUT</span> <span class="n">output</span><span class="p">;</span>

    <span class="n">output</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">float4</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
    <span class="n">output</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="n">worldMatrix</span><span class="p">);</span>    
    <span class="n">output</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="n">viewMatrix</span><span class="p">);</span>
    <span class="n">output</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="n">projectionMatrix</span><span class="p">);</span>

    <span class="n">output</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="n">color</span><span class="p">;</span>
    <span class="c1">// Set the texcoord output to the input.</span>
    <span class="n">output</span><span class="p">.</span><span class="n">texcoord</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="n">texcoord</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">output</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>Pixel Shader</strong></p>
<div class="highlight"><pre class="highlight cpp"><code><span class="c1">// Create  a sampler called "sam0" using sampler register 0, which is equal</span>
<span class="c1">// to the texture stage 0, to which we passed the texture.</span>
<span class="n">sampler</span> <span class="n">sam0</span> <span class="o">:</span> <span class="k">register</span><span class="p">(</span><span class="n">s0</span><span class="p">);</span>

<span class="k">struct</span> <span class="nc">PS_INPUT</span> <span class="p">{</span>
    <span class="n">float4</span> <span class="n">position</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">texcoord</span> <span class="o">:</span> <span class="n">TEXCOORD</span><span class="p">;</span>
    <span class="n">float4</span> <span class="n">color</span> <span class="o">:</span> <span class="n">COLOR</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">float4</span> <span class="n">main</span><span class="p">(</span><span class="n">PS_INPUT</span> <span class="n">input</span><span class="p">)</span> <span class="o">:</span> <span class="n">COLOR</span><span class="p">{</span>
    <span class="c1">// Do a linear interpolation between the texture color and the input color</span>
    <span class="c1">// using 75% of the input color.</span>
    <span class="c1">// tex2D returns the texture data at the specified texture coordinate.</span>
    <span class="k">return</span> <span class="n">lerp</span><span class="p">(</span><span class="n">tex2D</span><span class="p">(</span><span class="n">sam0</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">texcoord</span><span class="p">),</span> <span class="n">input</span><span class="p">.</span><span class="n">color</span><span class="p">,</span> <span class="mf">0.75</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h2>Quotes</h2>

<p><sup>[1]</sup><a href="https://en.wikipedia.org/wiki/DirectX">DirectX - Wikipedia</a></p>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/directx9.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by Simon Deitermann, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/directx9.html.markdown">1 contributor(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="s.f.deitermann@t-online.de">Simon Deitermann</a>
    </p>

    <p>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
