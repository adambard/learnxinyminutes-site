<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="en-us" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="en-us" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="en-us" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="en-us" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="en-us">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn C in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/c/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fc%2F&text=Learn+X+in+Y+minutes%2C+where+X%3DC">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="/">Learn X in Y minutes</a></h1>
  <h2>Where X=C</h2>
    <p class="filelink">
    Get the code:
    <a href="/docs/files/learnc.c">learnc.c</a>
    </p>
  <div id="doc">
    <p>Ah, C. Still <strong>the</strong> language of modern high-performance computing.</p>

<p>C is the lowest-level language most programmers will ever use, but
it more than makes up for it with raw speed. Just be aware of its manual
memory management and C will take you as far as you need to go.</p>

<blockquote>
<p><strong>About compiler flags</strong></p>

<p>By default, gcc and clang are pretty quiet about compilation warnings and
errors, which can be very useful information. Explicitly using stricter
compiler flags is recommended. Here are some recommended defaults:</p>

<p><code>-Wall -Wextra -Werror -O2 -std=c99 -pedantic</code></p>

<p>For information on what these flags do as well as other flags, consult the man page for your C compiler (e.g. <code>man 1 gcc</code>) or just search online.</p>
</blockquote>
<div class="highlight"><pre><span></span><span class="c1">// Single-line comments start with // - only available in C99 and later.</span>

<span class="cm">/*</span>
<span class="cm">Multi-line comments look like this. They work in C89 as well.</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">Multi-line comments don&#39;t nest /* Be careful */</span><span class="w">  </span><span class="c1">// comment ends on this line...</span>
<span class="o">*/</span><span class="w"> </span><span class="c1">// ...not this one!</span>

<span class="c1">// Constants: #define &lt;keyword&gt;</span>
<span class="c1">// Constants are written in all-caps out of convention, not requirement</span>
<span class="cp">#define DAYS_IN_YEAR 365</span>

<span class="c1">// Enumeration constants are also ways to declare constants.</span>
<span class="c1">// All statements must end with a semicolon</span>
<span class="k">enum</span><span class="w"> </span><span class="n">days</span><span class="w"> </span><span class="p">{</span><span class="n">SUN</span><span class="p">,</span><span class="w"> </span><span class="n">MON</span><span class="p">,</span><span class="w"> </span><span class="n">TUE</span><span class="p">,</span><span class="w"> </span><span class="n">WED</span><span class="p">,</span><span class="w"> </span><span class="n">THU</span><span class="p">,</span><span class="w"> </span><span class="n">FRI</span><span class="p">,</span><span class="w"> </span><span class="n">SAT</span><span class="p">};</span>
<span class="c1">// SUN gets 0, MON gets 1, TUE gets 2, etc.</span>

<span class="c1">// Enumeration values can also be specified</span>
<span class="k">enum</span><span class="w"> </span><span class="n">days</span><span class="w"> </span><span class="p">{</span><span class="n">SUN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">MON</span><span class="p">,</span><span class="w"> </span><span class="n">TUE</span><span class="p">,</span><span class="w"> </span><span class="n">WED</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">99</span><span class="p">,</span><span class="w"> </span><span class="n">THU</span><span class="p">,</span><span class="w"> </span><span class="n">FRI</span><span class="p">,</span><span class="w"> </span><span class="n">SAT</span><span class="p">};</span>
<span class="c1">// MON gets 2 automatically, TUE gets 3, etc.</span>
<span class="c1">// WED get 99, THU gets 100, FRI gets 101, etc.</span>

<span class="c1">// Import headers with #include</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>

<span class="c1">// File names between &lt;angle brackets&gt; tell the compiler to look in your system</span>
<span class="c1">// libraries for the headers.</span>
<span class="c1">// For your own headers, use double quotes instead of angle brackets, and</span>
<span class="c1">// provide the path:</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;my_header.h&quot;</span><span class="c1">      // local file</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;../my_lib/my_lib_header.h&quot;</span><span class="c1"> //relative path</span>

<span class="c1">// Declare function signatures in advance in a .h file, or at the top of</span>
<span class="c1">// your .c file.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">function_1</span><span class="p">();</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">function_2</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="c1">// At a minimum, you must declare a &#39;function prototype&#39; before its use in any function.</span>
<span class="c1">// Normally, prototypes are placed at the top of a file before any function definition.</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">add_two_ints</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x2</span><span class="p">);</span><span class="w"> </span><span class="c1">// function prototype</span>
<span class="c1">// although `int add_two_ints(int, int);` is also valid (no need to name the args),</span>
<span class="c1">// it is recommended to name arguments in the prototype as well for easier inspection</span>

<span class="c1">// Function prototypes are not necessary if the function definition comes before</span>
<span class="c1">// any other function that calls that function. However, it&#39;s standard practice to</span>
<span class="c1">// always add the function prototype to a header file (*.h) and then #include that</span>
<span class="c1">// file at the top. This prevents any issues where a function might be called</span>
<span class="c1">// before the compiler knows of its existence, while also giving the developer a</span>
<span class="c1">// clean header file to share with the rest of the project.</span>

<span class="c1">// Your program&#39;s entry point is a function called &quot;main&quot;. The return type can</span>
<span class="c1">// be anything, however most operating systems expect a return type of `int` for</span>
<span class="c1">// error code processing.</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// your program</span>
<span class="p">}</span>

<span class="c1">// The command line arguments used to run your program are also passed to main</span>
<span class="c1">// argc being the number of arguments - your program&#39;s name counts as 1</span>
<span class="c1">// argv is an array of character arrays - containing the arguments themselves</span>
<span class="c1">// argv[0] = name of your program, argv[1] = first argument, etc.</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// print output using printf, for &quot;print formatted&quot;</span>
<span class="w">  </span><span class="c1">// %d is an integer, \n is a newline</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Prints 0</span>

<span class="w">  </span><span class="c1">// take input using scanf</span>
<span class="w">  </span><span class="c1">// &#39;&amp;&#39; is used to define the location</span>
<span class="w">  </span><span class="c1">// where we want to store the input value</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">input</span><span class="p">;</span>
<span class="w">  </span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">input</span><span class="p">);</span>

<span class="w">  </span><span class="c1">///////////////////////////////////////</span>
<span class="w">  </span><span class="c1">// Types</span>
<span class="w">  </span><span class="c1">///////////////////////////////////////</span>

<span class="w">  </span><span class="c1">// Compilers that are not C99-compliant require that variables MUST be</span>
<span class="w">  </span><span class="c1">// declared at the top of the current block scope.</span>
<span class="w">  </span><span class="c1">// Compilers that ARE C99-compliant allow declarations near the point where</span>
<span class="w">  </span><span class="c1">// the value is used.</span>
<span class="w">  </span><span class="c1">// For the sake of the tutorial, variables are declared dynamically under</span>
<span class="w">  </span><span class="c1">// C99-compliant standards.</span>

<span class="w">  </span><span class="c1">// ints are usually 4 bytes (use the `sizeof` operator to check)</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x_int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// shorts are usually 2 bytes (use the `sizeof` operator to check)</span>
<span class="w">  </span><span class="kt">short</span><span class="w"> </span><span class="n">x_short</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// chars are defined as the smallest addressable unit for a processor.</span>
<span class="w">  </span><span class="c1">// This is usually 1 byte, but for some systems it can be more (ex. for TMS320 from TI it&#39;s 2 bytes).</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">x_char</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">y_char</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;y&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Char literals are quoted with &#39;&#39;</span>

<span class="w">  </span><span class="c1">// longs are often 4 to 8 bytes; long longs are guaranteed to be at least</span>
<span class="w">  </span><span class="c1">// 8 bytes</span>
<span class="w">  </span><span class="kt">long</span><span class="w"> </span><span class="n">x_long</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x_long_long</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// floats are usually 32-bit floating point numbers</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">x_float</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span><span class="w"> </span><span class="c1">// &#39;f&#39; suffix here denotes floating point literal</span>

<span class="w">  </span><span class="c1">// doubles are usually 64-bit floating-point numbers</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">x_double</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"> </span><span class="c1">// real numbers without any suffix are doubles</span>

<span class="w">  </span><span class="c1">// integer types may be unsigned (greater than or equal to zero)</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">ux_short</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ux_int</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">ux_long_long</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// chars inside single quotes are integers in machine&#39;s character set.</span>
<span class="w">  </span><span class="sc">&#39;0&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 48 in the ASCII character set.</span>
<span class="w">  </span><span class="sc">&#39;A&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 65 in the ASCII character set.</span>

<span class="w">  </span><span class="c1">// sizeof(T) gives you the size of a variable with type T in bytes</span>
<span class="w">  </span><span class="c1">// sizeof(obj) yields the size of the expression (variable, literal, etc.).</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"> </span><span class="c1">// =&gt; 4 (on most machines with 4-byte words)</span>

<span class="w">  </span><span class="c1">// If the argument of the `sizeof` operator is an expression, then its argument</span>
<span class="w">  </span><span class="c1">// is not evaluated (except VLAs (see below)).</span>
<span class="w">  </span><span class="c1">// The value it yields in this case is a compile-time constant.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// size_t is an unsigned integer type of at least 2 bytes used to represent</span>
<span class="w">  </span><span class="c1">// the size of an object.</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="o">++</span><span class="p">);</span><span class="w"> </span><span class="c1">// a++ is not evaluated</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(a++) = %zu where a = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// prints &quot;sizeof(a++) = 4 where a = 1&quot; (on a 32-bit architecture)</span>

<span class="w">  </span><span class="c1">// Arrays must be initialized with a concrete size.</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">my_char_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span><span class="w"> </span><span class="c1">// This array occupies 1 * 20 = 20 bytes</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">my_int_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span><span class="w"> </span><span class="c1">// This array occupies 4 * 20 = 80 bytes</span>
<span class="w">  </span><span class="c1">// (assuming 4-byte words)</span>

<span class="w">  </span><span class="c1">// You can initialize an array of twenty ints that all equal 0 thusly:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">my_array</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="w">  </span><span class="c1">// where the &quot;{0}&quot; part is called an &quot;array initializer&quot;.</span>
<span class="w">  </span><span class="c1">// All elements (if any) past the ones in the initializer are initialized to 0:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">my_array</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">};</span>
<span class="w">  </span><span class="c1">// So my_array now has five elements, all but the first two of which are 0:</span>
<span class="w">  </span><span class="c1">// [1, 2, 0, 0, 0]</span>
<span class="w">  </span><span class="c1">// NOTE that you get away without explicitly declaring the size</span>
<span class="w">  </span><span class="c1">// of the array IF you initialize the array on the same line:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">my_array</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="w">  </span><span class="c1">// NOTE that, when not declaring the size, the size of the array is the number</span>
<span class="w">  </span><span class="c1">// of elements in the initializer. With &quot;{0}&quot;, my_array is now of size one: [0]</span>
<span class="w">  </span><span class="c1">// To evaluate the size of the array at run-time, divide its byte size by the</span>
<span class="w">  </span><span class="c1">// byte size of its element type:</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">my_array_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">my_array</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">my_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">  </span><span class="c1">// WARNING You should evaluate the size *before* you begin passing the array</span>
<span class="w">  </span><span class="c1">// to functions (see later discussion) because arrays get &quot;downgraded&quot; to</span>
<span class="w">  </span><span class="c1">// raw pointers when they are passed to functions (so the statement above</span>
<span class="w">  </span><span class="c1">// will produce the wrong result inside the function).</span>

<span class="w">  </span><span class="c1">// Indexing an array is like other languages -- or,</span>
<span class="w">  </span><span class="c1">// rather, other languages are like C</span>
<span class="w">  </span><span class="n">my_array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="c1">// =&gt; 0</span>

<span class="w">  </span><span class="c1">// Arrays are mutable; it&#39;s just memory!</span>
<span class="w">  </span><span class="n">my_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">my_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"> </span><span class="c1">// =&gt; 2</span>

<span class="w">  </span><span class="c1">// In C99 (and as an optional feature in C11), variable-length arrays (VLAs)</span>
<span class="w">  </span><span class="c1">// can be declared as well. The size of such an array need not be a compile</span>
<span class="w">  </span><span class="c1">// time constant:</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Enter the array size: &quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// ask the user for an array size</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">array_size</span><span class="p">;</span>
<span class="w">  </span><span class="n">fscanf</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">array_size</span><span class="p">);</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">var_length_array</span><span class="p">[</span><span class="n">array_size</span><span class="p">];</span><span class="w"> </span><span class="c1">// declare the VLA</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof array = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="n">var_length_array</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Example:</span>
<span class="w">  </span><span class="c1">// &gt; Enter the array size: 10</span>
<span class="w">  </span><span class="c1">// &gt; sizeof array = 40</span>

<span class="w">  </span><span class="c1">// Strings are just arrays of chars terminated by a NULL (0x00) byte,</span>
<span class="w">  </span><span class="c1">// represented in strings as the special character &#39;\0&#39;.</span>
<span class="w">  </span><span class="c1">// (We don&#39;t have to include the NULL byte in string literals; the compiler</span>
<span class="w">  </span><span class="c1">//  inserts it at the end of the array for us.)</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">a_string</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;This is a string&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a_string</span><span class="p">);</span><span class="w"> </span><span class="c1">// %s formats a string</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a_string</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span><span class="w"> </span><span class="c1">// =&gt; 0</span>
<span class="w">  </span><span class="c1">// i.e., byte #17 is 0 (as are 18, 19, and 20)</span>

<span class="w">  </span><span class="c1">// If we have characters between single quotes, that&#39;s a character literal.</span>
<span class="w">  </span><span class="c1">// It&#39;s of type `int`, and *not* `char` (for historical reasons).</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">cha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// fine</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">chb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// fine too (implicit conversion from int to char)</span>

<span class="w">  </span><span class="c1">// Multi-dimensional arrays:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">multi_array</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>
<span class="w">  </span><span class="c1">// access elements:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">array_int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">multi_array</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="c1">// =&gt; 3</span>

<span class="w">  </span><span class="c1">///////////////////////////////////////</span>
<span class="w">  </span><span class="c1">// Operators</span>
<span class="w">  </span><span class="c1">///////////////////////////////////////</span>

<span class="w">  </span><span class="c1">// Shorthands for multiple declarations:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">i2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="n">f2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">  </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Arithmetic is straightforward</span>
<span class="w">  </span><span class="n">i1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 3</span>
<span class="w">  </span><span class="n">i2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">i1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>
<span class="w">  </span><span class="n">i2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 2</span>
<span class="w">  </span><span class="n">i1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">i2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0 (0.5, but truncated towards 0)</span>

<span class="w">  </span><span class="c1">// You need to cast at least one integer to float to get a floating-point result</span>
<span class="w">  </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">i1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">i2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0.5f</span>
<span class="w">  </span><span class="n">i1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">i2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0.5 // Same with double</span>
<span class="w">  </span><span class="n">f1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0.5, plus or minus epsilon</span>

<span class="w">  </span><span class="c1">// Floating-point numbers are defined by IEEE 754, thus cannot store perfectly</span>
<span class="w">  </span><span class="c1">// exact values. For instance, the following does not produce expected results</span>
<span class="w">  </span><span class="c1">// because 0.1 might actually be 0.099999999999 inside the computer, and 0.3</span>
<span class="w">  </span><span class="c1">// might be stored as 0.300000000001.</span>
<span class="w">  </span><span class="p">(</span><span class="mf">0.1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">0.1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">0.1</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mf">0.3</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1 (true)</span>
<span class="w">  </span><span class="c1">// and it is NOT associative due to reasons mentioned above.</span>
<span class="w">  </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mf">1e123</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1e123</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1e123</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1e123</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1 (true)</span>
<span class="w">  </span><span class="c1">// this notation is scientific notations for numbers: 1e123 = 1*10^123</span>

<span class="w">  </span><span class="c1">// It is important to note that most all systems have used IEEE 754 to</span>
<span class="w">  </span><span class="c1">// represent floating points. Even python, used for scientific computing,</span>
<span class="w">  </span><span class="c1">// eventually calls C which uses IEEE 754. It is mentioned this way not to</span>
<span class="w">  </span><span class="c1">// indicate that this is a poor implementation, but instead as a warning</span>
<span class="w">  </span><span class="c1">// that when doing floating point comparisons, a little bit of error (epsilon)</span>
<span class="w">  </span><span class="c1">// needs to be considered.</span>

<span class="w">  </span><span class="c1">// Modulo is there as well, but be careful if arguments are negative</span>
<span class="w">  </span><span class="mi">11</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">    </span><span class="c1">// =&gt; 2 as 11 = 2 + 3*x (x=3)</span>
<span class="w">  </span><span class="p">(</span><span class="mi">-11</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; -2, as one would expect</span>
<span class="w">  </span><span class="mi">11</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="p">(</span><span class="mi">-3</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; 2 and not -2, and it&#39;s quite counter intuitive</span>

<span class="w">  </span><span class="c1">// Comparison operators are probably familiar, but</span>
<span class="w">  </span><span class="c1">// there is no Boolean type in C. We use ints instead.</span>
<span class="w">  </span><span class="c1">// (C99 introduced the _Bool type provided in stdbool.h)</span>
<span class="w">  </span><span class="c1">// 0 is false, anything else is true. (The comparison</span>
<span class="w">  </span><span class="c1">// operators always yield 0 or 1.)</span>
<span class="w">  </span><span class="mi">3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0 (false)</span>
<span class="w">  </span><span class="mi">3</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1 (true)</span>
<span class="w">  </span><span class="mi">3</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">  </span><span class="c1">// =&gt; 1</span>
<span class="w">  </span><span class="mi">3</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">  </span><span class="c1">// =&gt; 0</span>
<span class="w">  </span><span class="mi">2</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>
<span class="w">  </span><span class="mi">2</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>

<span class="w">  </span><span class="c1">// C is not Python - comparisons do NOT chain.</span>
<span class="w">  </span><span class="c1">// Warning: The line below will compile, but it means `(0 &lt; a) &lt; 2`.</span>
<span class="w">  </span><span class="c1">// This expression is always true, because (0 &lt; a) could be either 1 or 0.</span>
<span class="w">  </span><span class="c1">// In this case it&#39;s 1, because (0 &lt; 1).</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">between_0_and_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Instead use:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">between_0_and_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Logic works on ints</span>
<span class="w">  </span><span class="o">!</span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0 (Logical not)</span>
<span class="w">  </span><span class="o">!</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>
<span class="w">  </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1 (Logical and)</span>
<span class="w">  </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0</span>
<span class="w">  </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1 (Logical or)</span>
<span class="w">  </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0</span>

<span class="w">  </span><span class="c1">// Conditional ternary expression ( ? : )</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="w">  </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 10 &quot;if e &gt; f return e, else return f.&quot;</span>

<span class="w">  </span><span class="c1">// Increment and decrement operators:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">// Return j THEN increase j. (s = 0, j = 1)</span>
<span class="w">  </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">;</span><span class="w"> </span><span class="c1">// Increase j THEN return j. (s = 2, j = 2)</span>
<span class="w">  </span><span class="c1">// same with j-- and --j</span>

<span class="w">  </span><span class="c1">// Bitwise operators!</span>
<span class="w">  </span><span class="o">~</span><span class="mh">0x0F</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0xFFFFFFF0 (bitwise negation, &quot;1&#39;s complement&quot;, example result for 32-bit int)</span>
<span class="w">  </span><span class="mh">0x0F</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xF0</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0x00 (bitwise AND)</span>
<span class="w">  </span><span class="mh">0x0F</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0xF0</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0xFF (bitwise OR)</span>
<span class="w">  </span><span class="mh">0x04</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="mh">0x0F</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0x0B (bitwise XOR)</span>
<span class="w">  </span><span class="mh">0x01</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0x02 (bitwise left shift (by 1))</span>
<span class="w">  </span><span class="mh">0x02</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0x01 (bitwise right shift (by 1))</span>

<span class="w">  </span><span class="c1">// Be careful when shifting signed integers - the following are undefined:</span>
<span class="w">  </span><span class="c1">// - shifting into the sign bit of a signed integer (int a = 1 &lt;&lt; 31)</span>
<span class="w">  </span><span class="c1">// - left-shifting a negative number (int a = -1 &lt;&lt; 2)</span>
<span class="w">  </span><span class="c1">// - shifting by an offset which is &gt;= the width of the type of the LHS:</span>
<span class="w">  </span><span class="c1">//   int a = 1 &lt;&lt; 32; // UB if int is 32 bits wide</span>

<span class="w">  </span><span class="c1">///////////////////////////////////////</span>
<span class="w">  </span><span class="c1">// Control Structures</span>
<span class="w">  </span><span class="c1">///////////////////////////////////////</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;I am never run</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;I am also never run</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;I print</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// While loops exist</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">ii</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">//ANY value less than ten is true.</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ii</span><span class="o">++</span><span class="p">);</span><span class="w"> </span><span class="c1">// ii++ increments ii AFTER using its current value.</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="c1">// =&gt; prints &quot;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">kk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">kk</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">++</span><span class="n">kk</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="c1">// ++kk increments kk BEFORE using its current value.</span>
<span class="w">  </span><span class="c1">// =&gt; prints &quot;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// For loops too</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">jj</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">jj</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">jj</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">jj</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">jj</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="c1">// =&gt; prints &quot;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// *****NOTES*****:</span>
<span class="w">  </span><span class="c1">// Loops and Functions MUST have a body. If no body is needed:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">;</span><span class="w"> </span><span class="c1">// use semicolon to act as the body (null statement)</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Or</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// branching with multiple choices: switch()</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span><span class="w"> </span><span class="c1">// labels need to be integral *constant* expressions (such as enums)</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hey, &#39;a&#39; equals 0!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"> </span><span class="c1">// if you don&#39;t break, control flow falls over labels</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Huh, &#39;a&#39; equals 1!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Be careful - without a &quot;break&quot;, execution continues until the</span>
<span class="w">    </span><span class="c1">// next &quot;break&quot; is reached.</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">3</span><span class="p">:</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">4</span><span class="p">:</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Look at that.. &#39;a&#39; is either 3, or 4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="k">default</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// if `some_integral_expression` didn&#39;t match any of the labels</span>
<span class="w">    </span><span class="n">fputs</span><span class="p">(</span><span class="s">&quot;Error!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">stderr</span><span class="p">);</span>
<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="mi">-1</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="cm">/*</span>
<span class="cm">    Using &quot;goto&quot; in C</span>
<span class="cm">  */</span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kt">bool</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// for C don&#39;t have bool as data type before C99 :(</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">disaster</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="p">((</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">150</span><span class="p">)</span>
<span class="w">        </span><span class="n">disaster</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">disaster</span><span class="p">)</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">error</span><span class="p">;</span><span class="w">  </span><span class="c1">// exit both for loops</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nl">error</span><span class="p">:</span><span class="w"> </span><span class="c1">// this is a label that you can &quot;jump&quot; to with &quot;goto error;&quot;</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Error occurred at i = %d &amp; j = %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">);</span>
<span class="w">  </span><span class="cm">/*</span>
<span class="cm">    https://ideone.com/GuPhd6</span>
<span class="cm">    this will print out &quot;Error occurred at i = 51 &amp; j = 99.&quot;</span>
<span class="cm">  */</span>
<span class="w">  </span><span class="cm">/*</span>
<span class="cm">    it is generally considered bad practice to do so, except if</span>
<span class="cm">    you really know what you are doing. See</span>
<span class="cm">    https://en.wikipedia.org/wiki/Spaghetti_code#Meaning</span>
<span class="cm">  */</span>

<span class="w">  </span><span class="c1">///////////////////////////////////////</span>
<span class="w">  </span><span class="c1">// Typecasting</span>
<span class="w">  </span><span class="c1">///////////////////////////////////////</span>

<span class="w">  </span><span class="c1">// Every value in C has a type, but you can cast one value into another type</span>
<span class="w">  </span><span class="c1">// if you want (with some constraints).</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x_hex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x01</span><span class="p">;</span><span class="w"> </span><span class="c1">// You can assign vars with hex literals</span>
<span class="w">                    </span><span class="c1">// binary is not in the standard, but allowed by some</span>
<span class="w">                    </span><span class="c1">// compilers (x_bin = 0b0010010110)</span>

<span class="w">  </span><span class="c1">// Casting between types will attempt to preserve their numeric values</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x_hex</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Prints 1</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">short</span><span class="p">)</span><span class="w"> </span><span class="n">x_hex</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Prints 1</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="n">x_hex</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Prints 1</span>

<span class="w">  </span><span class="c1">// If you assign a value greater than a types max val, it will rollover</span>
<span class="w">  </span><span class="c1">// without warning.</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="mi">257</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; 1 (Max char = 255 if char is 8 bits long)</span>

<span class="w">  </span><span class="c1">// For determining the max value of a `char`, a `signed char` and an `unsigned char`,</span>
<span class="w">  </span><span class="c1">// respectively, use the CHAR_MAX, SCHAR_MAX and UCHAR_MAX macros from &lt;limits.h&gt;</span>

<span class="w">  </span><span class="c1">// Integral types can be cast to floating-point types, and vice-versa.</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span><span class="w"> </span><span class="c1">// %f always formats a double...</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w">  </span><span class="mi">100</span><span class="p">);</span><span class="w"> </span><span class="c1">// ...even with a float.</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mf">100.0</span><span class="p">);</span>

<span class="w">  </span><span class="c1">///////////////////////////////////////</span>
<span class="w">  </span><span class="c1">// Pointers</span>
<span class="w">  </span><span class="c1">///////////////////////////////////////</span>

<span class="w">  </span><span class="c1">// A pointer is a variable declared to store a memory address. Its declaration will</span>
<span class="w">  </span><span class="c1">// also tell you the type of data it points to. You can retrieve the memory address</span>
<span class="w">  </span><span class="c1">// of your variables, then mess with them.</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// Use &amp; to retrieve the address of a variable</span>
<span class="w">  </span><span class="c1">// (%p formats an object pointer of type void *)</span>
<span class="w">  </span><span class="c1">// =&gt; Prints some address in memory;</span>

<span class="w">  </span><span class="c1">// Pointers start with * in their declaration</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">px</span><span class="p">,</span><span class="w"> </span><span class="n">not_a_pointer</span><span class="p">;</span><span class="w"> </span><span class="c1">// px is a pointer to an int</span>
<span class="w">  </span><span class="n">px</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// Stores the address of x in px</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">px</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Prints some address in memory</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%zu, %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">px</span><span class="p">),</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">not_a_pointer</span><span class="p">));</span>
<span class="w">  </span><span class="c1">// =&gt; Prints &quot;8, 4&quot; on a typical 64-bit system</span>

<span class="w">  </span><span class="c1">// To retrieve the value at the address a pointer is pointing to,</span>
<span class="w">  </span><span class="c1">// put * in front to dereference it.</span>
<span class="w">  </span><span class="c1">// Note: yes, it may be confusing that &#39;*&#39; is used for _both_ declaring a</span>
<span class="w">  </span><span class="c1">// pointer and dereferencing it.</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">px</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Prints 0, the value of x</span>

<span class="w">  </span><span class="c1">// You can also change the value the pointer is pointing to.</span>
<span class="w">  </span><span class="c1">// We&#39;ll have to wrap the dereference in parenthesis because</span>
<span class="w">  </span><span class="c1">// ++ has a higher precedence than *.</span>
<span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">px</span><span class="p">)</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">// Increment the value px is pointing to by 1</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">px</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Prints 1</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; Prints 1</span>

<span class="w">  </span><span class="c1">// Arrays are a good way to allocate a contiguous block of memory</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span><span class="w"> </span><span class="c1">//declares array of size 20 (cannot change size)</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">xx</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">xx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">xx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"> </span><span class="n">xx</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x_array</span><span class="p">[</span><span class="n">xx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">xx</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="c1">// Initialize x_array to 20, 19, 18,... 2, 1</span>

<span class="w">  </span><span class="c1">// Declare a pointer of type int and initialize it to point to x_array</span>
<span class="w">  </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">x_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x_array</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// x_ptr now points to the first element in the array (the integer 20).</span>
<span class="w">  </span><span class="c1">// This works because arrays often decay into pointers to their first element.</span>
<span class="w">  </span><span class="c1">// For example, when an array is passed to a function or is assigned to a pointer,</span>
<span class="w">  </span><span class="c1">// it decays into (implicitly converted to) a pointer.</span>
<span class="w">  </span><span class="c1">// Exceptions: when the array is the argument of the `&amp;` (address-of) operator:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">ptr_to_arr</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arr</span><span class="p">;</span><span class="w"> </span><span class="c1">// &amp;arr is NOT of type `int *`!</span>
<span class="w">  </span><span class="c1">// It&#39;s of type &quot;pointer to array&quot; (of ten `int`s).</span>
<span class="w">  </span><span class="c1">// or when the array is a string literal used for initializing a char array:</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">otherarr</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foobarbazquirk&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// or when it&#39;s the argument of the `sizeof` or `alignof` operator:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">arraythethird</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arraythethird</span><span class="p">;</span><span class="w"> </span><span class="c1">// equivalent with int *ptr = &amp;arr[0];</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%zu, %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">arraythethird</span><span class="p">),</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">ptr</span><span class="p">));</span>
<span class="w">  </span><span class="c1">// probably prints &quot;40, 4&quot; or &quot;40, 8&quot;</span>

<span class="w">  </span><span class="c1">// Pointers are incremented and decremented based on their type</span>
<span class="w">  </span><span class="c1">// (this is called pointer arithmetic)</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">x_ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w"> </span><span class="c1">// =&gt; Prints 19</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"> </span><span class="c1">// =&gt; Prints 19</span>

<span class="w">  </span><span class="c1">// You can also dynamically allocate contiguous blocks of memory with the</span>
<span class="w">  </span><span class="c1">// standard library function malloc, which takes one argument of type size_t</span>
<span class="w">  </span><span class="c1">// representing the number of bytes to allocate (usually from the heap, although this</span>
<span class="w">  </span><span class="c1">// may not be true on e.g. embedded systems - the C standard says nothing about it).</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">my_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">my_ptr</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">20</span><span class="p">);</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">xx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">xx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"> </span><span class="n">xx</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">*</span><span class="p">(</span><span class="n">my_ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">xx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">xx</span><span class="p">;</span><span class="w"> </span><span class="c1">// my_ptr[xx] = 20-xx</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="c1">// Initialize memory to 20, 19, 18, 17... 2, 1 (as ints)</span>

<span class="w">  </span><span class="c1">// Be careful passing user-provided values to malloc! If you want</span>
<span class="w">  </span><span class="c1">// to be safe, you can use calloc instead (which, unlike malloc, also zeros out the memory)</span>
<span class="w">  </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">my_other_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calloc</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// Note that there is no standard way to get the length of a</span>
<span class="w">  </span><span class="c1">// dynamically allocated array in C. Because of this, if your arrays are</span>
<span class="w">  </span><span class="c1">// going to be passed around your program a lot, you need another variable</span>
<span class="w">  </span><span class="c1">// to keep track of the number of elements (size) of an array. See the</span>
<span class="w">  </span><span class="c1">// functions section for more info.</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">my_arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="w">  </span><span class="c1">// Add an element to the array</span>
<span class="w">  </span><span class="n">size</span><span class="o">++</span><span class="p">;</span>
<span class="w">  </span><span class="n">my_arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">realloc</span><span class="p">(</span><span class="n">my_arr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">my_arr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">//Remember to check for realloc failure!</span>
<span class="w">    </span><span class="k">return</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">my_arr</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Dereferencing memory that you haven&#39;t allocated gives</span>
<span class="w">  </span><span class="c1">// &quot;unpredictable results&quot; - the program is said to invoke &quot;undefined behavior&quot;</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">my_ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">21</span><span class="p">));</span><span class="w"> </span><span class="c1">// =&gt; Prints who-knows-what? It may even crash.</span>

<span class="w">  </span><span class="c1">// When you&#39;re done with a malloc&#39;d block of memory, you need to free it,</span>
<span class="w">  </span><span class="c1">// or else no one else can use it until your program terminates</span>
<span class="w">  </span><span class="c1">// (this is called a &quot;memory leak&quot;):</span>
<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">my_ptr</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Strings are arrays of char, but they are usually represented as a</span>
<span class="w">  </span><span class="c1">// pointer-to-char (which is a pointer to the first element of the array).</span>
<span class="w">  </span><span class="c1">// It&#39;s good practice to use `const char *&#39; when referring to a string literal,</span>
<span class="w">  </span><span class="c1">// since string literals shall not be modified (i.e. &quot;foo&quot;[0] = &#39;a&#39; is ILLEGAL.)</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">my_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;This is my very own string literal&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">my_str</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; &#39;T&#39;</span>

<span class="w">  </span><span class="c1">// This is not the case if the string is an array</span>
<span class="w">  </span><span class="c1">// (potentially initialized with a string literal)</span>
<span class="w">  </span><span class="c1">// that resides in writable memory, as in:</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">foo</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foo&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">foo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// this is legal, foo now contains &quot;aoo&quot;</span>

<span class="w">  </span><span class="n">function_1</span><span class="p">();</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// end main function</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Functions</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// Function declaration syntax:</span>
<span class="c1">// &lt;return type&gt; &lt;function name&gt;(&lt;args&gt;)</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">add_two_ints</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x2</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x2</span><span class="p">;</span><span class="w"> </span><span class="c1">// Use return to return a value</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">Functions are call by value. When a function is called, the arguments passed to</span>
<span class="cm">the function are copies of the original arguments (except arrays). Anything you</span>
<span class="cm">do to the arguments in the function do not change the value of the original</span>
<span class="cm">argument where the function was called.</span>

<span class="cm">Use pointers if you need to edit the original argument values (arrays are always</span>
<span class="cm">passed in as pointers).</span>

<span class="cm">Example: in-place string reversal</span>
<span class="cm">*/</span>

<span class="c1">// A void function returns no value</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">str_reverse</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str_in</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">str_in</span><span class="p">);</span><span class="w"> </span><span class="c1">// `strlen()` is part of the c standard library</span>
<span class="w">                               </span><span class="c1">// NOTE: length returned by `strlen` DOESN&#39;T</span>
<span class="w">                               </span><span class="c1">//       include the terminating NULL byte (&#39;\0&#39;)</span>
<span class="w">  </span><span class="c1">// in C99 and newer versions, you can directly declare loop control variables</span>
<span class="w">  </span><span class="c1">// in the loop&#39;s parentheses. e.g., `for (size_t ii = 0; ...`</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">ii</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str_in</span><span class="p">[</span><span class="n">ii</span><span class="p">];</span>
<span class="w">    </span><span class="n">str_in</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str_in</span><span class="p">[</span><span class="n">len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="c1">// ii-th char from end</span>
<span class="w">    </span><span class="n">str_in</span><span class="p">[</span><span class="n">len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">//NOTE: string.h header file needs to be included to use strlen()</span>

<span class="cm">/*</span>
<span class="cm">char c[] = &quot;This is a test.&quot;;</span>
<span class="cm">str_reverse(c);</span>
<span class="cm">printf(&quot;%s\n&quot;, c); // =&gt; &quot;.tset a si sihT&quot;</span>
<span class="cm">*/</span>
<span class="cm">/*</span>
<span class="cm">as we can return only one variable</span>
<span class="cm">to change values of more than one variables we use call by reference</span>
<span class="cm">*/</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">swapTwoNumbers</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm">int first = 10;</span>
<span class="cm">int second = 20;</span>
<span class="cm">printf(&quot;first: %d\nsecond: %d\n&quot;, first, second);</span>
<span class="cm">swapTwoNumbers(&amp;first, &amp;second);</span>
<span class="cm">printf(&quot;first: %d\nsecond: %d\n&quot;, first, second);</span>
<span class="cm">// values will be swapped</span>
<span class="cm">*/</span>

<span class="c1">// Return multiple values.</span>
<span class="c1">// C does not allow for returning multiple values with the return statement. If</span>
<span class="c1">// you would like to return multiple values, then the caller must pass in the</span>
<span class="c1">// variables where they would like the returned values to go. These variables must</span>
<span class="c1">// be passed in as pointers such that the function can modify them.</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">return_multiple</span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">array_of_3</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ret1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ret2</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ret3</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">array_of_3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">//return error code (false)</span>

<span class="w">    </span><span class="c1">//de-reference the pointer so we modify its value</span>
<span class="w">   </span><span class="o">*</span><span class="n">ret1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array_of_3</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">   </span><span class="o">*</span><span class="n">ret2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array_of_3</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">   </span><span class="o">*</span><span class="n">ret3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array_of_3</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">//return error code (true)</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">With regards to arrays, they will always be passed to functions</span>
<span class="cm">as pointers. Even if you statically allocate an array like `arr[10]`,</span>
<span class="cm">it still gets passed as a pointer to the first element in any function calls.</span>
<span class="cm">Again, there is no standard way to get the size of a dynamically allocated</span>
<span class="cm">array in C.</span>
<span class="cm">*/</span>
<span class="c1">// Size must be passed!</span>
<span class="c1">// Otherwise, this function has no way of knowing how big the array is.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">printIntArray</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;arr[%d] is: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm">int my_arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</span>
<span class="cm">int size = 10;</span>
<span class="cm">printIntArray(my_arr, size);</span>
<span class="cm">// will print &quot;arr[0] is: 1&quot; etc</span>
<span class="cm">*/</span>

<span class="c1">// if referring to external variables outside function, you should use the extern keyword.</span>
<span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">testFunc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">extern</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="c1">//i here is now using external variable i</span>
<span class="p">}</span>

<span class="c1">// make external variables private to source file with static:</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">//other files using testFunc2() cannot access variable j</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">testFunc2</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">extern</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// The static keyword makes a variable inaccessible to code outside the</span>
<span class="c1">// compilation unit. (On almost all systems, a &quot;compilation unit&quot; is a .c</span>
<span class="c1">// file.) static can apply both to global (to the compilation unit) variables,</span>
<span class="c1">// functions, and function-local variables. When using static with</span>
<span class="c1">// function-local variables, the variable is effectively global and retains its</span>
<span class="c1">// value across function calls, but is only accessible within the function it</span>
<span class="c1">// is declared in. Additionally, static variables are initialized to 0 if not</span>
<span class="c1">// declared with some other starting value.</span>
<span class="c1">//**You may also declare functions as static to make them private**</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// User-defined types and structs</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// Typedefs can be used to create type aliases</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">my_type</span><span class="p">;</span>
<span class="n">my_type</span><span class="w"> </span><span class="n">my_type_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// Structs are just collections of data, the members are allocated sequentially,</span>
<span class="c1">// in the order they are written:</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">height</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// It&#39;s not generally true that</span>
<span class="c1">// sizeof(struct rectangle) == sizeof(int) + sizeof(int)</span>
<span class="c1">// due to potential padding between the structure members (this is for alignment</span>
<span class="c1">// reasons). [1]</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">function_1</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="n">my_rec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// Fields can be initialized immediately</span>

<span class="w">  </span><span class="c1">// Access struct members with .</span>
<span class="w">  </span><span class="n">my_rec</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">  </span><span class="n">my_rec</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// You can declare pointers to structs</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="o">*</span><span class="n">my_rec_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">my_rec</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Use dereferencing to set struct pointer members...</span>
<span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">my_rec_ptr</span><span class="p">).</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// ... or even better: prefer the -&gt; shorthand for the sake of readability</span>
<span class="w">  </span><span class="n">my_rec_ptr</span><span class="o">-&gt;</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="c1">// Same as (*my_rec_ptr).height = 10;</span>
<span class="p">}</span>

<span class="c1">// You can apply a typedef to a struct for convenience</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="n">rect</span><span class="p">;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">area</span><span class="p">(</span><span class="n">rect</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Typedefs can also be defined right during struct definition</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">rect</span><span class="p">;</span>
<span class="c1">// Like before, doing this means one can type</span>
<span class="n">rect</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>
<span class="c1">// instead of having to type</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>

<span class="c1">// if you have large structs, you can pass them &quot;by pointer&quot; to avoid copying</span>
<span class="c1">// the whole struct:</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">areaptr</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">rect</span><span class="w"> </span><span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Function pointers</span>
<span class="c1">///////////////////////////////////////</span>
<span class="cm">/*</span>
<span class="cm">At run time, functions are located at known memory addresses. Function pointers are</span>
<span class="cm">much like any other pointer (they just store a memory address), but can be used</span>
<span class="cm">to invoke functions directly, and to pass handlers (or callback functions) around.</span>
<span class="cm">However, definition syntax may be initially confusing.</span>

<span class="cm">Example: use str_reverse from a pointer</span>
<span class="cm">*/</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">str_reverse_through_pointer</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str_in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Define a function pointer variable, named f.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"> </span><span class="c1">// Signature should exactly match the target function.</span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">str_reverse</span><span class="p">;</span><span class="w"> </span><span class="c1">// Assign the address for the actual function (determined at run time)</span>
<span class="w">  </span><span class="c1">// f = str_reverse; would work as well - functions decay into pointers, similar to arrays</span>
<span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="n">str_in</span><span class="p">);</span><span class="w"> </span><span class="c1">// Just calling the function through the pointer</span>
<span class="w">  </span><span class="c1">// f(str_in); // That&#39;s an alternative but equally valid syntax for calling it.</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">As long as function signatures match, you can assign any function to the same pointer.</span>
<span class="cm">Function pointers are usually typedef&#39;d for simplicity and readability, as follows:</span>
<span class="cm">*/</span>

<span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">my_fnp_type</span><span class="p">)(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>

<span class="c1">// Then used when declaring the actual pointer variable:</span>
<span class="c1">// ...</span>
<span class="c1">// my_fnp_type f;</span>


<span class="c1">/////////////////////////////</span>
<span class="c1">// Printing characters with printf()</span>
<span class="c1">/////////////////////////////</span>

<span class="c1">//Special characters:</span>
<span class="cm">/*</span>
<span class="cm">&#39;\a&#39;; // alert (bell) character</span>
<span class="cm">&#39;\n&#39;; // newline character</span>
<span class="cm">&#39;\t&#39;; // tab character (left justifies text)</span>
<span class="cm">&#39;\v&#39;; // vertical tab</span>
<span class="cm">&#39;\f&#39;; // new page (form feed)</span>
<span class="cm">&#39;\r&#39;; // carriage return</span>
<span class="cm">&#39;\b&#39;; // backspace character</span>
<span class="cm">&#39;\0&#39;; // NULL character. Usually put at end of strings in C.</span>
<span class="cm">//   hello\n\0. \0 used by convention to mark end of string.</span>
<span class="cm">&#39;\\&#39;; // backslash</span>
<span class="cm">&#39;\?&#39;; // question mark</span>
<span class="cm">&#39;\&#39;&#39;; // single quote</span>
<span class="cm">&#39;\&quot;&#39;; // double quote</span>
<span class="cm">&#39;\xhh&#39;; // hexadecimal number. Example: &#39;\xb&#39; = vertical tab character</span>
<span class="cm">&#39;\0oo&#39;; // octal number. Example: &#39;\013&#39; = vertical tab character</span>

<span class="cm">//print formatting:</span>
<span class="cm">&quot;%d&quot;;    // integer</span>
<span class="cm">&quot;%3d&quot;;   // integer with minimum of length 3 digits (right justifies text)</span>
<span class="cm">&quot;%s&quot;;    // string</span>
<span class="cm">&quot;%f&quot;;    // float</span>
<span class="cm">&quot;%ld&quot;;   // long</span>
<span class="cm">&quot;%3.2f&quot;; // minimum 3 digits left and 2 digits right decimal float</span>
<span class="cm">&quot;%7.4s&quot;; // (can do with strings too)</span>
<span class="cm">&quot;%c&quot;;    // char</span>
<span class="cm">&quot;%p&quot;;    // pointer. NOTE: need to (void *)-cast the pointer, before passing</span>
<span class="cm">         //                it as an argument to `printf`.</span>
<span class="cm">&quot;%x&quot;;    // hexadecimal</span>
<span class="cm">&quot;%o&quot;;    // octal</span>
<span class="cm">&quot;%%&quot;;    // prints %</span>
<span class="cm">*/</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Order of Evaluation</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// From top to bottom, top has higher precedence</span>
<span class="c1">//---------------------------------------------------//</span>
<span class="c1">//        Operators                  | Associativity //</span>
<span class="c1">//---------------------------------------------------//</span>
<span class="c1">// () [] -&gt; .                        | left to right //</span>
<span class="c1">// ! ~ ++ -- + = *(type) sizeof      | right to left //</span>
<span class="c1">// * / %                             | left to right //</span>
<span class="c1">// + -                               | left to right //</span>
<span class="c1">// &lt;&lt; &gt;&gt;                             | left to right //</span>
<span class="c1">// &lt; &lt;= &gt; &gt;=                         | left to right //</span>
<span class="c1">// == !=                             | left to right //</span>
<span class="c1">// &amp;                                 | left to right //</span>
<span class="c1">// ^                                 | left to right //</span>
<span class="c1">// |                                 | left to right //</span>
<span class="c1">// &amp;&amp;                                | left to right //</span>
<span class="c1">// ||                                | left to right //</span>
<span class="c1">// ?:                                | right to left //</span>
<span class="c1">// = += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;= | right to left //</span>
<span class="c1">// ,                                 | left to right //</span>
<span class="c1">//---------------------------------------------------//</span>

<span class="cm">/******************************* Header Files **********************************</span>

<span class="cm">Header files are an important part of C as they allow for the connection of C</span>
<span class="cm">source files and can simplify code and definitions by separating them into</span>
<span class="cm">separate files.</span>

<span class="cm">Header files are syntactically similar to C source files but reside in &quot;.h&quot;</span>
<span class="cm">files. They can be included in your C source file by using the precompiler</span>
<span class="cm">command #include &quot;example.h&quot;, given that example.h exists in the same directory</span>
<span class="cm">as the C file.</span>
<span class="cm">*/</span>

<span class="cm">/* A safe guard to prevent the header from being defined too many times. This */</span>
<span class="cm">/* happens in the case of circle dependency, the contents of the header is    */</span>
<span class="cm">/* already defined.                                                           */</span>
<span class="cp">#ifndef EXAMPLE_H </span><span class="cm">/* if EXAMPLE_H is not yet defined. */</span>
<span class="cp">#define EXAMPLE_H </span><span class="cm">/* Define the macro EXAMPLE_H. */</span>

<span class="cm">/* Other headers can be included in headers and therefore transitively */</span>
<span class="cm">/* included into files that include this header.                       */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>

<span class="cm">/* Like for c source files, macros can be defined in headers */</span>
<span class="cm">/* and used in files that include this header file.          */</span>
<span class="cp">#define EXAMPLE_NAME &quot;Dennis Ritchie&quot;</span>

<span class="cm">/* Function macros can also be defined.  */</span>
<span class="cp">#define ADD(a, b) ((a) + (b))</span>

<span class="cm">/* Notice the parenthesis surrounding the arguments -- this is important to   */</span>
<span class="cm">/* ensure that a and b don&#39;t get expanded in an unexpected way (e.g. consider */</span>
<span class="cm">/* MUL(x, y) (x * y); MUL(1 + 2, 3) would expand to (1 + 2 * 3), yielding an  */</span>
<span class="cm">/* incorrect result)                                                          */</span>

<span class="cm">/* Structs and typedefs can be used for consistency between files. */</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Node</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Node</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">Node</span><span class="p">;</span>

<span class="cm">/* So can enumerations. */</span>
<span class="k">enum</span><span class="w"> </span><span class="n">traffic_light_state</span><span class="w"> </span><span class="p">{</span><span class="n">GREEN</span><span class="p">,</span><span class="w"> </span><span class="n">YELLOW</span><span class="p">,</span><span class="w"> </span><span class="n">RED</span><span class="p">};</span>

<span class="cm">/* Function prototypes can also be defined here for use in multiple files,  */</span>
<span class="cm">/* but it is bad practice to define the function in the header. Definitions */</span>
<span class="cm">/* should instead be put in a C file.                                       */</span>
<span class="n">Node</span><span class="w"> </span><span class="nf">createLinkedList</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">vals</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>

<span class="cm">/* Beyond the above elements, other definitions should be left to a C source */</span>
<span class="cm">/* file. Excessive includes or definitions should also not be contained in   */</span>
<span class="cm">/* a header file but instead put into separate headers or a C file.          */</span>

<span class="cp">#endif </span><span class="cm">/* End of the if precompiler directive. */</span>
</pre></div>
<h2>Further Reading</h2>

<p>Best to find yourself a copy of <a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">K&amp;R, aka &ldquo;The C Programming Language&rdquo;</a>. It is <em>the</em> book about C, written by Dennis Ritchie, the creator of C, and Brian Kernighan. Be careful, though - it&rsquo;s ancient and it contains some
inaccuracies (well, ideas that are not considered good anymore) or now-changed practices.</p>

<p>Another good resource is <a href="http://learncodethehardway.org/c/">Learn C The Hard Way</a> (not free).</p>

<p>If you have a question, read the <a href="http://c-faq.com">compl.lang.c Frequently Asked Questions</a>.</p>

<p>It&rsquo;s very important to use proper spacing, indentation and to be consistent with your coding style in general.
Readable code is better than clever code and fast code. For a good, sane coding style to adopt, see the
<a href="https://www.kernel.org/doc/Documentation/process/coding-style.rst">Linux kernel coding style</a>.</p>

<p>[1] <a href="https://stackoverflow.com/questions/119123/why-isnt-sizeof-for-a-struct-equal-to-the-sum-of-sizeof-of-each-member">Why isn&rsquo;t sizeof for a struct equal to the sum of sizeof of each member?</a></p>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/c.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by Adam Bard, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/c.html.markdown">50 contributors</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://adambard.com/">Adam Bard</a>,
        <a href="http://twitter.com/H2CO3_iOS">Árpád Goretity</a>,
        <a href="http://cbs.stgn.pl">Jakub Trzebiatowski</a>,
        <a href="https://marcoms.github.io">Marco Scannadinari</a>,
        <a href="https://github.io/zfergus2">Zachary Ferguson</a>,
        <a href="https://github.com/himanshu81494">himanshu</a>,
        <a href="https://github.com/JoshuaRLi">Joshua Li</a>,
        <a href="https://github.com/dchirila">Dragos B. Chirila</a>,
        <a href="https://github.com/heitorPB/">Heitor P. de Bittencourt</a>
    </p>

    <p>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
