<!DOCTYPE html lang="en-us" xml:lang="en-us" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="en-us">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn C in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/c/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fc%2F&text=Learn+X+in+Y+minutes%2C+where+X%3DC">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="/">Learn X in Y minutes</a></h1>
  <h2>Where X=C</h2>
    <p class="filelink">
    Get the code:
    <a href="/docs/files/learnc.c">learnc.c</a>
    </p>
  <div id="doc">
    <p>Ah, C. Still <strong>the</strong> language of modern high-performance computing.</p>

<p>C is the lowest-level language most programmers will ever use, but
it more than makes up for it with raw speed. Just be aware of its manual
memory management and C will take you as far as you need to go.</p>

<blockquote>
<p><strong>About compiler flags</strong></p>

<p>By default, gcc and clang are pretty quiet about compilation warnings and
errors, which can be very useful information. Explicitly using stricter
compiler flags is recommended. Here are some recommended defaults:</p>

<p><code>-Wall -Wextra -Werror -O2 -std=c99 -pedantic</code></p>

<p>For information on what these flags do as well as other flags, consult the man page for your C compiler (e.g. <code>man 1 gcc</code>) or just search online.</p>
</blockquote>
<div class="highlight"><pre class="highlight c"><code><span class="c1">// Single-line comments start with // - only available in C99 and later.</span>

<span class="cm">/*
Multi-line comments look like this. They work in C89 as well.
*/</span>

<span class="cm">/*
Multi-line comments don't nest /* Be careful */</span>  <span class="c1">// comment ends on this line...</span>
<span class="err">*/</span> <span class="c1">// ...not this one!</span>

<span class="c1">// Constants: #define &lt;keyword&gt;</span>
<span class="c1">// Constants are written in all-caps out of convention, not requirement</span>
<span class="cp">#define DAYS_IN_YEAR 365
</span>
<span class="c1">// Enumeration constants are also ways to declare constants.</span>
<span class="c1">// All statements must end with a semicolon</span>
<span class="k">enum</span> <span class="n">days</span> <span class="p">{</span><span class="n">SUN</span><span class="p">,</span> <span class="n">MON</span><span class="p">,</span> <span class="n">TUE</span><span class="p">,</span> <span class="n">WED</span><span class="p">,</span> <span class="n">THU</span><span class="p">,</span> <span class="n">FRI</span><span class="p">,</span> <span class="n">SAT</span><span class="p">};</span>
<span class="c1">// SUN gets 0, MON gets 1, TUE gets 2, etc.</span>

<span class="c1">// Enumeration values can also be specified</span>
<span class="k">enum</span> <span class="n">days</span> <span class="p">{</span><span class="n">SUN</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MON</span><span class="p">,</span> <span class="n">TUE</span><span class="p">,</span> <span class="n">WED</span> <span class="o">=</span> <span class="mi">99</span><span class="p">,</span> <span class="n">THU</span><span class="p">,</span> <span class="n">FRI</span><span class="p">,</span> <span class="n">SAT</span><span class="p">};</span>
<span class="c1">// MON gets 2 automatically, TUE gets 3, etc.</span>
<span class="c1">// WED get 99, THU gets 100, FRI gets 101, etc.</span>

<span class="c1">// Import headers with #include</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="c1">// File names between &lt;angle brackets&gt; tell the compiler to look in your system</span>
<span class="c1">// libraries for the headers.</span>
<span class="c1">// For your own headers, use double quotes instead of angle brackets, and</span>
<span class="c1">// provide the path:</span>
<span class="cp">#include</span> <span class="cpf">"my_header.h"</span><span class="c1">      // local file</span><span class="cp">
#include</span> <span class="cpf">"../my_lib/my_lib_header.h"</span><span class="c1"> //relative path</span><span class="cp">
</span>
<span class="c1">// Declare function signatures in advance in a .h file, or at the top of</span>
<span class="c1">// your .c file.</span>
<span class="kt">void</span> <span class="nf">function_1</span><span class="p">();</span>
<span class="kt">int</span> <span class="nf">function_2</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="c1">// At a minimum, you must declare a 'function prototype' before its use in any function.</span>
<span class="c1">// Normally, prototypes are placed at the top of a file before any function definition.</span>
<span class="kt">int</span> <span class="nf">add_two_ints</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">);</span> <span class="c1">// function prototype</span>
<span class="c1">// although `int add_two_ints(int, int);` is also valid (no need to name the args),</span>
<span class="c1">// it is recommended to name arguments in the prototype as well for easier inspection</span>

<span class="c1">// Function prototypes are not necessary if the function definition comes before</span>
<span class="c1">// any other function that calls that function. However, it's standard practice to</span>
<span class="c1">// always add the function prototype to a header file (*.h) and then #include that</span>
<span class="c1">// file at the top. This prevents any issues where a function might be called</span>
<span class="c1">// before the compiler knows of its existence, while also giving the developer a</span>
<span class="c1">// clean header file to share with the rest of the project.</span>

<span class="c1">// Your program's entry point is a function called "main". The return type can</span>
<span class="c1">// be anything, however most operating systems expect a return type of `int` for</span>
<span class="c1">// error code processing.</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// your program</span>
<span class="p">}</span>

<span class="c1">// The command line arguments used to run your program are also passed to main</span>
<span class="c1">// argc being the number of arguments - your program's name counts as 1</span>
<span class="c1">// argv is an array of character arrays - containing the arguments themselves</span>
<span class="c1">// argv[0] = name of your program, argv[1] = first argument, etc.</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// print output using printf, for "print formatted"</span>
  <span class="c1">// %d is an integer, \n is a newline</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// =&gt; Prints 0</span>

  <span class="c1">// take input using scanf</span>
  <span class="c1">// '&amp;' is used to define the location</span>
  <span class="c1">// where we want to store the input value</span>
  <span class="kt">int</span> <span class="n">input</span><span class="p">;</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">input</span><span class="p">);</span>

  <span class="c1">///////////////////////////////////////</span>
  <span class="c1">// Types</span>
  <span class="c1">///////////////////////////////////////</span>

  <span class="c1">// Compilers that are not C99-compliant require that variables MUST be</span>
  <span class="c1">// declared at the top of the current block scope.</span>
  <span class="c1">// Compilers that ARE C99-compliant allow declarations near the point where</span>
  <span class="c1">// the value is used.</span>
  <span class="c1">// For the sake of the tutorial, variables are declared dynamically under</span>
  <span class="c1">// C99-compliant standards.</span>

  <span class="c1">// ints are usually 4 bytes (use the `sizeof` operator to check)</span>
  <span class="kt">int</span> <span class="n">x_int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// shorts are usually 2 bytes (use the `sizeof` operator to check)</span>
  <span class="kt">short</span> <span class="n">x_short</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// chars are defined as the smallest addressable unit for a processor.</span>
  <span class="c1">// This is usually 1 byte, but for some systems it can be more (ex. for TMS320 from TI it's 2 bytes).</span>
  <span class="kt">char</span> <span class="n">x_char</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">y_char</span> <span class="o">=</span> <span class="sc">'y'</span><span class="p">;</span> <span class="c1">// Char literals are quoted with ''</span>

  <span class="c1">// longs are often 4 to 8 bytes; long longs are guaranteed to be at least</span>
  <span class="c1">// 8 bytes</span>
  <span class="kt">long</span> <span class="n">x_long</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">long</span> <span class="kt">long</span> <span class="n">x_long_long</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// floats are usually 32-bit floating point numbers</span>
  <span class="kt">float</span> <span class="n">x_float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span> <span class="c1">// 'f' suffix here denotes floating point literal</span>

  <span class="c1">// doubles are usually 64-bit floating-point numbers</span>
  <span class="kt">double</span> <span class="n">x_double</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span> <span class="c1">// real numbers without any suffix are doubles</span>

  <span class="c1">// integer types may be unsigned (greater than or equal to zero)</span>
  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ux_short</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ux_int</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ux_long_long</span><span class="p">;</span>

  <span class="c1">// chars inside single quotes are integers in machine's character set.</span>
  <span class="sc">'0'</span><span class="p">;</span> <span class="c1">// =&gt; 48 in the ASCII character set.</span>
  <span class="sc">'A'</span><span class="p">;</span> <span class="c1">// =&gt; 65 in the ASCII character set.</span>

  <span class="c1">// sizeof(T) gives you the size of a variable with type T in bytes</span>
  <span class="c1">// sizeof(obj) yields the size of the expression (variable, literal, etc.).</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span> <span class="c1">// =&gt; 4 (on most machines with 4-byte words)</span>

  <span class="c1">// If the argument of the `sizeof` operator is an expression, then its argument</span>
  <span class="c1">// is not evaluated (except VLAs (see below)).</span>
  <span class="c1">// The value it yields in this case is a compile-time constant.</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="c1">// size_t is an unsigned integer type of at least 2 bytes used to represent</span>
  <span class="c1">// the size of an object.</span>
  <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="o">++</span><span class="p">);</span> <span class="c1">// a++ is not evaluated</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"sizeof(a++) = %zu where a = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
  <span class="c1">// prints "sizeof(a++) = 4 where a = 1" (on a 32-bit architecture)</span>

  <span class="c1">// Arrays must be initialized with a concrete size.</span>
  <span class="kt">char</span> <span class="n">my_char_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span> <span class="c1">// This array occupies 1 * 20 = 20 bytes</span>
  <span class="kt">int</span> <span class="n">my_int_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span> <span class="c1">// This array occupies 4 * 20 = 80 bytes</span>
  <span class="c1">// (assuming 4-byte words)</span>

  <span class="c1">// You can initialize an array of twenty ints that all equal 0 thusly:</span>
  <span class="kt">int</span> <span class="n">my_array</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
  <span class="c1">// where the "{0}" part is called an "array initializer".</span>
  <span class="c1">// All elements (if any) past the ones in the initializer are initialized to 0:</span>
  <span class="kt">int</span> <span class="n">my_array</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
  <span class="c1">// So my_array now has five elements, all but the first two of which are 0:</span>
  <span class="c1">// [1, 2, 0, 0, 0]</span>
  <span class="c1">// NOTE that you get away without explicitly declaring the size</span>
  <span class="c1">// of the array IF you initialize the array on the same line:</span>
  <span class="kt">int</span> <span class="n">my_array</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
  <span class="c1">// NOTE that, when not declaring the size, the size of the array is the number</span>
  <span class="c1">// of elements in the initializer. With "{0}", my_array is now of size one: [0]</span>
  <span class="c1">// To evaluate the size of the array at run-time, divide its byte size by the</span>
  <span class="c1">// byte size of its element type:</span>
  <span class="kt">size_t</span> <span class="n">my_array_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_array</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="c1">// WARNING You should evaluate the size *before* you begin passing the array</span>
  <span class="c1">// to functions (see later discussion) because arrays get "downgraded" to</span>
  <span class="c1">// raw pointers when they are passed to functions (so the statement above</span>
  <span class="c1">// will produce the wrong result inside the function).</span>

  <span class="c1">// Indexing an array is like other languages -- or,</span>
  <span class="c1">// rather, other languages are like C</span>
  <span class="n">my_array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// =&gt; 0</span>

  <span class="c1">// Arrays are mutable; it's just memory!</span>
  <span class="n">my_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">my_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// =&gt; 2</span>

  <span class="c1">// In C99 (and as an optional feature in C11), variable-length arrays (VLAs)</span>
  <span class="c1">// can be declared as well. The size of such an array need not be a compile</span>
  <span class="c1">// time constant:</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Enter the array size: "</span><span class="p">);</span> <span class="c1">// ask the user for an array size</span>
  <span class="kt">int</span> <span class="n">array_size</span><span class="p">;</span>
  <span class="n">fscanf</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">array_size</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">var_length_array</span><span class="p">[</span><span class="n">array_size</span><span class="p">];</span> <span class="c1">// declare the VLA</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"sizeof array = %zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">var_length_array</span><span class="p">);</span>

  <span class="c1">// Example:</span>
  <span class="c1">// &gt; Enter the array size: 10</span>
  <span class="c1">// &gt; sizeof array = 40</span>

  <span class="c1">// Strings are just arrays of chars terminated by a NULL (0x00) byte,</span>
  <span class="c1">// represented in strings as the special character '\0'.</span>
  <span class="c1">// (We don't have to include the NULL byte in string literals; the compiler</span>
  <span class="c1">//  inserts it at the end of the array for us.)</span>
  <span class="kt">char</span> <span class="n">a_string</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="s">"This is a string"</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a_string</span><span class="p">);</span> <span class="c1">// %s formats a string</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a_string</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span> <span class="c1">// =&gt; 0</span>
  <span class="c1">// i.e., byte #17 is 0 (as are 18, 19, and 20)</span>

  <span class="c1">// If we have characters between single quotes, that's a character literal.</span>
  <span class="c1">// It's of type `int`, and *not* `char` (for historical reasons).</span>
  <span class="kt">int</span> <span class="n">cha</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span> <span class="c1">// fine</span>
  <span class="kt">char</span> <span class="n">chb</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span> <span class="c1">// fine too (implicit conversion from int to char)</span>

  <span class="c1">// Multi-dimensional arrays:</span>
  <span class="kt">int</span> <span class="n">multi_array</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">},</span>
    <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
  <span class="p">};</span>
  <span class="c1">// access elements:</span>
  <span class="kt">int</span> <span class="n">array_int</span> <span class="o">=</span> <span class="n">multi_array</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// =&gt; 3</span>

  <span class="c1">///////////////////////////////////////</span>
  <span class="c1">// Operators</span>
  <span class="c1">///////////////////////////////////////</span>

  <span class="c1">// Shorthands for multiple declarations:</span>
  <span class="kt">int</span> <span class="n">i1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">f1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">f2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// Arithmetic is straightforward</span>
  <span class="n">i1</span> <span class="o">+</span> <span class="n">i2</span><span class="p">;</span> <span class="c1">// =&gt; 3</span>
  <span class="n">i2</span> <span class="o">-</span> <span class="n">i1</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>
  <span class="n">i2</span> <span class="o">*</span> <span class="n">i1</span><span class="p">;</span> <span class="c1">// =&gt; 2</span>
  <span class="n">i1</span> <span class="o">/</span> <span class="n">i2</span><span class="p">;</span> <span class="c1">// =&gt; 0 (0.5, but truncated towards 0)</span>

  <span class="c1">// You need to cast at least one integer to float to get a floating-point result</span>
  <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">i1</span> <span class="o">/</span> <span class="n">i2</span><span class="p">;</span> <span class="c1">// =&gt; 0.5f</span>
  <span class="n">i1</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">i2</span><span class="p">;</span> <span class="c1">// =&gt; 0.5 // Same with double</span>
  <span class="n">f1</span> <span class="o">/</span> <span class="n">f2</span><span class="p">;</span> <span class="c1">// =&gt; 0.5, plus or minus epsilon</span>

  <span class="c1">// Floating-point numbers are defined by IEEE 754, thus cannot store perfectly</span>
  <span class="c1">// exact values. For instance, the following does not produce expected results</span>
  <span class="c1">// because 0.1 might actually be 0.099999999999 inside the computer, and 0.3</span>
  <span class="c1">// might be stored as 0.300000000001.</span>
  <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">3</span><span class="p">;</span> <span class="c1">// =&gt; 1 (true)</span>
  <span class="c1">// and it is NOT associative due to reasons mentioned above.</span>
  <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1e123</span> <span class="o">-</span> <span class="mf">1e123</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">1e123</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1e123</span><span class="p">;</span> <span class="c1">// =&gt; 1 (true)</span>
  <span class="c1">// this notation is scientific notations for numbers: 1e123 = 1*10^123</span>

  <span class="c1">// It is important to note that most all systems have used IEEE 754 to</span>
  <span class="c1">// represent floating points. Even python, used for scientific computing,</span>
  <span class="c1">// eventually calls C which uses IEEE 754. It is mentioned this way not to</span>
  <span class="c1">// indicate that this is a poor implementation, but instead as a warning</span>
  <span class="c1">// that when doing floating point comparisons, a little bit of error (epsilon)</span>
  <span class="c1">// needs to be considered.</span>

  <span class="c1">// Modulo is there as well, but be careful if arguments are negative</span>
  <span class="mi">11</span> <span class="o">%</span> <span class="mi">3</span><span class="p">;</span>    <span class="c1">// =&gt; 2 as 11 = 2 + 3*x (x=3)</span>
  <span class="p">(</span><span class="o">-</span><span class="mi">11</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// =&gt; -2, as one would expect</span>
  <span class="mi">11</span> <span class="o">%</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// =&gt; 2 and not -2, and it's quite counter intuitive</span>

  <span class="c1">// Comparison operators are probably familiar, but</span>
  <span class="c1">// there is no Boolean type in C. We use ints instead.</span>
  <span class="c1">// (C99 introduced the _Bool type provided in stdbool.h)</span>
  <span class="c1">// 0 is false, anything else is true. (The comparison</span>
  <span class="c1">// operators always yield 0 or 1.)</span>
  <span class="mi">3</span> <span class="o">==</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 0 (false)</span>
  <span class="mi">3</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 1 (true)</span>
  <span class="mi">3</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// =&gt; 1</span>
  <span class="mi">3</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// =&gt; 0</span>
  <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>
  <span class="mi">2</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>

  <span class="c1">// C is not Python - comparisons do NOT chain.</span>
  <span class="c1">// Warning: The line below will compile, but it means `(0 &lt; a) &lt; 2`.</span>
  <span class="c1">// This expression is always true, because (0 &lt; a) could be either 1 or 0.</span>
  <span class="c1">// In this case it's 1, because (0 &lt; 1).</span>
  <span class="kt">int</span> <span class="n">between_0_and_2</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span>
  <span class="c1">// Instead use:</span>
  <span class="kt">int</span> <span class="n">between_0_and_2</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span>

  <span class="c1">// Logic works on ints</span>
  <span class="o">!</span><span class="mi">3</span><span class="p">;</span> <span class="c1">// =&gt; 0 (Logical not)</span>
  <span class="o">!</span><span class="mi">0</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>
  <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 1 (Logical and)</span>
  <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 0</span>
  <span class="mi">0</span> <span class="o">||</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 1 (Logical or)</span>
  <span class="mi">0</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// =&gt; 0</span>

  <span class="c1">// Conditional ternary expression ( ? : )</span>
  <span class="kt">int</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">z</span><span class="p">;</span>
  <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">e</span> <span class="o">&gt;</span> <span class="n">f</span><span class="p">)</span> <span class="o">?</span> <span class="n">e</span> <span class="o">:</span> <span class="n">f</span><span class="p">;</span> <span class="c1">// =&gt; 10 "if e &gt; f return e, else return f."</span>

  <span class="c1">// Increment and decrement operators:</span>
  <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">j</span><span class="o">++</span><span class="p">;</span> <span class="c1">// Return j THEN increase j. (s = 0, j = 1)</span>
  <span class="n">s</span> <span class="o">=</span> <span class="o">++</span><span class="n">j</span><span class="p">;</span> <span class="c1">// Increase j THEN return j. (s = 2, j = 2)</span>
  <span class="c1">// same with j-- and --j</span>

  <span class="c1">// Bitwise operators!</span>
  <span class="o">~</span><span class="mh">0x0F</span><span class="p">;</span> <span class="c1">// =&gt; 0xFFFFFFF0 (bitwise negation, "1's complement", example result for 32-bit int)</span>
  <span class="mh">0x0F</span> <span class="o">&amp;</span> <span class="mh">0xF0</span><span class="p">;</span> <span class="c1">// =&gt; 0x00 (bitwise AND)</span>
  <span class="mh">0x0F</span> <span class="o">|</span> <span class="mh">0xF0</span><span class="p">;</span> <span class="c1">// =&gt; 0xFF (bitwise OR)</span>
  <span class="mh">0x04</span> <span class="o">^</span> <span class="mh">0x0F</span><span class="p">;</span> <span class="c1">// =&gt; 0x0B (bitwise XOR)</span>
  <span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 0x02 (bitwise left shift (by 1))</span>
  <span class="mh">0x02</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 0x01 (bitwise right shift (by 1))</span>

  <span class="c1">// Be careful when shifting signed integers - the following are undefined:</span>
  <span class="c1">// - shifting into the sign bit of a signed integer (int a = 1 &lt;&lt; 31)</span>
  <span class="c1">// - left-shifting a negative number (int a = -1 &lt;&lt; 2)</span>
  <span class="c1">// - shifting by an offset which is &gt;= the width of the type of the LHS:</span>
  <span class="c1">//   int a = 1 &lt;&lt; 32; // UB if int is 32 bits wide</span>

  <span class="c1">///////////////////////////////////////</span>
  <span class="c1">// Control Structures</span>
  <span class="c1">///////////////////////////////////////</span>

  <span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"I am never run</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"I am also never run</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"I print</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// While loops exist</span>
  <span class="kt">int</span> <span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">ii</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//ANY value less than ten is true.</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d, "</span><span class="p">,</span> <span class="n">ii</span><span class="o">++</span><span class="p">);</span> <span class="c1">// ii++ increments ii AFTER using its current value.</span>
  <span class="p">}</span> <span class="c1">// =&gt; prints "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">kk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d, "</span><span class="p">,</span> <span class="n">kk</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">kk</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">);</span> <span class="c1">// ++kk increments kk BEFORE using its current value.</span>
  <span class="c1">// =&gt; prints "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

  <span class="c1">// For loops too</span>
  <span class="kt">int</span> <span class="n">jj</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">jj</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">jj</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">jj</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d, "</span><span class="p">,</span> <span class="n">jj</span><span class="p">);</span>
  <span class="p">}</span> <span class="c1">// =&gt; prints "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

  <span class="c1">// *****NOTES*****:</span>
  <span class="c1">// Loops and Functions MUST have a body. If no body is needed:</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">;</span> <span class="c1">// use semicolon to act as the body (null statement)</span>
  <span class="p">}</span>
  <span class="c1">// Or</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">);</span>

  <span class="c1">// branching with multiple choices: switch()</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="mi">0</span><span class="p">:</span> <span class="c1">// labels need to be integral *constant* expressions (such as enums)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Hey, 'a' equals 0!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span> <span class="c1">// if you don't break, control flow falls over labels</span>
  <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Huh, 'a' equals 1!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
    <span class="c1">// Be careful - without a "break", execution continues until the</span>
    <span class="c1">// next "break" is reached.</span>
  <span class="k">case</span> <span class="mi">3</span><span class="p">:</span>
  <span class="k">case</span> <span class="mi">4</span><span class="p">:</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Look at that.. 'a' is either 3, or 4</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="nl">default:</span>
    <span class="c1">// if `some_integral_expression` didn't match any of the labels</span>
    <span class="n">fputs</span><span class="p">(</span><span class="s">"Error!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/*
    Using "goto" in C
  */</span>
  <span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span> <span class="p">}</span> <span class="n">bool</span><span class="p">;</span>
  <span class="c1">// for C don't have bool as data type before C99 :(</span>
  <span class="n">bool</span> <span class="n">disaster</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">150</span><span class="p">)</span>
        <span class="n">disaster</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">disaster</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>  <span class="c1">// exit both for loops</span>
  <span class="p">}</span>
  <span class="nl">error:</span> <span class="c1">// this is a label that you can "jump" to with "goto error;"</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Error occurred at i = %d &amp; j = %d.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
  <span class="cm">/*
    https://ideone.com/GuPhd6
    this will print out "Error occurred at i = 51 &amp; j = 99."
  */</span>
  <span class="cm">/*
    it is generally considered bad practice to do so, except if
    you really know what you are doing. See
    https://en.wikipedia.org/wiki/Spaghetti_code#Meaning
  */</span>

  <span class="c1">///////////////////////////////////////</span>
  <span class="c1">// Typecasting</span>
  <span class="c1">///////////////////////////////////////</span>

  <span class="c1">// Every value in C has a type, but you can cast one value into another type</span>
  <span class="c1">// if you want (with some constraints).</span>

  <span class="kt">int</span> <span class="n">x_hex</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span> <span class="c1">// You can assign vars with hex literals</span>
                    <span class="c1">// binary is not in the standard, but allowed by some</span>
                    <span class="c1">// compilers (x_bin = 0b0010010110)</span>

  <span class="c1">// Casting between types will attempt to preserve their numeric values</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x_hex</span><span class="p">);</span> <span class="c1">// =&gt; Prints 1</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">short</span><span class="p">)</span> <span class="n">x_hex</span><span class="p">);</span> <span class="c1">// =&gt; Prints 1</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="n">x_hex</span><span class="p">);</span> <span class="c1">// =&gt; Prints 1</span>

  <span class="c1">// If you assign a value greater than a types max val, it will rollover</span>
  <span class="c1">// without warning.</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="mi">257</span><span class="p">);</span> <span class="c1">// =&gt; 1 (Max char = 255 if char is 8 bits long)</span>

  <span class="c1">// For determining the max value of a `char`, a `signed char` and an `unsigned char`,</span>
  <span class="c1">// respectively, use the CHAR_MAX, SCHAR_MAX and UCHAR_MAX macros from &lt;limits.h&gt;</span>

  <span class="c1">// Integral types can be cast to floating-point types, and vice-versa.</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="mi">100</span><span class="p">);</span> <span class="c1">// %f always formats a double...</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span>  <span class="mi">100</span><span class="p">);</span> <span class="c1">// ...even with a float.</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mi">100</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>

  <span class="c1">///////////////////////////////////////</span>
  <span class="c1">// Pointers</span>
  <span class="c1">///////////////////////////////////////</span>

  <span class="c1">// A pointer is a variable declared to store a memory address. Its declaration will</span>
  <span class="c1">// also tell you the type of data it points to. You can retrieve the memory address</span>
  <span class="c1">// of your variables, then mess with them.</span>

  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span> <span class="c1">// Use &amp; to retrieve the address of a variable</span>
  <span class="c1">// (%p formats an object pointer of type void *)</span>
  <span class="c1">// =&gt; Prints some address in memory;</span>

  <span class="c1">// Pointers start with * in their declaration</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">px</span><span class="p">,</span> <span class="n">not_a_pointer</span><span class="p">;</span> <span class="c1">// px is a pointer to an int</span>
  <span class="n">px</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span> <span class="c1">// Stores the address of x in px</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">px</span><span class="p">);</span> <span class="c1">// =&gt; Prints some address in memory</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%zu, %zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">px</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">not_a_pointer</span><span class="p">));</span>
  <span class="c1">// =&gt; Prints "8, 4" on a typical 64-bit system</span>

  <span class="c1">// To retrieve the value at the address a pointer is pointing to,</span>
  <span class="c1">// put * in front to dereference it.</span>
  <span class="c1">// Note: yes, it may be confusing that '*' is used for _both_ declaring a</span>
  <span class="c1">// pointer and dereferencing it.</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">px</span><span class="p">);</span> <span class="c1">// =&gt; Prints 0, the value of x</span>

  <span class="c1">// You can also change the value the pointer is pointing to.</span>
  <span class="c1">// We'll have to wrap the dereference in parenthesis because</span>
  <span class="c1">// ++ has a higher precedence than *.</span>
  <span class="p">(</span><span class="o">*</span><span class="n">px</span><span class="p">)</span><span class="o">++</span><span class="p">;</span> <span class="c1">// Increment the value px is pointing to by 1</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">px</span><span class="p">);</span> <span class="c1">// =&gt; Prints 1</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// =&gt; Prints 1</span>

  <span class="c1">// Arrays are a good way to allocate a contiguous block of memory</span>
  <span class="kt">int</span> <span class="n">x_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span> <span class="c1">//declares array of size 20 (cannot change size)</span>
  <span class="kt">int</span> <span class="n">xx</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">xx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">xx</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">xx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x_array</span><span class="p">[</span><span class="n">xx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">-</span> <span class="n">xx</span><span class="p">;</span>
  <span class="p">}</span> <span class="c1">// Initialize x_array to 20, 19, 18,... 2, 1</span>

  <span class="c1">// Declare a pointer of type int and initialize it to point to x_array</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">x_ptr</span> <span class="o">=</span> <span class="n">x_array</span><span class="p">;</span>
  <span class="c1">// x_ptr now points to the first element in the array (the integer 20).</span>
  <span class="c1">// This works because arrays often decay into pointers to their first element.</span>
  <span class="c1">// For example, when an array is passed to a function or is assigned to a pointer,</span>
  <span class="c1">// it decays into (implicitly converted to) a pointer.</span>
  <span class="c1">// Exceptions: when the array is the argument of the `&amp;` (address-of) operator:</span>
  <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr_to_arr</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">;</span> <span class="c1">// &amp;arr is NOT of type `int *`!</span>
  <span class="c1">// It's of type "pointer to array" (of ten `int`s).</span>
  <span class="c1">// or when the array is a string literal used for initializing a char array:</span>
  <span class="kt">char</span> <span class="n">otherarr</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"foobarbazquirk"</span><span class="p">;</span>
  <span class="c1">// or when it's the argument of the `sizeof` or `alignof` operator:</span>
  <span class="kt">int</span> <span class="n">arraythethird</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">arraythethird</span><span class="p">;</span> <span class="c1">// equivalent with int *ptr = &amp;arr[0];</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%zu, %zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arraythethird</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ptr</span><span class="p">));</span>
  <span class="c1">// probably prints "40, 4" or "40, 8"</span>

  <span class="c1">// Pointers are incremented and decremented based on their type</span>
  <span class="c1">// (this is called pointer arithmetic)</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">x_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span> <span class="c1">// =&gt; Prints 19</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// =&gt; Prints 19</span>

  <span class="c1">// You can also dynamically allocate contiguous blocks of memory with the</span>
  <span class="c1">// standard library function malloc, which takes one argument of type size_t</span>
  <span class="c1">// representing the number of bytes to allocate (usually from the heap, although this</span>
  <span class="c1">// may not be true on e.g. embedded systems - the C standard says nothing about it).</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">my_ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">my_ptr</span><span class="p">)</span> <span class="o">*</span> <span class="mi">20</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">xx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">xx</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">xx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="p">(</span><span class="n">my_ptr</span> <span class="o">+</span> <span class="n">xx</span><span class="p">)</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">-</span> <span class="n">xx</span><span class="p">;</span> <span class="c1">// my_ptr[xx] = 20-xx</span>
  <span class="p">}</span> <span class="c1">// Initialize memory to 20, 19, 18, 17... 2, 1 (as ints)</span>

  <span class="c1">// Be careful passing user-provided values to malloc! If you want</span>
  <span class="c1">// to be safe, you can use calloc instead (which, unlike malloc, also zeros out the memory)</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">my_other_ptr</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

  <span class="c1">// Note that there is no standard way to get the length of a</span>
  <span class="c1">// dynamically allocated array in C. Because of this, if your arrays are</span>
  <span class="c1">// going to be passed around your program a lot, you need another variable</span>
  <span class="c1">// to keep track of the number of elements (size) of an array. See the</span>
  <span class="c1">// functions section for more info.</span>
  <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">my_arr</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
  <span class="c1">// Add an element to the array</span>
  <span class="n">size</span><span class="o">++</span><span class="p">;</span>
  <span class="n">my_arr</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">my_arr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">size</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">my_arr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//Remember to check for realloc failure!</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="n">my_arr</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

  <span class="c1">// Dereferencing memory that you haven't allocated gives</span>
  <span class="c1">// "unpredictable results" - the program is said to invoke "undefined behavior"</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">my_ptr</span> <span class="o">+</span> <span class="mi">21</span><span class="p">));</span> <span class="c1">// =&gt; Prints who-knows-what? It may even crash.</span>

  <span class="c1">// When you're done with a malloc'd block of memory, you need to free it,</span>
  <span class="c1">// or else no one else can use it until your program terminates</span>
  <span class="c1">// (this is called a "memory leak"):</span>
  <span class="n">free</span><span class="p">(</span><span class="n">my_ptr</span><span class="p">);</span>

  <span class="c1">// Strings are arrays of char, but they are usually represented as a</span>
  <span class="c1">// pointer-to-char (which is a pointer to the first element of the array).</span>
  <span class="c1">// It's good practice to use `const char *' when referring to a string literal,</span>
  <span class="c1">// since string literals shall not be modified (i.e. "foo"[0] = 'a' is ILLEGAL.)</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">my_str</span> <span class="o">=</span> <span class="s">"This is my very own string literal"</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%c</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">my_str</span><span class="p">);</span> <span class="c1">// =&gt; 'T'</span>

  <span class="c1">// This is not the case if the string is an array</span>
  <span class="c1">// (potentially initialized with a string literal)</span>
  <span class="c1">// that resides in writable memory, as in:</span>
  <span class="kt">char</span> <span class="n">foo</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"foo"</span><span class="p">;</span>
  <span class="n">foo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span> <span class="c1">// this is legal, foo now contains "aoo"</span>

  <span class="n">function_1</span><span class="p">();</span>
<span class="p">}</span> <span class="c1">// end main function</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Functions</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// Function declaration syntax:</span>
<span class="c1">// &lt;return type&gt; &lt;function name&gt;(&lt;args&gt;)</span>

<span class="kt">int</span> <span class="nf">add_two_ints</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="p">;</span> <span class="c1">// Use return to return a value</span>
<span class="p">}</span>

<span class="cm">/*
Functions are call by value. When a function is called, the arguments passed to
the function are copies of the original arguments (except arrays). Anything you
do to the arguments in the function do not change the value of the original
argument where the function was called.

Use pointers if you need to edit the original argument values (arrays are always
passed in as pointers).

Example: in-place string reversal
*/</span>

<span class="c1">// A void function returns no value</span>
<span class="kt">void</span> <span class="nf">str_reverse</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str_in</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str_in</span><span class="p">);</span> <span class="c1">// `strlen()` is part of the c standard library</span>
                               <span class="c1">// NOTE: length returned by `strlen` DOESN'T</span>
                               <span class="c1">//       include the terminating NULL byte ('\0')</span>
  <span class="c1">// in C99 and newer versions, you can directly declare loop control variables</span>
  <span class="c1">// in the loop's parentheses. e.g., `for (size_t ii = 0; ...`</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">ii</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">str_in</span><span class="p">[</span><span class="n">ii</span><span class="p">];</span>
    <span class="n">str_in</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">str_in</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">// ii-th char from end</span>
    <span class="n">str_in</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//NOTE: string.h header file needs to be included to use strlen()</span>

<span class="cm">/*
char c[] = "This is a test.";
str_reverse(c);
printf("%s\n", c); // =&gt; ".tset a si sihT"
*/</span>
<span class="cm">/*
as we can return only one variable
to change values of more than one variables we use call by reference
*/</span>
<span class="kt">void</span> <span class="nf">swapTwoNumbers</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
    <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
    <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
int first = 10;
int second = 20;
printf("first: %d\nsecond: %d\n", first, second);
swapTwoNumbers(&amp;first, &amp;second);
printf("first: %d\nsecond: %d\n", first, second);
// values will be swapped
*/</span>

<span class="c1">// Return multiple values.</span>
<span class="c1">// C does not allow for returning multiple values with the return statement. If</span>
<span class="c1">// you would like to return multiple values, then the caller must pass in the</span>
<span class="c1">// variables where they would like the returned values to go. These variables must</span>
<span class="c1">// be passed in as pointers such that the function can modify them.</span>
<span class="kt">int</span> <span class="nf">return_multiple</span><span class="p">(</span> <span class="kt">int</span> <span class="o">*</span><span class="n">array_of_3</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ret1</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ret2</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ret3</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">array_of_3</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//return error code (false)</span>

    <span class="c1">//de-reference the pointer so we modify its value</span>
   <span class="o">*</span><span class="n">ret1</span> <span class="o">=</span> <span class="n">array_of_3</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
   <span class="o">*</span><span class="n">ret2</span> <span class="o">=</span> <span class="n">array_of_3</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
   <span class="o">*</span><span class="n">ret3</span> <span class="o">=</span> <span class="n">array_of_3</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

   <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//return error code (true)</span>
<span class="p">}</span>

<span class="cm">/*
With regards to arrays, they will always be passed to functions
as pointers. Even if you statically allocate an array like `arr[10]`,
it still gets passed as a pointer to the first element in any function calls.
Again, there is no standard way to get the size of a dynamically allocated
array in C.
*/</span>
<span class="c1">// Size must be passed!</span>
<span class="c1">// Otherwise, this function has no way of knowing how big the array is.</span>
<span class="kt">void</span> <span class="nf">printIntArray</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"arr[%d] is: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*
int my_arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
int size = 10;
printIntArray(my_arr, size);
// will print "arr[0] is: 1" etc
*/</span>

<span class="c1">// if referring to external variables outside function, you should use the extern keyword.</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">testFunc</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">extern</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span> <span class="c1">//i here is now using external variable i</span>
<span class="p">}</span>

<span class="c1">// make external variables private to source file with static:</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//other files using testFunc2() cannot access variable j</span>
<span class="kt">void</span> <span class="nf">testFunc2</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">extern</span> <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// The static keyword makes a variable inaccessible to code outside the</span>
<span class="c1">// compilation unit. (On almost all systems, a "compilation unit" is a .c</span>
<span class="c1">// file.) static can apply both to global (to the compilation unit) variables,</span>
<span class="c1">// functions, and function-local variables. When using static with</span>
<span class="c1">// function-local variables, the variable is effectively global and retains its</span>
<span class="c1">// value across function calls, but is only accessible within the function it</span>
<span class="c1">// is declared in. Additionally, static variables are initialized to 0 if not</span>
<span class="c1">// declared with some other starting value.</span>
<span class="c1">//**You may also declare functions as static to make them private**</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// User-defined types and structs</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// Typedefs can be used to create type aliases</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">my_type</span><span class="p">;</span>
<span class="n">my_type</span> <span class="n">my_type_var</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// Structs are just collections of data, the members are allocated sequentially,</span>
<span class="c1">// in the order they are written:</span>
<span class="k">struct</span> <span class="n">rectangle</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">width</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">height</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// It's not generally true that</span>
<span class="c1">// sizeof(struct rectangle) == sizeof(int) + sizeof(int)</span>
<span class="c1">// due to potential padding between the structure members (this is for alignment</span>
<span class="c1">// reasons). [1]</span>

<span class="kt">void</span> <span class="nf">function_1</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">rectangle</span> <span class="n">my_rec</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">};</span> <span class="c1">// Fields can be initialized immediately</span>

  <span class="c1">// Access struct members with .</span>
  <span class="n">my_rec</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="n">my_rec</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

  <span class="c1">// You can declare pointers to structs</span>
  <span class="k">struct</span> <span class="n">rectangle</span> <span class="o">*</span><span class="n">my_rec_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_rec</span><span class="p">;</span>

  <span class="c1">// Use dereferencing to set struct pointer members...</span>
  <span class="p">(</span><span class="o">*</span><span class="n">my_rec_ptr</span><span class="p">).</span><span class="n">width</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>

  <span class="c1">// ... or even better: prefer the -&gt; shorthand for the sake of readability</span>
  <span class="n">my_rec_ptr</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// Same as (*my_rec_ptr).height = 10;</span>
<span class="p">}</span>

<span class="c1">// You can apply a typedef to a struct for convenience</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">rectangle</span> <span class="n">rect</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">area</span><span class="p">(</span><span class="n">rect</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">r</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">r</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Typedefs can also be defined right during struct definition</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">width</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">height</span><span class="p">;</span>
<span class="p">}</span> <span class="n">rect</span><span class="p">;</span>
<span class="c1">// Like before, doing this means one can type</span>
<span class="n">rect</span> <span class="n">r</span><span class="p">;</span>
<span class="c1">// instead of having to type</span>
<span class="k">struct</span> <span class="n">rectangle</span> <span class="n">r</span><span class="p">;</span>

<span class="c1">// if you have large structs, you can pass them "by pointer" to avoid copying</span>
<span class="c1">// the whole struct:</span>
<span class="kt">int</span> <span class="nf">areaptr</span><span class="p">(</span><span class="k">const</span> <span class="n">rect</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">*</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Function pointers</span>
<span class="c1">///////////////////////////////////////</span>
<span class="cm">/*
At run time, functions are located at known memory addresses. Function pointers are
much like any other pointer (they just store a memory address), but can be used
to invoke functions directly, and to pass handlers (or callback functions) around.
However, definition syntax may be initially confusing.

Example: use str_reverse from a pointer
*/</span>
<span class="kt">void</span> <span class="nf">str_reverse_through_pointer</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str_in</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Define a function pointer variable, named f.</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span> <span class="c1">// Signature should exactly match the target function.</span>
  <span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">str_reverse</span><span class="p">;</span> <span class="c1">// Assign the address for the actual function (determined at run time)</span>
  <span class="c1">// f = str_reverse; would work as well - functions decay into pointers, similar to arrays</span>
  <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="n">str_in</span><span class="p">);</span> <span class="c1">// Just calling the function through the pointer</span>
  <span class="c1">// f(str_in); // That's an alternative but equally valid syntax for calling it.</span>
<span class="p">}</span>

<span class="cm">/*
As long as function signatures match, you can assign any function to the same pointer.
Function pointers are usually typedef'd for simplicity and readability, as follows:
*/</span>

<span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">my_fnp_type</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span>

<span class="c1">// Then used when declaring the actual pointer variable:</span>
<span class="c1">// ...</span>
<span class="c1">// my_fnp_type f;</span>


<span class="c1">/////////////////////////////</span>
<span class="c1">// Printing characters with printf()</span>
<span class="c1">/////////////////////////////</span>

<span class="c1">//Special characters:</span>
<span class="cm">/*
'\a'; // alert (bell) character
'\n'; // newline character
'\t'; // tab character (left justifies text)
'\v'; // vertical tab
'\f'; // new page (form feed)
'\r'; // carriage return
'\b'; // backspace character
'\0'; // NULL character. Usually put at end of strings in C.
//   hello\n\0. \0 used by convention to mark end of string.
'\\'; // backslash
'\?'; // question mark
'\''; // single quote
'\"'; // double quote
'\xhh'; // hexadecimal number. Example: '\xb' = vertical tab character
'\0oo'; // octal number. Example: '\013' = vertical tab character

//print formatting:
"%d";    // integer
"%3d";   // integer with minimum of length 3 digits (right justifies text)
"%s";    // string
"%f";    // float
"%ld";   // long
"%3.2f"; // minimum 3 digits left and 2 digits right decimal float
"%7.4s"; // (can do with strings too)
"%c";    // char
"%p";    // pointer. NOTE: need to (void *)-cast the pointer, before passing
         //                it as an argument to `printf`.
"%x";    // hexadecimal
"%o";    // octal
"%%";    // prints %
*/</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Order of Evaluation</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// From top to bottom, top has higher precedence</span>
<span class="c1">//---------------------------------------------------//</span>
<span class="c1">//        Operators                  | Associativity //</span>
<span class="c1">//---------------------------------------------------//</span>
<span class="c1">// () [] -&gt; .                        | left to right //</span>
<span class="c1">// ! ~ ++ -- + = *(type) sizeof      | right to left //</span>
<span class="c1">// * / %                             | left to right //</span>
<span class="c1">// + -                               | left to right //</span>
<span class="c1">// &lt;&lt; &gt;&gt;                             | left to right //</span>
<span class="c1">// &lt; &lt;= &gt; &gt;=                         | left to right //</span>
<span class="c1">// == !=                             | left to right //</span>
<span class="c1">// &amp;                                 | left to right //</span>
<span class="c1">// ^                                 | left to right //</span>
<span class="c1">// |                                 | left to right //</span>
<span class="c1">// &amp;&amp;                                | left to right //</span>
<span class="c1">// ||                                | left to right //</span>
<span class="c1">// ?:                                | right to left //</span>
<span class="c1">// = += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;= | right to left //</span>
<span class="c1">// ,                                 | left to right //</span>
<span class="c1">//---------------------------------------------------//</span>

<span class="cm">/******************************* Header Files **********************************

Header files are an important part of C as they allow for the connection of C
source files and can simplify code and definitions by separating them into
separate files.

Header files are syntactically similar to C source files but reside in ".h"
files. They can be included in your C source file by using the precompiler
command #include "example.h", given that example.h exists in the same directory
as the C file.
*/</span>

<span class="cm">/* A safe guard to prevent the header from being defined too many times. This */</span>
<span class="cm">/* happens in the case of circle dependency, the contents of the header is    */</span>
<span class="cm">/* already defined.                                                           */</span>
<span class="cp">#ifndef EXAMPLE_H </span><span class="cm">/* if EXAMPLE_H is not yet defined. */</span><span class="cp">
#define EXAMPLE_H </span><span class="cm">/* Define the macro EXAMPLE_H. */</span><span class="cp">
</span>
<span class="cm">/* Other headers can be included in headers and therefore transitively */</span>
<span class="cm">/* included into files that include this header.                       */</span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="cm">/* Like for c source files, macros can be defined in headers */</span>
<span class="cm">/* and used in files that include this header file.          */</span>
<span class="cp">#define EXAMPLE_NAME "Dennis Ritchie"
</span>
<span class="cm">/* Function macros can also be defined.  */</span>
<span class="cp">#define ADD(a, b) ((a) + (b))
</span>
<span class="cm">/* Notice the parenthesis surrounding the arguments -- this is important to   */</span>
<span class="cm">/* ensure that a and b don't get expanded in an unexpected way (e.g. consider */</span>
<span class="cm">/* MUL(x, y) (x * y); MUL(1 + 2, 3) would expand to (1 + 2 * 3), yielding an  */</span>
<span class="cm">/* incorrect result)                                                          */</span>

<span class="cm">/* Structs and typedefs can be used for consistency between files. */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Node</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Node</span><span class="p">;</span>

<span class="cm">/* So can enumerations. */</span>
<span class="k">enum</span> <span class="n">traffic_light_state</span> <span class="p">{</span><span class="n">GREEN</span><span class="p">,</span> <span class="n">YELLOW</span><span class="p">,</span> <span class="n">RED</span><span class="p">};</span>

<span class="cm">/* Function prototypes can also be defined here for use in multiple files,  */</span>
<span class="cm">/* but it is bad practice to define the function in the header. Definitions */</span>
<span class="cm">/* should instead be put in a C file.                                       */</span>
<span class="n">Node</span> <span class="nf">createLinkedList</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">vals</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/* Beyond the above elements, other definitions should be left to a C source */</span>
<span class="cm">/* file. Excessive includes or definitions should also not be contained in   */</span>
<span class="cm">/* a header file but instead put into separate headers or a C file.          */</span>

<span class="cp">#endif </span><span class="cm">/* End of the if precompiler directive. */</span><span class="cp">
</span></code></pre></div>
<h2>Further Reading</h2>

<p>Best to find yourself a copy of <a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">K&amp;R, aka &ldquo;The C Programming Language&rdquo;</a>
It is <em>the</em> book about C, written by Dennis Ritchie, the creator of C, and Brian Kernighan. Be careful, though - it&rsquo;s ancient and it contains some
inaccuracies (well, ideas that are not considered good anymore) or now-changed practices.</p>

<p>Another good resource is <a href="http://learncodethehardway.org/c/">Learn C The Hard Way</a> (not free).</p>

<p>If you have a question, read the <a href="http://c-faq.com">compl.lang.c Frequently Asked Questions</a>.</p>

<p>It&rsquo;s very important to use proper spacing, indentation and to be consistent with your coding style in general.
Readable code is better than clever code and fast code. For a good, sane coding style to adopt, see the
<a href="https://www.kernel.org/doc/Documentation/process/coding-style.rst">Linux kernel coding style</a>.</p>

<p>Other than that, Google is your friend.</p>

<p>[1] <a href="https://stackoverflow.com/questions/119123/why-isnt-sizeof-for-a-struct-equal-to-the-sum-of-sizeof-of-each-member">Why isn&rsquo;t sizeof for a struct equal to the sum of sizeof of each member?</a></p>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/c.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by Adam Bard, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/c.html.markdown">49 contributor(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://adambard.com/">Adam Bard</a>,
        <a href="http://twitter.com/H2CO3_iOS">rpd Goretity</a>,
        <a href="http://cbs.stgn.pl">Jakub Trzebiatowski</a>,
        <a href="https://marcoms.github.io">Marco Scannadinari</a>,
        <a href="https://github.io/zfergus2">Zachary Ferguson</a>,
        <a href="https://github.com/himanshu81494">himanshu</a>,
        <a href="https://github.com/JoshuaRLi">Joshua Li</a>,
        <a href="https://github.com/dchirila">Dragos B. Chirila</a>,
        <a href="https://github.com/heitorPB/">Heitor P. de Bittencourt</a>
    </p>

    <p>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
