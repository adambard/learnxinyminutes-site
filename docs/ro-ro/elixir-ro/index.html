<!DOCTYPE html lang="ro-ro" xml:lang="ro-ro" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="ro-ro">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Elixir in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/ro-ro/elixir-ro/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fro-ro%2Felixir-ro%2F&text=Learn+X+in+Y+minutes%2C+where+X%3DElixir">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="/">Learn X in Y minutes</a></h1>
  <h2>Where X=Elixir</h2>
    <p class="filelink">
    Get the code:
    <a href="/docs/files/learnelixir-ro.ex">learnelixir-ro.ex</a>
    </p>
  <div id="doc">
    <p>Elixir este un limbaj funcțional modern construit pe baza mașinii virtuale Erlang.
E total compatibil cu Erlang, dar are o sintaxă mai prietenoasă și propune mai multe
posibilități.</p>
<div class="highlight"><pre class="highlight elixir"><code><span class="c1"># Comentariile de o linie încep cu simbolul diez.</span>

<span class="c1"># Pentru comentarii pe mai multe linii nu există sintaxă separată,</span>
<span class="c1"># de aceea folosiți mai multe linii cu comentarii.</span>

<span class="c1"># Pentru a folosi shell-ul Elixir utilizați comanda `iex`.</span>
<span class="c1"># Compilați modulele cu comanda `elixirc`.</span>

<span class="c1"># Ambele comenzi vor lucra în terminal, dacă ați instalat Elixir corect.</span>

<span class="c1">## ---------------------------</span>
<span class="c1">## -- Tipuri de bază</span>
<span class="c1">## ---------------------------</span>

<span class="c1"># Numere</span>
<span class="mi">3</span>    <span class="c1"># număr întreg</span>
<span class="mh">0x1F</span> <span class="c1"># număr întreg</span>
<span class="mf">3.0</span>  <span class="c1"># număr cu virgulă mobilă</span>

<span class="c1"># Atomii, sunt constante nenumerice. Ei încep cu `:`.</span>
<span class="ss">:salut</span> <span class="c1"># atom</span>

<span class="c1"># Tuplele sunt păstrate în memorie consecutiv.</span>
<span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span> <span class="c1"># tuple</span>

<span class="c1"># Putem accesa elementul tuplelui folosind funcția `elem`:</span>
<span class="n">elem</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">#=&gt; 1</span>

<span class="c1"># Listele sunt implementate ca liste înlănțuite.</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="c1"># listă</span>

<span class="c1"># Fiecare listă ne vidă are cap (primul element al listei)</span>
<span class="c1"># și coadă (restul elementelor).</span>
<span class="c1"># Putem accesa capul și coada listei cum urmează:</span>
<span class="p">[</span><span class="n">cap</span> <span class="o">|</span> <span class="n">coad</span><span class="err">ă</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">cap</span>   <span class="c1">#=&gt; 1</span>
<span class="n">coad</span><span class="err">ă</span> <span class="c1">#=&gt; [2, 3]</span>

<span class="c1"># În Elixir, ca și în Erlang, simbolul `=` denotă potrivirea șabloanelor și</span>
<span class="c1"># nu atribuire.</span>
<span class="c1">#</span>
<span class="c1"># Aceasta înseamnă că expresia din stînga (șablonul) se potrivește cu</span>
<span class="c1"># expresia din dreaptă.</span>
<span class="c1">#</span>
<span class="c1"># În modul acesta exemplul de mai sus lucrează accesînd capul și coada unei liste.</span>

<span class="c1"># Potrivirea șablonului va da eroare cînd expresiile din stînga și dreapta nu se</span>
<span class="c1"># potrivesc, în exemplu acesta tuplele au lungime diferită.</span>
<span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span> <span class="c1">#=&gt; ** (MatchError)</span>

<span class="c1"># Există și date binare</span>
<span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;&gt;</span>

<span class="c1"># Sunt două tipuri de șiruri de caractere</span>
<span class="s2">"salut"</span> <span class="c1"># șir de caractere Elixir</span>
<span class="s1">'salut'</span> <span class="c1"># listă de caractere Erlang</span>

<span class="c1"># Șir de caractere pe mai multe linii</span>
<span class="sd">"""
Sunt un șir de caractere
pe mai multe linii.
"""</span>
<span class="c1">#=&gt; "Sunt un șir de caractere\npe mai multe linii..\n"</span>

<span class="c1"># Șirurile de caractere sunt codificate în UTF-8:</span>
<span class="s2">"Bună dimineața"</span> <span class="c1">#=&gt; "Bună dimineața"</span>

<span class="c1"># Șirurile de caractere sunt date binare, listele de caractere doar liste.</span>
<span class="o">&lt;&lt;</span><span class="sx">?a</span><span class="p">,</span> <span class="sx">?b</span><span class="p">,</span> <span class="sx">?c</span><span class="o">&gt;&gt;</span> <span class="c1">#=&gt; "abc"</span>
<span class="p">[</span><span class="sx">?a</span><span class="p">,</span> <span class="sx">?b</span><span class="p">,</span> <span class="sx">?c</span><span class="p">]</span>   <span class="c1">#=&gt; 'abc'</span>

<span class="c1"># `?a` în Elixir întoarce codul ASCII pentru litera `a`</span>
<span class="sx">?a</span> <span class="c1">#=&gt; 97</span>

<span class="c1"># Pentru a concatena listele folosiți `++`, pentru date binare - `&lt;&gt;`</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>     <span class="c1">#=&gt; [1,2,3,4,5]</span>
<span class="s1">'Salut '</span> <span class="o">++</span> <span class="s1">'lume'</span>  <span class="c1">#=&gt; 'Salut lume'</span>

<span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;&gt;</span> <span class="o">&lt;&gt;</span> <span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="o">&gt;&gt;</span> <span class="c1">#=&gt; &lt;&lt;1,2,3,4,5&gt;&gt;</span>
<span class="s2">"Salut "</span> <span class="o">&lt;&gt;</span> <span class="s2">"lume"</span>  <span class="c1">#=&gt; "Salut lume"</span>

<span class="c1"># Diapazoanele sunt reprezentate ca `început..sfîrșit` (inclusiv)</span>
<span class="mi">1</span><span class="o">..</span><span class="mi">10</span> <span class="c1">#=&gt; 1..10</span>
<span class="err">î</span><span class="n">nceput</span><span class="o">..</span><span class="n">sf</span><span class="err">î</span><span class="n">r</span><span class="err">ș</span><span class="n">it</span> <span class="o">=</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span> <span class="c1"># Putem folosi potrivirea șabloanelor cu diapazoane de asemenea</span>
<span class="p">[</span><span class="err">î</span><span class="n">nceput</span><span class="p">,</span> <span class="n">sf</span><span class="err">î</span><span class="n">r</span><span class="err">ș</span><span class="n">it</span><span class="p">]</span> <span class="c1">#=&gt; [1, 10]</span>

<span class="c1"># Dicţionarele stochează chei şi o valoare pentru fiecare cheie</span>
<span class="n">genuri</span> <span class="o">=</span> <span class="p">%{</span><span class="s2">"Ion"</span> <span class="o">=&gt;</span> <span class="s2">"bărbat"</span><span class="p">,</span> <span class="s2">"Maria"</span> <span class="o">=&gt;</span> <span class="s2">"femeie"</span><span class="p">}</span>
<span class="n">genuri</span><span class="p">[</span><span class="s2">"Ion"</span><span class="p">]</span> <span class="c1">#=&gt; "bărbat"</span>

<span class="c1"># Dicționare cu chei de tip atom au sintaxă specială</span>
<span class="n">genuri</span> <span class="o">=</span> <span class="p">%{</span><span class="ss">ion:</span> <span class="s2">"bărbat"</span><span class="p">,</span> <span class="ss">maria:</span> <span class="s2">"femeie"</span><span class="p">}</span>
<span class="n">genuri</span><span class="o">.</span><span class="n">ion</span> <span class="c1">#=&gt; "bărbat"</span>

<span class="c1">## ---------------------------</span>
<span class="c1">## -- Operatori</span>
<span class="c1">## ---------------------------</span>

<span class="c1"># Operații matematice</span>
<span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1">#=&gt; 2</span>
<span class="mi">10</span> <span class="o">-</span> <span class="mi">5</span> <span class="c1">#=&gt; 5</span>
<span class="mi">5</span> <span class="o">*</span> <span class="mi">2</span>  <span class="c1">#=&gt; 10</span>
<span class="mi">10</span> <span class="o">/</span> <span class="mi">2</span> <span class="c1">#=&gt; 5.0</span>

<span class="c1"># În Elixir operatorul `/` întotdeauna întoarce un număr cu virgulă mobilă.</span>

<span class="c1"># Folosiți `div` pentru împărțirea numerelor întregi</span>
<span class="n">div</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">#=&gt; 5</span>

<span class="c1"># Pentru a obține restul de la împărțire utilizați `rem`</span>
<span class="n">rem</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">#=&gt; 1</span>

<span class="c1"># Există și operatori booleni: `or`, `and` and `not`.</span>
<span class="c1"># Acești operatori așteaptă ca primul argument o expresie booleană.</span>
<span class="no">true</span> <span class="ow">and</span> <span class="no">true</span> <span class="c1">#=&gt; true</span>
<span class="no">false</span> <span class="ow">or</span> <span class="no">true</span> <span class="c1">#=&gt; true</span>
<span class="mi">1</span> <span class="ow">and</span> <span class="no">true</span>    <span class="c1">#=&gt; ** (BadBooleanError)</span>

<span class="c1"># Elixir de asemenea  oferă `||`, `&amp;&amp;` și `!` care acceptă argumente de orice tip.</span>
<span class="c1"># Toate valorile în afară de `false` și `nil` se vor evalua ca `true`.</span>
<span class="mi">1</span> <span class="o">||</span> <span class="no">true</span>  <span class="c1">#=&gt; 1</span>
<span class="no">false</span> <span class="o">&amp;&amp;</span> <span class="mi">1</span> <span class="c1">#=&gt; false</span>
<span class="no">nil</span> <span class="o">&amp;&amp;</span> <span class="mi">20</span>  <span class="c1">#=&gt; nil</span>
<span class="n">!true</span> <span class="c1">#=&gt; false</span>

<span class="c1"># Operatori de comparație: `==`, `!=`, `===`, `!==`, `&lt;=`, `&gt;=`, `&lt;` și `&gt;`</span>
<span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="c1">#=&gt; true</span>
<span class="mi">1</span> <span class="o">!=</span> <span class="mi">1</span> <span class="c1">#=&gt; false</span>
<span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">2</span>  <span class="c1">#=&gt; true</span>

<span class="c1"># `===` și `!==` au strictețe mai mare cînd comparăm numere întregi și reale:</span>
<span class="mi">1</span> <span class="o">==</span> <span class="mf">1.0</span>  <span class="c1">#=&gt; true</span>
<span class="mi">1</span> <span class="o">===</span> <span class="mf">1.0</span> <span class="c1">#=&gt; false</span>

<span class="c1"># Putem compara de asemenea și date de diferite tipuri:</span>
<span class="mi">1</span> <span class="o">&lt;</span> <span class="ss">:salut</span> <span class="c1">#=&gt; true</span>

<span class="c1"># La compararea diferitor tipuri folosiți următoare prioritate:</span>
<span class="c1"># număr &lt; atom &lt; referință &lt; funcție &lt; port &lt; proces &lt; tuple &lt; listă &lt; șir de caractere</span>

<span class="c1"># Cităm pe Joe Armstrong în acest caz: "Ordinea actuală nu e importantă,</span>
<span class="n">dar</span> <span class="n">c</span><span class="err">ă</span> <span class="n">ordinea</span> <span class="n">total</span><span class="err">ă</span> <span class="n">este</span> <span class="n">bine</span> <span class="n">definit</span><span class="err">ă</span> <span class="n">este</span> <span class="n">important</span><span class="o">.</span><span class="s2">"

## ---------------------------
## -- Ordinea execuției
## ---------------------------

# expresia `if`
if false do
  "</span><span class="no">Aceasta</span> <span class="n">nu</span> <span class="n">ve</span><span class="err">ț</span><span class="n">i</span> <span class="n">vedea</span> <span class="n">niciodat</span><span class="err">ă</span><span class="s2">"
else
  "</span><span class="no">Aceasta</span> <span class="n">ve</span><span class="err">ț</span><span class="n">i</span> <span class="n">vedea</span><span class="s2">"
end

# expresia opusă `unless`
unless true do
  "</span><span class="no">Aceasta</span> <span class="n">nu</span> <span class="n">ve</span><span class="err">ț</span><span class="n">i</span> <span class="n">vedea</span> <span class="n">niciodat</span><span class="err">ă</span><span class="s2">"
else
  "</span><span class="no">Aceasta</span> <span class="n">ve</span><span class="err">ț</span><span class="n">i</span> <span class="n">vedea</span><span class="s2">"
end

# Țineți minte potrivirea șabloanelor? Multe structuri în Elixir se bazează pe ea.

# `case` ne permite să comparăm o valoare cu multe șabloane:
case {:unu, :doi} do
  {:patru, :cinci} -&gt;
    "</span><span class="no">Aceasta</span> <span class="n">nu</span> <span class="n">se</span> <span class="n">potrive</span><span class="err">ș</span><span class="n">te</span><span class="s2">"
  {:unu, x} -&gt;
    "</span><span class="no">Aceasta</span> <span class="n">se</span> <span class="n">potrive</span><span class="err">ș</span><span class="n">te</span> <span class="err">ș</span><span class="n">i</span> <span class="n">atribuie</span> <span class="n">lui</span> <span class="err">`</span><span class="n">x</span><span class="err">`</span> <span class="err">`</span><span class="ss">:doi</span><span class="err">`</span> <span class="err">î</span><span class="n">n</span> <span class="n">acest</span> <span class="n">bloc</span><span class="s2">"
  _ -&gt;
    "</span><span class="no">Aceasta</span> <span class="n">se</span> <span class="n">va</span> <span class="n">potrivi</span> <span class="n">cu</span> <span class="n">orice</span> <span class="n">valoare</span><span class="s2">"
end

# Simbolul `_` se numește variabila anonimă.
# Folosiți-l pentru valori ce nu vă interesează.
# De exemplu, dacă doar capul listei ne intereseaza:
[cap | _] = [1,2,3]
cap #=&gt; 1

# Pentru o citire mai bună putem scri:
[cap | _coadă] = [:a, :b, :c]
cap #=&gt; :a

# `cond` ne permite să verificăm multe condiții de odată.
# Folosiți `cond` în schimbul la multe expresii `if`.
cond do
  1 + 1 == 3 -&gt;
    "</span><span class="no">Aceasta</span> <span class="n">nu</span> <span class="n">ve</span><span class="err">ț</span><span class="n">i</span> <span class="n">vedea</span> <span class="n">niciodat</span><span class="err">ă</span><span class="s2">"
  2 * 5 == 12 -&gt;
    "</span><span class="no">Pe</span> <span class="n">mine</span> <span class="n">la</span> <span class="n">fel</span><span class="s2">"
  1 + 2 == 3 -&gt;
    "</span><span class="no">Aceasta</span> <span class="n">ve</span><span class="err">ț</span><span class="n">i</span> <span class="n">vedea</span><span class="s2">"
end

# Este obușnuit de setat ultima condiție cu `true`, care se va potrivi întotdeauna.
cond do
  1 + 1 == 3 -&gt;
    "</span><span class="no">Aceasta</span> <span class="n">nu</span> <span class="n">ve</span><span class="err">ț</span><span class="n">i</span> <span class="n">vedea</span> <span class="n">niciodat</span><span class="err">ă</span><span class="s2">"
  2 * 5 == 12 -&gt;
    "</span><span class="no">Pe</span> <span class="n">mine</span> <span class="n">la</span> <span class="n">fel</span><span class="s2">"
  true -&gt;
    "</span><span class="no">Aceasta</span> <span class="n">ve</span><span class="err">ț</span><span class="n">i</span> <span class="n">vedea</span> <span class="p">(</span><span class="n">este</span> <span class="k">else</span> <span class="err">î</span><span class="n">n</span> <span class="n">esen</span><span class="err">ță</span><span class="p">)</span><span class="s2">"
end

# Blocul `try/catch` se foloște pentru prelucrarea excepțiilor.
# Elixir suportă blocul `after` care se execută în orice caz.
try do
  throw(:salut)
catch
  mesaj -&gt; "</span><span class="no">Am</span> <span class="n">primit</span> <span class="c1">#{mesaj}."</span>
<span class="k">after</span>
  <span class="no">IO</span><span class="o">.</span><span class="n">puts</span><span class="p">(</span><span class="s2">"Sunt în blocul after."</span><span class="p">)</span>
<span class="k">end</span>
<span class="c1">#=&gt; Sunt în blocul after.</span>
<span class="c1"># "Am primit salut"</span>

<span class="c1">## ---------------------------</span>
<span class="c1">## -- Module și Funcții</span>
<span class="c1">## ---------------------------</span>

<span class="c1"># Funcții anonime (atenție la punct la apelarea funcției)</span>
<span class="n">square</span> <span class="o">=</span> <span class="k">fn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="k">end</span>
<span class="n">square</span><span class="o">.</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1">#=&gt; 25</span>

<span class="c1"># Ele de asemenea aceptă multe clauze și expresii de gardă.</span>
<span class="c1"># Expresiile de gardă vă permit să acordați potrivirea șabloanelor,</span>
<span class="c1"># ele sunt indicate după cuvîntul cheie `when`:</span>
<span class="n">f</span> <span class="o">=</span> <span class="k">fn</span>
  <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">when</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
  <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
<span class="k">end</span>

<span class="n">f</span><span class="o">.</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1">#=&gt; 4</span>
<span class="n">f</span><span class="o">.</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">#=&gt; -3</span>

<span class="c1"># Elixir de asemenea oferă multe funcții incorporate.</span>
<span class="c1"># Ele sunt accesibile în scopul curent.</span>
<span class="n">is_number</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>    <span class="c1">#=&gt; true</span>
<span class="n">is_list</span><span class="p">(</span><span class="s2">"salut"</span><span class="p">)</span> <span class="c1">#=&gt; false</span>
<span class="n">elem</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">},</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">#=&gt; 1</span>

<span class="c1"># Puteți grupa cîteva funcții într-un modul. În interiorul modulului folosiți `def`</span>
<span class="c1"># pentru a defini funcțiile necesare.</span>
<span class="k">defmodule</span> <span class="no">Math</span> <span class="k">do</span>
  <span class="k">def</span> <span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">Math</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1">#=&gt; 3</span>
<span class="no">Math</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1">#=&gt; 9</span>

<span class="c1"># Pentru a compila modulul nostru simplu Math îl salvăm ca `math.ex` și utilizăm `elixirc`.</span>
<span class="c1"># în terminal: elixirc math.ex</span>

<span class="c1"># În interiorul modulului putem defini funcții cu `def` și funcții private cu `defp`.</span>
<span class="k">defmodule</span> <span class="no">PrivateMath</span> <span class="k">do</span>
  <span class="c1"># O funcție definită cu `def` este accesibilă pentru apelare din alte module,</span>
  <span class="k">def</span> <span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">do_sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># O funcție privată poate fi apelată doar local.</span>
  <span class="k">defp</span> <span class="n">do_sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">PrivateMath</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>    <span class="c1">#=&gt; 3</span>
<span class="no">PrivateMath</span><span class="o">.</span><span class="n">do_sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">#=&gt; ** (UndefinedFunctionError)</span>

<span class="c1"># Declarația funcției de asemenea suportă expresii de gardă și multe clauze:</span>
<span class="k">defmodule</span> <span class="no">Geometry</span> <span class="k">do</span>
  <span class="k">def</span> <span class="n">area</span><span class="p">({</span><span class="ss">:rectangle</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">})</span> <span class="k">do</span>
    <span class="n">w</span> <span class="o">*</span> <span class="n">h</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">area</span><span class="p">({</span><span class="ss">:circle</span><span class="p">,</span> <span class="n">r</span><span class="p">})</span> <span class="ow">when</span> <span class="n">is_number</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">do</span>
    <span class="mf">3.14</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">r</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">Geometry</span><span class="o">.</span><span class="n">area</span><span class="p">({</span><span class="ss">:rectangle</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">})</span> <span class="c1">#=&gt; 6</span>
<span class="no">Geometry</span><span class="o">.</span><span class="n">area</span><span class="p">({</span><span class="ss">:circle</span><span class="p">,</span> <span class="mi">3</span><span class="p">})</span>       <span class="c1">#=&gt; 28.25999999999999801048</span>
<span class="no">Geometry</span><span class="o">.</span><span class="n">area</span><span class="p">({</span><span class="ss">:circle</span><span class="p">,</span> <span class="s2">"not_a_number"</span><span class="p">})</span> <span class="c1">#=&gt; ** (FunctionClauseError)</span>

<span class="c1"># Din cauza variabilelor imutabile, un rol important îl ocupă funcțiile recursive</span>
<span class="k">defmodule</span> <span class="no">Recursion</span> <span class="k">do</span>
  <span class="k">def</span> <span class="n">sum_list</span><span class="p">([</span><span class="n">head</span> <span class="o">|</span> <span class="n">tail</span><span class="p">],</span> <span class="n">acc</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">sum_list</span><span class="p">(</span><span class="n">tail</span><span class="p">,</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">head</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">sum_list</span><span class="p">([],</span> <span class="n">acc</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">acc</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">Recursion</span><span class="o">.</span><span class="n">sum_list</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">#=&gt; 6</span>

<span class="c1"># Modulele în Elixir suportă atribute, există atribute incorporate și</span>
<span class="c1"># puteți adăuga altele.</span>
<span class="k">defmodule</span> <span class="no">MyMod</span> <span class="k">do</span>
  <span class="nv">@moduledoc</span> <span class="sd">"""
  Este un atribut incorporat
  """</span>

  <span class="nv">@my_data</span> <span class="mi">100</span> <span class="c1"># Acesta e atributul nostru</span>
  <span class="no">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p">(</span><span class="nv">@my_data</span><span class="p">)</span> <span class="c1">#=&gt; 100</span>
<span class="k">end</span>

<span class="c1"># Operatorul |&gt; permite transferarea rezultatului unei expresii din stînga</span>
<span class="c1"># ca primul argument al unei funcții din dreapta.</span>
<span class="no">Range</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">fn</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="k">end</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">fn</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">rem</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">end</span><span class="p">)</span>
<span class="c1">#=&gt; [4, 16, 36, 64, 100]</span>

<span class="c1">## ---------------------------</span>
<span class="c1">## -- Structuri și Excepții</span>
<span class="c1">## ---------------------------</span>

<span class="c1"># Structurile sunt extensii a dicționarelor ce au valori implicite,</span>
<span class="c1"># verificări în timpul compilării și polimorfism</span>
<span class="k">defmodule</span> <span class="no">Person</span> <span class="k">do</span>
  <span class="k">defstruct</span> <span class="ss">name:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">age:</span> <span class="mi">0</span><span class="p">,</span> <span class="ss">height:</span> <span class="mi">0</span>
<span class="k">end</span>

<span class="n">joe_info</span> <span class="o">=</span> <span class="p">%</span><span class="no">Person</span><span class="p">{</span> <span class="ss">name:</span> <span class="s2">"Joe"</span><span class="p">,</span> <span class="ss">age:</span> <span class="mi">30</span><span class="p">,</span> <span class="ss">height:</span> <span class="mi">180</span> <span class="p">}</span>
<span class="c1">#=&gt; %Person{age: 30, height: 180, name: "Joe"}</span>

<span class="c1"># Acesarea cîmpului din structură</span>
<span class="n">joe_info</span><span class="o">.</span><span class="n">name</span> <span class="c1">#=&gt; "Joe"</span>

<span class="c1"># Actualizarea valorii cîmpului</span>
<span class="n">older_joe_info</span> <span class="o">=</span> <span class="p">%{</span> <span class="n">joe_info</span> <span class="o">|</span> <span class="ss">age:</span> <span class="mi">31</span> <span class="p">}</span>
<span class="c1">#=&gt; %Person{age: 31, height: 180, name: "Joe"}</span>

<span class="c1"># Blocul `try` cu cuvîntul cheie `rescue` e folosit pentru a prinde excepții</span>
<span class="k">try</span> <span class="k">do</span>
  <span class="k">raise</span> <span class="s2">"o eroare"</span>
<span class="k">rescue</span>
  <span class="no">RuntimeError</span> <span class="o">-&gt;</span> <span class="s2">"a fost prinsă o eroare runtime"</span>
  <span class="n">_error</span> <span class="o">-&gt;</span> <span class="s2">"aici vor fi prinse toate erorile"</span>
<span class="k">end</span>
<span class="c1">#=&gt; "a fost prinsă o eroare runtime"</span>

<span class="c1"># Toate excepțiile au un mesaj</span>
<span class="k">try</span> <span class="k">do</span>
  <span class="k">raise</span> <span class="s2">"o eroare"</span>
<span class="k">rescue</span>
  <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="no">RuntimeError</span><span class="p">]</span> <span class="o">-&gt;</span>
    <span class="n">x</span><span class="o">.</span><span class="n">message</span>
<span class="k">end</span>
<span class="c1">#=&gt; "o eroare"</span>

<span class="c1">## ---------------------------</span>
<span class="c1">## -- Concurența</span>
<span class="c1">## ---------------------------</span>

<span class="c1"># Concurența în Elixir se bazează pe modelul actor. Pentru a scrie programe</span>
<span class="c1"># concurente avem nevoie de trei lucruri:</span>
<span class="c1"># 1. Crearea proceselor</span>
<span class="c1"># 2. Trimiterea mesajelor</span>
<span class="c1"># 3. Primirea mesajelor</span>

<span class="c1"># Un nou proces se crează folosind funcția `spawn`, care primește o funcție</span>
<span class="c1"># ca argument.</span>
<span class="n">f</span> <span class="o">=</span> <span class="k">fn</span> <span class="o">-&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">end</span> <span class="c1">#=&gt; #Function&lt;erl_eval.20.80484245&gt;</span>
<span class="n">spawn</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="c1">#=&gt; #PID&lt;0.40.0&gt;</span>

<span class="c1"># `spawn` întoarce identificatorul procesului pid, îl puteți folosi pentru</span>
<span class="c1"># a trimite mesaje procesului. Mesajele se transmit folosind operatorul `send`.  </span>
<span class="c1"># Pentru primirea mesajelor se folosește mecanismul `receive`:</span>

<span class="c1"># Blocul `receive do` este folosit pentru așteptarea mesajelor și prelucrarea lor</span>
<span class="c1"># cînd au fost primite. Blocul `receive do` va procesa doar un singur mesaj primit.</span>
<span class="c1"># Pentru a procesa mai multe mesaje, funcția cu blocul `receive do` trebuie</span>
<span class="c1"># recursiv să se auto apeleze.</span>

<span class="k">defmodule</span> <span class="no">Geometry</span> <span class="k">do</span>
  <span class="k">def</span> <span class="n">area_loop</span> <span class="k">do</span>
    <span class="k">receive</span> <span class="k">do</span>
      <span class="p">{</span><span class="ss">:rectangle</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">}</span> <span class="o">-&gt;</span>
        <span class="no">IO</span><span class="o">.</span><span class="n">puts</span><span class="p">(</span><span class="s2">"Aria = </span><span class="si">#{</span><span class="n">w</span> <span class="o">*</span> <span class="n">h</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="n">area_loop</span><span class="p">()</span>
      <span class="p">{</span><span class="ss">:circle</span><span class="p">,</span> <span class="n">r</span><span class="p">}</span> <span class="o">-&gt;</span>
        <span class="no">IO</span><span class="o">.</span><span class="n">puts</span><span class="p">(</span><span class="s2">"Aria = </span><span class="si">#{</span><span class="mf">3.14</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">r</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="n">area_loop</span><span class="p">()</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># Compilați modulul și creați un proces</span>
<span class="n">pid</span> <span class="o">=</span> <span class="n">spawn</span><span class="p">(</span><span class="k">fn</span> <span class="o">-&gt;</span> <span class="no">Geometry</span><span class="o">.</span><span class="n">area_loop</span><span class="p">()</span> <span class="k">end</span><span class="p">)</span> <span class="c1">#=&gt; #PID&lt;0.40.0&gt;</span>
<span class="c1"># Un alt mod</span>
<span class="n">pid</span> <span class="o">=</span> <span class="n">spawn</span><span class="p">(</span><span class="no">Geometry</span><span class="p">,</span> <span class="ss">:area_loop</span><span class="p">,</span> <span class="p">[])</span>

<span class="c1"># Trimiteți un mesaj către `pid` care se va potrivi cu un șablon din blocul `receive`</span>
<span class="n">send</span> <span class="n">pid</span><span class="p">,</span> <span class="p">{</span><span class="ss">:rectangle</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="c1">#=&gt; Aria = 6</span>
<span class="c1">#   {:rectangle,2,3}</span>

<span class="n">send</span> <span class="n">pid</span><span class="p">,</span> <span class="p">{</span><span class="ss">:circle</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="c1">#=&gt; Aria = 12.56000000000000049738</span>
<span class="c1">#   {:circle,2}</span>

<span class="c1"># Interpretatorul este de asemenea un proces, puteți folosi `self` </span>
<span class="c1"># pentru a primi identificatorul de proces: </span>
<span class="n">self</span><span class="p">()</span> <span class="c1">#=&gt; #PID&lt;0.27.0&gt;</span>

<span class="c1">## ---------------------------</span>
<span class="c1">## -- Agenții</span>
<span class="c1">## ---------------------------</span>

<span class="c1"># Un agent este un proces care urmărește careva valori ce se schimbă.</span>

<span class="c1"># Creați un agent cu `Agent.start_link`, transmițînd o funcție.</span>
<span class="c1"># Stare inițială a agentului va fi rezultatul funcției.</span>
<span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="n">my_agent</span><span class="p">}</span> <span class="o">=</span> <span class="no">Agent</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="k">fn</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="s2">"roșu"</span><span class="p">,</span> <span class="s2">"verde"</span><span class="p">]</span> <span class="k">end</span><span class="p">)</span>

<span class="c1"># `Agent.get` primește numele agentului și o `fn` care primește starea curentă</span>
<span class="c1"># Orice va întoarce `fn` este ceea ce veți primi înapoi: </span>
<span class="no">Agent</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">my_agent</span><span class="p">,</span> <span class="k">fn</span> <span class="n">colors</span> <span class="o">-&gt;</span> <span class="n">colors</span> <span class="k">end</span><span class="p">)</span> <span class="c1">#=&gt; ["roșu", "verde"]</span>

<span class="c1"># Actualizați starea agentului în acelaș mod:</span>
<span class="no">Agent</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">my_agent</span><span class="p">,</span> <span class="k">fn</span> <span class="n">colors</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="s2">"albastru"</span> <span class="o">|</span> <span class="n">colors</span><span class="p">]</span> <span class="k">end</span><span class="p">)</span>
</code></pre></div>
<h2>Link-uri utile</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/introduction.html">Primii pași</a> de pe <a href="http://elixir-lang.org">situl Elixir</a></li>
<li><a href="http://elixir-lang.org/docs/master/">Documentația oficială Elixir</a></li>
<li><a href="http://media.pragprog.com/titles/elixir/ElixirCheat.pdf">Un mic conspect pe Elixir</a></li>
<li><a href="https://pragprog.com/book/elixir/programming-elixir">Cartea &ldquo;Programming Elixir&rdquo;</a> de Dave Thomas</li>
<li><a href="http://learnyousomeerlang.com/">Cartea &ldquo;Learn You Some Erlang for Great Good!&rdquo;</a> de Fred Hebert</li>
<li><a href="https://pragprog.com/book/jaerlang2/programming-erlang">Cartea &ldquo;Programming Erlang: Software for a Concurrent World&rdquo;</a> de Joe Armstrong</li>
</ul>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/ro-ro/elixir-ro.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by Joao Marques, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/ro-ro/elixir-ro.html.markdown">5 contributor(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://github.com/mrshankly">Joao Marques</a>,
        <a href="https://github.com/dskecse">Dzianis Dashkevich</a>,
        <a href="https://github.com/ryanplant-au">Ryan Plant</a>,
        <a href="https://github.com/evbogdanov">Ev Bogdanov</a>
    </p>

    <p>
      Translated by:
        <a href="https://github.com/vitaliel">Vitalie Lazu</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
