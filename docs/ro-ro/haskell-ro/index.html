<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="ro-ro" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="ro-ro" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="ro-ro" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="ro-ro" class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="ro-ro">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Haskell in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/ro-ro/haskell-ro/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fro-ro%2Fhaskell-ro%2F&text=Learn+X+in+Y+minutes%2C+where+X%3DHaskell">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="/">Learn X in Y minutes</a></h1>
  <h2>Where X=Haskell</h2>
    <p class="filelink">
    Get the code:
    <a href="/docs/files/haskell-ro.html">haskell-ro.html</a>
    </p>
  <div id="doc">
    <p>Haskell este un limbaj de programare practic, pur func»õional.</p>
<div class="highlight"><pre><span></span><span class="c1">-- Comentariile pe o singura linie incep cu 2 cratime.</span>
<span class="cm">{- Comentariile multilinie</span>
<span class="cm">  se scriu astfel.</span>
<span class="cm">-}</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 1. Tipuri de date primitive si operatori</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Exista numere</span>
<span class="mi">3</span><span class="w"> </span><span class="c1">-- 3</span>

<span class="c1">-- Matematica functioneaza ca de obicei</span>
<span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">-- 2</span>
<span class="mi">8</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">-- 7</span>
<span class="mi">10</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="c1">-- 20</span>
<span class="mi">35</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="c1">-- 7.0</span>

<span class="c1">-- Impartirea este cu virgula</span>
<span class="mi">35</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="c1">-- 8.75</span>

<span class="c1">-- Impartirea cu rest</span>
<span class="mi">35</span><span class="w"> </span><span class="p">`</span><span class="n">div</span><span class="p">`</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="c1">-- 8</span>

<span class="c1">-- Valorile booleene sunt primitive</span>
<span class="kt">True</span>
<span class="kt">False</span>

<span class="c1">-- Operatii logice</span>
<span class="nf">not</span><span class="w"> </span><span class="kt">True</span><span class="w"> </span><span class="c1">-- False</span>
<span class="nf">not</span><span class="w"> </span><span class="kt">False</span><span class="w"> </span><span class="c1">-- True</span>
<span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">-- True</span>
<span class="mi">1</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">-- False</span>
<span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="c1">-- True</span>

<span class="c1">-- In exemplele de mai sus, `not` este o functie ce primeste o valoare.</span>
<span class="c1">-- In Haskell nu se pun paranteze pentru apelurile de functie. Toate</span>
<span class="c1">-- argumentele sunt insirate dupa numele functiei. Sablonul general este:</span>
<span class="c1">-- func arg1 arg2 arg3</span>
<span class="c1">-- Vedeti sectiunea despre functii pentru a afla cum sa scrieti propria functie.</span>

<span class="c1">-- Caractere si siruri de caractere</span>
<span class="s">&quot;Acesta este un sir de caractere&quot;</span>
<span class="sc">&#39;a&#39;</span><span class="w"> </span><span class="c1">-- un caracter</span>
<span class="kt">&#39;Nu</span><span class="w"> </span><span class="n">se</span><span class="w"> </span><span class="n">pot</span><span class="w"> </span><span class="n">folosi</span><span class="w"> </span><span class="n">apostroafe</span><span class="w"> </span><span class="n">pentru</span><span class="w"> </span><span class="n">siruri</span><span class="o">.</span><span class="sc">&#39;</span><span class="err"> -- eroare!</span>

<span class="c1">-- Sirurile pot fi concatenate</span>
<span class="s">&quot;Hello &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s">&quot;world!&quot;</span><span class="w"> </span><span class="c1">-- &quot;Hello world!&quot;</span>

<span class="c1">-- Un string e de fapt o lista de caractere</span>
<span class="p">[</span><span class="sc">&#39;H&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;e&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;l&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;l&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;o&#39;</span><span class="p">]</span><span class="w"> </span><span class="c1">-- &quot;Hello&quot;</span>
<span class="s">&quot;Acesta este un string&quot;</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="c1">-- &#39;A&#39;</span>


<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 2. Liste si tupli</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Fiecare element dintr-o lista trebuie sa aiba acelasi tip.</span>
<span class="c1">-- Urmatoarele liste sunt identice.</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>

<span class="c1">-- Intervalele sunt versatile.</span>
<span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;F&#39;</span><span class="p">]</span><span class="w"> </span><span class="c1">-- &quot;ABCDEF&quot;</span>

<span class="c1">-- Se poate specifica un pas pentru intervale.</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [0, 2, 4, 6, 8, 10]</span>
<span class="p">[</span><span class="mi">5</span><span class="o">..</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="c1">-- Aceasta nu functioneaza deoarece pasul implicit este incrementarea.</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="o">..</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [5, 4, 3, 2, 1]</span>

<span class="c1">-- indexarea intr-o lista este de la zero</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">-- se obtine 4</span>

<span class="c1">-- Se pot crea liste infinite</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span><span class="w"> </span><span class="c1">-- lista tuturor numerelor naturale</span>

<span class="c1">-- Listele infinite functioneaza pentru ca Haskell foloseste &quot;evaluare lenesa&quot;</span>
<span class="c1">-- adica evalueaza lucrurile doar cand este nevoie de ele. Deci se poate</span>
<span class="c1">-- cere al 1000-lea element din lista infinita a numerelor naturale astfel:</span>

<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="mi">999</span><span class="w"> </span><span class="c1">-- rezulta 1000</span>

<span class="c1">-- Haskell a evaluat elementele 1 - 1000 din lista... dar restul elementelor</span>
<span class="c1">-- acestei liste &quot;infinite&quot; nu exista inca! Haskell nu le va evalua pana</span>
<span class="c1">-- nu va fi nevoie de ele.</span>

<span class="c1">-- concatenarea a doua liste</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="mi">6</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>

<span class="c1">-- alipirea la capul listei</span>
<span class="mi">0</span><span class="kt">:</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [0, 1, 2, 3, 4, 5]</span>

<span class="c1">-- operatii cu liste</span>
<span class="nf">head</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- 1</span>
<span class="nf">tail</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [2, 3, 4, 5]</span>
<span class="nf">init</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [1, 2, 3, 4]</span>
<span class="nf">last</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- 5</span>

<span class="c1">-- intelegerea listelor</span>
<span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]]</span><span class="w"> </span><span class="c1">-- [2, 4, 6, 8, 10]</span>

<span class="c1">-- folosind o conditie</span>
<span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [6, 8, 10]</span>

<span class="c1">-- Fiecare element dintr-un tuplu poate fi de un tip diferit</span>
<span class="c1">-- dar un tuplu are lungime fixa</span>
<span class="c1">-- Un tuplu:</span>
<span class="p">(</span><span class="s">&quot;haskell&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="c1">-- accesarea elementelor unui tuplu pereche</span>
<span class="nf">fst</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;haskell&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">-- &quot;haskell&quot; (first)</span>
<span class="nf">snd</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;haskell&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">-- 1 (second)</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 3. Functii</span>
<span class="c1">----------------------------------------------------</span>
<span class="c1">-- O functie simpla ce sumeaza doua variabile</span>
<span class="nf">add</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span>

<span class="c1">-- Aveti in vedere ca daca folositi ghci (interpretorul Haskell)</span>
<span class="c1">-- trebuie sa scrieti in fata si `let`, adica</span>
<span class="c1">-- let add a b = a + b</span>

<span class="c1">-- Apelarea functiei</span>
<span class="nf">add</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="c1">-- rezulta 3</span>

<span class="c1">-- Numele functiei se poate pune si intre argumente</span>
<span class="c1">-- folosind apostrof intors:</span>
<span class="mi">1</span><span class="w"> </span><span class="p">`</span><span class="n">add</span><span class="p">`</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="c1">-- 3</span>

<span class="c1">-- Se pot defini functii fara litere in denumire! Astfel se pot</span>
<span class="c1">-- defini noi operatori! De exemplu, iata un operator care realizeaza</span>
<span class="c1">-- impartirea intreaga</span>
<span class="p">(</span><span class="o">//</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">`</span><span class="n">div</span><span class="p">`</span><span class="w"> </span><span class="n">b</span>
<span class="mi">35</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="c1">-- rezulta 8</span>

<span class="c1">-- Guards: o metoda usoara de a crea ramuri de executie</span>
<span class="nf">fib</span><span class="w"> </span><span class="n">x</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>

<span class="c1">-- Potrivirea sirurilor se face similar. Aici am definit 3 definitii</span>
<span class="c1">-- pentru fib. Haskell o va alege automat pe prima care se potriveste</span>
<span class="c1">-- cu sablonul valorii.</span>
<span class="nf">fib</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>
<span class="nf">fib</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span>
<span class="nf">fib</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>

<span class="c1">-- Potrivirea in tupli:</span>
<span class="nf">foo</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>

<span class="c1">-- Potrivirea in liste. Aici `x` este primul element al listei,</span>
<span class="c1">-- iar `xs` este restul litei. Putem scrie propria functie</span>
<span class="c1">-- de mapare</span>
<span class="nf">myMap</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span>
<span class="nf">myMap</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="n">x</span><span class="kt">:</span><span class="p">(</span><span class="n">myMap</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span>

<span class="c1">-- Functiile anonime sunt create folosind un backslash urmat</span>
<span class="c1">-- de toate argumentele.</span>
<span class="nf">myMap</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [3, 4, 5, 6, 7]</span>

<span class="c1">-- utilizarea fold (denumit `inject` in alte limbaje) cu o functie</span>
<span class="c1">-- anonima. foldl1 inseamna pliere la stanga, folosind prima valoare</span>
<span class="c1">-- din lista drept valoarea initiala pentru acumulator</span>
<span class="nf">foldl1</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">acc</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- 15</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 4. Mai multe functii</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- aplicare partiala; daca nu se introduc toate argumentele unei functii,</span>
<span class="c1">-- este &quot;aplicata partial&quot;, adica returneaza o noua functie ce primeste</span>
<span class="c1">-- restul argumentelor, avand deja setate argumentele introduse</span>

<span class="nf">add</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="c1">-- foo este o functie ce primeste un numar si ii aduna 10</span>
<span class="nf">foo</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="c1">-- 15</span>

<span class="c1">-- alta maniera de a scrie acelasi lucru</span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="mi">10</span><span class="o">+</span><span class="p">)</span>
<span class="nf">foo</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="c1">-- 15</span>

<span class="c1">-- compunerea functiilor</span>
<span class="c1">-- operatorul `.` inlantuieste functiile.</span>
<span class="c1">-- De exeplu, aici foo este o functie care aduna 10 unui numar, il inmul</span>
<span class="c1">-- teste cu 4 si returneaza rezultatul calcului</span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="mi">10</span><span class="o">+</span><span class="p">)</span>

<span class="c1">-- 4*(10 + 5) = 60</span>
<span class="nf">foo</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="c1">-- 60</span>

<span class="c1">-- alterarea precedentei</span>
<span class="c1">-- Haskell detine un operator numit `$`. Acest operator aplica o functie</span>
<span class="c1">-- unui parametru dat. Fata de aplicarea standard a functiilor, care</span>
<span class="c1">-- foloseste prioritatea maxim posibila 10 si este asociativa la stanga,</span>
<span class="c1">-- operatorul `$` are prioritatea 0 si este asociativ la dreapta.</span>
<span class="c1">-- Aceasta inseamna ca expresia de la dreapta este aplicata ca parametru</span>
<span class="c1">-- functiei din stanga</span>

<span class="c1">-- inainte</span>
<span class="nf">even</span><span class="w"> </span><span class="p">(</span><span class="n">fib</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="c1">-- false</span>

<span class="c1">-- echivalent</span>
<span class="nf">even</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="c1">-- false</span>

<span class="c1">-- compunerea functiilor</span>
<span class="nf">even</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="c1">-- false</span>


<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 5. Type signatures</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Haskell are un sistem de tipuri de date foarte puternic; fiecare expresie</span>
<span class="c1">-- valida are un tip.</span>

<span class="c1">-- Cateva tipuri de baza:</span>
<span class="mi">5</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span>
<span class="s">&quot;hello&quot;</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">String</span>
<span class="kt">True</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Bool</span>

<span class="c1">-- Functiile au tipuri de asemenea.</span>
<span class="c1">-- `not` primeste un boolean si returneaza un boolean.</span>
<span class="c1">-- not :: Bool -&gt; Bool</span>

<span class="c1">-- Iata o functie ce primeste doi intregi</span>
<span class="c1">-- add :: Integer -&gt; Integer -&gt; Integer</span>

<span class="c1">-- Cand se defineste o valoare, este bine sa se precizeze tipul ei deasupra.</span>
<span class="nf">double</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span>
<span class="nf">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span>

<span class="c1">---------------------------------------------------------</span>
<span class="c1">-- 6. Controlul executiei si instructiunile conditionale</span>
<span class="c1">---------------------------------------------------------</span>

<span class="c1">-- expresia conditionala if</span>
<span class="nf">haskell</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="s">&quot;awesome&quot;</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="s">&quot;awful&quot;</span><span class="w"> </span><span class="c1">-- haskell = &quot;awesome&quot;</span>

<span class="c1">-- cand expresiile sunt pe mai multe linii, este importanta indentarea</span>
<span class="nf">haskell</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span>
<span class="w">            </span><span class="kr">then</span><span class="w"> </span><span class="s">&quot;awesome&quot;</span>
<span class="w">            </span><span class="kr">else</span><span class="w"> </span><span class="s">&quot;awful&quot;</span>

<span class="c1">-- expresiile de tip case; iata cum se verifica argumentele programului</span>
<span class="kr">case</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="kr">of</span>
<span class="w">  </span><span class="s">&quot;help&quot;</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">printHelp</span>
<span class="w">  </span><span class="s">&quot;start&quot;</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">startProgram</span>
<span class="w">  </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;bad args&quot;</span>


<span class="c1">-- Haskell nu foloseste cicluri, ci recursie</span>
<span class="c1">-- map aplica o functie fiecarui element dintr-o lista</span>

<span class="nf">map</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [2, 4, 6, 8, 10]</span>

<span class="c1">-- se poate face o functie for folosind map</span>
<span class="nf">for</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="n">array</span>

<span class="c1">-- si apoi se poate folosi astfel:</span>
<span class="nf">for</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="nf">\</span><span class="n">i</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="n">i</span>

<span class="c1">-- se poate scrie si asa:</span>
<span class="nf">for</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="n">show</span>

<span class="c1">-- Se poate folosi foldl sau foldr pentru a reduce o lista</span>
<span class="c1">-- foldl &lt;fn&gt; &lt;valoare initiala&gt; &lt;lista&gt;</span>
<span class="nf">foldl</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="c1">-- 43</span>

<span class="c1">-- Acelasi lucru ca a scrie</span>
<span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>

<span class="c1">-- foldl functioneaza spre stanga, foldr spre dreapta</span>
<span class="nf">foldr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="c1">-- 16</span>

<span class="c1">-- Acealsi lucru ca:</span>
<span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">)))</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 7. Tipuri de date</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Iata cum se creeaza un tip de date in Haskell</span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Culoare</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Rosu</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Albastru</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Verde</span>

<span class="c1">-- Acum poate fi folosit in functii</span>


<span class="nf">spune</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Culoare</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span>
<span class="nf">spune</span><span class="w"> </span><span class="kt">Rosu</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Esti Rosu!&quot;</span>
<span class="nf">spune</span><span class="w"> </span><span class="kt">Albastru</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Esti Albastru!&quot;</span>
<span class="nf">spune</span><span class="w"> </span><span class="kt">Verde</span><span class="w"> </span><span class="ow">=</span><span class="w">  </span><span class="s">&quot;Esti Verde!&quot;</span>

<span class="c1">-- Tipul de date poate avea si parametri.</span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Nothing</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="n">a</span>

<span class="c1">-- Toate acestea sunt de tipul Maybe</span>
<span class="kt">Just</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="w">    </span><span class="c1">-- de tipul `Maybe String`</span>
<span class="kt">Just</span><span class="w"> </span><span class="mi">1</span><span class="w">          </span><span class="c1">-- de tipul `Maybe Int`</span>
<span class="kt">Nothing</span><span class="w">         </span><span class="c1">-- de tipul `Maybe a` pentru oricare `a`</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 8. IO in Haskell</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Desi IO nu se poate explica intru totul fara a explica monadele,</span>
<span class="c1">-- nu este atat de greu de explicat pentru o idee de baza.</span>

<span class="c1">-- Cand se executa un program Haskell, se apeleaza `main`.</span>
<span class="c1">-- Trebuie sa returneze o valoare de tio `IO a` pentru un anumit tip `a`.</span>
<span class="c1">-- De exemplu:</span>

<span class="nf">main</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span>
<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">putStrLn</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="s">&quot;Hello, sky! &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">(</span><span class="n">say</span><span class="w"> </span><span class="kt">Blue</span><span class="p">)</span>
<span class="c1">-- putStrLn are tipul String -&gt; IO ()</span>

<span class="c1">-- Cel mai usor se lucreaza cu IO daca se implementeaza programul</span>
<span class="c1">-- ca o functie de la String la String. Functia</span>
<span class="c1">--    interact :: (String -&gt; String) -&gt; IO ()</span>
<span class="c1">-- citeste un text, executa o functie asupra ei, apoi afiseaza</span>
<span class="c1">-- iesirea.</span>

<span class="nf">countLines</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span>
<span class="nf">countLines</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">lines</span>

<span class="nf">main&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">interact</span><span class="w"> </span><span class="n">countLines</span>

<span class="c1">-- O valoare de tipul `IO ()` poate fi privita ca reprezentand</span>
<span class="c1">-- o secventa de actiuni pe care care computerul sa le execute,</span>
<span class="c1">-- similar cu felul in care un program este scris intr-un limbaj</span>
<span class="c1">-- imperativ. Putem folosi notatia `do` pentru a inlantui actiunile.</span>
<span class="c1">-- De exemplu:</span>

<span class="nf">sayHello</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span>
<span class="nf">sayHello</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span>
<span class="w">   </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;What is your name?&quot;</span>
<span class="w">   </span><span class="n">name</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getLine</span><span class="w"> </span><span class="c1">-- citeste o linie</span>
<span class="w">   </span><span class="n">putStrLn</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="s">&quot;Hello, &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">name</span>

<span class="c1">-- Exercise: Scrieti propria functie `interact` care citeste</span>
<span class="c1">--           o singura linie de la intrare.</span>


<span class="c1">-- Codul din `sayHello` nu va fi niciodata executat. Singura actiunile</span>
<span class="c1">-- care este executata este valoarea lui `main`.</span>
<span class="c1">-- Pentru a rula `sayHello.`, eliminati definitia de mai sus a `main`.</span>
<span class="c1">-- si inlocuiti-o cu</span>
<span class="c1">--   main = sayHello</span>

<span class="c1">-- Sa intelegem mai bine cum functioneaza functia `getLine`.</span>
<span class="c1">-- Tipul ei este:</span>
<span class="c1">--    getLine :: IO String</span>
<span class="c1">-- Pueti privi o valoare de tipul `IO a` ca fiind un program</span>
<span class="c1">-- de computer care va genera o valoare de tipul `a` cand</span>
<span class="c1">-- este executata (pe langa orice altceva face). O putem denumi</span>
<span class="c1">-- si refolosi utilizand `&lt;-`. De asemenea putem face propriile</span>
<span class="c1">-- actiuni te tipul `IO String`:</span>

<span class="nf">action</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">String</span>
<span class="nf">action</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span>
<span class="w">   </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;Aceasta e o linie.&quot;</span>
<span class="w">   </span><span class="n">input1</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getLine</span>
<span class="w">   </span><span class="n">input2</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getLine</span>
<span class="w">   </span><span class="c1">--Tipul instructiunii `do` este cel de pe ultima sa linie.</span>
<span class="w">   </span><span class="c1">-- `return` nu este un cuvant cheie, ci o functie</span>
<span class="w">   </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">input1</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">input2</span><span class="p">)</span><span class="w"> </span><span class="c1">-- return :: String -&gt; IO String</span>

<span class="c1">-- Putem folosi aceasta exact cum am folosit `getLine`:</span>

<span class="nf">main&#39;&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span>
<span class="w">    </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;I will echo two lines!&quot;</span>
<span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">action</span>
<span class="w">    </span><span class="n">putStrLn</span><span class="w"> </span><span class="n">result</span>
<span class="w">    </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;This was all, folks!&quot;</span>

<span class="c1">-- Tipul `IO` este un exemplu de &quot;monada&quot;. Felul in care Haskell foloseste</span>
<span class="c1">-- o monada pentru a realiza opeartii de intrare si iesire il face un limbaj</span>
<span class="c1">-- pur functional. Orice functie care interactioneaza cu exteriorul (adica</span>
<span class="c1">-- realieaza IO) este marcata ca `IO` in semnatura ei. Aceasta ne permite</span>
<span class="c1">-- sa spunem ce functii sunt &quot;pure&quot;, adica nu interactioneaza cu exteriorul.</span>

<span class="c1">-- Aceasta este o facilitate foarte puternica, deoarece este usor sa</span>
<span class="c1">-- se ruleze functii pure concurent; asadar, concurenta in Haskell se face usor</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 9. REPL in Haskell</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Se porneste introducand `ghci`.</span>
<span class="c1">-- Dupa aceasta, se poate introduce cod Haskell.</span>
<span class="c1">-- Toate valorile noi trebuie precedate de `let`.</span>

<span class="kr">let</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">5</span>

<span class="c1">-- Puteti vedea tipul oricarei valori sau expresii cu `:t`.</span>

<span class="o">&gt;</span><span class="w"> </span><span class="kt">:</span><span class="n">t</span><span class="w"> </span><span class="n">foo</span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span>

<span class="c1">-- Operatorii, precum `+`, `:` si `$` sunt functii.</span>
<span class="c1">-- Tipul lor poate fi observat punand operatorii intre paranteze.</span>

<span class="o">&gt;</span><span class="w"> </span><span class="kt">:</span><span class="n">t</span><span class="w"> </span><span class="p">(</span><span class="kt">:</span><span class="p">)</span>
<span class="p">(</span><span class="kt">:</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span>

<span class="c1">-- Se pot obtine informatii despre fiecare nume folosind `:i`</span>

<span class="o">&gt;</span><span class="w"> </span><span class="kt">:</span><span class="n">i</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span>
<span class="kr">class</span><span class="w"> </span><span class="kt">Num</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span>
<span class="w">  </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span>
<span class="w">  </span><span class="o">...</span>
<span class="w">    </span><span class="c1">-- Defined in ‚ÄòGHC.Num‚Äô</span>
<span class="kr">infixl</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="o">+</span>

<span class="c1">--De asemenea se poate executa orice actiune de tipul `IO ()`</span>

<span class="o">&gt;</span><span class="w"> </span><span class="n">sayHello</span>
<span class="kt">What</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">your</span><span class="w"> </span><span class="n">name</span><span class="o">?</span>
<span class="kt">Friend</span><span class="o">!</span>
<span class="kt">Hello</span><span class="p">,</span><span class="w"> </span><span class="kt">Friend</span><span class="o">!</span>
</pre></div>
<p>Mai sunt multe de spus despre Haskell, printre care typclasses »ôi monade.
Acestea sunt marile idei care fac programarea √Æn Haskell at√¢t de interesantƒÉ.
VƒÉ las un exemplu final √Æn Haskell: o variantƒÉ de implementare a sortƒÉrii rapide
(quicksort) √Æn Haskell:</p>
<div class="highlight"><pre><span></span><span class="nf">qsort</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span>
<span class="nf">qsort</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">qsort</span><span class="w"> </span><span class="n">lesser</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">qsort</span><span class="w"> </span><span class="n">greater</span>
<span class="w">    </span><span class="kr">where</span><span class="w"> </span><span class="n">lesser</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span>
<span class="w">          </span><span class="n">greater</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="o">&gt;=</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span>
</pre></div>
<p>ExistƒÉ douƒÉ maniere populare de a instala Haskell: prin <a href="http://www.haskell.org/platform/">instalarea bazatƒÉ pe Cabal</a>, »ôi prin mai noul <a href="https://www.stackage.org/install">proces bazat pe Stack</a>.</p>

<p>Se poate gƒÉsi o introducere √Æn Haskell mult mai bl√¢ndƒÉ la adresele
<a href="http://learnyouahaskell.com/">Learn you a Haskell</a> sau
<a href="http://book.realworldhaskell.org/">Real World Haskell</a>.</p>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/ro-ro/haskell-ro.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by Adit Bhargava, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/ro-ro/haskell-ro.html.markdown">3 contributors</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://adit.io">Adit Bhargava</a>
    </p>

    <p>
      Translated by:
        <a href="http://petru-dimitriu.github.io">Petru Dimitriu</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
