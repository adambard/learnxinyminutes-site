<!DOCTYPE html lang="pt-br" xml:lang="pt-br" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WXC8R75DEN');
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="pt-br">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn haxe in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/pt-br/haxe-pt/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fpt-br%2Fhaxe-pt%2F&text=Aprenda+X+em+Y+Minutos%2C+onde+X%3Dhaxe">
        Compartilhe esta página
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Selecione o tema:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">claro</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">sombrio</button>
  </div>
  <h1><a href="/">Aprenda X em Y Minutos</a></h1>
  <h2>Onde X=haxe</h2>
    <p class="filelink">
    Baixar o código:
    <a href="/docs/files/LearnHaxe3-br.hx">LearnHaxe3-br.hx</a>
    </p>
  <div id="doc">
    <p>Haxe é uma linguagem baseada na web que provê suporte a C++, C#, SWF/ActionScript,
Java e Neko byte code (também desenvolvida pelo autor de Haxe). Observe que
este guia é para a versão 3 de Haxe. Alguns pontos do guia são aplicáveis
para versões anteriores, mas é recomendado que você busque outras referências
para essas versões.</p>
<div class="highlight"><pre class="highlight csharp"><code><span class="cm">/*
   Bem vindo ao Aprenda Haxe 3 em 15 minutos. http://www.haxe.org
   Este é um tutorial executável. Você pode compilar e rodar este tutorial
   usando o compilador haxe, estando no mesmo diretório de LearnHaxe.hx:
   $&gt; haxe -main LearnHaxe3 -x out

   Olhe para os sinais de /* e */</span> <span class="n">em</span> <span class="n">volta</span> <span class="n">desses</span> <span class="n">par</span><span class="err">á</span><span class="n">grafos</span><span class="p">.</span> <span class="n">N</span><span class="err">ó</span><span class="n">s</span> <span class="n">estamos</span>
   <span class="n">dentro</span> <span class="n">de</span> <span class="n">um</span> <span class="s">"Comentário multilinha"</span><span class="p">.</span> <span class="n">N</span><span class="err">ó</span><span class="n">s</span> <span class="n">podemos</span> <span class="n">colocar</span> <span class="n">observa</span><span class="err">çõ</span><span class="n">es</span> <span class="n">aqui</span>
   <span class="n">e</span> <span class="n">elas</span> <span class="n">ser</span><span class="err">ã</span><span class="n">o</span> <span class="n">ignoradas</span> <span class="n">pelo</span> <span class="n">compilador</span><span class="p">.</span>

   <span class="n">Coment</span><span class="err">á</span><span class="n">rios</span> <span class="n">multilinha</span> <span class="n">tamb</span><span class="err">é</span><span class="n">m</span> <span class="n">s</span><span class="err">ã</span><span class="n">o</span> <span class="n">utilizados</span> <span class="n">para</span> <span class="n">gerar</span> <span class="n">documenta</span><span class="err">çã</span><span class="n">o</span> <span class="n">haxedoc</span><span class="p">,</span>
   <span class="n">seguindo</span> <span class="n">o</span> <span class="n">estilo</span> <span class="n">javadoc</span><span class="p">.</span> <span class="n">Eles</span> <span class="n">ser</span><span class="err">ã</span><span class="n">o</span> <span class="n">usados</span> <span class="n">pelo</span> <span class="n">haxedoc</span> <span class="n">se</span> <span class="n">precerem</span> <span class="n">imediatamente</span>
   <span class="n">uma</span> <span class="n">classe</span><span class="p">,</span> <span class="n">uma</span> <span class="n">fun</span><span class="err">çã</span><span class="n">o</span> <span class="n">de</span> <span class="n">uma</span> <span class="n">classe</span> <span class="n">ou</span> <span class="n">uma</span> <span class="n">vari</span><span class="err">á</span><span class="n">vel</span> <span class="n">de</span> <span class="n">uma</span> <span class="n">classe</span><span class="p">.</span>

 <span class="p">*/</span>

<span class="c1">// Duas barras, como as dessa linha, farão um comentário de linha única.</span>


<span class="cm">/*
   Este será o primeiro código haxe de verdade, e está declarando um pacote vazio.
   Não é necessário usar um pacote, mas ele será útil se você quiser criar
   um namespace para o seu código (exemplo: org.seuapp.SuaClasse).

   Omitir a declaração de pacote é a mesma coisa que declarar um pacote vazio.
 */</span>
<span class="n">package</span><span class="p">;</span> <span class="c1">// pacote vazio, sem namespace.</span>

<span class="cm">/*
   Pacotes são diretórios que contém módulos. Cada módulo é um arquivo .hx que
   contém tipos definidos em um pacote. Nomes de pacotes (ex. org.seuapp)
   devem estar em letras minúsculas, enquanto nomes de módulos devem começar
   com uma letra maiúscula. Um módulo contem um ou mais tipos, cujo os nomes
   também devem começar com uma letra maiúscula.

   Exemplo: a classe "org.seuapp.Foo" deve ter a estrutura de diretório org/module/Foo.hx,
   sendo acessível do diretório do compilador ou caminho da classe.   

   Se você importar código de outros arquivos, isso deve ser declarado antes
   do restante do código. Haxe disponibiliza várias classes padrões para você
   começar:
 */</span>
<span class="n">import</span> <span class="n">haxe</span><span class="p">.</span><span class="n">ds</span><span class="p">.</span><span class="n">ArraySort</span><span class="p">;</span>

<span class="c1">// você pode importar várias classes/módulos de uma vez usando "*"</span>
<span class="n">import</span> <span class="n">haxe</span><span class="p">.</span><span class="n">ds</span><span class="p">.*;</span>

<span class="c1">// você pode importar campos estáticos</span>
<span class="n">import</span> <span class="n">Lambda</span><span class="p">.</span><span class="n">array</span><span class="p">;</span>

<span class="c1">// você também pode usar "*" para importar todos os campos estáticos</span>
<span class="n">import</span> <span class="n">Math</span><span class="p">.*;</span>

<span class="cm">/*
   Você também pode importar classes de uma forma diferente, habilitando-as para
   extender a funcionalidade de outras classes, como um "mixin". Falaremos sobre
   "using" em breve.
 */</span>
<span class="k">using</span> <span class="nn">StringTools</span><span class="p">;</span>

<span class="cm">/*
   Typedefs são como variáveis... para tipos. Eles devem ser declarados antes
   de qualquer código. Veremos isso em breve.
 */</span>
<span class="n">typedef</span> <span class="n">FooString</span> <span class="p">=</span> <span class="n">String</span><span class="p">;</span>

<span class="c1">// Typedefs também podem referenciar tipos "estruturais". Também veremos isso em breve.</span>
<span class="n">typedef</span> <span class="n">FooObject</span> <span class="p">=</span> <span class="p">{</span> <span class="n">foo</span><span class="p">:</span> <span class="n">String</span> <span class="p">};</span>

<span class="cm">/*
   Esta é a definição da classe. É a classe principal do arquivo, visto que
   possui o mesmo nome (LearnHaxe3)
 */</span>
<span class="k">class</span> <span class="nc">LearnHaxe3</span><span class="p">{</span>
    <span class="cm">/*
       Se você quiser que um determinado código rode automaticamente, você
       precisa colocá-lo em uma função estática "main", e especificar a classe
       nos argumentos do compilador.
       Nesse caso, nós especificamos a classe "LearnHaxe3" no nos argumentos
       do compilador acima.
     */</span>
    <span class="k">static</span> <span class="n">function</span> <span class="nf">main</span><span class="p">(){</span>

        <span class="cm">/*
           Trace é o método padrão para imprimir expressões haxe na tela.
           Temos diferentes métodos para conseguir isso em diferentes destinos.
           Por exemplo: Java, C++, C#, etc. irão imprimir para stdout.
           Javascript irá imprimir no console.log, e Flash irá imprimir para um
           TextField anexado. Todos os "traces" imprimem também uma linha em branco
           por padrão. Por fim, é possível prevenir um trace de ser exibido usando
           o argumento "--no-traces" no compilador.
         */</span>
        <span class="nf">trace</span><span class="p">(</span><span class="s">"Olá mundo, com trace()!"</span><span class="p">);</span>

        <span class="cm">/*
           Trace pode tratar qualquer tipo de valor ou objeto. O método tentará
           imprimir a representação de uma expressão da melhor forma. Você também
           pode concatenar strings usando o operador "+":
         */</span>
        <span class="nf">trace</span><span class="p">(</span> <span class="s">" Integer: "</span> <span class="p">+</span> <span class="m">10</span> <span class="p">+</span> <span class="s">" Float: "</span> <span class="p">+</span> <span class="m">3.14</span> <span class="p">+</span> <span class="s">" Boolean: "</span> <span class="p">+</span> <span class="k">true</span><span class="p">);</span>

        <span class="cm">/*
           Em Haxe, é obrigatório separar expressões no mesmo bloco com ';'. Mas
           é possível colocar duas expressões na mesma linha, dessa forma:
         */</span>
        <span class="nf">trace</span><span class="p">(</span><span class="err">'</span><span class="n">duas</span> <span class="n">express</span><span class="err">õ</span><span class="n">es</span><span class="p">..</span><span class="err">'</span><span class="p">);</span> <span class="nf">trace</span><span class="p">(</span><span class="err">'</span><span class="n">uma</span> <span class="n">linha</span><span class="err">'</span><span class="p">);</span>


        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="c1">// Tipos &amp; Variáveis</span>
        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="nf">trace</span><span class="p">(</span><span class="s">"***Tipos &amp; Variáveis***"</span><span class="p">);</span>

        <span class="cm">/*
           Vcoê pode atrelar valores e referências à estruturas usando a
           palavra-chave "var":
         */</span>
        <span class="kt">var</span> <span class="n">um_inteiro</span><span class="p">:</span><span class="n">Int</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">um_inteiro</span> <span class="p">+</span> <span class="s">" é o valor de um_inteiro"</span><span class="p">);</span>


        <span class="cm">/*
           Haxe é tipada estaticamente, então "um_inteiro" temos que declarar
           um valor do tipo "Int", e o restante da expressão atrela o valor "1"
           a esta variável. Em muitos casos, não é necessário declarar o tipo.
           Aqui, o compilador haxe assume que o tipo de "outro_inteiro" deve
           ser "Int"
         */</span>
        <span class="kt">var</span> <span class="n">outro_inteiro</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">outro_inteiro</span> <span class="p">+</span> <span class="s">" é o valor de outro_inteiro"</span><span class="p">);</span>

        <span class="c1">// O método $type() imprime o tipo que o compilador assume:</span>
        <span class="err">$</span><span class="nf">type</span><span class="p">(</span><span class="n">outro_inteiro</span><span class="p">);</span>

        <span class="c1">// Você também pode representar inteiros em hexadecimal:</span>
        <span class="kt">var</span> <span class="n">hex_inteiro</span> <span class="p">=</span> <span class="m">0xffffff</span><span class="p">;</span>

        <span class="cm">/*
           Haxe usa precisão de pltaforma para os tamanhos de Int e Float.
           Ele também usa o comportamento de plataforma para sobrecarga.
           (É possível ter outros tipos numéricos e comportamentos usando
           bibliotecas especiais)
         */</span>

        <span class="cm">/*
           Em adição a valores simples como Integers, Floats e Booleans,
           Haxe disponibiliza implementações padrões de bibliotecas para
           dados comuns de estrutura como strings, arrays, lists e maps:
         */</span>

        <span class="kt">var</span> <span class="n">uma_string</span> <span class="p">=</span> <span class="s">"alguma"</span> <span class="p">+</span> <span class="err">'</span><span class="kt">string</span><span class="err">'</span><span class="p">;</span>  <span class="c1">// strings podem estar entre aspas simples ou duplas</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">uma_string</span> <span class="p">+</span> <span class="s">" é o valor de uma_string"</span><span class="p">);</span>

        <span class="cm">/*
           Strings podem ser "interpoladas" se inserirmos variáveis em
           posições específicas. A string deve estar entre aspas simples, e as
           variáveis devem ser precedidas por "$". Expressões podem estar entre
           ${...}.
         */</span>
        <span class="kt">var</span> <span class="n">x</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
        <span class="kt">var</span> <span class="n">uma_string_interpolada</span> <span class="p">=</span> <span class="err">'</span><span class="n">o</span> <span class="n">valor</span> <span class="n">de</span> <span class="n">x</span> <span class="err">é</span> <span class="err">$</span><span class="n">x</span><span class="err">'</span><span class="p">;</span>
        <span class="kt">var</span> <span class="n">outra_string_interpolada</span> <span class="p">=</span> <span class="err">'</span><span class="n">o</span> <span class="n">valor</span> <span class="n">de</span> <span class="n">x</span> <span class="p">+</span> <span class="m">1</span> <span class="err">é</span> <span class="err">$</span><span class="p">{</span><span class="n">x</span> <span class="p">+</span> <span class="m">1</span><span class="p">}</span><span class="err">'</span><span class="p">;</span>

        <span class="cm">/*
           Strings são imutáveis, métodos retornarão uma cópia de partes
           ou de toda a string. (Veja também a classe StringBuf)
         */</span>
        <span class="kt">var</span> <span class="n">uma_sub_string</span> <span class="p">=</span> <span class="n">a_string</span><span class="p">.</span><span class="nf">substr</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">4</span><span class="p">);</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">uma_sub_string</span> <span class="p">+</span> <span class="s">" é o valor de a_sub_string"</span><span class="p">);</span>

        <span class="cm">/*
           Regex também são suportadas, mas não temos espaço suficiente para
           entrar em muitos detalhes.
         */</span>
        <span class="kt">var</span> <span class="n">re</span> <span class="p">=</span> <span class="p">~/</span><span class="n">foobar</span><span class="p">/;</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="err">'</span><span class="n">foo</span><span class="err">'</span><span class="p">)</span> <span class="p">+</span> <span class="s">" é o valor de (~/foobar/.match('foo')))"</span><span class="p">);</span>

        <span class="cm">/*
           Arrays são indexadas a partir de zero, dinâmicas e mutáveis. Valores
           faltando são definidos como null.
         */</span>
        <span class="kt">var</span> <span class="n">a</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;();</span> <span class="c1">// um array que contém Strings</span>
        <span class="n">a</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="err">'</span><span class="n">foo</span><span class="err">'</span><span class="p">;</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">length</span> <span class="p">+</span> <span class="s">" é o valor de a.length"</span><span class="p">);</span>
        <span class="n">a</span><span class="p">[</span><span class="m">9</span><span class="p">]</span> <span class="p">=</span> <span class="err">'</span><span class="n">bar</span><span class="err">'</span><span class="p">;</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">length</span> <span class="p">+</span> <span class="s">" é o valor de a.length (depois da modificação)"</span><span class="p">);</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="m">3</span><span class="p">]</span> <span class="p">+</span> <span class="s">" é o valor de a[3]"</span><span class="p">);</span> <span class="c1">// null</span>

        <span class="cm">/*
           Arrays são *genéricas*, então você pode indicar quais valores elas
           contém usando um parâmetro de tipo:
         */</span>
        <span class="kt">var</span> <span class="n">a2</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;();</span> <span class="c1">// um Array de Ints</span>
        <span class="kt">var</span> <span class="n">a3</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;&gt;();</span> <span class="c1">// um Array de Arrays (de Strings).</span>

        <span class="cm">/*
           Mapas são estruturas simples de chave/valor. A chave e o valor podem
           ser de qualquer tipo.
         */</span>
        <span class="kt">var</span> <span class="n">m</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Map</span><span class="p">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Int</span><span class="p">&gt;();</span>  <span class="c1">// As chaves são strings, os valores são Ints.</span>
        <span class="n">m</span><span class="p">.</span><span class="k">set</span><span class="p">(</span><span class="err">'</span><span class="n">foo</span><span class="err">'</span><span class="p">,</span> <span class="m">4</span><span class="p">);</span>
        <span class="c1">// Você também pode usar a notação de array;</span>
        <span class="n">m</span><span class="p">[</span><span class="err">'</span><span class="n">bar</span><span class="err">'</span><span class="p">]</span> <span class="p">=</span> <span class="m">5</span><span class="p">;</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="nf">exists</span><span class="p">(</span><span class="err">'</span><span class="n">bar</span><span class="err">'</span><span class="p">)</span> <span class="p">+</span> <span class="s">" é o valor de m.exists('bar')"</span><span class="p">);</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="err">'</span><span class="n">bar</span><span class="err">'</span><span class="p">)</span> <span class="p">+</span> <span class="s">" é o valor de m.get('bar')"</span><span class="p">);</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="err">'</span><span class="n">bar</span><span class="err">'</span><span class="p">]</span> <span class="p">+</span> <span class="s">" é o valor de m['bar']"</span><span class="p">);</span>

        <span class="kt">var</span> <span class="n">m2</span> <span class="p">=</span>  <span class="p">[</span><span class="err">'</span><span class="n">foo</span><span class="err">'</span> <span class="p">=&gt;</span> <span class="m">4</span><span class="p">,</span> <span class="err">'</span><span class="n">baz</span><span class="err">'</span> <span class="p">=&gt;</span> <span class="m">6</span><span class="p">];</span> <span class="c1">// Syntaxe alternativa de map</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">m2</span> <span class="p">+</span> <span class="s">" é o valor de m2"</span><span class="p">);</span>

        <span class="cm">/*
           Lembre-se, você pode usar descoberta de tipo. O compilador
           Haxe irá decidir o tipo da variável assim que você passar um
           argumento que define um parâmetro de tipo.
         */</span>
        <span class="kt">var</span> <span class="n">m3</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Map</span><span class="p">();</span>
        <span class="n">m3</span><span class="p">.</span><span class="k">set</span><span class="p">(</span><span class="m">6</span><span class="p">,</span> <span class="err">'</span><span class="n">baz</span><span class="err">'</span><span class="p">);</span> <span class="c1">// m3 agora é Map&lt;Int,String&gt;</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">m3</span> <span class="p">+</span> <span class="s">" é o valor de m3"</span><span class="p">);</span>

        <span class="cm">/*
           Haxe possui mais algumas estruturas de dados padrões no módulo haxe.ds,
           tais como List, Stack e BalancedTree
         */</span>


        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="c1">// Operadores</span>
        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="nf">trace</span><span class="p">(</span><span class="s">"***OPERADORES***"</span><span class="p">);</span>

        <span class="c1">// aritmética básica</span>
        <span class="nf">trace</span><span class="p">((</span><span class="m">4</span> <span class="p">+</span> <span class="m">3</span><span class="p">)</span> <span class="p">+</span> <span class="s">" é o valor de (4 + 3)"</span><span class="p">);</span>
        <span class="nf">trace</span><span class="p">((</span><span class="m">5</span> <span class="p">-</span> <span class="m">1</span><span class="p">)</span> <span class="p">+</span> <span class="s">" é o valor de (5 - 1)"</span><span class="p">);</span>
        <span class="nf">trace</span><span class="p">((</span><span class="m">2</span> <span class="p">*</span> <span class="m">4</span><span class="p">)</span> <span class="p">+</span> <span class="s">" é o valor de (2 * 4)"</span><span class="p">);</span>
        <span class="nf">trace</span><span class="p">((</span><span class="m">8</span> <span class="p">/</span> <span class="m">3</span><span class="p">)</span> <span class="p">+</span> <span class="s">" é o valor de (8 / 3) (divisão sempre produz Floats)"</span><span class="p">);</span>
        <span class="nf">trace</span><span class="p">((</span><span class="m">12</span> <span class="p">%</span> <span class="m">4</span><span class="p">)</span> <span class="p">+</span> <span class="s">" é o valor de (12 % 4)"</span><span class="p">);</span>


        <span class="c1">// comparação básica</span>
        <span class="nf">trace</span><span class="p">((</span><span class="m">3</span> <span class="p">==</span> <span class="m">2</span><span class="p">)</span> <span class="p">+</span> <span class="s">" é o valor de 3 == 2"</span><span class="p">);</span>
        <span class="nf">trace</span><span class="p">((</span><span class="m">3</span> <span class="p">!=</span> <span class="m">2</span><span class="p">)</span> <span class="p">+</span> <span class="s">" é o valor de 3 != 2"</span><span class="p">);</span>
        <span class="nf">trace</span><span class="p">((</span><span class="m">3</span> <span class="p">&gt;</span>  <span class="m">2</span><span class="p">)</span> <span class="p">+</span> <span class="s">" é o valor de 3 &gt; 2"</span><span class="p">);</span>
        <span class="nf">trace</span><span class="p">((</span><span class="m">3</span> <span class="p">&lt;</span>  <span class="m">2</span><span class="p">)</span> <span class="p">+</span> <span class="s">" é o valor de 3 &lt; 2"</span><span class="p">);</span>
        <span class="nf">trace</span><span class="p">((</span><span class="m">3</span> <span class="p">&gt;=</span> <span class="m">2</span><span class="p">)</span> <span class="p">+</span> <span class="s">" é o valor de 3 &gt;= 2"</span><span class="p">);</span>
        <span class="nf">trace</span><span class="p">((</span><span class="m">3</span> <span class="p">&lt;=</span> <span class="m">2</span><span class="p">)</span> <span class="p">+</span> <span class="s">" é o valor de 3 &lt;= 2"</span><span class="p">);</span>

        <span class="c1">// operadores bit-a-bit padrões</span>
        <span class="cm">/*
        ~       Complemento bit-a-bit unário
        &lt;&lt;      Deslocamento a esquerda
        &gt;&gt;      Deslocamento a direita
        &gt;&gt;&gt;     Deslocamento a direita com preenchimento de 0
        &amp;       Bit-a-bit AND
        ^       Bit-a-bit OR exclusivo
        |       Bit-a-bit OR inclusivo
        */</span>

        <span class="c1">// incrementos</span>
        <span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="nf">trace</span><span class="p">(</span><span class="s">"Incrementos e decrementos"</span><span class="p">);</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">i</span><span class="p">++);</span> <span class="c1">//i = 1. Pós-incremento</span>
        <span class="nf">trace</span><span class="p">(++</span><span class="n">i</span><span class="p">);</span> <span class="c1">//i = 2. Pré-incremento</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">i</span><span class="p">--);</span> <span class="c1">//i = 1. Pós-decremento</span>
        <span class="nf">trace</span><span class="p">(--</span><span class="n">i</span><span class="p">);</span> <span class="c1">//i = 0. Pré-decremento</span>

        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="c1">// Estruturas de controle</span>
        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="nf">trace</span><span class="p">(</span><span class="s">"***ESTRUTURAS DE CONTROLE***"</span><span class="p">);</span>

        <span class="c1">// operadores if</span>
        <span class="kt">var</span> <span class="n">j</span> <span class="p">=</span> <span class="m">10</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="p">==</span> <span class="m">10</span><span class="p">){</span>
            <span class="nf">trace</span><span class="p">(</span><span class="s">"isto é impresso"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="p">&gt;</span> <span class="m">10</span><span class="p">){</span>
            <span class="nf">trace</span><span class="p">(</span><span class="s">"não é maior que 10, então não é impresso"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">trace</span><span class="p">(</span><span class="s">"também não é impresso."</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// temos também um if "ternário":</span>
        <span class="p">(</span><span class="n">j</span> <span class="p">==</span> <span class="m">10</span><span class="p">)</span> <span class="p">?</span>  <span class="nf">trace</span><span class="p">(</span><span class="s">"igual a 10"</span><span class="p">)</span> <span class="p">:</span> <span class="nf">trace</span><span class="p">(</span><span class="s">"diferente de 10"</span><span class="p">);</span>

        <span class="cm">/*
           Por fim, temos uma outra forma de estrutura de controle que opera
           e na hora da compilação: compilação condicional.
         */</span>
<span class="cp">#if neko
</span>        <span class="nf">trace</span><span class="p">(</span><span class="err">'</span><span class="n">ol</span><span class="err">á</span> <span class="n">de</span> <span class="n">neko</span><span class="err">'</span><span class="p">);</span>
<span class="err">#</span><span class="n">elseif</span> <span class="n">js</span>
        <span class="nf">trace</span><span class="p">(</span><span class="err">'</span><span class="n">ol</span><span class="err">á</span> <span class="n">de</span> <span class="n">js</span><span class="err">'</span><span class="p">);</span>
<span class="cp">#else
</span>        <span class="nf">trace</span><span class="p">(</span><span class="err">'</span><span class="n">ol</span><span class="err">á</span> <span class="n">de</span> <span class="n">outra</span> <span class="n">plataforma</span><span class="p">!</span><span class="err">'</span><span class="p">);</span>
<span class="err">#</span><span class="n">end</span>
        <span class="cm">/*
           O código compilado irá mudar de acordo com o alvo de plataforma.
           Se estivermos compilando para neko (-x ou -neko), só teremos a
           saudação de neko.
         */</span>


        <span class="nf">trace</span><span class="p">(</span><span class="s">"Loops e Interações"</span><span class="p">);</span>

        <span class="c1">// loop while</span>
        <span class="kt">var</span> <span class="n">k</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">k</span> <span class="p">&lt;</span> <span class="m">100</span><span class="p">){</span>
            <span class="c1">// trace(counter); // irá iprimir números de 0 a 99</span>
            <span class="n">k</span><span class="p">++;</span>
        <span class="p">}</span>

        <span class="c1">// loop do-while</span>
        <span class="kt">var</span>  <span class="n">l</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="k">do</span><span class="p">{</span>
            <span class="nf">trace</span><span class="p">(</span><span class="s">"do sempre rodará pelo menos uma vez"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">);</span>

        <span class="c1">// loop for</span>
        <span class="cm">/*
           Não há loop for no estilo C para Haxe, pois é propenso
           a erros e não é necessário. Ao invés disso, Haxe possui
           uma versão muito mais simples e segura que usa Iterators
           (veremos isso logo mais).
         */</span>
        <span class="kt">var</span> <span class="n">m</span> <span class="p">=</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">val</span> <span class="k">in</span> <span class="n">m</span><span class="p">){</span>
            <span class="nf">trace</span><span class="p">(</span><span class="n">val</span> <span class="p">+</span> <span class="s">" é o valor de val no array m"</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Perceba que você pode iterar em um índice usando uma lista limitada</span>
        <span class="c1">// (veremos isso em breve também)</span>
        <span class="kt">var</span> <span class="n">n</span> <span class="p">=</span> <span class="p">[</span><span class="err">'</span><span class="n">foo</span><span class="err">'</span><span class="p">,</span> <span class="err">'</span><span class="n">bar</span><span class="err">'</span><span class="p">,</span> <span class="err">'</span><span class="n">baz</span><span class="err">'</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">val</span> <span class="k">in</span> <span class="m">0.</span><span class="p">..</span><span class="n">n</span><span class="p">.</span><span class="n">length</span><span class="p">){</span>
            <span class="nf">trace</span><span class="p">(</span><span class="n">val</span> <span class="p">+</span> <span class="s">" é o valor de val (um índice de n)"</span><span class="p">);</span>
        <span class="p">}</span>


        <span class="nf">trace</span><span class="p">(</span><span class="s">"Compreensões de array"</span><span class="p">);</span>

        <span class="c1">// Compreensões de array servem para que você posse iterar um array</span>
        <span class="c1">// enquanto cria filtros e modificações</span>
        <span class="kt">var</span> <span class="n">n_filtrado</span> <span class="p">=</span> <span class="p">[</span><span class="k">for</span> <span class="p">(</span><span class="n">val</span> <span class="k">in</span> <span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="p">!=</span> <span class="s">"foo"</span><span class="p">)</span> <span class="n">val</span><span class="p">];</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">n_filtrado</span> <span class="p">+</span> <span class="s">" é o valor de n_filtrado"</span><span class="p">);</span>

        <span class="kt">var</span> <span class="n">n_modificado</span> <span class="p">=</span> <span class="p">[</span><span class="k">for</span> <span class="p">(</span><span class="n">val</span> <span class="k">in</span> <span class="n">n</span><span class="p">)</span> <span class="n">val</span> <span class="p">+=</span> <span class="sc">'!'</span><span class="p">];</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">n_modificado</span> <span class="p">+</span> <span class="s">" é o valor de n_modificado"</span><span class="p">);</span>

        <span class="kt">var</span> <span class="n">n_filtrado_e_modificado</span> <span class="p">=</span> <span class="p">[</span><span class="k">for</span> <span class="p">(</span><span class="n">val</span> <span class="k">in</span> <span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="p">!=</span> <span class="s">"foo"</span><span class="p">)</span> <span class="n">val</span> <span class="p">+=</span> <span class="s">"!"</span><span class="p">];</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">n_filtrado_e_modificado</span> <span class="p">+</span> <span class="s">" é o valor de n_filtrado_e_modificado"</span><span class="p">);</span>

        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="c1">// Blocos Switch (Tipos de valor)</span>
        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="nf">trace</span><span class="p">(</span><span class="s">"***BLOCOS SWITCH (Tipos de valor)***"</span><span class="p">);</span>

        <span class="cm">/*
           Blocos Switch no Haxe são muito poderosos. Além de funcionar com
           valores básicos como strings e ints, também funcionam com tipos
           algébricos em enums (falaremos sobre enums depois).
           Veja alguns exemplos de valor básico por enquanto:
         */</span>
        <span class="kt">var</span> <span class="n">meu_cachorro</span> <span class="p">=</span> <span class="s">"fido"</span><span class="p">;</span>
        <span class="kt">var</span> <span class="n">coisa_favorita</span>  <span class="p">=</span> <span class="s">""</span><span class="p">;</span>
        <span class="k">switch</span><span class="p">(</span><span class="n">meu_cachorro</span><span class="p">){</span>
            <span class="k">case</span> <span class="s">"fido"</span> <span class="p">:</span> <span class="n">favorite_thing</span> <span class="p">=</span> <span class="s">"osso"</span><span class="p">;</span>
            <span class="k">case</span> <span class="s">"rex"</span>  <span class="p">:</span> <span class="n">favorite_thing</span> <span class="p">=</span> <span class="s">"sapato"</span><span class="p">;</span>
            <span class="k">case</span> <span class="s">"spot"</span> <span class="p">:</span> <span class="n">favorite_thing</span> <span class="p">=</span> <span class="s">"bola de tênis"</span><span class="p">;</span>
            <span class="k">default</span>     <span class="p">:</span> <span class="n">favorite_thing</span> <span class="p">=</span> <span class="s">"algum brinquedo desconhecido"</span><span class="p">;</span>
            <span class="c1">// case _   : favorite_thing = "algum brinquedo desconhecido"; // mesma coisa que default</span>
        <span class="p">}</span>
        <span class="c1">// O case "_" acima é um valor "coringa" que</span>
        <span class="c1">// que funcionará para qualquer coisa.</span>

        <span class="nf">trace</span><span class="p">(</span><span class="s">"O nome do meu cachorro é "</span> <span class="p">+</span> <span class="n">meu_cachorro</span>
                <span class="p">+</span> <span class="s">", e sua coisa favorita é: "</span>
                <span class="p">+</span> <span class="n">coisa_favorita</span><span class="p">);</span>

        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="c1">// Declarações de expressão</span>
        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="nf">trace</span><span class="p">(</span><span class="s">"***DECLARAÇÕES DE EXPRESSÃO***"</span><span class="p">);</span>

        <span class="cm">/*
           As declarações de controle em Haxe são muito poderosas pois
           toda declaração também é uma expressão, considere o seguinte:
        */</span>

        <span class="c1">// declarações if</span>
        <span class="kt">var</span> <span class="n">k</span> <span class="p">=</span> <span class="k">if</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="m">10</span> <span class="k">else</span> <span class="m">20</span><span class="p">;</span>

        <span class="nf">trace</span><span class="p">(</span><span class="s">"k igual a "</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span> <span class="c1">// retorna 10</span>

        <span class="kt">var</span> <span class="n">outra_coisa_favorita</span> <span class="p">=</span> <span class="k">switch</span><span class="p">(</span><span class="n">meu_cachorro</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="s">"fido"</span> <span class="p">:</span> <span class="s">"ursinho"</span><span class="p">;</span>
            <span class="k">case</span> <span class="s">"rex"</span>  <span class="p">:</span> <span class="s">"graveto"</span><span class="p">;</span>
            <span class="k">case</span> <span class="s">"spot"</span> <span class="p">:</span> <span class="s">"bola de futebol"</span><span class="p">;</span>
            <span class="k">default</span>     <span class="p">:</span> <span class="s">"algum brinquedo desconhecido"</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nf">trace</span><span class="p">(</span><span class="s">"O nome do meu cachorro é "</span> <span class="p">+</span> <span class="n">meu</span> <span class="n">cachorro</span>
                <span class="p">+</span> <span class="s">", e sua outra coisa favorita é: "</span>
                <span class="p">+</span> <span class="n">outra_coisa_favorita</span><span class="p">);</span>

        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="c1">// Convertendo tipos de valores</span>
        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="nf">trace</span><span class="p">(</span><span class="s">"***CONVERTENDO TIPOS DE VALORES***"</span><span class="p">);</span>

        <span class="c1">// Você pode converter strings em ints de forma bem fácil.</span>

        <span class="c1">// string para int</span>
        <span class="n">Std</span><span class="p">.</span><span class="nf">parseInt</span><span class="p">(</span><span class="s">"0"</span><span class="p">);</span> <span class="c1">// retorna 0</span>
        <span class="n">Std</span><span class="p">.</span><span class="nf">parseFloat</span><span class="p">(</span><span class="s">"0.4"</span><span class="p">);</span> <span class="c1">// retorna 0.4;</span>

        <span class="c1">// int para string</span>
        <span class="n">Std</span><span class="p">.</span><span class="kt">string</span><span class="p">(</span><span class="m">0</span><span class="p">);</span> <span class="c1">// retorna "0";</span>
        <span class="c1">// concatenar com strings irá converter automaticamente em string.</span>
        <span class="m">0</span> <span class="p">+</span> <span class="s">""</span><span class="p">;</span>  <span class="c1">// retorna "0";</span>
        <span class="k">true</span> <span class="p">+</span> <span class="s">""</span><span class="p">;</span> <span class="c1">// retorna "true";</span>
        <span class="c1">// Veja a documentação de parseamento em Std para mais detalhes.</span>


        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="c1">// Lidando com Tipos</span>
        <span class="c1">//////////////////////////////////////////////////////////////////</span>

        <span class="cm">/*
           Como mencionamos anteriormente, Haxe é uma linguagem tipada
           estaticamente. Tipagem estática é uma coisa maravilhosa. Isto
           permite autocompletar mais preciso, e pode ser usado para checar
           completamente o funcionamento de um programa. Além disso, o compilador
           Haxe é super rápido.

           *ENTRETANTO*, há momentos em que você espera que o compilador apenas
           deixe algo passar, e não lance um "type error" em um determinado caso.

           Para fazer isso, Haxe tem duas palavras-chave separadas. A primeira
           é o tipo "Dynamic":
         */</span>
        <span class="kt">var</span> <span class="n">din</span><span class="p">:</span> <span class="n">Dynamic</span> <span class="p">=</span> <span class="s">"qualquer tipo de variável, assim como essa string"</span><span class="p">;</span>

        <span class="cm">/*
           Tudo o que você sabe sobre uma variável Dynamic é que o compilador
           não irá mais se preocupar com o tipo dela. É como uma variável
           "coringa": você pode usar isso ao invés de qualquer tipo de variável,
           e você pode atrelar qualquer valor a essa variável.

           A outra (e mais extrema) opção é a palavra-chave "untyped":
         */</span>

            <span class="n">untyped</span> <span class="p">{</span>
                <span class="kt">var</span> <span class="n">x</span><span class="p">:</span><span class="n">Int</span> <span class="p">=</span> <span class="err">'</span><span class="n">foo</span><span class="err">'</span><span class="p">;</span> <span class="c1">// não faz sentido!</span>
                <span class="kt">var</span> <span class="n">y</span><span class="p">:</span><span class="n">String</span> <span class="p">=</span> <span class="m">4</span><span class="p">;</span> <span class="c1">// loucura!</span>
            <span class="p">}</span>

        <span class="cm">/*
           A palavra-chave "untyped" opera em *blocos* inteiros de código,
           ignorando qualquer verificação de tipo que seria obrigatória em
           outros casos. Essa palavra-chave deve ser usada com muita cautela,
           como em situações limitadas de compilação condicional onde a
           verificação de tipo pode ser um obstáculo.

           No geral, ignorar verificações de tipo *não* é recomendado. Use
           os modelos de enum, herança ou estrutural para garantir o correto
           funcionamento do seu programa. Só quando você tiver certeza de que
           nenhum desses modelos funcionam no seu caso, você deve usar "Dynamic"
           ou "untyped".
         */</span>

        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="c1">// Programação básica orientada a objetos</span>
        <span class="c1">//////////////////////////////////////////////////////////////////</span>
        <span class="nf">trace</span><span class="p">(</span><span class="s">"***PROGRAMAÇÃO BÁSICA ORIENTADA A OBJETOS***"</span><span class="p">);</span>


        <span class="cm">/*
           Cria uma instância da FooClass. As definicções dessas classes
           estão no final do arquivo.
         */</span>
        <span class="kt">var</span> <span class="n">instancia_foo</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">FooClass</span><span class="p">(</span><span class="m">3</span><span class="p">);</span>

        <span class="c1">// lê a variável pública normalmente</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">instancia_foo</span><span class="p">.</span><span class="n">variavel_publica</span> <span class="p">+</span> <span class="s">" é o valor de instancia_foo.variavel_publica"</span><span class="p">);</span>

        <span class="c1">// nós podemos ler essa variável</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">instancia_foo</span><span class="p">.</span><span class="n">publica_leitura</span> <span class="p">+</span> <span class="s">" é o valor de instancia_foo.publica_leitura"</span><span class="p">);</span>
        <span class="c1">// mas não podemos escrever nela</span>
        <span class="c1">// instancia_foo.publica_leitura = 4; // isso irá causar um erro se descomentado:</span>
        <span class="c1">// trace(instancia_foo.public_escrita); // e isso também.</span>

        <span class="c1">// chama o método toString:</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">instancia_foo</span> <span class="p">+</span> <span class="s">" é o valor de instancia_foo"</span><span class="p">);</span>
        <span class="c1">// mesma coisa:</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">instancia_foo</span><span class="p">.</span><span class="nf">toString</span><span class="p">()</span> <span class="p">+</span> <span class="s">" é o valor de instancia_foo.toString()"</span><span class="p">);</span>


        <span class="cm">/*
           A instancia_foo é do tipo "FooClass", enquanto acceptBarInstance
           é do tipo BarClass. Entretanto, como FooClass extende BarClass,
           ela é aceita.
         */</span>
        <span class="n">BarClass</span><span class="p">.</span><span class="nf">acceptBarInstance</span><span class="p">(</span><span class="n">instancia_foo</span><span class="p">);</span>

        <span class="cm">/*
           As classes abaixo têm mais alguns exemplos avançados, o método
           "example()" executará esses exemplos aqui:
         */</span>
        <span class="n">SimpleEnumTest</span><span class="p">.</span><span class="nf">example</span><span class="p">();</span>
        <span class="n">ComplexEnumTest</span><span class="p">.</span><span class="nf">example</span><span class="p">();</span>
        <span class="n">TypedefsAndStructuralTypes</span><span class="p">.</span><span class="nf">example</span><span class="p">();</span>
        <span class="n">UsingExample</span><span class="p">.</span><span class="nf">example</span><span class="p">();</span>

    <span class="p">}</span>

<span class="p">}</span>

<span class="cm">/*
   Essa é a "classe filha" do classe principal LearnHaxe3
 */</span>
<span class="k">class</span> <span class="nc">FooClass</span> <span class="n">extends</span> <span class="n">BarClass</span> <span class="n">implements</span> <span class="n">BarInterface</span><span class="p">{</span>
    <span class="k">public</span> <span class="kt">var</span> <span class="n">variavel_publica</span><span class="p">:</span><span class="n">Int</span><span class="p">;</span> <span class="c1">// variáveis públicas são acessíveis de qualquer lugar</span>
    <span class="k">public</span> <span class="kt">var</span> <span class="nf">publica_leitura</span> <span class="p">(</span><span class="k">default</span><span class="p">,</span> <span class="k">null</span><span class="p">):</span> <span class="n">Int</span><span class="p">;</span> <span class="c1">// somente leitura pública habilitada</span>
    <span class="k">public</span> <span class="kt">var</span> <span class="nf">publica_escrita</span> <span class="p">(</span><span class="k">null</span><span class="p">,</span> <span class="k">default</span><span class="p">):</span> <span class="n">Int</span><span class="p">;</span> <span class="c1">// somente escrita pública habilitada</span>
    <span class="k">public</span> <span class="kt">var</span> <span class="nf">property</span> <span class="p">(</span><span class="k">get</span><span class="p">,</span> <span class="k">set</span><span class="p">):</span> <span class="n">Int</span><span class="p">;</span> <span class="c1">// use este estilo para habilitar getters e setters</span>

    <span class="c1">// variáveis privadas não estão disponíveis fora da classe.</span>
    <span class="c1">// veja @:allow para formas de fazer isso.</span>
    <span class="kt">var</span> <span class="n">_private</span><span class="p">:</span><span class="n">Int</span><span class="p">;</span> <span class="c1">// variáveis são privadas se não forem marcadas como públicas</span>

    <span class="c1">// um construtor público</span>
    <span class="k">public</span> <span class="n">function</span> <span class="k">new</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span><span class="n">Int</span><span class="p">){</span>
        <span class="c1">// chama o construtor do objeto pai, já que nós extendemos a BarClass:</span>
        <span class="nf">super</span><span class="p">();</span>

        <span class="k">this</span><span class="p">.</span><span class="n">variavel_publica</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">_private</span> <span class="p">=</span> <span class="n">arg</span><span class="p">;</span>

    <span class="p">}</span>

    <span class="c1">// getter para _private</span>
    <span class="n">function</span> <span class="nf">get_property</span><span class="p">()</span> <span class="p">:</span> <span class="n">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">_private</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// setter para _private</span>
    <span class="n">function</span> <span class="nf">set_property</span><span class="p">(</span><span class="n">val</span><span class="p">:</span><span class="n">Int</span><span class="p">)</span> <span class="p">:</span> <span class="n">Int</span> <span class="p">{</span>
        <span class="n">_private</span> <span class="p">=</span> <span class="n">val</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">val</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// função especial que é chamada sempre que uma instância é convertida em string.</span>
    <span class="k">public</span> <span class="n">function</span> <span class="nf">toString</span><span class="p">(){</span>
        <span class="k">return</span> <span class="n">_private</span> <span class="p">+</span> <span class="s">" com o método toString()!"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// essa classe precisa ter essa função definida, pois ela implementa</span>
    <span class="c1">// a interface BarInterface</span>
    <span class="k">public</span> <span class="n">function</span> <span class="nf">baseFunction</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">:</span> <span class="n">String</span><span class="p">{</span>
        <span class="c1">// converte o int em string automaticamente</span>
        <span class="k">return</span> <span class="n">x</span> <span class="p">+</span> <span class="s">" foi passado pela baseFunction!"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*
    Uma classe simples para extendermos
*/</span>
<span class="k">class</span> <span class="nc">BarClass</span> <span class="p">{</span>
    <span class="kt">var</span> <span class="n">base_variable</span><span class="p">:</span><span class="n">Int</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">function</span> <span class="k">new</span><span class="p">(){</span>
        <span class="n">base_variable</span> <span class="p">=</span> <span class="m">4</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">function</span> <span class="nf">acceptBarInstance</span><span class="p">(</span><span class="n">b</span><span class="p">:</span><span class="n">BarClass</span><span class="p">){</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*
    Uma interface simples para implementarmos
*/</span>
<span class="k">interface</span> <span class="nc">BarInterface</span><span class="p">{</span>
    <span class="k">public</span> <span class="n">function</span> <span class="nf">baseFunction</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="n">Int</span><span class="p">):</span><span class="n">String</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//////////////////////////////////////////////////////////////////</span>
<span class="c1">// Declarações Enum e Switch</span>
<span class="c1">//////////////////////////////////////////////////////////////////</span>

<span class="cm">/*
   Enums no Haxe são muito poderosos. Resumidamente, enums são
   um tipo com um número limitado de estados:
 */</span>

<span class="k">enum</span> <span class="n">SimpleEnum</span> <span class="p">{</span>
    <span class="n">Foo</span><span class="p">;</span>
    <span class="n">Bar</span><span class="p">;</span>
    <span class="n">Baz</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//   Uma classe que faz uso desse enum:</span>

<span class="k">class</span> <span class="nc">SimpleEnumTest</span><span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">function</span> <span class="nf">example</span><span class="p">(){</span>
        <span class="kt">var</span> <span class="n">e_explicit</span><span class="p">:</span><span class="n">SimpleEnum</span> <span class="p">=</span> <span class="n">SimpleEnum</span><span class="p">.</span><span class="n">Foo</span><span class="p">;</span> <span class="c1">// você pode especificar o nome "completo"</span>
        <span class="kt">var</span> <span class="n">e</span> <span class="p">=</span> <span class="n">Foo</span><span class="p">;</span> <span class="c1">// bas descoberta de tipo também funciona.</span>
        <span class="k">switch</span><span class="p">(</span><span class="n">e</span><span class="p">){</span>
            <span class="k">case</span> <span class="n">Foo</span><span class="p">:</span> <span class="nf">trace</span><span class="p">(</span><span class="s">"e era Foo"</span><span class="p">);</span>
            <span class="k">case</span> <span class="n">Bar</span><span class="p">:</span> <span class="nf">trace</span><span class="p">(</span><span class="s">"e era Bar"</span><span class="p">);</span>
            <span class="k">case</span> <span class="n">Baz</span><span class="p">:</span> <span class="nf">trace</span><span class="p">(</span><span class="s">"e era Baz"</span><span class="p">);</span> <span class="c1">// comente esta linha e teremos um erro.</span>
        <span class="p">}</span>

        <span class="cm">/*
           Isso não parece tão diferente de uma alteração simples de valor em strings.
           Entretanto, se nós não incluirmos *todos* os estados, o compilador
           reclamará. Você pode testar isso comentando a linha mencionada acima.

           Você também pode especificar um valor padrão (default) para enums:
         */</span>
        <span class="k">switch</span><span class="p">(</span><span class="n">e</span><span class="p">){</span>
            <span class="k">case</span> <span class="n">Foo</span><span class="p">:</span> <span class="nf">trace</span><span class="p">(</span><span class="s">"e é Foo outra vez"</span><span class="p">);</span>
            <span class="k">default</span> <span class="p">:</span> <span class="nf">trace</span><span class="p">(</span><span class="s">"default funciona aqui também"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*
    Enums vão muito mais além que estados simples, nós também
    podemos enumerar *construtores*, mas nós precisaremos de um
    exemplo mais complexo de enum:
 */</span>
<span class="k">enum</span> <span class="n">ComplexEnum</span><span class="p">{</span>
    <span class="nf">IntEnum</span><span class="p">(</span><span class="n">i</span><span class="p">:</span><span class="n">Int</span><span class="p">);</span>
    <span class="nf">MultiEnum</span><span class="p">(</span><span class="n">i</span><span class="p">:</span><span class="n">Int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span><span class="n">String</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span><span class="n">Float</span><span class="p">);</span>
    <span class="nf">SimpleEnumEnum</span><span class="p">(</span><span class="n">s</span><span class="p">:</span><span class="n">SimpleEnum</span><span class="p">);</span>
    <span class="nf">ComplexEnumEnum</span><span class="p">(</span><span class="n">c</span><span class="p">:</span><span class="n">ComplexEnum</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// Observação: O enum acima pode incluir *outros* enums também, incluindo ele mesmo!</span>
<span class="c1">// Observação: Isto é o que chamamos de *Tipos de dado algébricos* em algumas outras linguagens.</span>

<span class="k">class</span> <span class="nc">ComplexEnumTest</span><span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">function</span> <span class="nf">example</span><span class="p">(){</span>
        <span class="kt">var</span> <span class="n">e1</span><span class="p">:</span><span class="n">ComplexEnum</span> <span class="p">=</span> <span class="nf">IntEnum</span><span class="p">(</span><span class="m">4</span><span class="p">);</span> <span class="c1">// especificando o parâmetro enum</span>
        <span class="cm">/*
           Agora nós podemos usar switch no enum, assim como extrair qualquer
           parâmetros que ele possa ter.
         */</span>
        <span class="k">switch</span><span class="p">(</span><span class="n">e1</span><span class="p">){</span>
            <span class="k">case</span> <span class="nf">IntEnum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">:</span> <span class="nf">trace</span><span class="p">(</span><span class="err">'$</span><span class="n">x</span> <span class="n">foi</span> <span class="n">o</span> <span class="n">par</span><span class="err">â</span><span class="n">metro</span> <span class="n">passado</span> <span class="n">para</span> <span class="n">e1</span><span class="err">'</span><span class="p">);</span>
            <span class="k">default</span><span class="p">:</span> <span class="nf">trace</span><span class="p">(</span><span class="s">"Isso não deve ser impresso"</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// outro parâmetro aqui que também é um enum... um enum enum?</span>
        <span class="kt">var</span> <span class="n">e2</span> <span class="p">=</span> <span class="nf">SimpleEnumEnum</span><span class="p">(</span><span class="n">Foo</span><span class="p">);</span>
        <span class="k">switch</span><span class="p">(</span><span class="n">e2</span><span class="p">){</span>
            <span class="k">case</span> <span class="nf">SimpleEnumEnum</span><span class="p">(</span><span class="n">s</span><span class="p">):</span> <span class="nf">trace</span><span class="p">(</span><span class="err">'$</span><span class="n">s</span> <span class="n">foi</span> <span class="n">o</span> <span class="n">par</span><span class="err">â</span><span class="n">metro</span> <span class="n">passado</span> <span class="n">para</span> <span class="n">e2</span><span class="err">'</span><span class="p">);</span>
            <span class="k">default</span><span class="p">:</span> <span class="nf">trace</span><span class="p">(</span><span class="s">"Isso não deve ser impresso"</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// enum dentro de enum dentro de enum</span>
        <span class="kt">var</span> <span class="n">e3</span> <span class="p">=</span> <span class="nf">ComplexEnumEnum</span><span class="p">(</span><span class="nf">ComplexEnumEnum</span><span class="p">(</span><span class="nf">MultiEnum</span><span class="p">(</span><span class="m">4</span><span class="p">,</span> <span class="err">'</span><span class="n">hi</span><span class="err">'</span><span class="p">,</span> <span class="m">4.3</span><span class="p">)));</span>
        <span class="k">switch</span><span class="p">(</span><span class="n">e3</span><span class="p">){</span>
            <span class="c1">// Você pode buscar por certos enums aninhados especificando-os</span>
            <span class="c1">// explicitamente:</span>
            <span class="k">case</span> <span class="nf">ComplexEnumEnum</span><span class="p">(</span><span class="nf">ComplexEnumEnum</span><span class="p">(</span><span class="nf">MultiEnum</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)))</span> <span class="p">:</span> <span class="p">{</span>
                <span class="nf">trace</span><span class="p">(</span><span class="err">'$</span><span class="n">i</span><span class="p">,</span> <span class="err">$</span><span class="n">j</span><span class="p">,</span> <span class="n">e</span> <span class="err">$</span><span class="n">k</span> <span class="n">foram</span> <span class="n">passados</span> <span class="n">dentro</span> <span class="n">desse</span> <span class="n">monstro</span> <span class="n">aninhado</span><span class="p">.</span><span class="err">'</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">default</span><span class="p">:</span> <span class="nf">trace</span><span class="p">(</span><span class="s">"Isso não deve ser impresso"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="cm">/*
           Veja outros "tipos de dado algébricos" (GADT, do inglês) para mais
           detalhes sobre o porque eles são tão úteis.
         */</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">TypedefsAndStructuralTypes</span> <span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">function</span> <span class="nf">example</span><span class="p">(){</span>
        <span class="cm">/*
           Aqui nós usaremos tipos typedef, ao invés de tipos base.
           Lá no começo, nós definimos que o tipo "FooString" é um tipo "String". 
         */</span>
        <span class="kt">var</span> <span class="n">t1</span><span class="p">:</span><span class="n">FooString</span> <span class="p">=</span> <span class="s">"alguma string"</span><span class="p">;</span>

        <span class="cm">/*
           Aqui nós usamos typedefs para "tipos estruturais" também. Esses tipos
           são definidos pela sua estrutura de campos, não por herança de classe.
           Aqui temos um objeto anônimo com um campo String chamado "foo":
         */</span>

        <span class="kt">var</span> <span class="n">anon_obj</span> <span class="p">=</span> <span class="p">{</span> <span class="n">foo</span><span class="p">:</span> <span class="err">'</span><span class="n">hi</span><span class="err">'</span> <span class="p">};</span>

        <span class="cm">/*
           A variável anon_obj não tem um tipo declarado, e é um objeto anônimo
           de acordo com o compilador. Entretanto, lembra que lá no início nós
           declaramos a typedef FooObj? Visto que o anon_obj tem a mesma estrutura,
           nós podemos usar ele em qualquer lugar que um "FooObject" é esperado.
         */</span>

        <span class="kt">var</span> <span class="n">f</span> <span class="p">=</span> <span class="nf">function</span><span class="p">(</span><span class="n">fo</span><span class="p">:</span><span class="n">FooObject</span><span class="p">){</span>
            <span class="nf">trace</span><span class="p">(</span><span class="err">'$</span><span class="n">fo</span> <span class="n">foi</span> <span class="n">passado</span> <span class="n">para</span> <span class="n">esta</span> <span class="n">fun</span><span class="err">çã</span><span class="n">o</span><span class="err">'</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nf">f</span><span class="p">(</span><span class="n">anon_obj</span><span class="p">);</span> <span class="c1">// chama a assinatura de FooObject com anon_obj.</span>

        <span class="cm">/*
           Note que typedefs podem ter campos opcionais também, marcados com "?"

           typedef OptionalFooObj = {
                ?optionalString: String,
                requiredInt: Int
           }
         */</span>

        <span class="cm">/*
           Typedefs também funcionam com compilação condicional. Por exemplo,
           nós poderíamos ter incluído isso no topo deste arquivo:

#if( js )
        typedef Surface = js.html.CanvasRenderingContext2D;
#elseif( nme )
        typedef Surface = nme.display.Graphics;
#elseif( !flash9 )
        typedef Surface = flash8.MovieClip;
#elseif( java )
        typedef Surface = java.awt.geom.GeneralPath;
#end

        E teríamos apenas um tipo "Surface" para funcionar em todas
        essas plataformas.
        */</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">UsingExample</span> <span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">function</span> <span class="nf">example</span><span class="p">()</span> <span class="p">{</span>

        <span class="cm">/*
           A palavra-chave "using" é um tipo especial de import de classe que
           altera o comportamento de qualquer método estático na classe.

           Neste arquivo, nós aplicamos "using" em "StringTools", que contém
           alguns métodos estáticos para tratar tipos String.
         */</span>
        <span class="nf">trace</span><span class="p">(</span><span class="n">StringTools</span><span class="p">.</span><span class="nf">endsWith</span><span class="p">(</span><span class="s">"foobar"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">)</span> <span class="p">+</span> <span class="s">" deve ser verdadeiro!"</span><span class="p">);</span>

        <span class="cm">/*
           Com um import "using", o primeiro argumento é extendido com o método.
           O que isso significa? Bem, como "endsWith" tem um primeiro argumento
           de tipo "String", isso significa que todos os tipos "String" agora
           possuem o método "endsWith":
         */</span>
        <span class="nf">trace</span><span class="p">(</span><span class="s">"foobar"</span><span class="p">.</span><span class="nf">endsWith</span><span class="p">(</span><span class="s">"bar"</span><span class="p">)</span> <span class="p">+</span> <span class="s">" deve ser verdadeiro!"</span><span class="p">);</span>

        <span class="cm">/*
           Essa técnica habilita uma grande quantidade de expressões para certos
           tipos, e limita o escopo de modificações para um único arquivo.

           Note que a instância String *não* é modificada em tempo de execução.
           O novo método adicionado não é uma parte da instância anexada, e o
           compilador ainda irá gerar o código equivalente ao método estático.
         */</span>
      <span class="p">}</span>

<span class="p">}</span>
</code></pre></div>
<p>Isso foi apenas o começo do que Haxe pode fazer. Para uma documentação de todos
os recursos de Haxe, veja o <a href="https://haxe.org/manual">manual</a> e a
<a href="https://api.haxe.org/">documentação de API</a>. Para um diretório de bibliotecas de terceiros
disponíveis, veja a <a href="https://lib.haxe.org/">Haxelib</a></p>

<p>Para tópicos mais avançados, dê uma olhada em:</p>

<ul>
<li><a href="https://haxe.org/manual/types-abstract.html">Tipos abstratos</a></li>
<li><a href="https://haxe.org/manual/macro.html">Macros</a></li>
<li><a href="https://haxe.org/manual/cr-features.html">Recursos do compilador</a></li>
</ul>

<p>Por fim, participe do <a href="https://community.haxe.org/">forum Haxe</a>,
ou no IRC <a href="http://webchat.freenode.net/">#haxe onfreenode</a>, ou no
<a href="https://gitter.im/HaxeFoundation/haxe">Chat Gitter</a>.</p>

    <hr>
    <p>Sugestões ou correções? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Abra uma issue</a> no repositório do Github, ou faça um <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/pt-br/haxe-pt.html.markdown">pull request</a> você mesmo!
    </p>
    <p class="contributed">
    Originalmente contribuído por Justin Donaldson e atualizado por <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/pt-br/haxe-pt.html.markdown">2 colaborador(es)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="https://github.com/jdonaldson/">Justin Donaldson</a>,
        <a href="https://github.com/nadako/">Dan Korostelev</a>
    </p>

    <p>
      Translated by:
        <a href="https://github.com/davelima/">David Lima</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>
    </body>
</html>
