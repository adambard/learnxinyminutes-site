<!DOCTYPE html lang="pt-br" xml:lang="pt-br" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="pt-br">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Rust in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/pt-br/rust-pt/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fpt-br%2Frust-pt%2F&text=Aprenda+X+em+Y+Minutos%2C+onde+X%3DRust">
        Compartilhe esta página
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Selecione o tema:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">claro</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">sombrio</button>
  </div>
  <h1><a href="/">Aprenda X em Y Minutos</a></h1>
  <h2>Onde X=Rust</h2>
    <p class="filelink">
    Baixar o código:
    <a href="/docs/files/rust-pt.rs">rust-pt.rs</a>
    </p>
  <div id="doc">
    <p>Rust é uma linguagem de programação desenvolvida pelo Mozilla Research. Rust
combina controle de baixo nível sobre o desempenho com facilidades de alto
nível e garantias de segurança.</p>

<p>Ele atinge esse objetivo sem necessitar de um coletor de lixo ou um processo
<em>runtime</em>, permitindo que se use bibliotecas Rust em substituição a bibliotecas 
em C.</p>

<p>A primeira versão de Rust, 0.1, apareceu em janeiro de 2012, e por três anos o
desenvolvimento correu tão rapidamente que que até recentemente o uso de
versões estáveis foi desencorajado e em vez disso a recomendação era usar as
versões empacotadas toda noite.</p>

<p>Em 15 de maio de 2015, a versão 1.0 de Rust foi liberada com a garantia total
de compatibilidade reversa. Melhorias no tempo de compilação e em outros
aspectos do compilador estão disponíveis atualmente nas versões empacotadas à
noite. Rust adotou um modelo de versões <em>train-based</em> com novas versões
regularmente liberadas a cada seis semanas. A versão 1.1 beta de Rust foi
disponibilizada ao mesmo tempo que a versão 1.0.</p>

<p>Apesar de Rust ser uma linguagem mais de baixo nível, Rust tem alguns conceitos
funcionais geralmente encontradas em linguagens de alto nível. Isso faz Rust
não apenas rápido, mas também fácil e eficiente para programar.</p>
<div class="highlight"><pre class="highlight rust"><code><span class="c1">// Isso é um comentário. Linhas de comentários são assim...</span>
<span class="c1">// e múltiplas linhas se parecem assim.</span>

<span class="cd">/// Comentários para documentação são assim e permitem notação em markdown.</span>
<span class="cd">/// # Exemplos</span>
<span class="cd">///</span>
<span class="cd">/// ```</span>
<span class="cd">/// let five = 5</span>
<span class="cd">/// ```</span>

<span class="c1">///////////////</span>
<span class="c1">// 1. Básico //</span>
<span class="c1">///////////////</span>

<span class="c1">// Funções</span>
<span class="c1">// `i32` é o tipo para inteiros com sinal de 32 bits</span>
<span class="k">fn</span> <span class="nf">add2</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="c1">// Implicit return (no semicolon)</span>
    <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="p">}</span>

<span class="c1">// Função main</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Números //</span>

    <span class="c1">// Immutable bindings</span>
    <span class="k">let</span> <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// Inteiros/Sufixos para ponto flutuante</span>
    <span class="k">let</span> <span class="n">y</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="mi">13i32</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">f</span><span class="p">:</span> <span class="nb">f64</span> <span class="o">=</span> <span class="mf">1.3f64</span><span class="p">;</span>

    <span class="c1">// Inferência de tipos</span>
    <span class="c1">// Em geral, o compilador Rust consegue inferir qual o tipo de uma </span>
    <span class="c1">// variável, então você não tem que escrever uma anotação explícita de tipo.</span>
    <span class="c1">// Ao longo desse tutorial, os tipos serão explicitamente anotados em </span>
    <span class="c1">// muitos lugares, mas apenas com propósito demonstrativo. A inferência de </span>
    <span class="c1">// tipos pode gerenciar isso na maioria das vezes.</span>
    <span class="k">let</span> <span class="n">implicit_x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">implicit_f</span> <span class="o">=</span> <span class="mf">1.3</span><span class="p">;</span>

    <span class="c1">// Aritmética</span>
    <span class="k">let</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">13</span><span class="p">;</span>

    <span class="c1">// Variáveis mutáveis</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">mutable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">mutable</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="n">mutable</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>

    <span class="c1">// Strings //</span>

    <span class="c1">// String literais</span>
    <span class="k">let</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">"hello world!"</span><span class="p">;</span>

    <span class="c1">// Imprimindo</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{} {}"</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// 1.3 hello world</span>

    <span class="c1">// Uma `String` – uma String alocada no heap</span>
    <span class="k">let</span> <span class="n">s</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="s">"hello world"</span><span class="nf">.to_string</span><span class="p">();</span>

    <span class="c1">// Uma String slice - uma visão imutável em outra string.</span>
    <span class="c1">// Basicamente, isso é um par imutável de ponteiros para uma string - ele</span>
    <span class="c1">// não contém o conteúdo de uma strinf, apenas um ponteiro para o começo e </span>
    <span class="c1">// um ponteiro para o fim da área de memória para a string, estaticamente</span>
    <span class="c1">// alocada ou contida em outro objeto (nesse caso, `s`)</span>
    <span class="k">let</span> <span class="n">s_slice</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">;</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"{} {}"</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s_slice</span><span class="p">);</span> <span class="c1">// hello world hello world</span>

    <span class="c1">// Vetores/arrays //</span>

    <span class="c1">// Um array de tamanho fixo</span>
    <span class="k">let</span> <span class="n">four_ints</span><span class="p">:</span> <span class="p">[</span><span class="nb">i32</span><span class="p">;</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>

    <span class="c1">// Um array dinâmico (vetor)</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">vector</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
    <span class="n">vector</span><span class="nf">.push</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

    <span class="c1">// Uma fatia – uma visão imutável em um vetor ou array</span>
    <span class="c1">// Isso é como um string slice, mas para vetores</span>
    <span class="k">let</span> <span class="n">slice</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">i32</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vector</span><span class="p">;</span>

    <span class="c1">// Use `{:?}` para imprimir alguma coisa no estilo de depuração</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?} {:?}"</span><span class="p">,</span> <span class="n">vector</span><span class="p">,</span> <span class="n">slice</span><span class="p">);</span> <span class="c1">// [1, 2, 3, 4, 5] [1, 2, 3, 4, 5]</span>

    <span class="c1">// Tuplas //</span>

    <span class="c1">// Uma tupla é um conjunto de tamanho fixo de valores de tipos</span>
    <span class="c1">// possivelmente diferentes</span>
    <span class="k">let</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="nb">f64</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"hello"</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">);</span>

    <span class="c1">// Desestruturando `let`</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{} {} {}"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span> <span class="c1">// 1 hello 3.4</span>

    <span class="c1">// Indexando</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">x</span><span class="na">.1</span><span class="p">);</span> <span class="c1">// hello</span>

    <span class="c1">//////////////</span>
    <span class="c1">// 2. Tipos //</span>
    <span class="c1">//////////////</span>

    <span class="c1">// Struct</span>
    <span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
        <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
        <span class="n">y</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">origin</span><span class="p">:</span> <span class="n">Point</span> <span class="o">=</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">0</span> <span class="p">};</span>

    <span class="c1">// Uma estrutura com campos sem nome, chamada 'estrutura em tupla'</span>
    <span class="k">struct</span> <span class="nf">Point2</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">origin2</span> <span class="o">=</span> <span class="nf">Point2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// enum básico com na linguagem C</span>
    <span class="k">enum</span> <span class="n">Direction</span> <span class="p">{</span>
        <span class="nb">Left</span><span class="p">,</span>
        <span class="nb">Right</span><span class="p">,</span>
        <span class="n">Up</span><span class="p">,</span>
        <span class="n">Down</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">up</span> <span class="o">=</span> <span class="nn">Direction</span><span class="p">::</span><span class="n">Up</span><span class="p">;</span>

    <span class="c1">// Enum com campos</span>
    <span class="k">enum</span> <span class="n">OptionalI32</span> <span class="p">{</span>
        <span class="nf">AnI32</span><span class="p">(</span><span class="nb">i32</span><span class="p">),</span>
        <span class="n">Nothing</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">two</span><span class="p">:</span> <span class="n">OptionalI32</span> <span class="o">=</span> <span class="nn">OptionalI32</span><span class="p">::</span><span class="nf">AnI32</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">nothing</span> <span class="o">=</span> <span class="nn">OptionalI32</span><span class="p">::</span><span class="n">Nothing</span><span class="p">;</span>

    <span class="c1">// Generics //</span>

    <span class="k">struct</span> <span class="n">Foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">bar</span><span class="p">:</span> <span class="n">T</span> <span class="p">}</span>

    <span class="c1">// Isso é definido na biblioteca padrão como um `Option`</span>
    <span class="k">enum</span> <span class="n">Optional</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">SomeVal</span><span class="p">(</span><span class="n">T</span><span class="p">),</span>
        <span class="n">NoVal</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1">// Methods //</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// Métodos recebem um parâmetro `self` explícito</span>
        <span class="k">fn</span> <span class="nf">get_bar</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.bar</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">a_foo</span> <span class="o">=</span> <span class="n">Foo</span> <span class="p">{</span> <span class="n">bar</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">a_foo</span><span class="nf">.get_bar</span><span class="p">());</span> <span class="c1">// 1</span>

    <span class="c1">// Traits (conhecidos como interfaces ou typeclasses em outras linguagens)//</span>

    <span class="k">trait</span> <span class="n">Frobnicate</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">frobnicate</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Frobnicate</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">frobnicate</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="k">self</span><span class="py">.bar</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">another_foo</span> <span class="o">=</span> <span class="n">Foo</span> <span class="p">{</span> <span class="n">bar</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">another_foo</span><span class="nf">.frobnicate</span><span class="p">());</span> <span class="c1">// Some(1)</span>

    <span class="c1">//////////////////////////////////</span>
    <span class="c1">// 3. Reconhecimento de padrões //</span>
    <span class="c1">//////////////////////////////////</span>

    <span class="k">let</span> <span class="n">foo</span> <span class="o">=</span> <span class="nn">OptionalI32</span><span class="p">::</span><span class="nf">AnI32</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">match</span> <span class="n">foo</span> <span class="p">{</span>
        <span class="nn">OptionalI32</span><span class="p">::</span><span class="nf">AnI32</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"it’s an i32: {}"</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span>
        <span class="nn">OptionalI32</span><span class="p">::</span><span class="n">Nothing</span>  <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"it’s nothing!"</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="c1">// Reconhecimento avançado de padrões</span>
    <span class="k">struct</span> <span class="n">FooBar</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">OptionalI32</span> <span class="p">}</span>
    <span class="k">let</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">FooBar</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nn">OptionalI32</span><span class="p">::</span><span class="nf">AnI32</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="p">};</span>

    <span class="k">match</span> <span class="n">bar</span> <span class="p">{</span>
        <span class="n">FooBar</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nn">OptionalI32</span><span class="p">::</span><span class="nf">AnI32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">}</span> <span class="k">=&gt;</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"The numbers are zero!"</span><span class="p">),</span>
        <span class="n">FooBar</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="n">n</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nn">OptionalI32</span><span class="p">::</span><span class="nf">AnI32</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">}</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">m</span> <span class="k">=&gt;</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"The numbers are the same"</span><span class="p">),</span>
        <span class="n">FooBar</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="n">n</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nn">OptionalI32</span><span class="p">::</span><span class="nf">AnI32</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">}</span> <span class="k">=&gt;</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Different numbers: {} {}"</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span>
        <span class="n">FooBar</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="n">_</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nn">OptionalI32</span><span class="p">::</span><span class="n">Nothing</span> <span class="p">}</span> <span class="k">=&gt;</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"The second number is Nothing!"</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="c1">//////////////////////////</span>
    <span class="c1">// 4. Controle de fluxo //</span>
    <span class="c1">//////////////////////////</span>

    <span class="c1">// `for` laços de repetição/iteração</span>
    <span class="k">let</span> <span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">array</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Ranges</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0u32</span><span class="o">..</span><span class="mi">10</span> <span class="p">{</span>
        <span class="nd">print!</span><span class="p">(</span><span class="s">"{} "</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">""</span><span class="p">);</span>
    <span class="c1">// prints `0 1 2 3 4 5 6 7 8 9 `</span>

    <span class="c1">// `if`</span>
    <span class="k">if</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Maths is working!"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Oh no..."</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// `if` como expressão</span>
    <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="k">if</span> <span class="k">true</span> <span class="p">{</span>
        <span class="s">"good"</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="s">"bad"</span>
    <span class="p">};</span>

    <span class="c1">// laço `while` de repetição</span>
    <span class="k">while</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"The universe is operating normally."</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Repetição infinita</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello!"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">////////////////////////////////////////</span>
    <span class="c1">// 5. Proteção de memória &amp; ponteiros //</span>
    <span class="c1">////////////////////////////////////////</span>

    <span class="c1">// Ponteiro com dono - somente uma coisa pode 'possuir' esse ponteiro por</span>
    <span class="c1">// vez.</span>
    <span class="c1">// Isso significa que quando `Box` perde seu escopo, ele pode ser</span>
    <span class="c1">// automaticamente desalocado com segurança.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">mine</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="o">*</span><span class="n">mine</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// dereference</span>
    <span class="c1">// Aqui, `now_its_mine` possui o controle exclusivo de `mine`. Em outras </span>
    <span class="c1">// palavras, `mine` tem o controle transferido.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">now_its_mine</span> <span class="o">=</span> <span class="n">mine</span><span class="p">;</span>
    <span class="o">*</span><span class="n">now_its_mine</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">now_its_mine</span><span class="p">);</span> <span class="c1">// 7</span>
    <span class="c1">// println!("{}", mine); // não compila porque `now_its_mine` é o dono</span>

    <span class="c1">// Referência - um ponteiro imutável que referencia outro dado</span>
    <span class="c1">// Quando uma referência é dada a um valor, nós dizemos que o valor foi</span>
    <span class="c1">// emprestado 'borrowed'.</span>
    <span class="c1">// Quando um valor é emprestado sem ser mutável, ele não pode ser alterado</span>
    <span class="c1">// ou ter a sua propriedade transferida.</span>
    <span class="c1">// Um empréstimo finaliza quando o escopo em que ele foi criado termina.</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">var</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="n">var</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">ref_var</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">i32</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">var</span><span class="p">;</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">var</span><span class="p">);</span> <span class="c1">// AO contrário de `mine`, `var` ainda pode ser usado</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="o">*</span><span class="n">ref_var</span><span class="p">);</span>
    <span class="c1">// var = 5; // não compila porque `var` é emprestado</span>
    <span class="c1">// *ref_var = 6; // não compila, porque `ref_var` é uma referência imutável</span>

    <span class="c1">// Referência mutável</span>
    <span class="c1">// Quando um valor mutável é emprestado, ele não pode ser acessado.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">var2</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">ref_var2</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">i32</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">var2</span><span class="p">;</span>
    <span class="o">*</span><span class="n">ref_var2</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>         <span class="c1">// '*' aponta para var2, que é mutável e emprestada</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="o">*</span><span class="n">ref_var2</span><span class="p">);</span> <span class="c1">// 6 , // var2 não compila.</span>
    <span class="c1">// ref_var2 é do tipo &amp;mut i32, que guarda uma referência i32, não o valor.</span>
    <span class="c1">// var2 = 2; // não compila porque `var2` é empretada.</span>
<span class="p">}</span>
</code></pre></div>
<h2>Outras leituras</h2>

<p>Existe muita coisa sobre Rust - isto aqui é apenas o básico para que você possa 
entender as coisas mais importantes. Para aprender mais sobre Rust, leia <a href="http://doc.rust-lang.org/book/index.html">The 
Rust Programming Language</a> e 
acompanhe <a href="http://reddit.com/r/rust">/r/rust</a>. A galera no canal #rust do
irc.mozilla.org também estão sempre dispostos a ajudar os novatos.</p>

<p>Você pode brincar com outras característica de Rust com um compilador online
no portal oficial do projeto <a href="http://play.rust-lang.org">Rust playpen</a>, or ler 
mais na página oficial <a href="http://rust-lang.org">Rust website</a>.</p>

<p>No Brasil acompanhe os encontros do <a href="http://www.meetup.com/pt-BR/Rust-Sao-Paulo-Meetup/">Meetup Rust São Paulo</a>.</p>

    <hr>
    <p>Sugestões ou correções? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Abra uma issue</a> no repositório do Github, ou faça um <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/pt-br/rust-pt.html.markdown">pull request</a> você mesmo!
    </p>
    <p class="contributed">
    Originalmente contribuído por Paulo Henrique Rodrigues Pinheiro e atualizado por <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/pt-br/rust-pt.html.markdown">0 colaborador(es)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="https://about.me/paulohrpinheiro">Paulo Henrique Rodrigues Pinheiro</a>
    </p>

    <p>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>

        <script>
            var _gaq=[['_setAccount','UA-3525624-21'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>
</html>
