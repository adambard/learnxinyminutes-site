<!DOCTYPE html>
<html lang="de">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-WXC8R75DEN');
    </script>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="Content-Language" content="de">
    <title>Learn Go in Y Minutes</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto+Slab:wght@100..900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/screen.css">
    <link rel="stylesheet" href="/css/light.css">
    <link rel="stylesheet" href="/css/dark.css">

    <link rel="canonical" href="https://learnxinyminutes.com/de/go/">
    <script>
      localStorage.removeItem("lxiym_theme");
    </script>
  </head>
  <body>
    <div class="container">
      <h1><a href="/">Lerne X in Y Minuten</a></h1>
      <h2>Wobei X=Go</h2>

      <div class="lang-choice">
        <label for="lang-select">Sprache:</label>
        <select id="lang-select" name="lang-select">
          <option value="de">Deutsch</option>
          <option value="ca" data-url="/ca/go/">català</option>
          <option value="cs" data-url="/cs/go/">čeština</option>
          <option value="en" data-url="/go/">English</option>
          <option value="es" data-url="/es/go/">español</option>
          <option value="fi" data-url="/fi/go/">suomi</option>
          <option value="fr" data-url="/fr/go/">français</option>
          <option value="hu" data-url="/hu/go/">magyar</option>
          <option value="it" data-url="/it/go/">italiano</option>
          <option value="ko" data-url="/ko/go/">한국어</option>
          <option value="pt-br" data-url="/pt-br/go/">português (Brasil)</option>
          <option value="ru" data-url="/ru/go/">русский</option>
          <option value="uk" data-url="/uk/go/">українська</option>
          <option value="zh-cn" data-url="/zh-cn/go/">中文 (简体)</option>
        </select>
      </div>
      <p class="filelink">
        Lade den Code herunter:
        <a href="/de/files/learngo.go">learngo.go</a>
      </p>
      <div id="doc">
<p>Die Sprache Go (auch golang) wurde von Google entwickelt und wird seit 2007
benutzt. Go ähnelt in der Syntax der Sprache C, bietet darüber hinaus aber viele
Vorteile. Einerseits verzichtet Go auf Speicherarithmetik und
benutzt einen Garbage Collector. Andererseits enthält Go native Sprachelemente
für die Unterstützung von Nebenläufigkeit. Durch den Fokus auf einen schnellen
Kompilierprozess wird außerdem die Softwareentwicklung in Großprojekten
erleichtert.</p>
<p>Außerdem beinhaltet Go eine gut ausgestattete Standardbibliothek und hat eine
aktive Community.</p>
<div class="highlight"><pre lang="go"><span class="c1">// Einzeiliger Kommentar</span>
<span class="cm">/* Mehr-</span>
<span class="cm">   zeiliger Kommentar */</span>

<span class="c1">// Wie bei Java gehört jede Quelldatei einem Paket an (Modularisierung).</span>
<span class="c1">// &quot;main&quot; ist ein besonderer Paketname, da er ein ausführbares Programm</span>
<span class="c1">// einleitet, im Gegensatz zu jedem anderen Namen, der eine Bibliothek</span>
<span class="c1">// deklariert.</span>
<span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="c1">// Ein &quot;import&quot; wird verwendet, um Pakete zu deklarieren, die in dieser</span>
<span class="c1">// Quelldatei Anwendung finden.</span>
<span class="kn">import</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;fmt&quot;</span><span class="w">      </span><span class="c1">// Ein Paket in der Go Standardbibliothek</span>
<span class="w">    </span><span class="s">&quot;net/http&quot;</span><span class="w"> </span><span class="c1">// Ja, ein Webserver.</span>
<span class="w">    </span><span class="s">&quot;strconv&quot;</span><span class="w">  </span><span class="c1">// Zeichenkettenmanipulation</span>
<span class="p">)</span>

<span class="c1">// Es folgt die Definition einer Funktion, in diesem Fall von &quot;main&quot;. Auch hier</span>
<span class="c1">// ist der Name wieder besonders. &quot;main&quot; markiert den Eintrittspunkt des</span>
<span class="c1">// Programms.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Println gibt eine Zeile zu stdout aus.</span>
<span class="w">    </span><span class="c1">// Der Prefix &quot;fmt&quot; bestimmt das Paket aus welchem die Funktion stammt.</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Hello world!&quot;</span><span class="p">)</span>

<span class="w">    </span><span class="c1">// Aufruf einer weiteren Funktion definiert innerhalb dieses Pakets.</span>
<span class="w">    </span><span class="nx">beyondHello</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// Funktionen können Parameter akzeptieren. Diese werden in Klammern deklariert,</span>
<span class="c1">// die aber auch ohne Parameter erforderlich sind.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">beyondHello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="c1">// Deklaration einer Variable, muss vor Gebrauch geschehen.</span>
<span class="w">    </span><span class="nx">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">3</span><span class="w">     </span><span class="c1">// Zuweisung eines Werts.</span>
<span class="w">    </span><span class="c1">// Kurze Deklaration: Benutzen Sie &quot;:=&quot;, um die Typisierung automatisch zu</span>
<span class="w">    </span><span class="c1">// folgern, die Variable zu deklarieren und ihr einen Wert zuzuweisen.</span>
<span class="w">    </span><span class="nx">y</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">4</span>

<span class="w">    </span><span class="c1">// Eine Funktion mit mehreren Rückgabewerten.</span>
<span class="w">    </span><span class="nx">sum</span><span class="p">,</span><span class="w"> </span><span class="nx">prod</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">learnMultiple</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="p">)</span>

<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;sum:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">sum</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;prod:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">prod</span><span class="p">)</span><span class="w"> </span><span class="c1">// Simple Ausgabe</span>
<span class="w">    </span><span class="nx">learnTypes</span><span class="p">()</span><span class="w">                            </span><span class="c1">// In &lt; y Minuten lernen Sie mehr!</span>
<span class="p">}</span>

<span class="c1">// Funktionen können mehrere Parameter und (mehrere!) Rückgabewerte haben.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">learnMultiple</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">sum</span><span class="p">,</span><span class="w"> </span><span class="nx">prod</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">y</span><span class="p">,</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="c1">// Wiedergabe zweier Werte</span>
<span class="p">}</span>

<span class="c1">// Überblick über einige eingebaute Typen und Literale.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">learnTypes</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Kurze Deklarationen sind die Norm.</span>
<span class="w">    </span><span class="nx">s</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="s">&quot;Lernen Sie Go!&quot;</span><span class="w"> </span><span class="c1">// Zeichenketten-Typ</span>

<span class="w">    </span><span class="nx">s2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="s">`Eine &quot;raw&quot; Zeichenkette kann</span>
<span class="s">Zeilenumbrüche beinhalten.`</span><span class="w"> </span><span class="c1">// Selber Zeichenketten-Typ</span>

<span class="w">    </span><span class="c1">// nicht-ASCII Literal.  Go Quelltext ist UTF-8 kompatibel.</span>
<span class="w">    </span><span class="nx">g</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="sc">&#39;Σ&#39;</span><span class="w"> </span><span class="c1">// Ein Runen-Typ, alias int32, gebraucht für unicode code points.</span>

<span class="w">    </span><span class="nx">f</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mf">3.14159</span><span class="w"> </span><span class="c1">// float64, eine IEEE-754 64-bit Dezimalzahl</span>
<span class="w">    </span><span class="nx">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">4i</span><span class="w">  </span><span class="c1">// complex128, besteht intern aus zwei float64-er</span>

<span class="w">    </span><span class="c1">// &quot;var&quot;-Syntax mit Initialwert</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">u</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="c1">// Vorzeichenlos, aber die Größe ist implementationsabhängig</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">pi</span><span class="w"> </span><span class="kt">float32</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">22.</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">7</span>

<span class="w">    </span><span class="c1">// Umwandlungs-Syntax mit kurzer Deklaration</span>
<span class="w">    </span><span class="nx">n</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">byte</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">)</span><span class="w"> </span><span class="c1">// byte ist ein Alias für uint8</span>

<span class="w">    </span><span class="c1">// Arrays haben bei Kompile-Zeit festgelegte Größen</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">a4</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">int</span><span class="w">           </span><span class="c1">// Ein Array mit 4 ints, alle mit Initialwert 0</span>
<span class="w">    </span><span class="nx">a3</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">}</span><span class="w"> </span><span class="c1">// Ein Array mit 3 ints, Initialwerte wie angezeigt</span>

<span class="w">    </span><span class="c1">// &quot;slices&quot; haben eine dynamische Größe. Arrays und Slices haben beide ihre</span>
<span class="w">    </span><span class="c1">// Vorzüge, aber slices werden viel häufiger verwendet</span>
<span class="w">    </span><span class="nx">s3</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">}</span><span class="w">       </span><span class="c1">// Vergleichen Sie mit a3, hier: keine Ellipse</span>
<span class="w">    </span><span class="nx">s4</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">       </span><span class="c1">// Weist Speicher für 4 ints zu, alle mit Wert 0</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">d2</span><span class="w"> </span><span class="p">[][]</span><span class="kt">float64</span><span class="w">         </span><span class="c1">// Nur eine Deklaration, keine Speicherzuweisung</span>
<span class="w">    </span><span class="nx">bs</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;eine slice&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">// Umwandlungs-Syntax</span>

<span class="w">    </span><span class="nx">p</span><span class="p">,</span><span class="w"> </span><span class="nx">q</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">learnMemory</span><span class="p">()</span><span class="w"> </span><span class="c1">// Deklariert p &amp; q als Zeiger zu einer int.</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="nx">q</span><span class="p">)</span><span class="w">   </span><span class="c1">// Die gibt die zwei Werte aus. &quot;*&quot; für den Zugriff</span>

<span class="w">    </span><span class="c1">// &quot;Maps&quot; sind dynamische Datenstrukturen mit variabler Größe. Sie sind wie</span>
<span class="w">    </span><span class="c1">// &quot;hashs&quot; oder &quot;dictionaries&quot; aus anderen Sprachen.</span>
<span class="w">    </span><span class="nx">m</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">&quot;drei&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vier&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">4</span><span class="p">}</span>
<span class="w">    </span><span class="nx">m</span><span class="p">[</span><span class="s">&quot;eins&quot;</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span>

<span class="w">    </span><span class="c1">// Ungebrauchte Variablen sind Fehler in Go</span>
<span class="w">    </span><span class="c1">// Der Unterstrich wird verwendet, um einen Wert zu verwerfen.</span>
<span class="w">    </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">s2</span><span class="p">,</span><span class="w"> </span><span class="nx">g</span><span class="p">,</span><span class="w"> </span><span class="nx">f</span><span class="p">,</span><span class="w"> </span><span class="nx">u</span><span class="p">,</span><span class="w"> </span><span class="nx">pi</span><span class="p">,</span><span class="w"> </span><span class="nx">n</span><span class="p">,</span><span class="w"> </span><span class="nx">a3</span><span class="p">,</span><span class="w"> </span><span class="nx">s4</span><span class="p">,</span><span class="w"> </span><span class="nx">bs</span>
<span class="w">    </span><span class="c1">// Die Ausgabe zählt natürlich auch als Gebrauch</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">,</span><span class="w"> </span><span class="nx">a4</span><span class="p">,</span><span class="w"> </span><span class="nx">s3</span><span class="p">,</span><span class="w"> </span><span class="nx">d2</span><span class="p">,</span><span class="w"> </span><span class="nx">m</span><span class="p">)</span>

<span class="w">    </span><span class="nx">learnFlowControl</span><span class="p">()</span><span class="w"> </span><span class="c1">// Auf zum Kontrollfluss!</span>
<span class="p">}</span>

<span class="c1">// Go ist komplett &quot;garbage collected&quot;. Sie unterstützt Zeiger (pointers) aber</span>
<span class="c1">// keine Zeiger-Rechnungen. Fehler können sich durch &quot;nil&quot; einschleichen, jedoch</span>
<span class="c1">// nicht durch erhöhen eines Zeigers.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">learnMemory</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="nx">p</span><span class="p">,</span><span class="w"> </span><span class="nx">q</span><span class="w"> </span><span class="o">*</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Die benannten Rückgabewerte p &amp; q sind vom Typ *int</span>
<span class="w">    </span><span class="nx">p</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="c1">// Eingebaute Funktion &quot;new&quot; weist neuen Speicherplatz zu</span>
<span class="w">    </span><span class="c1">// Der zugewiesene Speicher ist mit 0 initialisiert, p ist nicht länger nil</span>
<span class="w">    </span><span class="nx">s</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="c1">// So weist man 20 ints nebeneinander (im Speicher) zu</span>
<span class="w">    </span><span class="nx">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">7</span><span class="w">             </span><span class="c1">// Einer von ihnen wird ein Wert zugewiesen</span>
<span class="w">    </span><span class="nx">r</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="w">              </span><span class="c1">// Deklaration einer weiteren lokalen Variable</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">s</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">r</span><span class="w">     </span><span class="c1">// &amp; gibt die Adresse einer Variable</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">expensiveComputation</span><span class="p">()</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mf">1e6</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">learnFlowControl</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Bedingte Anweisungen verlangen nach geschweiften Klammern, normale</span>
<span class="w">    </span><span class="c1">// Klammern um die Bedingung werden aber nicht gebraucht.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;hab&#39;s dir ja gesagt!&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Die Formatierung ist durch den Befehl &quot;go fmt&quot; standardisiert</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// nicht hier</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// sondern hier! spielt die Musik</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Benutzen Sie ein &quot;switch&quot; Statement anstatt eine Anreihung von if-s</span>
<span class="w">    </span><span class="nx">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span>
<span class="w">        </span><span class="c1">// Einzelne Fälle fallen nicht zum nächsten durch!</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">2</span><span class="p">:</span>
<span class="w">        </span><span class="c1">// wird nicht ausgeführt</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Wie bei &quot;if&quot;, braucht &quot;for&quot; auch keine Klammern um die Bedingung</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="nx">x</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ++ ist ein Statement</span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;-te Iteration&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Ab hier gilt wieder: x == 1</span>

<span class="w">    </span><span class="c1">// For ist die einzige Schleifenform in Go, sie hat aber mehrere Formen:</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Endlosschleife</span>
<span class="w">        </span><span class="k">break</span><span class="w">    </span><span class="c1">// nur ein Spaß</span>
<span class="w">        </span><span class="k">continue</span><span class="w"> </span><span class="c1">// wird nie ausgeführt</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Wie bei for, bedeutet := in einer bedingten Anweisung zunächst die</span>
<span class="w">    </span><span class="c1">// Zuweisung und erst dann die Überprüfung der Bedingung.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">expensiveComputation</span><span class="p">();</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">y</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Funktionsliterale sind &quot;closures&quot;</span>
<span class="w">    </span><span class="nx">xBig</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="c1">// Verweist auf x, deklariert vor dem switch</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;xBig:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">xBig</span><span class="p">())</span><span class="w"> </span><span class="c1">// true (im moment gilt: x == 1e6)</span>
<span class="w">    </span><span class="nx">x</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mf">1e5</span><span class="w">                     </span><span class="c1">// dies macht x == 10</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;xBig:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">xBig</span><span class="p">())</span><span class="w"> </span><span class="c1">// jetzt: false</span>

<span class="w">    </span><span class="c1">// Wenn Sie&#39;s brauchen, werden Sie&#39;s lieben!</span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="nx">love</span>
<span class="nx">love</span><span class="p">:</span>

<span class="w">    </span><span class="nx">learnInterfaces</span><span class="p">()</span><span class="w"> </span><span class="c1">// Jetzt zum interessanten Teil!</span>
<span class="p">}</span>

<span class="c1">// Definiere &quot;Stringer&quot; als ein Interface mit einer Methode: String</span>
<span class="kd">type</span><span class="w"> </span><span class="nx">Stringer</span><span class="w"> </span><span class="kd">interface</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">String</span><span class="p">()</span><span class="w"> </span><span class="kt">string</span>
<span class="p">}</span>

<span class="c1">// Definiere ein Paar als struct mit zwei Feldern, Integers mit Namen x &amp; y.</span>
<span class="kd">type</span><span class="w"> </span><span class="nx">pair</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="kt">int</span>
<span class="p">}</span>

<span class="c1">// Definiere eine Methode von &quot;pair&quot;.</span>
<span class="c1">// Dieser Typ erfüllt jetzt das Stringer interface.</span>
<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">p</span><span class="w"> </span><span class="nx">pair</span><span class="p">)</span><span class="w"> </span><span class="nx">String</span><span class="p">()</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// p ist der Empfänger</span>
<span class="w">    </span><span class="c1">// Sprintf ist eine weitere öffentliche Funktion von fmt.</span>
<span class="w">    </span><span class="c1">// Der Syntax mit Punkt greift auf die Felder zu.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;(%d, %d)&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">p</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">p</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">learnInterfaces</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Der Klammer-Syntax ist ein &quot;struct literal&quot;. Es ist ein vollkommen</span>
<span class="w">    </span><span class="c1">// initialisiertes struct. Der := Syntax deklariert und initialisiert p.</span>
<span class="w">    </span><span class="nx">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">pair</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">}</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span><span class="w"> </span><span class="c1">// Aufruf der String() Methode von p.</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="nx">Stringer</span><span class="w">          </span><span class="c1">// Deklariere i vom Typ: Stringer</span>
<span class="w">    </span><span class="nx">i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">p</span><span class="w">                   </span><span class="c1">// Ok, weil p auch vom Typ Stringer ist.</span>
<span class="w">    </span><span class="c1">// Aufruf der String Methode von i, gleiche Ausgabe wie zuvor.</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span>

<span class="w">    </span><span class="c1">// Funktionen des fmt-Pakets rufen die String() Methode auf um eine</span>
<span class="w">    </span><span class="c1">// druckbare Variante des Empfängers zu erhalten.</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span><span class="w"> </span><span class="c1">// gleiche Ausgabe wie zuvor</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="w"> </span><span class="c1">// und wieder die gleiche Ausgabe wie zuvor</span>

<span class="w">    </span><span class="nx">learnErrorHandling</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">learnErrorHandling</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Das &quot;, ok&quot; Idiom wird häufig verwendet um zu überprüfen ob etwas schief</span>
<span class="w">    </span><span class="c1">// gegangen ist.</span>
<span class="w">    </span><span class="nx">m</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="mi">3</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;drei&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;vier&quot;</span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">m</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ok wird false sein, da 1 nicht in der map ist.</span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;keine eins gefunden&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span><span class="w"> </span><span class="c1">// x wäre der Wert, wenn er in der map wäre.</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Ein Fehler-Wert (error value) gibt mehr Informationen über den Grund für</span>
<span class="w">    </span><span class="c1">// das Problem an.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">strconv</span><span class="p">.</span><span class="nx">Atoi</span><span class="p">(</span><span class="s">&quot;nicht-int&quot;</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// _ verwirft den Wert</span>
<span class="w">        </span><span class="c1">// Gibt: &quot;strconv.ParseInt: parsing &quot;nicht-int&quot;: invalid syntax&quot; aus</span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Wir kommen bald nochmal auf Interfaces zurück. Aber inzwischen:</span>
<span class="w">    </span><span class="nx">learnConcurrency</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// c ist ein Kanal, ein sicheres Kommunikationsmedium.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">inc</span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="kd">chan</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">c</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// &lt;- ist der &quot;send&quot; Operator, wenn ein Kanal auf der Linken ist</span>
<span class="p">}</span>

<span class="c1">// Wir verwenden &quot;inc&quot; um Zahlen parallel zu erhöhen.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">learnConcurrency</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Die selbe &quot;make&quot;-Funktion wie vorhin. Sie initialisiert Speicher für</span>
<span class="w">    </span><span class="c1">// maps, slices und Kanäle.</span>
<span class="w">    </span><span class="nx">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span>
<span class="w">    </span><span class="c1">// Starte drei parallele &quot;Goroutines&quot;.</span>
<span class="w">    </span><span class="c1">// Die Zahlen werden parallel (concurrently) erhöht.</span>
<span class="w">    </span><span class="c1">// Alle drei senden ihr Ergebnis in den gleichen Kanal.</span>
<span class="w">    </span><span class="k">go</span><span class="w"> </span><span class="nx">inc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">)</span><span class="w"> </span><span class="c1">// &quot;go&quot; ist das Statement zum Start einer neuen Goroutine</span>
<span class="w">    </span><span class="k">go</span><span class="w"> </span><span class="nx">inc</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">)</span>
<span class="w">    </span><span class="k">go</span><span class="w"> </span><span class="nx">inc</span><span class="p">(</span><span class="o">-</span><span class="mi">805</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">)</span>
<span class="w">    </span><span class="c1">// Auslesen und dann Ausgeben der drei berechneten Werte.</span>
<span class="w">    </span><span class="c1">// Man kann nicht im voraus feststellen in welcher Reihenfolge die Werte</span>
<span class="w">    </span><span class="c1">// ankommen.</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">c</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">c</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">c</span><span class="p">)</span><span class="w"> </span><span class="c1">// mit dem Kanal rechts ist &lt;- der Empfangs-Operator</span>

<span class="w">    </span><span class="nx">cs</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w">       </span><span class="c1">// ein weiterer Kanal, diesmal für strings</span>
<span class="w">    </span><span class="nx">cc</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kd">chan</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w">  </span><span class="c1">// ein Kanal für string Kanäle</span>

<span class="w">    </span><span class="c1">// Start einer neuen Goroutine, nur um einen Wert zu senden</span>
<span class="w">    </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">84</span><span class="w"> </span><span class="p">}()</span>
<span class="w">    </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">cs</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s">&quot;wortreich&quot;</span><span class="w"> </span><span class="p">}()</span><span class="w"> </span><span class="c1">// schon wieder, diesmal für</span>
<span class="w">    </span><span class="c1">// &quot;select&quot; hat eine Syntax wie ein switch Statement, aber jeder Fall ist</span>
<span class="w">    </span><span class="c1">// eine Kanaloperation. Es wählt einen Fall zufällig aus allen, die</span>
<span class="w">    </span><span class="c1">// kommunikationsbereit sind, aus.</span>
<span class="w">    </span><span class="k">select</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">c</span><span class="p">:</span><span class="w"> </span><span class="c1">// der empfangene Wert kann einer Variable zugewiesen werden</span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;es ist ein: %T&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">cs</span><span class="p">:</span><span class="w"> </span><span class="c1">// oder der Wert kann verworfen werden</span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;es ist eine Zeichenkette!&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">cc</span><span class="p">:</span><span class="w"> </span><span class="c1">// leerer Kanal, nicht bereit für den Empfang</span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;wird nicht passieren.&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Hier wird eine der beiden Goroutines fertig sein, die andere nicht.</span>
<span class="w">    </span><span class="c1">// Sie wird warten bis der Wert den sie sendet von dem Kanal gelesen wird.</span>

<span class="w">    </span><span class="nx">learnWebProgramming</span><span class="p">()</span><span class="w"> </span><span class="c1">// Go kann es und Sie hoffentlich auch bald.</span>
<span class="p">}</span>

<span class="c1">// Eine einzige Funktion aus dem http-Paket kann einen Webserver starten.</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">learnWebProgramming</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Der erste Parameter von &quot;ListenAndServe&quot; ist eine TCP Adresse, an die</span>
<span class="w">    </span><span class="c1">// sich angeschlossen werden soll.</span>
<span class="w">    </span><span class="c1">// Der zweite Parameter ist ein Interface, speziell: ein http.Handler</span>
<span class="w">    </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">http</span><span class="p">.</span><span class="nx">ListenAndServe</span><span class="p">(</span><span class="s">&quot;:8080&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">pair</span><span class="p">{})</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"> </span><span class="c1">// Fehler sollte man nicht ignorieren!</span>
<span class="p">}</span>

<span class="c1">// Wir lassen &quot;pair&quot; das http.Handler Interface erfüllen, indem wir seine einzige</span>
<span class="c1">// Methode implementieren: ServeHTTP</span>
<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">p</span><span class="w"> </span><span class="nx">pair</span><span class="p">)</span><span class="w"> </span><span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span><span class="w"> </span><span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Senden von Daten mit einer Methode des http.ResponseWriter</span>
<span class="w">    </span><span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;Sie haben Go in Y Minuten gelernt!&quot;</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
<h2>Weitere Resourcen</h2>
<p>Informationen zu Go findet man auf der <a href="https://go.dev/">offiziellen Go Webseite</a>.
Dort gibt es unter anderem ein Tutorial und interaktive Quelltext-Beispiele, vor
allem aber Dokumentation zur Sprache und den Paketen.</p>
<p>Auch zu empfehlen ist die Spezifikation von Go, die nach heutigen Standards sehr
kurz und gut verständlich formuliert ist. Auf der Leseliste von Go-Neulingen
ist außerdem der Quelltext der <a href="https://go.dev/src/">Go standard Bibliothek</a>
einzusehen. Dieser kann als Referenz für leicht zu verstehendes und im idiomatischen Stil
verfasstes Go dienen. Erreichbar ist der Quelltext auch durch das Klicken der Funktionsnamen
in der <a href="https://go.dev/pkg/">offiziellen Dokumentation von Go</a>.</p>

        <hr>
        <p>
          Du hast einen Verbesserungsvorschlag oder einen Fehler gefunden? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Erstelle ein Ticket</a> im offiziellen GitHub Repo, oder du erstellst einfach gleich einen <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/de/go.md">pull request</a>!
        </p>
        <p class="contributed">
          Originalversion von Joseph Adams, mit Updates von <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/de/go.md">12 contributors</a>.
        </p>

        <footer>
          <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width: 0; width: 80px; height: 28px; padding-bottom: 5px;" src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-sa.svg" /></a>
          <p>
            &copy; 2025
            <a href="https://github.com/jcla1">Joseph Adams</a>,
            <a href="https://github.com/denniskeller">Dennis Keller</a>
          </p>
        </footer>
      </div>

      <script>
        document.addEventListener('DOMContentLoaded', () => {
          const langSelect = document.getElementById('lang-select');
          langSelect?.addEventListener('change', () => {
            const selectedOption = langSelect.options[langSelect.selectedIndex];
            const url = selectedOption?.getAttribute('data-url');
            if (url) {
              window.location.href = url;
            }
          });
        });
      </script>
    </div>
  </body>
</html>