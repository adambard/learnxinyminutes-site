<!DOCTYPE html>
<html lang="de">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-WXC8R75DEN');
    </script>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="Content-Language" content="de">
    <title>Learn Clojure in Y Minutes</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto+Slab:wght@100..900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/screen.css">
    <link rel="stylesheet" href="/css/light.css">
    <link rel="stylesheet" href="/css/dark.css">

    <link rel="canonical" href="https://learnxinyminutes.com/de/clojure/">
    <script>
      localStorage.removeItem("lxiym_theme");
    </script>
  </head>
  <body>
    <div class="container">
      <div class="share">
        <span class="sharemsg">
          <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fde%2Fclojure%2F&amp;text=Lerne+X+in+Y+Minuten%2C+wobei+X%3DClojure">
            Teile diese Seite mit anderen
          </a>
        </span>
        <span class='st_facebook_large' displayText='Facebook'></span>
        <span class='st_twitter_large' displayText='Tweet'></span>
      </div>
      <h1><a href="/">Lerne X in Y Minuten</a></h1>
      <h2>Wobei X=Clojure</h2>
      <p class="filelink">
        Lade den Code herunter:
        <a href="/de/files/learnclojure.clj">learnclojure.clj</a>
      </p>
      <div id="doc">
<p>Clojure ist ein Lispdialekt, der für die Java Virtual Maschine entwickelt worden ist. Sie hat eine stärkere Betonung auf reine <a href="https://en.wikipedia.org/wiki/Functional_programming">funktionale Programmierung</a> als Common Lisp. Jedoch besitzt sie je nach Bedarf mehrere <a href="https://en.wikipedia.org/wiki/Software_transactional_memory">STM</a> Werkzeuge zur Handhabung von Zustand.</p>
<p>Diese Verknüpfung erlaubt es, parallele Verarbeitung sehr einfach und häufig automatisch zu verarbeiten.</p>
<p>(Du brauchst die Clojure Version 1.2 oder neuer)</p>
<div class="highlight"><pre lang="clojure"><span class="c1">; Kommentare starten mit einem Semikolon.</span>

<span class="c1">; Clojure wird in &quot;Forms&quot; geschrieben, was nur Listen von Dingen</span>
<span class="c1">; in Klammern sind, getrennt durch Leerzeichen.</span>
<span class="c1">;</span>
<span class="c1">; Der Clojure Leser nimmt an, dass das Erste, was aufgerufen wird</span>
<span class="c1">; eine Funktion oder ein Makro ist, der Rest sind Argumente.</span>

<span class="c1">; Der erste Aufruf in einer Datei sollte ns sein, um den Namespace zu setzen.</span>
<span class="p">(</span><span class="kd">ns </span><span class="nv">learnclojure</span><span class="p">)</span>

<span class="c1">; Weitere einfache Beispiele:</span>

<span class="c1">; str erstellt einen String aus allen Argumenten</span>
<span class="p">(</span><span class="nb">str </span><span class="s">&quot;Hallo&quot;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="s">&quot;Welt&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; &quot;Hallo Welt&quot;</span>

<span class="c1">; Mathe ist einfach</span>
<span class="p">(</span><span class="nb">+ </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; 2</span>
<span class="p">(</span><span class="nb">- </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; 1</span>
<span class="p">(</span><span class="nb">* </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; 2</span>
<span class="p">(</span><span class="nb">/ </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; 2</span>

<span class="c1">; Gleichheit ist =</span>
<span class="p">(</span><span class="nb">= </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; true</span>
<span class="p">(</span><span class="nb">= </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; false</span>

<span class="c1">; Du brauchst auch not für Logik</span>
<span class="p">(</span><span class="nb">not </span><span class="nv">true</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; false</span>

<span class="c1">; Verschachtelte Forms funktionieren, wie erwartet</span>
<span class="p">(</span><span class="nb">+ </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="nb">- </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="c1">; = 1 + (3 - 2) =&gt; 2</span>

<span class="c1">; Typen</span>
<span class="c1">;;;;;;;;;;;;;</span>

<span class="c1">; Clojure verwendet Javas Objekt Typen für Booleans, Strings und Zahlen.</span>
<span class="c1">; Verwende `class` um sie zu inspizieren.</span>
<span class="p">(</span><span class="nb">class </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">; Integer-Literale sind standardmäßig java.lang.Long</span>
<span class="p">(</span><span class="nb">class </span><span class="mi">1</span><span class="nv">.</span><span class="p">)</span><span class="c1">; Float-Literale sind java.lang.Double</span>
<span class="p">(</span><span class="nb">class </span><span class="s">&quot;&quot;</span><span class="p">)</span><span class="c1">; Strings sind immer in doppelten Anführungszeichen notiert und sind java.lang.String</span>
<span class="p">(</span><span class="nb">class </span><span class="nv">false</span><span class="p">)</span><span class="w"> </span><span class="c1">; Booleans sind java.lang.Boolean</span>
<span class="p">(</span><span class="nb">class </span><span class="nv">nil</span><span class="p">)</span><span class="c1">; Der &quot;null&quot; Wert heißt nil</span>

<span class="c1">; Wenn du ein literale Liste aus Daten erzeugen willst, verwendest du &#39; um</span>
<span class="c1">; zu verhindern dass es evaluiert wird</span>
<span class="o">&#39;</span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; (+ 1 2)</span>
<span class="c1">; (Kurzform für (quote (+ 1 2)))</span>

<span class="c1">; Du kannst eine zitierte Liste evaluieren</span>
<span class="p">(</span><span class="nb">eval </span><span class="o">&#39;</span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="c1">; =&gt; 3</span>

<span class="c1">; Kollektionen &amp; Sequenzen</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">; Listen sind Linked-Lists Datenstrukturen, während Vektoren arraybasierend sind.</span>
<span class="c1">; Vektoren und Listen sind auch Java Klassen!</span>
<span class="p">(</span><span class="nb">class </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="c1">; =&gt; clojure.lang.PersistentVector</span>
<span class="p">(</span><span class="nb">class </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="c1">; =&gt; clojure.lang.PersistentList</span>

<span class="c1">; Eine Liste würde nur als (1 2 3) geschrieben, aber wir müssen es zitieren</span>
<span class="c1">; damit der Leser aufhört zu denken, es sei eine Funktion.</span>
<span class="c1">; Außerdem ist (list 1 2 3) dasselbe, wie &#39;(1 2 3)</span>

<span class="c1">; &quot;Kollektionen&quot; sind nur Gruppen von Daten</span>
<span class="c1">; Listen und Vektoren sind Kollektionen:</span>
<span class="p">(</span><span class="nf">coll?</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="c1">; =&gt; true</span>
<span class="p">(</span><span class="nf">coll?</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="c1">; =&gt; true</span>

<span class="c1">; &quot;Sequenzen&quot; (seqs) sind abstrakte Beschreibungen von Listen von Daten.</span>
<span class="c1">; Nur Listen sind seqs.</span>
<span class="p">(</span><span class="nb">seq? </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="c1">; =&gt; true</span>
<span class="p">(</span><span class="nb">seq? </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="c1">; =&gt; false</span>

<span class="c1">; Ein seq muss nur einen Eintrittspunkt bereitstellen, wenn auf ihm zugegriffen wird.</span>
<span class="c1">; Das heißt, dass seqs faul sein können -- Mit ihnen kann man unendliche Serien beschreiben.</span>
<span class="p">(</span><span class="nb">range </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; (0 1 2 3)</span>
<span class="p">(</span><span class="nf">range</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; (0 1 2 3 4 ...) (eine unendliche Serie)</span>
<span class="p">(</span><span class="nb">take </span><span class="mi">4</span><span class="w"> </span><span class="p">(</span><span class="nf">range</span><span class="p">))</span><span class="w"> </span><span class="c1">;  (0 1 2 3)</span>

<span class="c1">; Verwende cons um ein Item zum Anfang einer Liste oder eines Vektors hinzuzufügen.</span>
<span class="p">(</span><span class="nb">cons </span><span class="mi">4</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="c1">; =&gt; (4 1 2 3)</span>
<span class="p">(</span><span class="nb">cons </span><span class="mi">4</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="c1">; =&gt; (4 1 2 3)</span>

<span class="c1">; Conj fügt ein Item auf die effizienteste Weise zu einer Kollektion hinzu.</span>
<span class="c1">; Für Listen fügt er sie an den Anfang hinzu. Für Vektoren fügt er sie an das Ende hinzu.</span>
<span class="p">(</span><span class="nb">conj </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; [1 2 3 4]</span>
<span class="p">(</span><span class="nb">conj </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; (4 1 2 3)</span>

<span class="c1">; Verwende concat um Listen und Vektoren miteinander zu verbinden</span>
<span class="p">(</span><span class="nb">concat </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="c1">; =&gt; (1 2 3 4)</span>

<span class="c1">; Verwende filter, map um mit Kollektionen zu interagieren</span>
<span class="p">(</span><span class="nb">map inc </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="c1">; =&gt; (2 3 4)</span>
<span class="p">(</span><span class="nb">filter </span><span class="nv">even?</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="c1">; =&gt; (2)</span>

<span class="c1">; Verwende reduce um sie zu reduzieren</span>
<span class="p">(</span><span class="nb">reduce + </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">])</span>
<span class="c1">; = (+ (+ (+ 1 2) 3) 4)</span>
<span class="c1">; =&gt; 10</span>

<span class="c1">; Reduce kann auch einen Initialwert als Argument verwenden</span>
<span class="p">(</span><span class="nb">reduce conj </span><span class="p">[]</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>
<span class="c1">; = (conj (conj (conj [] 3) 2) 1)</span>
<span class="c1">; =&gt; [3 2 1]</span>

<span class="c1">; Funktionen</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">; Verwende fn um neue Funktionen zu erstellen. Eine Funktion gibt immer ihr</span>
<span class="c1">; letztes Statement zurück.</span>
<span class="p">(</span><span class="k">fn </span><span class="p">[]</span><span class="w"> </span><span class="s">&quot;Hallo Welt&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; fn</span>

<span class="c1">; (Du brauchst exta Klammern um sie aufzurufen)</span>
<span class="p">((</span><span class="k">fn </span><span class="p">[]</span><span class="w"> </span><span class="s">&quot;Hallo Welt&quot;</span><span class="p">))</span><span class="w"> </span><span class="c1">; =&gt; &quot;Hallo Welt&quot;</span>

<span class="c1">; Du kannst eine Variable mit def erstellen</span>
<span class="p">(</span><span class="k">def </span><span class="nv">x</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="nv">x</span><span class="w"> </span><span class="c1">; =&gt; 1</span>

<span class="c1">; Weise eine Funktion einer Variable zu</span>
<span class="p">(</span><span class="k">def </span><span class="nv">hello-world</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="p">[]</span><span class="w"> </span><span class="s">&quot;Hallo Welt&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="nf">hello-world</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; &quot;Hallo Welt&quot;</span>

<span class="c1">; Du kannst den Prozess verkürzen indem du defn verwendest</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">hello-world</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="s">&quot;Hallo Welt&quot;</span><span class="p">)</span>

<span class="c1">; [] ist die Liste der Argumente für die Funktion</span>
<span class="c1">; The [] is the list of arguments for the function.</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">hello</span><span class="w"> </span><span class="p">[</span><span class="nv">name</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">str </span><span class="s">&quot;Hallo &quot;</span><span class="w"> </span><span class="nv">name</span><span class="p">))</span>
<span class="p">(</span><span class="nf">hello</span><span class="w"> </span><span class="s">&quot;Steve&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; &quot;Hallo Steve&quot;</span>

<span class="c1">; Du kannst diese Kurzschreibweise verwenden um Funktionen zu erstellen:</span>
<span class="p">(</span><span class="k">def </span><span class="nv">hello2</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">str </span><span class="s">&quot;Hallo &quot;</span><span class="w"> </span><span class="nv">%1</span><span class="p">))</span>
<span class="p">(</span><span class="nf">hello2</span><span class="w"> </span><span class="s">&quot;Julie&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; &quot;Hallo Julie&quot;</span>

<span class="c1">; Du kannst auch multi-variadische Funktionen haben</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">hello3</span>
<span class="w">  </span><span class="p">([]</span><span class="w"> </span><span class="s">&quot;Hallo Welt&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">([</span><span class="nv">name</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">str </span><span class="s">&quot;Hallo &quot;</span><span class="w"> </span><span class="nv">name</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">hello3</span><span class="w"> </span><span class="s">&quot;Jake&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; &quot;Hallo Jake&quot;</span>
<span class="p">(</span><span class="nf">hello3</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; &quot;Hallo Welt&quot;</span>

<span class="c1">; Funktionen können auch extra Argumente in einem seq für dich speichern</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">count-args</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="nv">args</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">str </span><span class="s">&quot;Du hast &quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">count </span><span class="nv">args</span><span class="p">)</span><span class="w"> </span><span class="s">&quot; Argumente übergeben: &quot;</span><span class="w"> </span><span class="nv">args</span><span class="p">))</span>
<span class="p">(</span><span class="nf">count-args</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; &quot;Du hast 3 Argumente übergeben: (1 2 3)&quot;</span>

<span class="c1">; Du kannst reguläre und gepackte Argumente mischen</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">hello-count</span><span class="w"> </span><span class="p">[</span><span class="nb">name </span><span class="o">&amp;</span><span class="w"> </span><span class="nv">args</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">str </span><span class="s">&quot;Hallo &quot;</span><span class="w"> </span><span class="nb">name </span><span class="s">&quot;, Du hast &quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">count </span><span class="nv">args</span><span class="p">)</span><span class="w"> </span><span class="s">&quot; extra Argumente übergeben&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="nf">hello-count</span><span class="w"> </span><span class="s">&quot;Finn&quot;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
<span class="c1">; =&gt; &quot;Hallo Finn, Du hast 3 extra Argumente übergeben&quot;</span>


<span class="c1">; Maps</span>
<span class="c1">;;;;;;;;;;</span>

<span class="c1">; Hash maps und Array maps teilen sich ein Interface. Hash maps haben eine schnellere Zugriffszeit,</span>
<span class="c1">; aber behalten keine Schlüsselreihenfolge.</span>
<span class="p">(</span><span class="nb">class </span><span class="p">{</span><span class="ss">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ss">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ss">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w"> </span><span class="c1">; =&gt; clojure.lang.PersistentArrayMap</span>
<span class="p">(</span><span class="nb">class </span><span class="p">(</span><span class="nb">hash-map </span><span class="ss">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ss">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ss">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="c1">; =&gt; clojure.lang.PersistentHashMap</span>

<span class="c1">; Arraymaps werden durch die meisten Operationen automatisch zu Hashmaps,</span>
<span class="c1">; sobald sie groß genug werden. Das heißt du musst dich nicht darum sorgen.</span>

<span class="c1">; Maps können einen beliebigen Hash-Typ als Schlüssel verwenden, in der Regel</span>
<span class="c1">; sind jedoch Keywords am besten. Keywords sind wie Strings, jedoch besitzen sie</span>
<span class="c1">; Performance-Vorteile</span>
<span class="p">(</span><span class="nb">class </span><span class="ss">:a</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; clojure.lang.Keyword</span>

<span class="p">(</span><span class="k">def </span><span class="nv">stringmap</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;a&quot;</span><span class="w"> </span><span class="mi">1</span>,<span class="w"> </span><span class="s">&quot;b&quot;</span><span class="w"> </span><span class="mi">2</span>,<span class="w"> </span><span class="s">&quot;c&quot;</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span>
<span class="nv">stringmap</span><span class="w">  </span><span class="c1">; =&gt; {&quot;a&quot; 1, &quot;b&quot; 2, &quot;c&quot; 3}</span>

<span class="p">(</span><span class="k">def </span><span class="nv">keymap</span><span class="w"> </span><span class="p">{</span><span class="ss">:a</span><span class="w"> </span><span class="mi">1</span>,<span class="w"> </span><span class="ss">:b</span><span class="w"> </span><span class="mi">2</span>,<span class="w"> </span><span class="ss">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span>
<span class="nv">keymap</span><span class="w"> </span><span class="c1">; =&gt; {:a 1, :c 3, :b 2}</span>

<span class="c1">; Übrigens werden Kommas als Leerzeichen behandelt und machen nichts.</span>

<span class="c1">; Rufe einen Wert von einer Map ab, indem du sie als Funktion aufrufst</span>
<span class="p">(</span><span class="nf">stringmap</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; 1</span>
<span class="p">(</span><span class="nf">keymap</span><span class="w"> </span><span class="ss">:a</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; 1</span>

<span class="c1">; Keywords können auch verwendet werden um ihren Wert aus der Map zu bekommen!</span>
<span class="p">(</span><span class="ss">:b</span><span class="w"> </span><span class="nv">keymap</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; 2</span>

<span class="c1">; Versuche es nicht mit Strings.</span>
<span class="c1">;(&quot;a&quot; stringmap)</span>
<span class="c1">; =&gt; Exception: java.lang.String cannot be cast to clojure.lang.IFn</span>

<span class="c1">; Das Abrufen eines nicht vorhandenen Keys gibt nil zurück</span>
<span class="p">(</span><span class="nf">stringmap</span><span class="w"> </span><span class="s">&quot;d&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; nil</span>

<span class="c1">; Verwende assoc um einen neuen Key zu einer Hash-map hinzuzufügen</span>
<span class="p">(</span><span class="k">def </span><span class="nv">newkeymap</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc </span><span class="nv">keymap</span><span class="w"> </span><span class="ss">:d</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span>
<span class="nv">newkeymap</span><span class="w"> </span><span class="c1">; =&gt; {:a 1, :b 2, :c 3, :d 4}</span>

<span class="c1">; Aber denk daran, Clojure Typen sind unveränderlich!</span>
<span class="nv">keymap</span><span class="w"> </span><span class="c1">; =&gt; {:a 1, :b 2, :c 3}</span>

<span class="c1">; Verwende dissoc um Keys zu entfernen</span>
<span class="p">(</span><span class="nb">dissoc </span><span class="nv">keymap</span><span class="w"> </span><span class="ss">:a</span><span class="w"> </span><span class="ss">:b</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; {:c 3}</span>

<span class="c1">; Sets</span>
<span class="c1">;;;;;;</span>

<span class="p">(</span><span class="nb">class </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w"> </span><span class="c1">; =&gt; clojure.lang.PersistentHashSet</span>
<span class="p">(</span><span class="nb">set </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="c1">; =&gt; #{1 2 3}</span>

<span class="c1">; Füge ein Element mit conj hinzu</span>
<span class="p">(</span><span class="nb">conj </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; #{1 2 3 4}</span>

<span class="c1">; Entferne ein Element mit disj</span>
<span class="p">(</span><span class="nb">disj </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; #{2 3}</span>

<span class="c1">; Teste auf Existenz, indem du das Set als Funktion verwendest:</span>
<span class="p">(</span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; 1</span>
<span class="p">(</span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; nil</span>

<span class="c1">; Es gibt mehr Funktionen in dem clojure.sets Namespace.</span>

<span class="c1">; Nützliche Forms</span>
<span class="c1">;;;;;;;;;;;;;;;;;</span>

<span class="c1">; Logische Konstrukte in Clojure sind nur Makros und sie sehen, wie alles</span>
<span class="c1">; andere aus</span>
<span class="p">(</span><span class="k">if </span><span class="nv">false</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="w"> </span><span class="s">&quot;b&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; &quot;b&quot;</span>
<span class="p">(</span><span class="k">if </span><span class="nv">false</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; nil</span>

<span class="c1">; Verwende let um temporäre Bindungen aufzubauen</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">a</span><span class="w"> </span><span class="nv">b</span><span class="p">))</span><span class="w"> </span><span class="c1">; =&gt; false</span>

<span class="c1">; Gruppiere Statements mit do zusammen</span>
<span class="c1">; Group statements together with do</span>
<span class="p">(</span><span class="nf">do</span>
<span class="w">  </span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;Hallo&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Welt&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; &quot;Welt&quot; (prints &quot;Hallo&quot;)</span>

<span class="c1">; Funktionen haben ein implizites do</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">print-and-say-hello</span><span class="w"> </span><span class="p">[</span><span class="nv">name</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;Sage Hallo zu &quot;</span><span class="w"> </span><span class="nv">name</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">str </span><span class="s">&quot;Hallo &quot;</span><span class="w"> </span><span class="nv">name</span><span class="p">))</span>
<span class="p">(</span><span class="nf">print-and-say-hello</span><span class="w"> </span><span class="s">&quot;Jeff&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">;=&gt; &quot;Hallo Jeff&quot; (prints &quot;Sage Hallo zu Jeff&quot;)</span>

<span class="c1">; let macht das auch</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nb">name </span><span class="s">&quot;Urkel&quot;</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;Sage Hallo zu &quot;</span><span class="w"> </span><span class="nv">name</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">str </span><span class="s">&quot;Hallo &quot;</span><span class="w"> </span><span class="nv">name</span><span class="p">))</span><span class="w"> </span><span class="c1">; =&gt; &quot;Hallo Urkel&quot; (prints &quot;Sage Hallo zu Urkel&quot;)</span>


<span class="c1">; Verwende die Threading Makros (-&gt; and -&gt;&gt;) um Transformationen von</span>
<span class="c1">; Daten deutlicher auszudrücken.</span>

<span class="c1">; Das &quot;Thread-zuerst&quot; Makro (-&gt;) fügt in jede Form das Ergebnis des</span>
<span class="c1">; Vorherigen als erstes Argument (zweites Element) ein.</span>
<span class="p">(</span><span class="nf">-&gt;</span>
<span class="w">   </span><span class="p">{</span><span class="ss">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ss">:b</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span>
<span class="w">   </span><span class="p">(</span><span class="nb">assoc </span><span class="ss">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">;=&gt; (assoc {:a 1 :b 2} :c 3)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">dissoc </span><span class="ss">:b</span><span class="p">))</span><span class="w"> </span><span class="c1">;=&gt; (dissoc (assoc {:a 1 :b 2} :c 3) :b)</span>

<span class="c1">; Dieser Ausdruck kann auch als so geschrieben werden:</span>
<span class="c1">; (dissoc (assoc {:a 1 :b 2} :c 3) :b)</span>
<span class="c1">; and evaluates to {:a 1 :c 3}</span>

<span class="c1">; Der Doppelpfeil macht das Selbe, aber er fügt das Ergebnis von jeder</span>
<span class="c1">; Zeile an das Ende der Form, Das ist vor allem für Operationen auf</span>
<span class="c1">; Kollektionen nützlich:</span>
<span class="p">(</span><span class="nf">-&gt;&gt;</span>
<span class="w">   </span><span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">map </span><span class="nv">inc</span><span class="p">)</span><span class="w">     </span><span class="c1">;=&gt; (map inc (range 10))</span>
<span class="w">   </span><span class="p">(</span><span class="nb">filter </span><span class="nv">odd?</span><span class="p">)</span><span class="w"> </span><span class="c1">;=&gt; (filter odd? (map inc (range 10)))</span>
<span class="w">   </span><span class="p">(</span><span class="nb">into </span><span class="p">[]))</span><span class="w">    </span><span class="c1">;=&gt; (into [] (filter odd? (map inc (range 10))))</span>
<span class="w">                 </span><span class="c1">; Result: [1 3 5 7 9]</span>

<span class="c1">; Wenn du in einer Situation bist, in der du mehr Freiheit willst,</span>
<span class="c1">; wohin du das Ergebnis vorheriger Datentransformationen in einem Ausdruck</span>
<span class="c1">; platzieren möchtest, kannst du das as-&gt; Macro verwenden. Mit diesem Macro</span>
<span class="c1">; kannst du einen speziellen Namen auf die Ausgabe einer Transformationen geben.</span>
<span class="c1">; Du kannst es als Platzhalter in verketteten Ausdrücken verwenden:</span>

<span class="p">(</span><span class="nf">as-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="nv">input</span>
<span class="w">  </span><span class="p">(</span><span class="nb">map inc </span><span class="nv">input</span><span class="p">)</span><span class="c1">;=&gt; Du kannst die letzte Ausgabe der Transformation in der letzten Position verwenden</span>
<span class="w">  </span><span class="p">(</span><span class="nb">nth </span><span class="nv">input</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">;=&gt;  und auch in der zweiten Position, im selben Ausdruck verwenden</span>
<span class="w">  </span><span class="p">(</span><span class="nb">conj </span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="nv">input</span><span class="w"> </span><span class="p">[</span><span class="mi">8</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">10</span><span class="p">]))</span><span class="w"> </span><span class="c1">;=&gt; oder auch in der Mitte!</span>



<span class="c1">; Module</span>
<span class="c1">;;;;;;;;;;;;;;;</span>

<span class="c1">; Verwende &quot;use&quot; um alle Funktionen aus einem Modul zu bekommen</span>
<span class="p">(</span><span class="nf">use</span><span class="w"> </span><span class="ss">&#39;clojure.set</span><span class="p">)</span>

<span class="c1">; Nun können wir set Operationen verwenden</span>
<span class="p">(</span><span class="nb">intersection </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">})</span><span class="w"> </span><span class="c1">; =&gt; #{2 3}</span>
<span class="p">(</span><span class="nb">difference </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">})</span><span class="w"> </span><span class="c1">; =&gt; #{1}</span>

<span class="c1">; Du kannst auch auswählen nur ein Subset von Funktionen zu importieren</span>
<span class="p">(</span><span class="nf">use</span><span class="w"> </span><span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.set</span><span class="w"> </span><span class="ss">:only</span><span class="w"> </span><span class="p">[</span><span class="nv">intersection</span><span class="p">]])</span>

<span class="c1">; Verwende require um ein Modul zu importieren</span>
<span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="ss">&#39;clojure.string</span><span class="p">)</span>

<span class="c1">; Verwende / um eine Funktion aus einem Modul aufzurufen</span>
<span class="c1">; Hier verwenden wir das Modul clojure.string und die Funktion blank?</span>
<span class="p">(</span><span class="nf">clojure.string/blank?</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; true</span>

<span class="c1">; Du kannst auch einem Modul einen kürzeren Namen beim Import geben</span>
<span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.string</span><span class="w"> </span><span class="ss">:as</span><span class="w"> </span><span class="nv">str</span><span class="p">])</span>
<span class="p">(</span><span class="nf">str/replace</span><span class="w"> </span><span class="s">&quot;Das ist ein Test.&quot;</span><span class="w"> </span><span class="o">#</span><span class="s">&quot;[a-o]&quot;</span><span class="w"> </span><span class="nv">str/upper-case</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; &quot;DAs IsT EIN TEsT.&quot;</span>
<span class="c1">; (#&quot;&quot; bezeichnet einen regulären literalen Ausdruck)</span>

<span class="c1">; Du kannst require aus einem Namespace verwenden (auch use ist möglich, aber nicht zu empfehlen)</span>
<span class="c1">; indem du :require verwendest.</span>
<span class="c1">; Du brauchst keine Zitierzeichen für deine Module verwenden, wenn du</span>
<span class="c1">; es auf diese Weise machst.</span>
<span class="p">(</span><span class="kd">ns </span><span class="nv">test</span>
<span class="w">  </span><span class="p">(</span><span class="ss">:require</span>
<span class="w">    </span><span class="p">[</span><span class="nv">clojure.string</span><span class="w"> </span><span class="ss">:as</span><span class="w"> </span><span class="nv">str</span><span class="p">]</span>
<span class="w">    </span><span class="p">[</span><span class="nv">clojure.set</span><span class="w"> </span><span class="ss">:as</span><span class="w"> </span><span class="nv">set</span><span class="p">]))</span>

<span class="c1">; Java</span>
<span class="c1">;;;;;;;;;;;;;;;;;</span>

<span class="c1">; Java hat eine riesige und nützliche Standardbibliothek,</span>
<span class="c1">; du möchtest lernen wie man sie verwendet.</span>

<span class="c1">; Verwende import um ein Java modul zu laden.</span>
<span class="p">(</span><span class="nb">import </span><span class="nv">java.util.Date</span><span class="p">)</span>

<span class="c1">; Du kannst auch von einem ns importieren.</span>
<span class="p">(</span><span class="kd">ns </span><span class="nv">test</span>
<span class="w">  </span><span class="p">(</span><span class="ss">:import</span><span class="w"> </span><span class="nv">java.util.Date</span>
<span class="w">           </span><span class="nv">java.util.Calendar</span><span class="p">))</span>

<span class="c1">; Verwende den Klassennamen mit einem &quot;.&quot; am Ende, um eine neue Instanz zu erstellen</span>
<span class="p">(</span><span class="nf">Date.</span><span class="p">)</span><span class="w"> </span><span class="c1">; &lt;a date object&gt;</span>

<span class="c1">; Verwende . um Methoden aufzurufen oder verwende die &quot;.method&quot; Abkürzung</span>
<span class="p">(</span><span class="k">. </span><span class="p">(</span><span class="nf">Date.</span><span class="p">)</span><span class="w"> </span><span class="nv">getTime</span><span class="p">)</span><span class="w"> </span><span class="c1">; &lt;a timestamp&gt;</span>
<span class="p">(</span><span class="nf">.getTime</span><span class="w"> </span><span class="p">(</span><span class="nf">Date.</span><span class="p">))</span><span class="w"> </span><span class="c1">; Genau das Selbe</span>

<span class="c1">; Verwende / um statische Methoden aufzurufen</span>
<span class="p">(</span><span class="nf">System/currentTimeMillis</span><span class="p">)</span><span class="w"> </span><span class="c1">; &lt;a timestamp&gt; (system ist immer da)</span>

<span class="c1">; Verwende doto um mit veränderliche Klassen besser umzugehen</span>
<span class="p">(</span><span class="nb">import </span><span class="nv">java.util.Calendar</span><span class="p">)</span>
<span class="p">(</span><span class="nb">doto </span><span class="p">(</span><span class="nf">Calendar/getInstance</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">.set</span><span class="w"> </span><span class="mi">2000</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">  </span><span class="nv">.getTime</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; A Date. set to 2000-01-01 00:00:00</span>

<span class="c1">; STM</span>
<span class="c1">;;;;;;;;;;;;;;;;;</span>

<span class="c1">; Software Transactional Memory ist der Mechanismus, den Clojure verwendet</span>
<span class="c1">; um mit persistenten Zuständen umzugehen. Es gibt ein Paar Konstrukte in</span>
<span class="c1">; Clojure die es verwenden.</span>

<span class="c1">; Ein Atom ist das Einfachste. Gebe es einen Initialwert</span>
<span class="p">(</span><span class="k">def </span><span class="nv">my-atom</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="p">{}))</span>

<span class="c1">; Update ein Atom mit swap!.</span>
<span class="c1">; swap! nimmt eine Funktion und ruft sie mit dem aktuellen Zustand des</span>
<span class="c1">; Atoms auf und alle nachfolgenden Argumente als das Zweite</span>
<span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="nv">my-atom</span><span class="w"> </span><span class="nb">assoc </span><span class="ss">:a</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">; Setzt my-atom zu dem Ergebnis von (assoc {} :a 1)</span>
<span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="nv">my-atom</span><span class="w"> </span><span class="nb">assoc </span><span class="ss">:b</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">; Setzt my-atom zu dem Ergebnis von (assoc {:a 1} :b 2)</span>

<span class="c1">; Verwende &#39;@&#39; um das Atom zu dereferenzieren und den Wert zu bekommen</span>
<span class="nv">my-atom</span><span class="w">  </span><span class="c1">;=&gt; Atom&lt;#...&gt; (Gibt das Atom Objekt zurück</span>
<span class="o">@</span><span class="nv">my-atom</span><span class="w"> </span><span class="c1">; =&gt; {:a 1 :b 2}</span>

<span class="c1">; Hier ist ein einfacher Zähler mit einem Atom</span>
<span class="p">(</span><span class="k">def </span><span class="nv">counter</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">inc-counter</span><span class="w"> </span><span class="p">[]</span>
<span class="w">  </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="nv">counter</span><span class="w"> </span><span class="nv">inc</span><span class="p">))</span>

<span class="p">(</span><span class="nf">inc-counter</span><span class="p">)</span>
<span class="p">(</span><span class="nf">inc-counter</span><span class="p">)</span>
<span class="p">(</span><span class="nf">inc-counter</span><span class="p">)</span>
<span class="p">(</span><span class="nf">inc-counter</span><span class="p">)</span>
<span class="p">(</span><span class="nf">inc-counter</span><span class="p">)</span>

<span class="o">@</span><span class="nv">counter</span><span class="w"> </span><span class="c1">; =&gt; 5</span>

<span class="c1">; Andere STM Konstrukte sind refs und agents.</span>
<span class="c1">; Refs: http://clojure.org/refs</span>
<span class="c1">; Agents: http://clojure.org/agents</span>
</pre></div>
<h3>Weiterführende Literatur</h3>
<p>Das ist alles andere als erschöpfend, aber hoffentlich ist es genug, um dich auf die Beine zu stellen.</p>
<p>Clojure.org hat eine Menge von Artikeln:
<a href="http://clojure.org/">http://clojure.org/</a></p>
<p>Clojuredocs.org hat eine Dokumentation mit Beispielen für die meisten Kernfunktionen
<a href="http://clojuredocs.org/quickref/Clojure%20Core">http://clojuredocs.org/quickref/Clojure%20Core</a></p>
<p>4Clojure ist eine gute Möglichkeit um deine clojure/FP zu verbessern:
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a></p>
<p>Clojure-doc.org (ja, wirklich) hat eine Reihe von Artikeln zum Starten:
<a href="http://clojure-doc.org/">http://clojure-doc.org/</a></p>

        <hr>
        <p>
          Du hast einen Verbesserungsvorschlag oder einen Fehler gefunden? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Erstelle ein Ticket</a> im offiziellen GitHub Repo, oder du erstellst einfach gleich einen <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/de/clojure.md">pull request</a>!
        </p>
        <p class="contributed">
          Originalversion von Adam Bard, mit Updates von <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/de/clojure.md">3 contributors</a>.
        </p>

        <footer>
          <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width: 0; width: 80px; height: 28px; padding-bottom: 5px;" src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-sa.svg" /></a>
          <p>
            &copy; 2025
            <a href="http://adambard.com/">Adam Bard</a>
          </p>
        </footer>
      </div>
    </div>
  </body>
</html>