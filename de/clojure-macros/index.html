<!DOCTYPE html>
<html lang="de">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-WXC8R75DEN');
    </script>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="Content-Language" content="de">
    <title>Learn Clojure macros in Y Minutes</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto+Slab:wght@100..900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/screen.css">
    <link rel="stylesheet" href="/css/light.css">
    <link rel="stylesheet" href="/css/dark.css">

    <link rel="canonical" href="https://learnxinyminutes.com/de/clojure-macros/">
    <script>
      localStorage.removeItem("lxiym_theme");
    </script>
  </head>
  <body>
    <div class="container">
      <div class="share">
        <span class="sharemsg">
          <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fde%2Fclojure-macros%2F&amp;text=Lerne+X+in+Y+Minuten%2C+wobei+X%3DClojure+macros">
            Teile diese Seite mit anderen
          </a>
        </span>
        <span class='st_facebook_large' displayText='Facebook'></span>
        <span class='st_twitter_large' displayText='Tweet'></span>
      </div>
      <h1><a href="/">Lerne X in Y Minuten</a></h1>
      <h2>Wobei X=Clojure macros</h2>
      <p class="filelink">
        Lade den Code herunter:
        <a href="/de/files/learnclojuremacros.clj">learnclojuremacros.clj</a>
      </p>
      <div id="doc">
<p>Wie mit allen Lisps besitzt auch Clojure die inhärente <a href="https://en.wikipedia.org/wiki/Homoiconic">Homoikonizität</a>,
die dir den vollen Zugang der Sprache gibt, um
Code-Generierungsroutinen zu schreiben. Diese werden &quot;Macros&quot; genannt.
Macros geben dir eine leistungsstarke Möglichkeit, die Sprache
an deine Bedürfnisse anzupassen.</p>
<p>Sei aber vorsichtig, es wird als schlechter Stil angesehen, wenn du
ein Macro schreibst, obwohl eine Funktion genauso gut funktionieren würde.
Verwende nur dann ein Macro, wenn du Kontrolle darüber brauchst, wann oder ob Argumente in einer Form evaluiert werden.</p>
<p>Wenn du mit Clojure vertraut sein möchtest, stelle sicher, dass du alles in <a href="../clojure/">Clojure in Y Minutes</a> verstehst.</p>
<div class="highlight"><pre lang="clojure"><span class="c1">;; Definiere ein Macro mit defmacro. Dein Macro sollte eine Liste zurückgeben,</span>
<span class="c1">;; die als Clojure Code evaluiert werden kann.</span>
<span class="c1">;;</span>
<span class="c1">;; Dieses Macro ist das Gleiche, als ob du (reverse &quot;Hallo Welt&quot;) geschrieben</span>
<span class="c1">;; hättest</span>
<span class="p">(</span><span class="kd">defmacro </span><span class="nv">my-first-macro</span><span class="w"> </span><span class="p">[]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">list reverse </span><span class="s">&quot;Hallo Welt&quot;</span><span class="p">))</span>

<span class="c1">;; Inspiziere das Ergebnis eines Macros mit macroexpand oder macroexpand-1.</span>
<span class="c1">;;</span>
<span class="c1">;; Beachte, dass der Aufruf zitiert sein muss.</span>
<span class="p">(</span><span class="nb">macroexpand </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">my-first-macro</span><span class="p">))</span>
<span class="c1">;; -&gt; (#&lt;core$reverse clojure.core$reverse@xxxxxxxx&gt; &quot;Hallo Welt&quot;)</span>

<span class="c1">;; Du kannst das Ergebnis von macroexpand direkt auswerten.</span>
<span class="p">(</span><span class="nb">eval </span><span class="p">(</span><span class="nb">macroexpand </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">my-first-macro</span><span class="p">)))</span>
<span class="c1">; -&gt; (\t \l \e \W \space \o \l \l \a \H)</span>

<span class="c1">;; Aber du solltest diese prägnante und funktionsähnliche Syntax verwenden:</span>
<span class="p">(</span><span class="nf">my-first-macro</span><span class="p">)</span><span class="w">  </span><span class="c1">; -&gt; (\t \l \e \W \space \o \l \l \a \H)</span>

<span class="c1">;; Du kannst es dir leichter machen, indem du die Zitiersyntax verwendest</span>
<span class="c1">;; um Listen in ihren Makros zu erstellen:</span>
<span class="p">(</span><span class="kd">defmacro </span><span class="nv">my-first-quoted-macro</span><span class="w"> </span><span class="p">[]</span>
<span class="w">  </span><span class="o">&#39;</span><span class="p">(</span><span class="nb">reverse </span><span class="s">&quot;Hallo Welt&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nb">macroexpand </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">my-first-quoted-macro</span><span class="p">))</span>
<span class="c1">;; -&gt; (reverse &quot;Hallo Welt&quot;)</span>
<span class="c1">;; Beachte, dass reverse nicht mehr ein Funktionsobjekt ist, sondern ein Symbol</span>

<span class="c1">;; Macros können Argumente haben.</span>
<span class="p">(</span><span class="kd">defmacro </span><span class="nv">inc2</span><span class="w"> </span><span class="p">[</span><span class="nv">arg</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">list + </span><span class="mi">2</span><span class="w"> </span><span class="nv">arg</span><span class="p">))</span>

<span class="p">(</span><span class="nf">inc2</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">; -&gt; 4</span>

<span class="c1">;; Aber wenn du versuchst das mit einer zitierten Liste zu machen wirst du</span>
<span class="c1">;; einen Fehler bekommen, weil das Argument auch zitiert sein wird.</span>
<span class="c1">;; Um dies zu umgehen, bietet Clojure eine Art und Weise Macros zu zitieren: `</span>
<span class="c1">;; In ` kannst du ~ verwenden um in den äußeren Bereich zu kommen.</span>
<span class="p">(</span><span class="kd">defmacro </span><span class="nv">inc2-quoted</span><span class="w"> </span><span class="p">[</span><span class="nv">arg</span><span class="p">]</span>
<span class="w">  </span><span class="o">`</span><span class="p">(</span><span class="nb">+ </span><span class="mi">2</span><span class="w"> </span><span class="o">~</span><span class="nv">arg</span><span class="p">))</span>

<span class="p">(</span><span class="nf">inc2-quoted</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>

<span class="c1">;; Du kannst die normalen destruktuierungs Argumente verwenden. Expandiere</span>
<span class="c1">;; Listenvariablen mit ~@.</span>
<span class="p">(</span><span class="kd">defmacro </span><span class="nv">unless</span><span class="w"> </span><span class="p">[</span><span class="nv">arg</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="o">`</span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="o">~</span><span class="nv">arg</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="k">do </span><span class="o">~@</span><span class="nv">body</span><span class="p">)))</span><span class="w"> </span><span class="c1">; Erinnere dich an das do!</span>

<span class="p">(</span><span class="nb">macroexpand </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">unless</span><span class="w"> </span><span class="nv">true</span><span class="w"> </span><span class="p">(</span><span class="nb">reverse </span><span class="s">&quot;Hallo Welt&quot;</span><span class="p">)))</span>
<span class="c1">;; -&gt;</span>
<span class="c1">;; (if (clojure.core/not true) (do (reverse &quot;Hallo Welt&quot;)))</span>

<span class="c1">;; (unless) evaluiert und gibt body zurück, wenn das erste Argument falsch ist.</span>
<span class="c1">;; Andernfalls gibt es nil zurück</span>

<span class="p">(</span><span class="nf">unless</span><span class="w"> </span><span class="nv">true</span><span class="w"> </span><span class="s">&quot;Hallo&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; -&gt; nil</span>
<span class="p">(</span><span class="nf">unless</span><span class="w"> </span><span class="nv">false</span><span class="w"> </span><span class="s">&quot;Hallo&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; -&gt; &quot;Hallo&quot;</span>

<span class="c1">;; Die Verwendung Macros ohne Sorgfalt kann viel Böses auslösen, indem es</span>
<span class="c1">;; deine Variablen überschreibt</span>
<span class="p">(</span><span class="kd">defmacro </span><span class="nv">define-x</span><span class="w"> </span><span class="p">[]</span>
<span class="w">  </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">do</span>
<span class="w">     </span><span class="p">(</span><span class="k">def </span><span class="nv">x</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="nb">list </span><span class="nv">x</span><span class="p">)))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">x</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>
<span class="p">(</span><span class="nf">define-x</span><span class="p">)</span><span class="w"> </span><span class="c1">; -&gt; (2)</span>
<span class="p">(</span><span class="nb">list </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="c1">; -&gt; (2)</span>

<span class="c1">;; Um das zu verhindern kannst du gensym verwenden um einen eindeutigen</span>
<span class="c1">;; Identifikator zu bekommen</span>
<span class="p">(</span><span class="nb">gensym </span><span class="ss">&#39;x</span><span class="p">)</span><span class="w"> </span><span class="c1">; -&gt; x1281 (oder etwas Ähnliches)</span>

<span class="p">(</span><span class="kd">defmacro </span><span class="nv">define-x-safely</span><span class="w"> </span><span class="p">[]</span>
<span class="w">  </span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">sym</span><span class="w"> </span><span class="p">(</span><span class="nb">gensym </span><span class="ss">&#39;x</span><span class="p">)]</span>
<span class="w">    </span><span class="o">`</span><span class="p">(</span><span class="nf">do</span>
<span class="w">       </span><span class="p">(</span><span class="k">def </span><span class="o">~</span><span class="nv">sym</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="nb">list </span><span class="o">~</span><span class="nv">sym</span><span class="p">))))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">x</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>
<span class="p">(</span><span class="nf">define-x-safely</span><span class="p">)</span><span class="w"> </span><span class="c1">; -&gt; (2)</span>
<span class="p">(</span><span class="nb">list </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="c1">; -&gt; (4)</span>

<span class="c1">;; Du kannst # innerhalb von ` verwenden um für jedes Symbol automatisch</span>
<span class="c1">;; ein gensym zu erstellen</span>
<span class="p">(</span><span class="kd">defmacro </span><span class="nv">define-x-hygienically</span><span class="w"> </span><span class="p">[]</span>
<span class="w">  </span><span class="o">`</span><span class="p">(</span><span class="nf">do</span>
<span class="w">     </span><span class="p">(</span><span class="k">def </span><span class="nv">x#</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="nb">list </span><span class="nv">x#</span><span class="p">)))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">x</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>
<span class="p">(</span><span class="nf">define-x-hygienically</span><span class="p">)</span><span class="w"> </span><span class="c1">; -&gt; (2)</span>
<span class="p">(</span><span class="nb">list </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="c1">; -&gt; (4)</span>

<span class="c1">;; Es ist üblich, Hilfsfunktionen mit Macros zu verwenden. Lass uns einige</span>
<span class="c1">;; erstellen, die uns helfen , eine (dumme) arithmetische Syntax</span>
<span class="c1">;; zu unterstützen</span>
<span class="p">(</span><span class="kd">declare </span><span class="nv">inline-2-helper</span><span class="p">)</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">clean-arg</span><span class="w"> </span><span class="p">[</span><span class="nv">arg</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">seq? </span><span class="nv">arg</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nf">inline-2-helper</span><span class="w"> </span><span class="nv">arg</span><span class="p">)</span>
<span class="w">    </span><span class="nv">arg</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">apply-arg</span>
<span class="w">  </span><span class="s">&quot;Bekomme die Argumente [x (+ y)], gebe (+ x y) zurück&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nb">val </span><span class="p">[</span><span class="nv">op</span><span class="w"> </span><span class="nv">arg</span><span class="p">]]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">list </span><span class="nv">op</span><span class="w"> </span><span class="nb">val </span><span class="p">(</span><span class="nf">clean-arg</span><span class="w"> </span><span class="nv">arg</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">inline-2-helper</span>
<span class="w">  </span><span class="p">[[</span><span class="nv">arg1</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nv">ops-and-args</span><span class="p">]]</span>
<span class="w">  </span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">ops</span><span class="w"> </span><span class="p">(</span><span class="nf">partition</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="nv">ops-and-args</span><span class="p">)]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">reduce </span><span class="nv">apply-arg</span><span class="w"> </span><span class="p">(</span><span class="nf">clean-arg</span><span class="w"> </span><span class="nv">arg1</span><span class="p">)</span><span class="w"> </span><span class="nv">ops</span><span class="p">)))</span>

<span class="c1">;; Wir können es sofort testen, ohne ein Macro zu erstellen</span>
<span class="p">(</span><span class="nf">inline-2-helper</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">a</span><span class="w"> </span><span class="nb">+ </span><span class="p">(</span><span class="nf">b</span><span class="w"> </span><span class="nb">- </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="nb">- </span><span class="p">(</span><span class="nf">c</span><span class="w"> </span><span class="nb">* </span><span class="mi">5</span><span class="p">)))</span><span class="w"> </span><span class="c1">; -&gt; (- (+ a (- b 2)) (* c 5))</span>

<span class="c1">; Allerdings, brauchen wir ein Macro, wenn wir es zur Kompilierungszeit</span>
<span class="c1">; ausführen wollen</span>
<span class="p">(</span><span class="kd">defmacro </span><span class="nv">inline-2</span><span class="w"> </span><span class="p">[</span><span class="nv">form</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nf">inline-2-helper</span><span class="w"> </span><span class="nv">form</span><span class="p">))</span>

<span class="p">(</span><span class="nb">macroexpand </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">inline-2</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="nb">+ </span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="nb">/ </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="nb">- </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="nb">/ </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="nb">+ </span><span class="mi">1</span><span class="p">)))</span>
<span class="c1">; -&gt; (+ (- (+ 1 (/ 3 2)) (/ 1 2)) 1)</span>

<span class="p">(</span><span class="nf">inline-2</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="nb">+ </span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="nb">/ </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="nb">- </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="nb">/ </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="nb">+ </span><span class="mi">1</span><span class="p">))</span>
<span class="c1">; -&gt; 3 (eigentlich, 3N, da die Zahl zu einem rationalen Bruch mit / umgewandelt wird)</span>
</pre></div>
<h3>Weiterführende Literatur</h3>
<p><a href="http://www.braveclojure.com/writing-macros/">Macros schreiben</a></p>
<p><a href="http://clojure.org/macros">Offizielle Docs</a></p>
<p><a href="https://lispcast.com/when-to-use-a-macro/">Wann verwendet man Macros?</a></p>

        <hr>
        <p>
          Du hast einen Verbesserungsvorschlag oder einen Fehler gefunden? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Erstelle ein Ticket</a> im offiziellen GitHub Repo, oder du erstellst einfach gleich einen <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/de/clojure-macros.md">pull request</a>!
        </p>
        <p class="contributed">
          Originalversion von Adam Bard, mit Updates von <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/de/clojure-macros.md">3 contributors</a>.
        </p>

        <footer>
          <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width: 0; width: 80px; height: 28px; padding-bottom: 5px;" src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-sa.svg" /></a>
          <p>
            &copy; 2025
            <a href="http://adambard.com/">Adam Bard</a>
          </p>
        </footer>
      </div>
    </div>
  </body>
</html>