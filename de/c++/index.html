<!DOCTYPE html>
<html lang="de">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-WXC8R75DEN');
    </script>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="Content-Language" content="de">
    <title>Learn C++ in Y Minutes</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto+Slab:wght@100..900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/screen.css">
    <link rel="stylesheet" href="/css/light.css">
    <link rel="stylesheet" href="/css/dark.css">

    <link rel="canonical" href="https://learnxinyminutes.com/de/c++/">
    <script>
      localStorage.removeItem("lxiym_theme");
    </script>
  </head>
  <body>
    <div class="container">
      <h1><a href="/">Lerne X in Y Minuten</a></h1>
      <h2>Wobei X=C++</h2>

      <div class="lang-choice">
        <label for="lang-select">Sprache:</label>
        <select id="lang-select" name="lang-select">
          <option value="de">Deutsch</option>
          <option value="en" data-url="/c++/">English</option>
          <option value="es" data-url="/es/c++/">español</option>
          <option value="fr" data-url="/fr/c++/">français</option>
          <option value="hi" data-url="/hi/c++/">हिन्दी</option>
          <option value="it" data-url="/it/c++/">italiano</option>
          <option value="pt-br" data-url="/pt-br/c++/">português (Brasil)</option>
          <option value="ru" data-url="/ru/c++/">русский</option>
          <option value="tr" data-url="/tr/c++/">Türkçe</option>
          <option value="zh-cn" data-url="/zh-cn/c++/">中文 (简体)</option>
        </select>
      </div>
      <p class="filelink">
        Lade den Code herunter:
        <a href="/de/files/learncpp.cpp">learncpp.cpp</a>
      </p>
      <div id="doc">
<p>C++ ist eine Systemprogrammiersprache die,</p>
<p><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">laut dem Begründer Bjarne Stroustrup</a>
entworfen wurde um,</p>
<ul>
<li>&quot;besseres C&quot; zu sein</li>
<li>Datenabstraktion zu unterstützen</li>
<li>Objektorientierung zu unterstützen</li>
<li>generische Programmierung zu unterstützen</li>
</ul>
<p>Durch seine Syntax kann sie durchaus schwieriger und komplexer als neuere Sprachen sein.</p>
<p>Sie ist weit verbreitet, weil sie in Maschinen-Code kompiliert, welcher direkt vom Prozessor ausgeführt
werden kann und somit eine strikte Kontrolle über die Hardware bietet und gleichzeitig
High-Level-Features wie generics, exceptions und Klassen enthält.</p>
<p>Diese Kombination aus Geschwindigkeit und Funktionalität bildet C++ und ist eine der
weitverbreitesten Programmiersprachen.</p>
<div class="highlight"><pre lang="c++"><span class="c1">//////////////////</span>
<span class="c1">// Vergleich zu C</span>
<span class="c1">//////////////////</span>

<span class="c1">// C ist fast eine Untermenge von C++ und teilt sich grundsätzlich die</span>
<span class="c1">// Syntax für Variablen Deklarationen, primitiven Typen und Funktionen.</span>

<span class="c1">// Wie in C ist der Programmeinsprungpunkt eine Funktion, welche &quot;main&quot; genannt wird und</span>
<span class="c1">// einen Integer als Rückgabetyp besitzt.</span>

<span class="c1">// Dieser Wert fungiert als Beendigungsstatus des Programms.</span>
<span class="c1">// Siehe: https://de.wikipedia.org/wiki/Return_Code für weitere Informationen</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Kommandozeilen Argumente werden genauso wie in C über argc und argv übergeben</span>
<span class="w">    </span><span class="c1">// argc entspricht der Anzahl von Argumenten und argv ist ein Array von C-style</span>
<span class="w">    </span><span class="c1">// strings (char*), welche die Argumente repräsentieren.</span>
<span class="w">    </span><span class="c1">// Das erste Argument ist der Name des Programms, welches aufgerufen wird.</span>
<span class="w">    </span><span class="c1">// Argc und argv können, wenn nicht benötigt, weg gelassen werden, indem</span>
<span class="w">    </span><span class="c1">// die Funktionssignatur &quot;int main()&quot; verwendet wird.</span>

<span class="w">    </span><span class="c1">//  Ein Rückgabewert von 0 repräsentiert die erfolgreiche Ausführung.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// C++ unterscheidet sich in einigen Punkten von C:</span>

<span class="c1">// In C++ sind Zeichen-Literale char´s</span>
<span class="k">sizeof</span><span class="p">(</span><span class="sc">&#39;c&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span>

<span class="c1">// In C sind Zeichen-Literale int´s</span>
<span class="k">sizeof</span><span class="p">(</span><span class="sc">&#39;c&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>

<span class="c1">// C++ verwendet striktes prototyping</span>
<span class="kt">void</span><span class="w"> </span><span class="n">func</span><span class="p">();</span><span class="w"> </span><span class="c1">// Funktion ohne Argumente</span>

<span class="c1">// In C</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">();</span><span class="w"> </span><span class="c1">// Funktion mit beliebiger Anzahl von Argumenten</span>

<span class="c1">// Verwende nullptr, anstatt von NULL!!!</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="c1">// C standard header sind in C++ verfügbar.</span>
<span class="c1">// C header enden mit .h, während</span>
<span class="c1">// C++ header das Präfix &quot;c&quot; besitzen und kein &quot;.h&quot; Suffix verwenden.</span>

<span class="c1">// Die C++ Standard Version:</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdio&gt;</span>

<span class="c1">// Die C Standard Version:</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, world!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">///////////////////////</span>
<span class="c1">// Funktionsüberladung</span>
<span class="c1">///////////////////////</span>

<span class="c1">// C++ unterstützt Funktionsüberladung</span>
<span class="c1">// Jede Funktion kann unterschiedliche Parameter erhalten.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">myString</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;String %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">myString</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">myInt</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;My int is %d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">myInt</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Wird aufgelöst zu &quot;void print(const char*)&quot;</span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span><span class="w"> </span><span class="c1">// Wird aufgelöst zu &quot;void print(int)&quot;</span>
<span class="p">}</span>

<span class="c1">/////////////////////////////</span>
<span class="c1">// Standard Funktionsargumente</span>
<span class="c1">/////////////////////////////</span>

<span class="c1">// Argumente können per Standard für eine Funktion gesetzt werden,</span>
<span class="c1">// wenn diese beim Aufruf nicht bereitgestellt werden.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">doSomethingWithInts</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// führe Anweisungen mit &quot;int´s&quot; aus.</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">doSomethingWithInts</span><span class="p">();</span><span class="w">      </span><span class="c1">// a = 1,  b = 4</span>
<span class="w">    </span><span class="n">doSomethingWithInts</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w">    </span><span class="c1">// a = 20, b = 4</span>
<span class="w">    </span><span class="n">doSomethingWithInts</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// a = 20, b = 5</span>
<span class="p">}</span>

<span class="c1">// Standard-Argumente müssen am Ende der Liste der Argumente stehen.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">invalidDeclaration</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="c1">// Fehler!</span>
<span class="p">{</span>
<span class="p">}</span>


<span class="c1">/////////////</span>
<span class="c1">// Namespaces (Namensräume)</span>
<span class="c1">/////////////</span>

<span class="c1">// Namespaces stellen einen getrennten Gültigkeitsbereich für Variablen,</span>
<span class="c1">// Funktionen und andere Deklarationen zur Verfügung.</span>
<span class="c1">// Namespaces können geschachtelt werden.</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">First</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Nested</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;This is First::Nested::foo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// Ende des Namespace &quot;Nested&quot;</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// Ende des Namespace &quot;First&quot;</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">Second</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;This is Second::foo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;This is global foo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Fügt alle Symbole aus dem namespace Second in den aktuellen Gültigkeitsbereich (scope).</span>
<span class="w">    </span><span class="c1">// &quot;foo()&quot; wird nun nicht länger funktionieren, da es nun doppeldeutig ist, ob foo aus</span>
<span class="w">    </span><span class="c1">// dem namespace foo oder darüberliegenden aufgerufen wird.</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Second</span><span class="p">;</span>

<span class="w">    </span><span class="n">Second</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// Gibt &quot;This is Second::foo&quot; aus.</span>
<span class="w">    </span><span class="n">First</span><span class="o">::</span><span class="n">Nested</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// Gibt &quot;This is First::Nested::foo&quot; aus.</span>
<span class="w">    </span><span class="o">::</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// Gibt &quot;This is global foo&quot; aus.</span>
<span class="p">}</span>

<span class="c1">///////////////</span>
<span class="c1">// Eingabe/Ausgabe</span>
<span class="c1">///////////////</span>

<span class="c1">// C++ verwendet für die Eingabe und Ausgabe streams.</span>
<span class="c1">// cin, cout und cerr repräsentieren stdin, stdout und stderr.</span>
<span class="c1">// &lt;&lt; ist der Einfügeoperator und &gt;&gt; ist der Extraktionsoperator.</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="c1"> // Include für Eingabe/Ausgabe (I/O) streams</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"> </span><span class="c1">// Streams befinden sich im std namespace (standard library)</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">myInt</span><span class="p">;</span>

<span class="w">   </span><span class="c1">// Ausgabe auf stdout (oder Terminal/Bildschirm)</span>
<span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Enter your favorite number:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="w">   </span><span class="c1">// Empfängt Eingabe</span>
<span class="w">   </span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">myInt</span><span class="p">;</span>

<span class="w">   </span><span class="c1">// cout kann ebenfalls formatiert werden</span>
<span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Your favorite number is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myInt</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">   </span><span class="c1">// Gibt &quot;Your favorite number is &lt;myInt&gt;&quot; aus</span>

<span class="w">    </span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Used for error messages&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//////////</span>
<span class="c1">// Zeichenketten (Strings)</span>
<span class="c1">//////////</span>

<span class="c1">// Strings in C++ sind Objekte und haben diverse member-functions</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"> </span><span class="c1">// Strings sind ebenfalls im namespace std (Standard Bibliothek)</span>

<span class="n">string</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span><span class="p">;</span>
<span class="n">string</span><span class="w"> </span><span class="n">myOtherString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot; World&quot;</span><span class="p">;</span>

<span class="c1">// + wird für das Anhängen von strings verwendet.</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">myOtherString</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;Hello World&quot;</span>

<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; You&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;Hello You&quot;</span>

<span class="c1">// C++ strings sind mutable.</span>
<span class="n">myString</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot; Dog&quot;</span><span class="p">);</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myString</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;Hello Dog&quot;</span>


<span class="c1">/////////////</span>
<span class="c1">// Referenzen</span>
<span class="c1">/////////////</span>

<span class="c1">// Zusätzlich zu Pointern, wie jene in C.</span>
<span class="c1">// C++ besitzt _Referenzen_.</span>
<span class="c1">// Diese sind Pointer-Typen, welche nicht erneut zugewiesen werden können</span>
<span class="c1">// und nicht Null sein können.</span>
<span class="c1">// Sie besitzen den selben Syntax wie Variablen.</span>
<span class="c1">// Für die Dereferenzierung ist kein * notwendig und</span>
<span class="c1">// &amp; (die Adresse) wird nicht für die Zuweisung verwendet.</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="n">string</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;I am foo&quot;</span><span class="p">;</span>
<span class="n">string</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;I am bar&quot;</span><span class="p">;</span>


<span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">fooRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w"> </span><span class="c1">// Erzeugt eine Referenz auf foo.</span>
<span class="n">fooRef</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;. Hi!&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Verändert foo durch die Referenz</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fooRef</span><span class="p">;</span><span class="w"> </span><span class="c1">// Gibt &quot;I am foo. Hi!&quot; aus.</span>


<span class="c1">// Weist &quot;fooRef&quot; nicht erneut zu. Dies ist dasselbe, wie &quot;foo = bar&quot; und </span>
<span class="c1">// foo == &quot;I am bar&quot;</span>
<span class="c1">// nach dieser Zeile </span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fooRef</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Gibt die Adresse von foo aus</span>
<span class="n">fooRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fooRef</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Gibt ebenfalls die Adresse von foo aus</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fooRef</span><span class="p">;</span><span class="w">  </span><span class="c1">// Gibt &quot;I am bar&quot; aus</span>

<span class="c1">// Die Adresse von fooRef verbleibt die selbe, sie verweist immer noch auf foo</span>

<span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">barRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span><span class="w"> </span><span class="c1">// Erzeugt konstante Referenz auf bar.</span>
<span class="c1">// Wie in C, können konstante Werte ( und Pointer bzw. Referenzen) nicht verändert werden.</span>

<span class="n">barRef</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;. Hi!&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Fehler: konstante Referenzen können nicht verändert werden.</span>

<span class="c1">// Hinweis: bevor wir genauer Referenzen besprechen, schauen wir uns zuerst ein Konzept an,</span>
<span class="c1">// welches als &quot;temporäres Objekt&quot; bezeichnet wird. Gehen wir von folgenden Code aus:</span>
<span class="n">string</span><span class="w"> </span><span class="nf">tempObjectFun</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="n">string</span><span class="w"> </span><span class="n">retVal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tempObjectFun</span><span class="p">();</span>

<span class="c1">// Was passiert nun in der zweiten Zeile:</span>
<span class="c1">//  - ein String Objekt wird von &quot;tempObjectFun&quot; zurückgegeben</span>
<span class="c1">//  - ein neuer String wird mit dem zurückgegebenen Objekt als Argument für den Konstruktor erzeugt.</span>
<span class="c1">//  - das zurückgegebene Objekt wird zerstört</span>
<span class="c1">// Das zurückgegebene Objekt wird temporäres Objekt genannt. Temporäre Objekte werden erzeugt</span>
<span class="c1">// wann immer eine Funktion ein Objekt zurückgibt. Zerstört werden diese am Ende der Auswertung des Ausdrucks</span>
<span class="c1">// (dies schreibt der Standard vor, aber Compiler sind berechtigt dieses Verhalten zu ändern. Siehe &quot;return value optimization&quot;</span>
<span class="c1">// für Details). Wie in diesem Code:</span>
<span class="n">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">(</span><span class="n">tempObjectFun</span><span class="p">()))</span>

<span class="c1">// Nehmen wir an, foo und bar existieren. Das Objekt wird von &quot;tempObjectFun&quot; zurückgegeben,</span>
<span class="c1">// wird an bar übergeben und ist zerstört bevor foo aufgerufen wird.</span>

<span class="c1">// Zurück zu Referenzen. Die Annahme, dass die &quot;am Ende des Ausdrucks&quot; Regel gültig ist,</span>
<span class="c1">// wenn das temporäre Objekt an eine konstante Referenz gebunden ist, ist der Fall, wenn die Lebensdauer</span>
<span class="c1">// auf den aktuellen Gültigkeitsbereich erweitert wird.</span>

<span class="kt">void</span><span class="w"> </span><span class="n">constReferenceTempObjectFun</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// constRef erhält das temporäre Objekt und ist gültig bis ans Ende der Funktion</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">constRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tempObjectFun</span><span class="p">();</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>

<span class="c1">// Eine andere Art von Referenzen wurde in C++11 eingeführt und ist speziell für</span>
<span class="c1">// temporäre Objekte. Es ist nicht möglich Variablen des Typs zu besitzen, aber</span>
<span class="c1">// Vorrechte bei der Auflösung zu besitzen.</span>

<span class="kt">void</span><span class="w"> </span><span class="n">someFun</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">  </span><span class="c1">// Reguläre Referenz</span>
<span class="kt">void</span><span class="w"> </span><span class="n">someFun</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">  </span><span class="c1">// Referenz auf ein temporäres Objekt</span>

<span class="n">string</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>
<span class="n">someFun</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span><span class="w">  </span><span class="c1">// Ruft die Funktion mit der regulären Referenz auf</span>
<span class="n">someFun</span><span class="p">(</span><span class="n">tempObjectFun</span><span class="p">());</span><span class="w">  </span><span class="c1">// Ruft die Funktion mit der temporären Referenz auf</span>

<span class="c1">// Zum Beispiel existieren diese zwei Varianten von Konstruktoren für</span>
<span class="c1">// std::basic_string:</span>
<span class="n">basic_string</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">basic_string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
<span class="n">basic_string</span><span class="p">(</span><span class="n">basic_string</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>

<span class="c1">// Nehmen wir an, wir erzeugen einen neuen String eines temporären Objekts (welches später</span>
<span class="c1">// zerstört wird), hierbei existiert ein effizienterer Konstruktor. Dieses Konzept wird</span>
<span class="c1">// als &quot;move semantics&quot; bezeichnet (bewegen eines Objekts in ein anderes in C++).</span>

<span class="c1">/////////////////////</span>
<span class="c1">// Enumerations (Aufzählungstypen)</span>
<span class="c1">/////////////////////</span>

<span class="c1">// Enums sind eine einfachere Art und Weise einen Wert einer Konstante zu zuweisen.</span>
<span class="c1">// Häufig wird dies verwendet, um den Code lesbarer zu gestalten bzw. zu visualisieren.</span>
<span class="k">enum</span><span class="w"> </span><span class="nc">ECarTypes</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Sedan</span><span class="p">,</span>
<span class="w">  </span><span class="n">Hatchback</span><span class="p">,</span>
<span class="w">  </span><span class="n">SUV</span><span class="p">,</span>
<span class="w">  </span><span class="n">Wagon</span>
<span class="p">};</span>

<span class="n">ECarTypes</span><span class="w"> </span><span class="nf">GetPreferredCarType</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">ECarTypes</span><span class="o">::</span><span class="n">Hatchback</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Mit C++11 existiert eine einfache Möglichkeit einem Typ dem Enum zuzuweisen. Dies</span>
<span class="c1">// kann durchaus sinnvoll bei der Serialisierung von Daten sein, oder bei der Konvertierung</span>
<span class="c1">// zwischen Typen bzw. Konstanten.</span>
<span class="k">enum</span><span class="w"> </span><span class="nc">ECarTypes</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">uint8_t</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Sedan</span><span class="p">,</span><span class="w"> </span><span class="c1">// 0</span>
<span class="w">  </span><span class="n">Hatchback</span><span class="p">,</span><span class="w"> </span><span class="c1">// 1</span>
<span class="w">  </span><span class="n">SUV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">254</span><span class="p">,</span><span class="w"> </span><span class="c1">// 254</span>
<span class="w">  </span><span class="n">Hybrid</span><span class="w"> </span><span class="c1">// 255</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">WriteByteToFile</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">InputValue</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Serialisierung von &quot;InputValue&quot; in eine Datei</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">WritePreferredCarTypeToFile</span><span class="p">(</span><span class="n">ECarTypes</span><span class="w"> </span><span class="n">InputCarType</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Das enum wird implizit zu einem &quot;uint8_t&quot; konvertiert. Bedingt dadurch, dass</span>
<span class="w">    </span><span class="c1">// es sich um ein &quot;enum&quot; handelt.</span>
<span class="w">	</span><span class="n">WriteByteToFile</span><span class="p">(</span><span class="n">InputCarType</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Nicht immer ist es gewünscht, dass enum´s zu einem Integer oder zu einem anderen</span>
<span class="c1">// enum umgewandelt werden. Daher ist es möglich eine enum-Klasse zu erzeugen, welche</span>
<span class="c1">// nicht implizit umgewandelt wird.</span>
<span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">ECarTypes</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">uint8_t</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Sedan</span><span class="p">,</span><span class="w"> </span><span class="c1">// 0</span>
<span class="w">  </span><span class="n">Hatchback</span><span class="p">,</span><span class="w"> </span><span class="c1">// 1</span>
<span class="w">  </span><span class="n">SUV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">254</span><span class="p">,</span><span class="w"> </span><span class="c1">// 254</span>
<span class="w">  </span><span class="n">Hybrid</span><span class="w"> </span><span class="c1">// 255</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">WriteByteToFile</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">InputValue</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Serialisierung von InputValue in eine Datei</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">WritePreferredCarTypeToFile</span><span class="p">(</span><span class="n">ECarTypes</span><span class="w"> </span><span class="n">InputCarType</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Wird nicht kompilieren, da &quot;ECarTypes&quot; ein &quot;uint8_t&quot; ist, da das enum</span>
<span class="w">  </span><span class="c1">// als &quot;enum class&quot; deklariert wurde!</span>
<span class="w">	</span><span class="n">WriteByteToFile</span><span class="p">(</span><span class="n">InputCarType</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//////////////////////////////////////////</span>
<span class="c1">// Klassen und objekorientierte Programmierung</span>
<span class="c1">//////////////////////////////////////////</span>

<span class="c1">// Erstes Beispiel einer Klasse</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="c1">// Deklaration einer Klasse.</span>
<span class="c1">// Klassen werden üblicherweise im header (.h oder .hpp) deklariert.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Dog</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Member Variablen und Funktionen sind private per default (standard).</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">weight</span><span class="p">;</span>

<span class="c1">// Alle nachfolgenden member sind &quot;public&quot; bis</span>
<span class="c1">// &quot;private:&quot; oder &quot;protected:&quot; auftritt.</span>
<span class="k">public</span><span class="o">:</span>

<span class="w">    </span><span class="c1">// Standard Konstruktor</span>
<span class="w">    </span><span class="n">Dog</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Member-Funktionsdeklaration (Implementierung folgt).</span>
<span class="w">    </span><span class="c1">// Bemerkung: std::string statt der Verwendung von namespace std;</span>
<span class="w">    </span><span class="c1">// &quot;using namespace&quot; sollte niemals in einem header verwendet werden.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">setName</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dogsName</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">setWeight</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">dogsWeight</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Funktionen, die Objekte nicht ändern, sollten mit const deklariert werden.</span>
<span class="w">    </span><span class="c1">// Funktionen müssen explizit als &quot;virtual&quot; deklariert werden, um in einer</span>
<span class="w">    </span><span class="c1">// abgeleiteten Klassen überschrieben zu werden.</span>
<span class="w">    </span><span class="c1">// Aus performance Gründen sind Funktionen nicht per default virtual.</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Funktionen können ebenfalls im class body definiert werden.</span>
<span class="w">    </span><span class="c1">// Derart definierte Funktionen sind automatisch &quot;inline&quot;.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">bark</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; barks!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Neben Konstruktoren, bietet C++ Destruktoren.</span>
<span class="w">    </span><span class="c1">// Diese werden aufgerufen, wenn ein Objekt freigegeben wird oder</span>
<span class="w">    </span><span class="c1">// seinen Wertebereich verlässt.</span>
<span class="w">    </span><span class="c1">// Dies ermöglicht mächtige Paradigmen, wie auch RAII.</span>
<span class="w">    </span><span class="c1">// Destruktoren sollten virtual sein, wenn eine Klasse von ihr</span>
<span class="w">    </span><span class="c1">// abgeleitet wird. Ist dieser nicht virtual, dann wird der</span>
<span class="w">    </span><span class="c1">// Destruktor der abgeleiteten Klasse nicht aufgerufen, insofern</span>
<span class="w">    </span><span class="c1">// das Objekt durch eine Referenz/Pointer der Basisklasse entfernt wird.</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Dog</span><span class="p">();</span>

<span class="p">};</span><span class="w"> </span><span class="c1">// Ein Semikolon schließt die Definition der Klasse ab.  </span>

<span class="c1">// Klassen-Member-Funktionen sind üblicherweise in der .cpp Datei implementiert.</span>
<span class="n">Dog</span><span class="o">::</span><span class="n">Dog</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;A dog has been constructed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Objekte sollten als Referenz übergeben werden und wenn diese nicht</span>
<span class="c1">// verändert werden sollen, sollte das Objekt als const Referenz übergeben werden.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">Dog</span><span class="o">::</span><span class="n">setName</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dogsName</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dogsName</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">Dog</span><span class="o">::</span><span class="n">setWeight</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">dogsWeight</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dogsWeight</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// &quot;Virtual&quot; wird nur bei der Deklaration benötigt und nicht bei der Definition.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">Dog</span><span class="o">::</span><span class="n">print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Dog is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; and weighs &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;kg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Dog</span><span class="o">::~</span><span class="n">Dog</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Goodbye &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Dog</span><span class="w"> </span><span class="n">myDog</span><span class="p">;</span><span class="w"> </span><span class="c1">// Ausgabe: &quot;A dog has been constructed&quot;</span>
<span class="w">    </span><span class="n">myDog</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">&quot;Barkley&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">myDog</span><span class="p">.</span><span class="n">setWeight</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="n">myDog</span><span class="p">.</span><span class="n">print</span><span class="p">();</span><span class="w"> </span><span class="c1">// Ausgabe: &quot;Dog is Barkley and weighs 10 kg&quot;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// Ausgabe: &quot;Goodbye Barkley&quot;</span>

<span class="c1">// Diese Klasse erbt alles was public bzw. protected ist von der Dog-Klasse</span>
<span class="c1">// und darüber hinaus auch private Methoden/Attribute, jedoch kann auf diese</span>
<span class="c1">// nicht direkt zugegriffen werden. Lediglich über public/procted getter/setter.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">OwnedDog</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Dog</span><span class="w"> </span><span class="p">{</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">setOwner</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dogsOwner</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Überschreibt das Verhalten der &quot;print&quot; Funktion für alle &quot;OwnedDogs&quot;.</span>
<span class="w">    </span><span class="c1">// Siehe: http://en.wikipedia.org/wiki/Polymorphism_(computer_science)#Subtyping</span>
<span class="w">    </span><span class="c1">// für eine grundlegende Einführung in &quot;Subtype Polymorphismus&quot;.</span>
<span class="w">    </span><span class="c1">// Das &quot;override&quot; Schlüsselwort ist optional, aber stellt sicher, dass die</span>
<span class="w">    </span><span class="c1">// Methode der Basisklasse tatsächlich überschrieben wurde.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">owner</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Die zugehörige .cpp Datei</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">OwnedDog::setOwner</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dogsOwner</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dogsOwner</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">OwnedDog::print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Dog</span><span class="o">::</span><span class="n">print</span><span class="p">();</span><span class="w"> </span><span class="c1">// Ruft die &quot;print&quot; Funktion der Basisklasse auf.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Dog is owned by &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">owner</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Ausgaben: &quot;Dog is &lt;name&gt; and weights &lt;weight&gt;&quot;</span>
<span class="w">    </span><span class="c1">//           &quot;Dog is owned by &lt;owner&gt;&quot;</span>
<span class="p">}</span>

<span class="c1">//////////////////////////////////////////</span>
<span class="c1">// Initialisierung und Operatorüberladung</span>
<span class="c1">//////////////////////////////////////////</span>

<span class="c1">// In C++ können Operatoren wie: +, -, *, / etc. überladen werden.</span>
<span class="c1">// Dies wird umgesetzt, indem eine entsprechende Funktion definiert wird,</span>
<span class="c1">// welche immer dann aufgerufen wird, sobald der Operator verwendet wird.</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Point</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// Member Variablen können mit einem default Wert initialisiert werden.</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Definition des Standard Konstruktor, welcher nichts tut</span>
<span class="w">    </span><span class="c1">// außer den Punkt auf den default Wert (0,0) zu setzen.</span>
<span class="w">    </span><span class="n">Point</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// Die nachfolgende Syntax ist bekannt als &quot;initialization list&quot;</span>
<span class="w">    </span><span class="c1">// und ist eine gängige Art Klassen-Member zu initialisieren.</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">        </span><span class="n">x</span><span class="p">(</span><span class="n">a</span><span class="p">),</span>
<span class="w">        </span><span class="n">y</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="cm">/* Ausschließliche Initialisierung der Werte */</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Überladung des &quot;+&quot; Operator.</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Überladung des &quot;+=&quot; Operator</span>
<span class="w">    </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Sinnhaft wäre es an dieser Stelle den &quot;-&quot; und &quot;-=&quot; Operator</span>
<span class="w">    </span><span class="c1">// ebenfalls zu überladen.</span>
<span class="p">};</span>

<span class="n">Point</span><span class="w"> </span><span class="n">Point</span><span class="o">::</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Erzeugung eines neuen Punkts, welcher die Summe aus sich</span>
<span class="w">    </span><span class="c1">// selbst und &quot;rhs&quot; bildet</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Point</span><span class="o">::</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="nf">up</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="nf">right</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Ruft den + Operator mit den entsprechenden Parametern auf.</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Ausgabe: &quot;Result is upright (1,1)&quot;</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Result is upright (&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;,&#39;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/////////////////////</span>
<span class="c1">// Templates</span>
<span class="c1">/////////////////////</span>

<span class="c1">// Templates in C++ werden in erster Linie dafür verwendet generisch zu programmieren.</span>
<span class="c1">// Sie unterstützen explizite und partielle Spezialisierung und darüber hinaus können</span>
<span class="c1">// sie für funktionale Klassen verwendet werden.</span>
<span class="c1">// Tatsächlich bilden Templates die Turing-Vollständigkeit</span>
<span class="c1">// (universelle Programmierbarkeit) ab.</span>


<span class="c1">// Zu Beginn ein einführendes Beispiel der generischen Programmierung.</span>
<span class="c1">// Die Definition einer Klasse bzw. Funktion, welche mit dem Typ T parametriert wird.</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Box</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// T repräsentiert an dieser Stelle einen beliebigen Typen.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Während der Kompilierung generiert der Compiler Kopien für jedes Template, wobei</span>
<span class="c1">// hierbei die Parameter substituiert werden. Somit muss bei jedem Aufruf die gesamte</span>
<span class="c1">// Definition der Klasse zur Verfügung stehen. Aus diesem Grund wird ein Template</span>
<span class="c1">// komplett im header definiert.</span>

<span class="c1">// Erzeugung einer Template-Klasse auf dem Stack:</span>
<span class="n">Box</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">intBox</span><span class="p">;</span>

<span class="c1">// eine der zu erwartenden Verwendungen:</span>
<span class="n">intBox</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>

<span class="c1">// Verschachtelungen von Templates sind möglich.</span>
<span class="n">Box</span><span class="o">&lt;</span><span class="n">Box</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">boxOfBox</span><span class="p">;</span>
<span class="n">boxOfBox</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">intBox</span><span class="p">);</span>

<span class="c1">// Bis C++11 war es erforderlich ein Leerzeichen zwischen &#39;&gt;&#39; einzufügen,</span>
<span class="c1">// andernfalls wurde es als &#39;&gt;&gt;&#39; geparsed (right shift).</span>

<span class="c1">// Manchmal ist folgende Notation anzutreffen:</span>
<span class="c1">// template&lt;typename T&gt;</span>
<span class="c1">// Das &#39;class&#39; Schlüsselwort und das &#39;typename&#39; Schlüsselwort</span>
<span class="c1">// sind fast identisch hinsichtlich der Funktionalität. Weitere</span>
<span class="c1">// Informationen auf: http://en.wikipedia.org/wiki/Typename</span>

<span class="c1">// Eine Template-Funktion:</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">barkThreeTimes</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">input</span><span class="p">.</span><span class="n">bark</span><span class="p">();</span>
<span class="w">    </span><span class="n">input</span><span class="p">.</span><span class="n">bark</span><span class="p">();</span>
<span class="w">    </span><span class="n">input</span><span class="p">.</span><span class="n">bark</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Hierbei ist zu beachten, dass an dieser Stelle nichts über den Typen des Parameters</span>
<span class="c1">// definiert wurde. Der Compiler wird bei jedem Aufruf bzw. jeder Erzeugung den Typen</span>
<span class="c1">// prüfen. Somit funktioniert die zuvor definierte Funktion für jeden Typ &#39;T&#39;, die die</span>
<span class="c1">// const Methode &#39;bark&#39; implementiert hat.</span>

<span class="n">Dog</span><span class="w"> </span><span class="n">fluffy</span><span class="p">;</span>
<span class="n">fluffy</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">&quot;Fluffy&quot;</span><span class="p">)</span>
<span class="n">barkThreeTimes</span><span class="p">(</span><span class="n">fluffy</span><span class="p">);</span><span class="w"> </span><span class="c1">// Gibt &quot;Fluffy barks&quot; dreimal aus.</span>

<span class="c1">// Template Parameter müssen keine Klassen sein.</span>
<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">Y</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">printMessage</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Learn C++ in &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; minutes!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Des Weiteren können Templates aus Effizienzgründen genauer spezifiziert werden.</span>
<span class="c1">// Selbstverständlich sind reale Probleme, welche genauer spezifiziert werden, nicht</span>
<span class="c1">// derart trivial. Auch wenn alle Parameter explizit definiert wurden, muss die</span>
<span class="c1">// Funktion oder Klasse als Template deklariert werden.</span>
<span class="k">template</span><span class="o">&lt;&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">printMessage</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Learn C++ faster in only 10 minutes!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">printMessage</span><span class="o">&lt;</span><span class="mi">20</span><span class="o">&gt;</span><span class="p">();</span><span class="w">  </span><span class="c1">// Gibt &quot;Learn C++ in 20 minutes!&quot; aus.</span>
<span class="n">printMessage</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span><span class="p">();</span><span class="w">  </span><span class="c1">// Gibt &quot;Learn C++ faster in only 10 minutes!&quot; aus.</span>


<span class="c1">/////////////////////</span>
<span class="c1">// Ausnahme Behandlungen (Exception-Handling)</span>
<span class="c1">/////////////////////</span>

<span class="c1">// Die Standard Bibliothek bietet einige exceptions.</span>
<span class="c1">// Siehe: http://en.cppreference.com/w/cpp/error/exception.</span>
<span class="c1">// Grundsätzlich können alle Typen als exception geworfen werden.</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exception&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdexcept&gt;</span>

<span class="c1">// Alle exceptions, die in dem &quot;try&quot; Block geworfen werden, können mittels</span>
<span class="c1">// &quot;catch&quot; abgefangen werden.</span>
<span class="k">try</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// exceptions sollten nicht auf dem heap mithilfe</span>
<span class="w">    </span><span class="c1">// von &quot;new&quot; allokiert werden.</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;A problem occurred&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Exceptions sollten als const Referenz abgefangen werden</span>
<span class="c1">// insofern diese Objekte sind.</span>
<span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Abfangen aller Exceptions, welche zuvor nicht abgefangen wurden.</span>
<span class="k">catch</span><span class="w"> </span><span class="p">(...)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Unknown exception caught&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">throw</span><span class="p">;</span><span class="w"> </span><span class="c1">// Erneutes werfen der exception</span>
<span class="p">}</span>

<span class="c1">///////</span>
<span class="c1">// RAII</span>
<span class="c1">///////</span>

<span class="c1">// RAII steht für &quot;Resource Acquisition Is Initialization&quot;.</span>
<span class="c1">// Oft wird dies als eines der wichtigsten Paradigmen in C++ betrachtet.</span>
<span class="c1">// RAII beschreibt das Konzept, dass der Konstruktor für ein Objekt</span>
<span class="c1">// die Ressourcen akquiriert und der Destruktor diese freigibt.</span>

<span class="c1">// Zum Verständnis, warum dies sinnvoll ist, nachfolgend</span>
<span class="c1">// ein einführendes Beispiel:</span>
<span class="kt">void</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Wir nehmen an, dass nichts schiefgehen wird.</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Öffnen der Datei im read-mode.</span>

<span class="w">    </span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Schließen des file-handle.</span>
<span class="p">}</span>

<span class="c1">// Unglücklicherweise ist die Fehlerbehandlung äußerst kompliziert.</span>
<span class="c1">// Sollte fopen fehlschlagen und &quot;doSomethingWithTheFile&quot; bzw.</span>
<span class="c1">// &quot;doSomethingElseWithIt&quot;, geben diese einen Fehlercode zurück.</span>
<span class="c1">// (Exceptions sind eine bevorzugte Möglichkeit Fehler abzufangen</span>
<span class="c1">// , allerdings bei einigen Programmierern, besonders solchen die einen C</span>
<span class="c1">// background besitzen, ein unbeliebtes Mittel zur Fehlerbehandlung).</span>
<span class="c1">// Nun müssen wir jeden Aufruf auf mögliche auftretende Fehler überprüfen.</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Öffnet die Datei im read-mode</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fh</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="c1">// Der Pointer ist bei einem Fehler NULL .</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Benachrichtigt den Aufrufer über den Fehler.</span>

<span class="w">    </span><span class="c1">// Wir nehmen an, dass jede Funktion false zurückgibt, in einem Fehlerfall</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// File handle schließen.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Fehler &quot;melden&quot;.</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// File handle schließen.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Fehler &quot;melden&quot;.</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// File handle schließen.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// Erfolg &quot;melden&quot;.</span>
<span class="p">}</span>

<span class="c1">// C-Programmierer handhaben dies häufig durch goto-Anweisungen:</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fh</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">failure</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">failure</span><span class="p">;</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// File handle schließen.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// Erfolg &quot;melden&quot;.</span>

<span class="nl">failure</span><span class="p">:</span>
<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Fehler &quot;melden&quot;.</span>
<span class="p">}</span>

<span class="c1">// Insofern Funktionen Fehler durch exceptions indizieren,</span>
<span class="c1">// ist dies &quot;sauberer&quot;, aber immer noch suboptimal.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Öffnet die Datei im read-mode</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fh</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Could not open the file.&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">try</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">        </span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">catch</span><span class="w"> </span><span class="p">(...)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Im Fehlerfall sollte sichergestellt sein, dass die</span>
<span class="w">        </span><span class="c1">// Datei geschlossen wird.</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">        </span><span class="k">throw</span><span class="p">;</span><span class="w"> </span><span class="c1">// Erneutes werfen der exception</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Schließen der Datei</span>
<span class="p">}</span>

<span class="c1">// Folgendes ist mit der C++ file stream Klasse (fstream) zu vergleichen.</span>
<span class="c1">// fstream verwendet den Destruktor, um die Datei zu schließen.</span>
<span class="c1">// Der obige Destruktor wird automatisch aufgerufen, sobald das Objekt</span>
<span class="c1">// den Gültigkeitsbereich verlässt.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// ifstream entspricht der Kurzform von &quot;input file stream&quot;.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span><span class="w"> </span><span class="nf">fh</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span><span class="w"> </span><span class="c1">// Öffnen der Datei</span>

<span class="w">    </span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// Die Datei wird automatisch vom Destruktor geschlossen.</span>

<span class="c1">// Diese Vorgehensweise bietet massive Vorteile:</span>
<span class="c1">// 1. Egal was passiert, die Ressource (das Datei-Handle) wird aufgelöst,</span>
<span class="c1">//    insofern der Destruktor korrekt beschrieben wurde. Es ist möglich</span>
<span class="c1">//    zu vergessen das Datei-Handle zu schließen, was zu einem &quot;leak&quot; der</span>
<span class="c1">//    entsprechenden Ressource führt.</span>
<span class="c1">// 2. Der Code selbst ist wesentlich &quot;sauberer&quot;.</span>
<span class="c1">//    Der Destruktor wird das Datei-Handle im Hintergrund schließen und der</span>
<span class="c1">//    Programmierer muss sich darum keinerlei Sorgen machen.</span>
<span class="c1">// 3. Der Code ist &quot;exception sicher&quot;.</span>
<span class="c1">//    Egal wo die exception geworfen wird, das Aufräumen wird definitiv vollzogen.</span>

<span class="c1">// Der gesamte idiomatische C++ Code verwendet RAII für alle Ressourcen.</span>
<span class="c1">// Weitere Beispiele:</span>
<span class="c1">// - Speicher verwenden &quot;unique_ptr&quot; und &quot;shared_ptr&quot;.</span>
<span class="c1">// - Container - verkettete Listen (linked list), vector (selbst organisierende</span>
<span class="c1">//   Arrays), hash maps, etc., entfernen deren Inhalt, wenn diese außerhalb des</span>
<span class="c1">//   Gültigkeitsbereichs laufen.</span>
<span class="c1">// - Mutex´s verwenden lock_guard und unique_lock.</span>

<span class="c1">/////////////////////</span>
<span class="c1">// Container</span>
<span class="c1">/////////////////////</span>

<span class="c1">// Die Container der Standard template Bibliothek beinhaltet einige vordefinierte Templates.</span>
<span class="c1">// Diese verwalten die Speicherbereiche für die eigenen Elemente und stellen Member-Funktionen</span>
<span class="c1">// für den Zugriff und die Manipulation bereit.</span>

<span class="c1">// Beispielhafte Container:</span>

<span class="c1">// Vector (dynamisches array)</span>
<span class="c1">// Erlaubt das Definieren von Arrays oder Listen zur Laufzeit</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<span class="n">string</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">my_vector</span><span class="p">;</span><span class="w"> </span><span class="c1">// Initialisierung des Vectors.</span>
<span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="n">my_vector</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">val</span><span class="p">);</span><span class="w"> </span><span class="c1">// Fügt den Wert &quot;val&quot; zum Vektor &quot;my_vector&quot; hinzu.</span>
<span class="n">my_vector</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">val</span><span class="p">);</span><span class="w"> </span><span class="c1">// Fügt den Wert &quot;val&quot; zum Vektor &quot;my_vector&quot; hinzu (nun zwei Elemente).</span>

<span class="c1">// Für die Iteration über Vektoren stehen zwei Methodiken zu Verfügung:</span>
<span class="c1">// Entweder die klassische Iteration über den Index:</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">my_vector</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">	</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">my_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Zugriff auf die Elemente des Vektors über den [] Operator</span>
<span class="p">}</span>

<span class="c1">// Oder die Verwendung von Iteratoren:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="p">;</span><span class="w"> </span><span class="c1">// Initialisierung des Iterators.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_vector</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">my_vector</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">	</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="w">  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Set (Mengen)</span>
<span class="c1">// Sets sind Container, welche einzigartige Elemente beinhalten die einer</span>
<span class="c1">// spezifischen Ordnung folgen.</span>

<span class="cp">#include</span><span class="cpf">&lt;set&gt;</span>
<span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ST</span><span class="p">;</span><span class="w">    </span><span class="c1">// Initialisierung des Sets mit einem Integer Datentyp.</span>
<span class="n">ST</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span><span class="w">  </span><span class="c1">// Einfügen des Werts 30 in das Set ST</span>
<span class="n">ST</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w">  </span><span class="c1">// Einfügen des Werts 10 in das Set ST</span>
<span class="n">ST</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w">  </span><span class="c1">// Einfügen des Werts 20 in das Set ST</span>
<span class="n">ST</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span><span class="w">  </span><span class="c1">// Einfügen des Werts 30 in das Set ST</span>
<span class="c1">// Folgende Elemente befinden sich nun in dem Set:</span>
<span class="c1">//  10 20 30</span>

<span class="c1">// Entfernen eines Elements:</span>
<span class="n">ST</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>

<span class="c1">// Set ST: 10 30</span>
<span class="c1">// Für das iterieren verwenden wir Iteratoren:</span>
<span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="p">;</span>

<span class="k">for</span><span class="p">(</span><span class="n">it</span><span class="o">=</span><span class="n">ST</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="n">it</span><span class="o">&lt;</span><span class="n">ST</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="n">it</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">	</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Ausgabe:</span>
<span class="c1">// 10</span>
<span class="c1">// 30</span>

<span class="c1">// Zum leeren des gesamten Containers wird die Methode</span>
<span class="c1">// Container._name.clear() verwendet.</span>
<span class="n">ST</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ST</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w">  </span><span class="c1">// Ausgabe der Set-Größe</span>

<span class="c1">// Ausgabe: 0</span>

<span class="c1">// Bemerkung: für mehrdeutige Elemente werden multisets verwendet.</span>
<span class="c1">// Für hash-Sets sollten unordered_set´s verwendet werden, da diese</span>
<span class="c1">// wesentlich effizienter sind, allerdings keiner Ordnung folgen.</span>
<span class="c1">// Verfügbar sind diese Features ab C++11.</span>

<span class="c1">// Map</span>
<span class="c1">// Maps speichern Elemente, welche einer Kombination aus &quot;Key&quot;</span>
<span class="c1">// und &quot;Value&quot; folgen.</span>

<span class="cp">#include</span><span class="cpf">&lt;map&gt;</span>
<span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mymap</span><span class="p">;</span><span class="w">  </span><span class="c1">// Initialisierung der Map: char -&gt; Key, int -&gt; Value.</span>

<span class="n">mymap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="sc">&#39;A&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span><span class="w"> </span><span class="c1">// Einfügen des Werts &quot;1&quot; für den Key &quot;A&quot;.</span>

<span class="n">mymap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="sc">&#39;Z&#39;</span><span class="p">,</span><span class="mi">26</span><span class="p">));</span><span class="w"> </span><span class="c1">// Einfügen des Werts &quot;26&quot; für den Key &quot;Z&quot;.</span>

<span class="c1">// Das Iterieren über Maps:</span>
<span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">it</span><span class="o">=</span><span class="n">mymap</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="o">!=</span><span class="n">mymap</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;-&gt;&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>

<span class="c1">// Ausgabe:</span>
<span class="c1">// A-&gt;1</span>
<span class="c1">// Z-&gt;26</span>

<span class="c1">// Für das Finden des dazugehörigen Value des Keys.</span>
<span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mymap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39;Z&#39;</span><span class="p">);</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>

<span class="c1">// Ausgabe: 26</span>

<span class="c1">// Bemerkung: für &quot;hash maps&quot; sollten die &quot;unordered_map´s&quot; verwendet werden. Diese</span>
<span class="c1">// sind effizienter und benötigen keine Reihenfolge. &quot;unordered_maps&quot; sind ab</span>
<span class="c1">// C++11 verfügbar.</span>

<span class="c1">// Container für nicht-primitive Datentypen benötigen Vergleichsfunktionen im Objekt selbst,</span>
<span class="c1">// oder als Funktionspointer. Primitive Datentypen besitzen default-Vergleichsfunktionen.</span>
<span class="c1">// Allerdings können diese überschrieben werden.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Foo</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">    </span><span class="n">Foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">j</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">compareFunction</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">Foo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Foo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">j</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Folgender Code ist nicht valide, könnte aber von einigen Compilern</span>
<span class="c1">// als valide angesehen werden:</span>
<span class="c1">// std::map&lt;Foo, int&gt; fooMap;</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">compareFunction</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fooMap</span><span class="p">;</span>
<span class="n">fooMap</span><span class="p">[</span><span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">fooMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w"> </span><span class="c1">// Wahr</span>


<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Lambda Ausdrücke (C++11 und höher)</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// Lambdas sind eine gängige Methodik, um anonyme Funktionen an dem</span>
<span class="c1">// Ort der Verwendung zu definieren. Darüber hinaus auch bei der</span>
<span class="c1">// Verwendung von Funktionen als Argument einer Funktion.</span>

<span class="c1">// Nehmen wir an, es soll ein Vektor von &quot;pairs&quot; (Paaren) mithilfe</span>
<span class="c1">// des zweiten Werts des &quot;pairs&quot; sortiert werden.</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">tester</span><span class="p">;</span>
<span class="n">tester</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">));</span>
<span class="n">tester</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">));</span>
<span class="n">tester</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span>

<span class="c1">// Übergabe des Lambda-Ausdrucks als drittes Argument für die nachfolgende Sortierfunktion.</span>
<span class="n">sort</span><span class="p">(</span><span class="n">tester</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">tester</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">lhs</span><span class="p">.</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<span class="p">});</span>

<span class="c1">// Beachte die Syntax von Lambda-Ausdrücken.</span>
<span class="c1">// Die [] im Lambda Ausdruck werden für die Variablen verwendet.</span>
<span class="c1">// Diese so genannte &quot;capture list&quot; definiert, was außerhalb des Lambdas,</span>
<span class="c1">// innerhalb der Funktion verfügbar sein soll und in welcher Form.</span>
<span class="c1">// Dies kann folgendes sein:</span>
<span class="c1">//     1. ein Wert [x]</span>
<span class="c1">//     2. eine Referenz [&amp;x]</span>
<span class="c1">//     3. eine beliebige Variable, welche sich im Gültigkeitsbereich durch</span>
<span class="c1">//        die Referenz [&amp;] befindet.</span>
<span class="c1">//     4. wie bei 3. aber mithilfe des Werts [=]</span>
<span class="c1">// Beispiel:</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dog_ids</span><span class="p">;</span>

<span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">	</span><span class="n">dog_ids</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">weight</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">30</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">};</span>

<span class="c1">// Nehmen wir an wir möchten die &quot;dog_ids&quot; gemäß des Gewichts des Hundes sortieren.</span>
<span class="c1">// So sollten sich die &quot;dog_ids&quot; wie folgt verhalten: [2, 0, 1]</span>

<span class="c1">// Hier werden Lambdas praktisch:</span>
<span class="n">sort</span><span class="p">(</span><span class="n">dog_ids</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">dog_ids</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">weight</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">weight</span><span class="p">[</span><span class="n">lhs</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">weight</span><span class="p">[</span><span class="n">rhs</span><span class="p">];</span>
<span class="p">});</span>


<span class="c1">// Weiterführender Link über Lambda-Ausdrücke:</span>
<span class="c1">// http://stackoverflow.com/questions/7627098/what-is-a-lambda-expression-in-c11</span>

<span class="c1">///////////////////////////////</span>
<span class="c1">// Range For (C++11 und höher)</span>
<span class="c1">///////////////////////////////</span>

<span class="c1">// Range-For Schleifen können verwendet werden, um über Container zu iterieren.</span>
<span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span>

<span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">elem</span><span class="o">:</span><span class="w"> </span><span class="n">arr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">	</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Insofern &quot;auto&quot; verwendet wird, muss der Typ nicht weiter beachtet werden.</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">elem</span><span class="o">:</span><span class="w"> </span><span class="n">arr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">	</span><span class="c1">// Anweisungen ...</span>
<span class="p">}</span>

<span class="c1">/////////////////////</span>
<span class="c1">// Weiteres:</span>
<span class="c1">/////////////////////</span>

<span class="c1">// Einige Aspekte von C++ sind für Neueinsteiger häufig überraschend (aber auch für</span>
<span class="c1">// C++ Veteranen).</span>
<span class="c1">// Der nachfolgende Abschnitt ist leider nicht vollständig:</span>
<span class="c1">// C++ ist eine der Sprachen, bei der es ein Leichtes ist, sich selbst ins Bein zu schießen.</span>

<span class="c1">// Private-Methoden können überschrieben werden</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Foo</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">FooSub</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">();</span><span class="w">  </span><span class="c1">// Überschreibt Foo::bar!</span>
<span class="p">};</span>

<span class="c1">// 0 == false == NULL</span>
<span class="kt">bool</span><span class="o">*</span><span class="w"> </span><span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">bool</span><span class="p">;</span>
<span class="o">*</span><span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// Setzt den Wert des Pointers &#39;pt&#39; auf false.</span>
<span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// Setzt &#39;pt&#39; auf den &quot;null-pointer&quot;. Keine Compiler-Warnung.</span>

<span class="c1">// nullptr sollte dieses Problem nicht lösen:</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">pt2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>
<span class="o">*</span><span class="n">pt2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"> </span><span class="c1">// Kompiliert nicht.</span>
<span class="n">pt2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w">  </span><span class="c1">// Setzt pt2 auf null.</span>

<span class="c1">// Eine Ausnahme bilden bool´s.</span>
<span class="c1">// Dies erlaubt es &quot;null-pointer&quot; zu testen: if(!ptr)</span>
<span class="c1">// Die Konsequenz ist jedoch, dass dem nullptr ein bool zugewiesen werden kann.</span>
<span class="o">*</span><span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w">  </span><span class="c1">// Kompiliert auch, wenn &#39;*pt&#39; ein bool ist!</span>

<span class="c1">// &#39;=&#39; != &#39;=&#39; != &#39;=&#39;!</span>
<span class="c1">// Ruft Foo::Foo(const Foo&amp;) auf, oder den Kopierkonstruktor</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span>

<span class="c1">// Ruft Foo::Foo(const Foo&amp;) auf, aber kopiert lediglich den &quot;Foo&quot; Teil von</span>
<span class="c1">// &quot;fooSub&quot;. Alle zusätzlichen Member werden verworfen. Diese eigenartige Verhalten</span>
<span class="c1">// wird auch &quot;object slicing&quot; genannt.</span>
<span class="n">FooSub</span><span class="w"> </span><span class="n">fooSub</span><span class="p">;</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fooSub</span><span class="p">;</span>

<span class="c1">// Ruft Foo::operator=(Foo&amp;) oder eine andere Variante auf.</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f1</span><span class="p">;</span>
<span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Tuple (C++11 und höher)</span>
<span class="c1">///////////////////////////////////////</span>

<span class="cp">#include</span><span class="cpf">&lt;tuple&gt;</span>

<span class="c1">// Konzeptionell sind Tupel alten Datenstrukturen sehr ähnlich, allerdings haben diese keine</span>
<span class="c1">// bezeichneten Daten-Member, sondern werden durch die Reihenfolge angesprochen.</span>

<span class="c1">// Erstellen des Tupels und das Einfügen eines Werts.</span>
<span class="k">auto</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;A&#39;</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maxN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1e9</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maxL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">15</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_tuple</span><span class="p">(</span><span class="n">maxN</span><span class="p">,</span><span class="w"> </span><span class="n">maxL</span><span class="p">);</span>

<span class="c1">// Ausgabe der Elemente des &quot;first&quot; Tuple.</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">first</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">first</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Ausgabe : 10 A</span>

<span class="c1">// Ausgabe der Elemente des &quot;second&quot; Tuple.</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">second</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">second</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Ausgabe: 1000000000 15</span>

<span class="kt">int</span><span class="w"> </span><span class="n">first_int</span><span class="p">;</span>
<span class="kt">char</span><span class="w"> </span><span class="n">first_char</span><span class="p">;</span>
<span class="n">tie</span><span class="p">(</span><span class="n">first_int</span><span class="p">,</span><span class="w"> </span><span class="n">first_char</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first</span><span class="p">;</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">first_int</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">first_char</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w">  </span><span class="c1">// Ausgabe : 10 A</span>

<span class="c1">// Tuple können auch wie folgt erzeugt werden:</span>

<span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">third</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;A&#39;</span><span class="p">,</span><span class="w"> </span><span class="mf">3.14141</span><span class="p">);</span>
<span class="c1">// tuple_size  gibt die Anzahl der Elemente in einem Tuple zurück.</span>
<span class="c1">// Als &quot;constexpr&quot;.</span>

<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">tuple_size</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">third</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// prints: 3</span>

<span class="c1">// tuple_cat fügt die Elemente eines Tupels aneinander (in der selben Reihenfolge).</span>

<span class="k">auto</span><span class="w"> </span><span class="n">concatenated_tuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tuple_cat</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">second</span><span class="p">,</span><span class="w"> </span><span class="n">third</span><span class="p">);</span>
<span class="c1">// concatenated_tuple wird zu = (10, &#39;A&#39;, 1e9, 15, 11, &#39;A&#39;, 3.14141)</span>

<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">concatenated_tuple</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Ausgabe: 10</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">concatenated_tuple</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Ausgabe: 15</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">&gt;</span><span class="p">(</span><span class="n">concatenated_tuple</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Ausgabe: &#39;A&#39;</span>


<span class="c1">///////////////////////////////////</span>
<span class="c1">// Logische- und Bitoperatoren</span>
<span class="c1">//////////////////////////////////</span>

<span class="c1">// Die meisten Operatoren in C++ entsprechen denen aus anderen Sprachen</span>

<span class="c1">// Logische Operatoren.</span>
<span class="c1">// C++ verwendet so genannte &quot;Short-circuit&quot; Evaluierung für Boolean-Ausdrücke.</span>
<span class="c1">// Das zweite Argument wird ausgeführt bzw. evaluiert, wenn das erste Argument genügt,</span>
<span class="c1">// um den Ausdruck zu bestimmen.</span>

<span class="nb">true</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="c1">// Führt **logisches und** aus.</span>
<span class="nb">true</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="c1">// Führt **logisches oder** aus.</span>
<span class="o">!</span><span class="w"> </span><span class="nb">true</span><span class="w">        </span><span class="c1">// Führt **logisches nicht** aus.</span>

<span class="c1">// Anstelle von Symbolen können auch Schlüsselwörter verwendet werden.</span>
<span class="nb">true</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="c1">// Führt **logisches und** aus.</span>
<span class="nb">true</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="nb">false</span><span class="w">  </span><span class="c1">// Führt **logisches oder** aus.</span>
<span class="k">not</span><span class="w"> </span><span class="nb">true</span><span class="w">       </span><span class="c1">// Führt **logisches nicht** aus.</span>

<span class="c1">// Bitoperationen</span>

<span class="c1">// **&lt;&lt;** Links-Shift</span>
<span class="c1">// **&gt;&gt;** Rechts-Shift</span>

<span class="o">~</span><span class="mi">4</span><span class="w">    </span><span class="c1">// Führt bitweises nicht aus.</span>
<span class="mi">4</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">// Führt bitweises oder aus.</span>
<span class="mi">4</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">// Führt bitweises und aus.</span>
<span class="mi">4</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">// Führt bitweises xor aus.</span>

<span class="c1">// Gleichwertige Schlüsselwörter:</span>
<span class="k">compl</span><span class="w"> </span><span class="mi">4</span><span class="w">    </span><span class="c1">// Führt bitweises nicht aus.</span>
<span class="mi">4</span><span class="w"> </span><span class="k">bitor</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="c1">// Führt bitweises oder aus.</span>
<span class="mi">4</span><span class="w"> </span><span class="k">bitand</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">// Führt bitweises und aus.</span>
<span class="mi">4</span><span class="w"> </span><span class="k">xor</span><span class="w"> </span><span class="mi">3</span><span class="w">    </span><span class="c1">// Führt bitweises xor aus.</span>
</pre></div>
<p>Weiterführende Literatur:</p>
<ul>
<li>Aktuelle Sprachen-Referenz <a href="http://cppreference.com/w/cpp">CPP Reference</a>.</li>
<li>Zusätzliches: <a href="http://cplusplus.com">CPlusPlus</a>.</li>
<li>Grundlagen Tutorial: <a href="https://www.youtube.com/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb">TheChernoProject - C++</a>.</li>
</ul>

        <hr>
        <p>
          Du hast einen Verbesserungsvorschlag oder einen Fehler gefunden? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Erstelle ein Ticket</a> im offiziellen GitHub Repo, oder du erstellst einfach gleich einen <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/de/c++.md">pull request</a>!
        </p>
        <p class="contributed">
          Originalversion von Steven Basart, mit Updates von <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/de/c++.md">5 contributors</a>.
        </p>

        <footer>
          <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width: 0; width: 80px; height: 28px; padding-bottom: 5px;" src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-sa.svg" /></a>
          <p>
            &copy; 2025
            <a href="http://github.com/xksteven">Steven Basart</a>,
            <a href="https://github.com/mrkline">Matt Kline</a>,
            <a href="http://geoffliu.me">Geoff Liu</a>,
            <a href="http://github.com/connorwaters">Connor Waters</a>,
            <a href="http://github.com/ankushg07">Ankush Goyal</a>,
            <a href="https://github.com/jatindhankhar">Jatin Dhankhar</a>,
            <a href="https://github.com/LamdaLamdaLamda">Maximilian Sonnenburg</a>,
            <a href="https://github.com/caminsha">caminsha</a>
          </p>
        </footer>
      </div>

      <script>
        document.addEventListener('DOMContentLoaded', () => {
          const langSelect = document.getElementById('lang-select');
          langSelect?.addEventListener('change', () => {
            const selectedOption = langSelect.options[langSelect.selectedIndex];
            const url = selectedOption?.getAttribute('data-url');
            if (url) {
              window.location.href = url;
            }
          });
        });
      </script>
    </div>
  </body>
</html>