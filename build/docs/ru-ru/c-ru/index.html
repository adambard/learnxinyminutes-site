<!DOCTYPE html lang="ru-ru" xml:lang="ru-ru" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="ru-ru">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn C in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/ru-ru/c-ru/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fru-ru%2Fc-ru%2F&text=%D0%98%D0%B7%D1%83%D1%87%D0%B8%D1%82%D0%B5+X+%D0%B7%D0%B0+Y+%D0%BC%D0%B8%D0%BD%D1%83%D1%82%2C+%D0%B3%D0%B4%D0%B5+X%3DC">
        Поделиться страницей
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Выберите тему:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">светлая</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">тёмная</button>
  </div>
  <h1><a href="/">Изучите X за Y минут</a></h1>
  <h2>Где X=C</h2>
    <p class="filelink">
    Получить исходный код:
    <a href="/docs/files/learnc-ru.c">learnc-ru.c</a>
    </p>
  <div id="doc">
    <p>Что ж, Си всё ещё является лидером среди современных высокопроизводительных языков.</p>

<p>Для большинства программистов, Си – это самый низкоуровневый язык на котором они когда-либо писали,
но этот язык даёт больше, чем просто повышение производительности.
Держите это руководство в памяти и вы сможете использовать Си максимально эффективно.</p>
<div class="highlight"><pre class="highlight c"><code><span class="c1">// Однострочный комментарий начинается с // - доступен только после С99.</span>

<span class="cm">/*
Многострочный комментарий выглядит так. Работает начиная с С89.
*/</span>

<span class="c1">// Импорт файлов происходит с помощью **#include**</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="c1">// Файлы &lt;в угловых скобочках&gt; будут подключаться из стандартной библиотеки.</span>
<span class="c1">// Свои файлы необходимо подключать с помощью "двойных кавычек".</span>
<span class="cp">#include</span> <span class="cpf">"my_header.h"</span><span class="cp">
</span>
<span class="c1">// Объявление функций должно происходить в .h файлах или вверху .c файла.</span>
<span class="kt">void</span> <span class="nf">function_1</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">function_2</span><span class="p">();</span>

<span class="c1">// Точка входа в программу – это функция main.</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// для форматированного вывода в консоль используется printf</span>
    <span class="c1">// %d – означает, что будем выводить целое число, \n переводит указатель вывода</span>
    <span class="c1">// на новую строчку</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// =&gt; напечатает "0"</span>
    <span class="c1">// Каждый оператор заканчивается точкой с запятой.</span>

    <span class="c1">///////////////////////////////////////</span>
    <span class="c1">// Типы</span>
    <span class="c1">///////////////////////////////////////</span>

    <span class="c1">// int обычно имеет длину 4 байта</span>
    <span class="kt">int</span> <span class="n">x_int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// short обычно имеет длину 2 байта</span>
    <span class="kt">short</span> <span class="n">x_short</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// char гарантированно имеет длину 1 байта</span>
    <span class="kt">char</span> <span class="n">x_char</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">y_char</span> <span class="o">=</span> <span class="sc">'y'</span><span class="p">;</span> <span class="c1">// Символьные литералы заключаются в кавычки ''</span>

    <span class="c1">// long как правило занимает от 4 до 8 байт</span>
    <span class="c1">// long long занимает как минимум 64 бита</span>
    <span class="kt">long</span> <span class="n">x_long</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">x_long_long</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 

    <span class="c1">// float это 32-битное число с плавающей точкой</span>
    <span class="kt">float</span> <span class="n">x_float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

    <span class="c1">// double это 64-битное число с плавающей точкой</span>
    <span class="kt">double</span> <span class="n">x_double</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

    <span class="c1">// Целые типы могут быть беззнаковыми.</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ux_short</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ux_int</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ux_long_long</span><span class="p">;</span>

    <span class="c1">// sizeof(T) возвращает размер переменной типа Т в байтах.</span>
    <span class="c1">// sizeof(obj) возвращает размер объекта obj в байтах.</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span> <span class="c1">// =&gt; 4 (на большинстве машин int занимает 4 байта)</span>

    <span class="c1">// Если аргументом sizeof будет выражение, то этот аргумент вычисляется</span>
    <span class="c1">// ещё во время компиляции кода (кроме динамических массивов).</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="c1">// size_t это беззнаковый целый тип который использует как минимум 2 байта</span>
    <span class="c1">// для записи размера объекта</span>
    <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="o">++</span><span class="p">);</span> <span class="c1">// a++ не выполнится</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"sizeof(a++) = %zu, где a = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="c1">// выведет строку "sizeof(a++) = 4, где a = 1" (на 32-битной архитектуре)</span>

    <span class="c1">// Можно задать размер массива при объявлении.</span>
    <span class="kt">char</span> <span class="n">my_char_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span> <span class="c1">// Этот массив занимает 1 * 20 = 20 байт</span>
    <span class="kt">int</span> <span class="n">my_int_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span> <span class="c1">// Этот массив занимает 4 * 20 = 80 байт (сумма 4-битных слов)</span>

    <span class="c1">// Можно обнулить массив при объявлении.</span>
    <span class="kt">char</span> <span class="n">my_array</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

    <span class="c1">// Индексация массива происходит также как и в других Си-подобных языках.</span>
    <span class="n">my_array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// =&gt; 0</span>

    <span class="c1">// Массивы изменяемы. Это просто память как и другие переменные.</span>
    <span class="n">my_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">my_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// =&gt; 2</span>

    <span class="c1">// В C99 (а также опционально в C11), массив может быть объявлен динамически.</span>
    <span class="c1">// Размер массива не обязательно должен быть рассчитан на этапе компиляции.</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Enter the array size: "</span><span class="p">);</span> <span class="c1">// спрашиваем юзера размер массива</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mh">0x100</span><span class="p">];</span>
    <span class="n">fgets</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">buf</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
    <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span> <span class="c1">// strtoul парсит строку в беззнаковое целое</span>
    <span class="kt">int</span> <span class="n">var_length_array</span><span class="p">[</span><span class="n">size</span><span class="p">];</span> <span class="c1">// объявление динамического массива</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"sizeof array = %zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">var_length_array</span><span class="p">);</span>
    <span class="c1">// Вывод программы (в зависимости от архитектуры) будет таким:</span>
    <span class="c1">// &gt; Enter the array size: 10</span>
    <span class="c1">// &gt; sizeof array = 40</span>

    <span class="c1">// Строка – это просто массив символов, оканчивающийся нулевым (NUL (0x00)) байтом</span>
    <span class="c1">// представляемым в строке специальным символом '\0'.</span>
    <span class="c1">// Нам не нужно вставлять нулевой байт в строковой литерал,</span>
    <span class="c1">// компилятор всё сделает за нас.</span>
    <span class="kt">char</span> <span class="n">a_string</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="s">"This is a string"</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a_string</span><span class="p">);</span> <span class="c1">// %s обозначает вывод строки</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a_string</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span> <span class="c1">// =&gt; 0</span>
    <span class="c1">// байт #17 тоже равен 0 (а также 18, 19, и 20)</span>

    <span class="c1">// Если между одинарными кавычками есть символ – это символьный литерал,</span>
    <span class="c1">// но это тип int, а не char (по историческим причинам).</span>

    <span class="kt">int</span> <span class="n">cha</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span> <span class="c1">// хорошо</span>
    <span class="kt">char</span> <span class="n">chb</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span> <span class="c1">// тоже хорошо (подразумевается преобразование int в char)</span>

    <span class="c1">///////////////////////////////////////</span>
    <span class="c1">// Операторы</span>
    <span class="c1">///////////////////////////////////////</span>

    <span class="c1">// Можно использовать множественное объявление.</span>
    <span class="kt">int</span> <span class="n">i1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">f1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">f2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

    <span class="c1">// Арифметика обычная</span>
    <span class="n">i1</span> <span class="o">+</span> <span class="n">i2</span><span class="p">;</span> <span class="c1">// =&gt; 3</span>
    <span class="n">i2</span> <span class="o">-</span> <span class="n">i1</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>
    <span class="n">i2</span> <span class="o">*</span> <span class="n">i1</span><span class="p">;</span> <span class="c1">// =&gt; 2</span>
    <span class="n">i1</span> <span class="o">/</span> <span class="n">i2</span><span class="p">;</span> <span class="c1">// =&gt; 0 (0.5, но обрезается до 0)</span>

    <span class="n">f1</span> <span class="o">/</span> <span class="n">f2</span><span class="p">;</span> <span class="c1">// =&gt; 0.5, плюс-минус погрешность потому что,</span>
    <span class="c1">// цифры с плавающей точкой вычисляются неточно!</span>

    <span class="c1">// Остаток от деления</span>
    <span class="mi">11</span> <span class="o">%</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// =&gt; 2</span>

    <span class="c1">// Операции сравнения вам уже знакомы, но в Си нет булевого типа.</span>
    <span class="c1">// Вместо него используется int. 0 это false, всё остальное это true.</span>
    <span class="c1">// Операции сравнения всегда возвращают 1 или 0.</span>
    <span class="mi">3</span> <span class="o">==</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 0 (false)</span>
    <span class="mi">3</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 1 (true)</span>
    <span class="mi">3</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>
    <span class="mi">3</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 0</span>
    <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>
    <span class="mi">2</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>

    <span class="c1">// Си это не Питон – операции сравнения могут быть только парными.</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="c1">// ОШИБКА:</span>
    <span class="kt">int</span> <span class="n">between_0_and_2</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span>
    <span class="c1">// Правильно:</span>
    <span class="kt">int</span> <span class="n">between_0_and_2</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span>

    <span class="c1">// Логика </span>
    <span class="o">!</span><span class="mi">3</span><span class="p">;</span> <span class="c1">// =&gt; 0 (логическое НЕ)</span>
    <span class="o">!</span><span class="mi">0</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>
    <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 1 (логическое И)</span>
    <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 0</span>
    <span class="mi">0</span> <span class="o">||</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 1 (логическое ИЛИ)</span>
    <span class="mi">0</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// =&gt; 0</span>

    <span class="c1">// Битовые операторы</span>
    <span class="o">~</span><span class="mh">0x0F</span><span class="p">;</span> <span class="c1">// =&gt; 0xF0 (побитовое отрицание)</span>
    <span class="mh">0x0F</span> <span class="o">&amp;</span> <span class="mh">0xF0</span><span class="p">;</span> <span class="c1">// =&gt; 0x00 (побитовое И)</span>
    <span class="mh">0x0F</span> <span class="o">|</span> <span class="mh">0xF0</span><span class="p">;</span> <span class="c1">// =&gt; 0xFF (побитовое ИЛИ)</span>
    <span class="mh">0x04</span> <span class="o">^</span> <span class="mh">0x0F</span><span class="p">;</span> <span class="c1">// =&gt; 0x0B (исключающее ИЛИ (XOR))</span>
    <span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 0x02 (побитовый сдвиг влево (на 1))</span>
    <span class="mh">0x02</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 0x01 (побитовый сдвиг вправо (на 1))</span>

    <span class="c1">// Будьте осторожны при сдвиге беззнакового int, эти операции не определены:</span>
    <span class="c1">// - сдвиг в знаковый бит у целого числа (int a = 1 &lt;&lt; 32)</span>
    <span class="c1">// - сдвиг влево отрицательных чисел (int a = -1 &lt;&lt; 2)</span>

    <span class="c1">///////////////////////////////////////</span>
    <span class="c1">// Структуры ветвления</span>
    <span class="c1">///////////////////////////////////////</span>

    <span class="c1">// Условный оператор</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"I am never run</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"I am also never run</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"I print</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Цикл с предусловием</span>
    <span class="kt">int</span> <span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">ii</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d, "</span><span class="p">,</span> <span class="n">ii</span><span class="o">++</span><span class="p">);</span> <span class="c1">// инкрементация происходит после того как</span>
                              <span class="c1">// значение ii передано ("postincrement")</span>
    <span class="p">}</span> <span class="c1">// =&gt; prints "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="c1">//Цикл с постусловием</span>
    <span class="kt">int</span> <span class="n">kk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d, "</span><span class="p">,</span> <span class="n">kk</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">kk</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">);</span> <span class="c1">// инкрементация происходит перед тем как</span>
                         <span class="c1">// передаётся значение kk ("preincrement")</span>
    <span class="c1">// =&gt; prints "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="c1">// Цикл со счётчиком</span>
    <span class="kt">int</span> <span class="n">jj</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">jj</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">jj</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">jj</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d, "</span><span class="p">,</span> <span class="n">jj</span><span class="p">);</span>
    <span class="p">}</span> <span class="c1">// =&gt; prints "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="c1">// Ветвление с множественным выбором</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">some_integral_expression</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="mi">0</span><span class="p">:</span> <span class="c1">// значения должны быть целыми константами (и могут быть выражениями)</span>
        <span class="n">do_stuff</span><span class="p">();</span>
        <span class="k">break</span><span class="p">;</span> <span class="c1">// если не написать break; то управление будет передано следующему блоку</span>
    <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">do_something_else</span><span class="p">();</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="nl">default:</span>
        <span class="c1">// если не было совпадения, то выполняется блок default:</span>
        <span class="n">fputs</span><span class="p">(</span><span class="s">"ошибка!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">///////////////////////////////////////</span>
    <span class="c1">// Форматирование вывода</span>
    <span class="c1">///////////////////////////////////////</span>

    <span class="c1">// Каждое выражение в Си имеет тип, но вы можете привести один тип к другому, </span>
    <span class="c1">// если хотите (с некоторыми искажениями).</span>

    <span class="kt">int</span> <span class="n">x_hex</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span> <span class="c1">// Вы можете назначать переменные с помощью шестнадцатеричного кода.</span>

    <span class="c1">// Приведение типов будет пытаться сохранять цифровые значения.</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x_hex</span><span class="p">);</span> <span class="c1">// =&gt; Prints 1</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">short</span><span class="p">)</span> <span class="n">x_hex</span><span class="p">);</span> <span class="c1">// =&gt; Prints 1</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="n">x_hex</span><span class="p">);</span> <span class="c1">// =&gt; Prints 1</span>

    <span class="c1">// Типы могут переполняться без вызова предупреждения.</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="mi">257</span><span class="p">);</span> <span class="c1">// =&gt; 1 (Max char = 255 if char is 8 bits long)</span>

    <span class="c1">// Для определения максимального значения типов `char`, `signed char` и `unisigned char`,</span>
    <span class="c1">// соответственно используйте CHAR_MAX, SCHAR_MAX и UCHAR_MAX макросы из &lt;limits.h&gt;</span>

    <span class="c1">// Целые типы могут быть приведены к вещественным и наоборот.</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="mi">100</span><span class="p">);</span> <span class="c1">// %f formats a float</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%lf</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="mi">100</span><span class="p">);</span> <span class="c1">// %lf formats a double</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mi">100</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>

    <span class="c1">///////////////////////////////////////</span>
    <span class="c1">// Указатели</span>
    <span class="c1">///////////////////////////////////////</span>

    <span class="c1">// Указатель – это переменная которая хранит адрес в памяти.</span>
    <span class="c1">// При объявлении указателя указывается тип данных переменной на которую он будет ссылаться.</span>
    <span class="c1">// Вы можете получить адрес любой переменной, а потом работать с ним.</span>

    <span class="c1">// Используйте &amp; для получения адреса переменной.</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span> <span class="c1">// =&gt; Напечатает адрес в памяти, где лежит переменная x</span>
    <span class="c1">// (%p выводит указатель на void *)</span>

    <span class="c1">// Для объявления указателя нужно поставить * перед именем.</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">px</span><span class="p">,</span> <span class="n">not_a_pointer</span><span class="p">;</span> <span class="c1">// px это указатель на int</span>
    <span class="n">px</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span> <span class="c1">// сохранит адрес x в px</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">px</span><span class="p">);</span> <span class="c1">// =&gt; Напечатает адрес в памяти, где лежит переменная px</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%zu, %zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">px</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">not_a_pointer</span><span class="p">));</span>
    <span class="c1">// =&gt; Напечатает "8, 4" в 64 битной системе</span>

    <span class="c1">// Для того, чтобы получить значение по адресу, напечатайте * перед именем.</span>
    <span class="c1">// Да, * используется при объявлении указателя и для получении значения по адресу</span>
    <span class="c1">// немного запутано, но вы привыкнете.</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">px</span><span class="p">);</span> <span class="c1">// =&gt; Напечатает 0, значение перемененной x</span>

    <span class="c1">// Вы также можете изменять значение, на которое указывает указатель.</span>
    <span class="p">(</span><span class="o">*</span><span class="n">px</span><span class="p">)</span><span class="o">++</span><span class="p">;</span> <span class="c1">// Инкрементирует значение на которое указывает px на единицу</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">px</span><span class="p">);</span> <span class="c1">// =&gt; Напечатает 1</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// =&gt; Напечатает 1</span>

    <span class="c1">// Массивы удобно использовать для большого количества однотипных данных.</span>
    <span class="kt">int</span> <span class="n">x_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">xx</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">xx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">xx</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">xx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x_array</span><span class="p">[</span><span class="n">xx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">-</span> <span class="n">xx</span><span class="p">;</span>
    <span class="p">}</span> <span class="c1">// Объявление x_array с значениями 20, 19, 18,... 2, 1</span>

    <span class="c1">// Объявление указателя на int с адресом массива.</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">x_ptr</span> <span class="o">=</span> <span class="n">x_array</span><span class="p">;</span>
    <span class="c1">// x_ptr сейчас указывает на первый элемент массива (со значением 20). </span>
    <span class="c1">// Это работает, потому что при обращении к имени массива возвращается </span>
    <span class="c1">// указатель на первый элемент.</span>
    <span class="c1">// Например, когда массив передаётся в функцию или присваивается указателю, он</span>
    <span class="c1">// неявно преобразуется в указатель.</span>
    <span class="c1">// Исключения: когда массив является аргументом для оператор '&amp;':</span>
    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr_to_arr</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">;</span> <span class="c1">// &amp;arr не является 'int *'!</span>
                                  <span class="c1">// он является "указателем на массив" (из десяти 'int'ов).</span>
    <span class="c1">// или когда массив это строчный литерал, используемый при объявлении массива символов:</span>
    <span class="kt">char</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"foobarbazquirk"</span><span class="p">;</span>
    <span class="c1">// или когда массив является аргументом `sizeof` или `alignof` операторов:</span>
    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span> <span class="c1">// то же самое что и "int *ptr = &amp;arr[0];"</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%zu %zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">arr</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">ptr</span><span class="p">);</span> <span class="c1">// напечатает "40, 4" или "40, 8"</span>

    <span class="c1">// Декрементация и инкрементация указателей зависит от их типа</span>
    <span class="c1">// (это называется арифметика указателей)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">x_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span> <span class="c1">// =&gt; Напечатает 19</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// =&gt; Напечатает 19</span>

    <span class="c1">// Вы также можете динамически выделять несколько блоков памяти с помощью</span>
    <span class="c1">// функции malloc из стандартной библиотеки, которая принимает один </span>
    <span class="c1">// аргумент типа size_t – количество байт необходимых для выделения.</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">my_ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">my_ptr</span><span class="p">)</span> <span class="o">*</span> <span class="mi">20</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">xx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">xx</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">xx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="p">(</span><span class="n">my_ptr</span> <span class="o">+</span> <span class="n">xx</span><span class="p">)</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">-</span> <span class="n">xx</span><span class="p">;</span> <span class="c1">// my_ptr[xx] = 20-xx</span>
    <span class="p">}</span> <span class="c1">// Выделяет память для 20, 19, 18, 17... 2, 1 (как int'ы)</span>

    <span class="c1">// Работа с памятью с помощью указателей может давать неожиданные и</span>
    <span class="c1">// непредсказуемые результаты.</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">my_ptr</span> <span class="o">+</span> <span class="mi">21</span><span class="p">));</span> <span class="c1">// =&gt; Напечатает кто-нибудь знает, что? </span>
                                    <span class="c1">// Скорей всего программа вылетит.</span>

    <span class="c1">// Когда вы закончили работать с памятью, которую ранее выделили, вам необходимо </span>
    <span class="c1">// освободить её, иначе это может вызвать утечку памяти или ошибки.</span>
    <span class="n">free</span><span class="p">(</span><span class="n">my_ptr</span><span class="p">);</span>

    <span class="c1">// Строки это массивы символов, но обычно они представляются как </span>
    <span class="c1">// указатели на символ (как указатели на первый элемент массива).</span>
    <span class="c1">// Хорошей практикой считается использование `const char *' при объявлении </span>
    <span class="c1">// строчного литерала. При таком подходе литерал не может быть изменён.</span>
    <span class="c1">// (например "foo"[0] = 'a' вызовет ошибку!)</span>

    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">my_str</span> <span class="o">=</span> <span class="s">"This is my very own string literal"</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%c</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">my_str</span><span class="p">);</span> <span class="c1">// =&gt; 'T'</span>

    <span class="c1">// Это не работает, если строка является массивом</span>
    <span class="c1">// (потенциально задаваемой с помощью строкового литерала)</span>
    <span class="c1">// который находится в перезаписываемой части памяти:</span>

    <span class="kt">char</span> <span class="n">foo</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"foo"</span><span class="p">;</span>
    <span class="n">foo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span> <span class="c1">// это выполнится и строка теперь "aoo"</span>

    <span class="kt">void</span> <span class="n">function_1</span><span class="p">()</span>
<span class="p">}</span> <span class="c1">// конец функции main()</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Функции</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// Синтаксис объявления функции:</span>
<span class="c1">// &lt;возвращаемый тип&gt; &lt;имя функции&gt;(аргументы)</span>

<span class="kt">int</span> <span class="nf">add_two_ints</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="p">;</span> <span class="c1">// Используйте return для возврата значения</span>
<span class="p">}</span>

<span class="cm">/*
Данные в функцию передаются "по значению", но никто не мешает
вам передавать в функцию указатели и менять данные по указателям.

Например: инвертировать строку прямо в функции
*/</span>

<span class="c1">// void означает, что функция ничего не возвращает</span>
<span class="kt">void</span> <span class="nf">str_reverse</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str_in</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str_in</span><span class="p">);</span> <span class="c1">// `strlen()` является частью стандартной библиотеки</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">ii</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">str_in</span><span class="p">[</span><span class="n">ii</span><span class="p">];</span>
        <span class="n">str_in</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">str_in</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">// ii-тый символ с конца</span>
        <span class="n">str_in</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="n">c</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"This is a test."</span><span class="p">;</span>
<span class="n">str_reverse</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span> <span class="c1">// =&gt; Выведет ".tset a si sihT"</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Типы и структуры определяемые пользователем</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// typedef используется для задания стандартным типам своих названий</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">my_type</span><span class="p">;</span>
<span class="n">my_type</span> <span class="n">my_type_var</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// Структуры это просто коллекция данных, память выделяется последовательно,</span>
<span class="c1">// в том порядке в котором записаны данные.</span>
<span class="k">struct</span> <span class="n">rectangle</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">width</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">height</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// sizeof(struct rectangle) == sizeof(int) + sizeof(int) – не всегда верно</span>
<span class="c1">// из-за особенностей компиляции (необычное поведение при отступах)[1].</span>

<span class="kt">void</span> <span class="nf">function_1</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">rectangle</span> <span class="n">my_rec</span><span class="p">;</span>

    <span class="c1">// Доступ к структурам через точку</span>
    <span class="n">my_rec</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">my_rec</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

    <span class="c1">// Вы можете объявить указатель на структуру</span>
    <span class="k">struct</span> <span class="n">rectangle</span> <span class="o">*</span><span class="n">my_rec_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_rec</span><span class="p">;</span>

    <span class="c1">// Можно получить доступ к структуре и через указатель</span>
    <span class="p">(</span><span class="o">*</span><span class="n">my_rec_ptr</span><span class="p">).</span><span class="n">width</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>

    <span class="c1">// ... или ещё лучше: используйте оператор -&gt; для лучшей читабельности</span>
    <span class="n">my_rec_ptr</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// то же что и "(*my_rec_ptr).height = 10;"</span>
<span class="p">}</span>

<span class="c1">// Вы можете применить typedef к структуре, для удобства.</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">rectangle</span> <span class="n">rect</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">area</span><span class="p">(</span><span class="n">rect</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">r</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Если вы имеете большую структуру, можно получить доступ к ней "по указателю",</span>
<span class="c1">// чтобы избежать копирования всей структуры.</span>
<span class="kt">int</span> <span class="nf">area</span><span class="p">(</span><span class="k">const</span> <span class="n">rect</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">*</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Указатели на функции</span>
<span class="c1">///////////////////////////////////////</span>

<span class="cm">/*
Во время исполнения функции находятся по известным адресам в памяти.
Указатель на функцию может быть использован для непосредственного вызова функции.
Однако синтаксис может сбивать с толку.

Пример: использование str_reverse по указателю
*/</span>

<span class="kt">void</span> <span class="nf">str_reverse_through_pointer</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str_in</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Определение функции через указатель.</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span> <span class="c1">// Сигнатура должна полностью совпадать с целевой функцией.</span>
    <span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">str_reverse</span><span class="p">;</span> <span class="c1">// Присвоить фактический адрес (во время исполнения)</span>
    <span class="c1">// "f = str_reverse;" тоже будет работать.</span>
    <span class="c1">//Имя функции (как и массива) возвращает указатель на начало.</span>
    <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="n">str_in</span><span class="p">);</span> <span class="c1">// Просто вызываем функцию через указатель.</span>
    <span class="c1">// "f(str_in);" или вот так</span>
<span class="p">}</span>
</code></pre></div>
<h2>На почитать</h2>

<p>Лучше всего найдите копию <a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">K&amp;R, aka &ldquo;The C Programming Language&rdquo;</a>
Это <strong>книга</strong> написанная создателями Си. Но будьте осторожны, она содержит идеи которые больше не считаются хорошими.</p>

<p>Другой хороший ресурс: <a href="http://learncodethehardway.org/c/">Learn C the hard way</a>.</p>

<p>Если у вас появился вопрос, почитайте <a href="http://c-faq.com">compl.lang.c Frequently Asked Questions</a>.</p>

<p>Очень важно использовать правильные отступы и ставить пробелы в нужных местах.
Читаемый код лучше чем красивый или быстрый код.
Чтобы научиться писать хороший код, почитайте <a href="https://www.kernel.org/doc/Documentation/CodingStyle">Linux kernel coding style</a>.</p>

<p>Также не забывайте, что <a href="http://google.com">Google</a> и <a href="http://yandex.ru">Яндекс</a> – ваши хорошие друзья.</p>

<p>[1] http://stackoverflow.com/questions/119123/why-isnt-sizeof-for-a-struct-equal-to-the-sum-of-sizeof-of-each-member</p>

    <hr>
    <p>Хотите предложить свой перевод? Может быть, улучшение перевода? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Откройте Issue</a> в репозитории Github или сделайте <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/ru-ru/c-ru.html.markdown">pull request</a> сами!
    </p>
    <p class="contributed">
    Первоначально предоставлено автором Adam Bard, и обновлено <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/ru-ru/c-ru.html.markdown">1 автором (-ами)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://adambard.com/">Adam Bard</a>,
        <a href="http://twitter.com/H2CO3_iOS">Árpád Goretity</a>
    </p>

    <p>
      Translated by:
        <a href="http://evlogii.com">Evlogy Sutormin</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>

        <script>
            var _gaq=[['_setAccount','UA-3525624-21'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>
</html>
