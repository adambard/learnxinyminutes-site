<!DOCTYPE html lang="fr-fr" xml:lang="fr-fr" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="fr-fr">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Haskell in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/fr-fr/haskell-fr/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Ffr-fr%2Fhaskell-fr%2F&text=Apprendre+X+en+Y+minutes%2C+o%C3%B9+X%3DHaskell">
        Partager cette page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Sélectionner un thème :</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">clair</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">sombre</button>
  </div>
  <h1><a href="/">Apprendre X en Y minutes</a></h1>
  <h2>Où X=Haskell</h2>
    <p class="filelink">
    Récupérer le code :
    <a href="/docs/files/learnhaskell-fr.hs">learnhaskell-fr.hs</a>
    </p>
  <div id="doc">
    <p>Haskell a été conçu pour être un langage fonctionnel pur et maniable. Il est connu pour ses monades et son système de types, mais je n&#39;ai cesse d&#39;y revenir pour son élégance. Pour moi, Haskell fait de la programmation une joie.</p>
<div class="highlight"><pre class="highlight haskell"><code><span class="c1">-- Un commentaire en une ligne commence avec deux tirets.</span>
<span class="cm">{- Un commentaire sur plusieurs lignes peut être contenu dans
un bloc de cette façon.
-}</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 1. Types de données primitifs et opérateurs</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Vous avez les nombres</span>
<span class="mi">3</span> <span class="c1">-- 3</span>

<span class="c1">-- Les maths sont comme vous vous y attendez</span>
<span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">-- 2</span>
<span class="mi">8</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">-- 7</span>
<span class="mi">10</span> <span class="o">*</span> <span class="mi">2</span> <span class="c1">-- 20</span>
<span class="mi">35</span> <span class="o">/</span> <span class="mi">5</span> <span class="c1">-- 7.0</span>

<span class="c1">-- La division n'est pas entière par défaut</span>
<span class="mi">35</span> <span class="o">/</span> <span class="mi">4</span> <span class="c1">-- 8.75</span>

<span class="c1">-- division entière</span>
<span class="mi">35</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">4</span> <span class="c1">-- 8</span>

<span class="c1">-- Les booléens sont primitifs</span>
<span class="kt">True</span>
<span class="kt">False</span>

<span class="c1">-- Opérations avec les booléens</span>
<span class="n">not</span> <span class="kt">True</span> <span class="c1">-- False</span>
<span class="n">not</span> <span class="kt">False</span> <span class="c1">-- True</span>
<span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="c1">-- True</span>
<span class="mi">1</span> <span class="o">/=</span> <span class="mi">1</span> <span class="c1">-- False</span>
<span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="c1">-- True</span>

<span class="c1">-- Dans les exemples plus hauts, `not` est une fonction qui prend une valeur.</span>
<span class="c1">-- Haskell n'a pas besoin de parenthèses pour appeler une fonction... tous</span>
<span class="c1">-- les arguments sont juste listés après la fonction. Le schéma général est</span>
<span class="c1">-- donc :</span>
<span class="c1">-- func arg1 arg2 arg3...</span>
<span class="c1">-- Voyez la section sur les fonctions pour savoir comment écrire les vôtres.</span>

<span class="c1">-- Caractères et chaînes de caractère</span>
<span class="s">"Ceci est une chaîne de caractère."</span>
<span class="sc">'a'</span> <span class="c1">-- caractère</span>
<span class="kt">'Vous</span> <span class="n">ne</span> <span class="n">pouvez</span> <span class="n">pas</span> <span class="n">utiliser</span> <span class="n">des</span> <span class="n">apostrophes</span> <span class="n">pour</span> <span class="n">les</span> <span class="n">cha</span><span class="err">î</span><span class="n">nes</span> <span class="n">de</span> <span class="n">caract</span><span class="err">è</span><span class="n">re</span><span class="o">.</span><span class="n">'</span> <span class="c1">-- erreur !</span>

<span class="c1">-- Les chaînes peuvent être concaténées</span>
<span class="s">"Hello "</span> <span class="o">++</span> <span class="s">"world!"</span> <span class="c1">-- "Hello world!"</span>

<span class="c1">-- Une chaîne de caractère est *réellement* une liste</span>
<span class="s">"Ceci est une chaîne."</span> <span class="o">!!</span> <span class="mi">0</span> <span class="c1">-- 'C'</span>


<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 2. Listes et tuples</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Tous les éléments d'une liste doit avoir le même type.</span>
<span class="c1">-- les deux lignes suivantes sont semblables</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>

<span class="c1">-- Il y a aussi des listes infinies en Haskell !</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span> <span class="c1">-- une liste de tous les nombres naturels</span>

<span class="c1">-- Les listes infinies fonctionnent parce que Haskell est « paresseux »:</span>
<span class="c1">-- ça veut dire qu'il n'évalue que ce qui a besoin de l'être. Vous pouvez</span>
<span class="c1">-- donc vous demander le 1000e élément de votre liste et il vous le donnera :</span>

<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span> <span class="o">!!</span> <span class="mi">999</span> <span class="c1">-- 1000</span>

<span class="c1">-- Et là, Haskell a évalué les éléments 1 à 1000 de la liste... mais le reste</span>
<span class="c1">-- de cette liste « infinie » n'existe pas encore ! En fait, Haskell ne va jamais </span>
<span class="c1">-- le faire à moins qu'il ne le doive.</span>

<span class="c1">-- Adjoindre deux listes </span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="mi">6</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>

<span class="c1">-- ajouter au début de la liste</span>
<span class="mi">0</span><span class="o">:</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- [0, 1, 2, 3, 4, 5]</span>

<span class="c1">-- l'indice d'une liste</span>
<span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">]</span> <span class="o">!!</span> <span class="mi">5</span> <span class="c1">-- 5</span>

<span class="c1">-- d'autres opérations sur les listes</span>
<span class="n">head</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- 1</span>
<span class="n">tail</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- [2, 3, 4, 5]</span>
<span class="n">init</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- [1, 2, 3, 4]</span>
<span class="n">last</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- 5</span>

<span class="c1">--liste en compréhension</span>
<span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]]</span> <span class="c1">-- [2, 4, 6, 8, 10]</span>

<span class="c1">--avec un conditionnel</span>
<span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">],</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">]</span> <span class="c1">-- [6, 8, 10]</span>

<span class="c1">-- Chaque élément d'un tuple peut être d'un type différent, mais un</span>
<span class="c1">-- tuple a une longueur fixée.</span>
<span class="c1">-- Un tuple :</span>
<span class="p">(</span><span class="s">"haskell"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1">-- accéder aux éléments d'un tuple</span>
<span class="n">fst</span> <span class="p">(</span><span class="s">"haskell"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">-- "haskell"</span>
<span class="n">snd</span> <span class="p">(</span><span class="s">"haskell"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">-- 1</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 3. Functions</span>
<span class="c1">----------------------------------------------------</span>
<span class="c1">-- Une simple fonction qui prend deux paramètres</span>
<span class="n">add</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="c1">-- Notez que si vous utilisez ghci (l'interpréteur Haskell)</span>
<span class="c1">-- vous devrez utiliser `let`. Par exemple :</span>
<span class="c1">-- let add a b = a + b</span>

<span class="c1">-- Utiliser une fonction</span>
<span class="n">add</span> <span class="mi">1</span> <span class="mi">2</span> <span class="c1">-- 3</span>

<span class="c1">-- Vous pouvez également mettre le nom de la fonction entre les</span>
<span class="c1">-- deux arguments avec des accents graves :</span>
<span class="mi">1</span> <span class="p">`</span><span class="n">add</span><span class="p">`</span> <span class="mi">2</span> <span class="c1">-- 3</span>

<span class="c1">-- Vous pouvez également définir des fonctions qui n'ont pas de</span>
<span class="c1">-- lettres ! Ça vous laisse créer vos propres opérateurs ! Voilà </span>
<span class="c1">-- un opérateur qui fait une division entière :</span>
<span class="p">(</span><span class="o">//</span><span class="p">)</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="n">b</span>
<span class="mi">35</span> <span class="o">//</span> <span class="mi">4</span> <span class="c1">-- 8</span>

<span class="c1">-- Gardes : Une façon de gérer la valeur de vos arguments en amont</span>
<span class="n">fib</span> <span class="n">x</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">=</span> <span class="n">x</span>
  <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="n">fib</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1">-- Le filtrage par motif est similaire. Là, on a donné trois </span>
<span class="c1">-- définitions différentes de `fib`. Haskell appellera automatiquement</span>
<span class="c1">-- la première fonction qui correspond au motif de la valeur.</span>
<span class="n">fib</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">fib</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">fib</span> <span class="n">x</span> <span class="o">=</span> <span class="n">fib</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1">-- Filtrage par motif sur un tuple.</span>
<span class="n">foo</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1">-- Filtrage par motif sur des listes. Ici, `x` est le premier</span>
<span class="c1">-- élément de la liste, et `xs` le reste. On peut écrire notre</span>
<span class="c1">-- propre fonction `map` :</span>
<span class="n">myMap</span> <span class="n">func</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">myMap</span> <span class="n">func</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">func</span> <span class="n">x</span><span class="o">:</span><span class="p">(</span><span class="n">myMap</span> <span class="n">func</span> <span class="n">xs</span><span class="p">)</span>

<span class="c1">-- Les fonctions anonymes sont créées avec des barres obliques </span>
<span class="c1">-- inverses, suivies de tous les arguments.</span>
<span class="n">myMap</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- [3, 4, 5, 6, 7]</span>

<span class="c1">-- Une utilisation de fold (appelée `inject` dans quelques autres</span>
<span class="c1">-- langages) avec comme paramètre une fonction anonyme.</span>
<span class="c1">-- `foldl1` veut dire fold left -- soit littéralement pli gauche --</span>
<span class="c1">-- et utilise la première valeur de la liste comme accumulateur.</span>
<span class="n">foldl1</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- 15</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 4. Plus de fonctions</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- curryfication : si vous n'appliquez pas tous les arguments à une</span>
<span class="c1">-- fonction, elle devient « curryfiée ». Ça veut dire qu'elle retourne</span>
<span class="c1">-- une fonction qui prend le reste des arguments.</span>

<span class="n">add</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">add</span> <span class="mi">10</span> <span class="c1">-- foo est une fonction qui prend un nombre et y ajoute 10</span>
<span class="n">foo</span> <span class="mi">5</span> <span class="c1">-- 15</span>

<span class="c1">-- Une autre façon de l'écrire</span>
<span class="n">foo</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="mi">10</span><span class="p">)</span>
<span class="n">foo</span> <span class="mi">5</span> <span class="c1">-- 15</span>

<span class="c1">-- Composition de fonctions</span>
<span class="c1">-- la fonction (.) enchaîne deux fonctions.</span>
<span class="c1">-- Par exemple, on a foo qui est une fonction qui prend une valeur, y ajoute</span>
<span class="c1">-- 10 et multiplie ce résultat par 5, et ensuite retourne la valeur finale.</span>
<span class="n">foo</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="mi">5</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="o">+</span><span class="mi">10</span><span class="p">)</span>

<span class="c1">-- (5 + 10) * 5 = 75</span>
<span class="n">foo</span> <span class="mi">5</span> <span class="c1">-- 75</span>

<span class="c1">-- fixation de priorité</span>
<span class="c1">-- Haskell a une autre fonction appelée `$`. Elle peut changer la priorité</span>
<span class="c1">-- de sorte que tout ce qu'il y a à sa gauche est calculé d'abord et ensuite </span>
<span class="c1">-- appliqué à tout ce qu'il y a à droite. Vous pouvez utiliser `.` et `$` </span>
<span class="c1">-- pour vous débarrasser de beaucoup de parenthèses :</span>

<span class="c1">-- avant</span>
<span class="p">(</span><span class="n">even</span> <span class="p">(</span><span class="n">fib</span> <span class="mi">7</span><span class="p">))</span> <span class="c1">-- False</span>

<span class="c1">-- ensuite</span>
<span class="n">even</span> <span class="o">.</span> <span class="n">fib</span> <span class="o">$</span> <span class="mi">7</span> <span class="c1">-- False</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 5. Signature de type</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Haskell a un système de types très strict : par exemple, tout a un type.</span>

<span class="c1">-- Quelques types simples :</span>
<span class="mi">5</span> <span class="o">::</span> <span class="kt">Integer</span>
<span class="s">"hello"</span> <span class="o">::</span> <span class="kt">String</span>
<span class="kt">True</span> <span class="o">::</span> <span class="kt">Bool</span>

<span class="c1">-- Les fonctions ont également des types.</span>
<span class="c1">-- `not` prend un booléen et retourne un booléen.</span>
<span class="c1">-- not :: Bool -&gt; Bool</span>

<span class="c1">-- Voilà une fonction qui prend deux paramètres.</span>
<span class="c1">-- add :: Integer -&gt; Integer -&gt; Integer</span>

<span class="c1">-- Quand vous définissez une valeur (souvenez-vous, tout est valeur en</span>
<span class="c1">-- Haskell), une bonne pratique est d'écrire son type explicitement</span>
<span class="n">double</span> <span class="o">::</span> <span class="kt">Integer</span> <span class="o">-&gt;</span> <span class="kt">Integer</span>
<span class="n">double</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 6. Flux de contrôle et structures conditionnelles</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- structure conditionnelle if</span>
<span class="n">haskell</span> <span class="o">=</span> <span class="kr">if</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="kr">then</span> <span class="s">"awesome"</span> <span class="kr">else</span> <span class="s">"awful"</span> <span class="c1">-- haskell = "awesome"</span>

<span class="c1">-- les structures if peuvent être écrites sur plusieurs lignes</span>
<span class="n">haskell</span> <span class="o">=</span> <span class="kr">if</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="kr">then</span> <span class="s">"awesome"</span>
            <span class="kr">else</span> <span class="s">"awful"</span>

<span class="c1">-- les structures case : voilà comment vous pourriez analyser les arguments de </span>
<span class="c1">-- ligne de commande</span>
<span class="kr">case</span> <span class="n">args</span> <span class="kr">of</span>
  <span class="s">"help"</span> <span class="o">-&gt;</span> <span class="n">printHelp</span>
  <span class="s">"start"</span> <span class="o">-&gt;</span> <span class="n">startProgram</span>
  <span class="kr">_</span> <span class="o">-&gt;</span> <span class="n">putStrLn</span> <span class="s">"bad args"</span>


<span class="c1">-- Haskell n'a pas de boucles parce qu'il utilise la récursion.</span>
<span class="c1">-- `map` applique une fonction sur chaque élément d'une liste</span>

<span class="n">map</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- [2, 4, 6, 8, 10]</span>

<span class="c1">-- vous pouvez créer une fonction `for` en utilisant `map`</span>
<span class="n">for</span> <span class="n">array</span> <span class="n">func</span> <span class="o">=</span> <span class="n">map</span> <span class="n">func</span> <span class="n">array</span>

<span class="c1">-- et l'utiliser</span>
<span class="n">for</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="o">$</span> <span class="nf">\</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">show</span> <span class="n">i</span>

<span class="c1">-- nous aurions pu l'écrire également ainsi</span>
<span class="n">for</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="n">show</span>

<span class="c1">-- vous pouvez utiliser foldl et foldr pour </span>
<span class="c1">-- réduire une liste</span>
<span class="c1">-- foldl &lt;fonction&gt; &lt;valeur initiale&gt; &lt;liste&gt;</span>
<span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="mi">4</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="c1">-- 43</span>

<span class="c1">-- C'est donc la même chose que </span>
<span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>

<span class="c1">-- foldl évalue de gauche à droite, foldr</span>
<span class="c1">-- de droite à gauche</span>
<span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="mi">4</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="c1">-- 16</span>

<span class="c1">-- Et c'est équivalent à</span>
<span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)))</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 7. Types de données</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Vous pouvez écrire vos propres types de données en Haskell</span>

<span class="kr">data</span> <span class="kt">Couleur</span> <span class="o">=</span> <span class="kt">Rouge</span> <span class="o">|</span> <span class="kt">Bleu</span> <span class="o">|</span> <span class="kt">Vert</span>

<span class="c1">-- Et maintenant l'utiliser dans une fonction</span>


<span class="n">say</span> <span class="o">::</span> <span class="kt">Couleur</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">say</span> <span class="kt">Rouge</span> <span class="o">=</span> <span class="s">"Vous êtes Rouge !"</span>
<span class="n">say</span> <span class="kt">Bleu</span> <span class="o">=</span> <span class="s">"Vous êtes Bleu !"</span>
<span class="n">say</span> <span class="kt">Vert</span> <span class="o">=</span>  <span class="s">"Vous êtes Vert !"</span>

<span class="c1">-- Vos types peuvent également avoir des paramètres</span>

<span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Nothing</span> <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>

<span class="c1">-- Tous les exemples ci-dessous sont issus du type Maybe</span>
<span class="kt">Just</span> <span class="s">"hello"</span>    <span class="c1">-- of type `Maybe String`</span>
<span class="kt">Just</span> <span class="mi">1</span>          <span class="c1">-- of type `Maybe Int`</span>
<span class="kt">Nothing</span>         <span class="c1">-- of type `Maybe a` for any `a`</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 8. Haskell IO</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Tandis que l'IO ne peut pas être totalement expliqué pleinement</span>
<span class="c1">-- sans que les monades ne le soient, il n'est pas difficile</span>
<span class="c1">-- d'expliquer suffisamment pour commencer.</span>

<span class="c1">-- Quand un programme en Haskell est exécuté, la fonction `main`</span>
<span class="c1">-- est appelée. Il doit retourner une valeur de type `IO ()`.</span>
<span class="c1">-- Par exemple :</span>

<span class="n">main</span> <span class="o">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">main</span> <span class="o">=</span> <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">"Bonjour, le ciel ! "</span> <span class="o">++</span> <span class="p">(</span><span class="n">say</span> <span class="kt">Blue</span><span class="p">)</span> 
<span class="c1">-- putStrLn a comme type String -&gt; IO ()</span>

<span class="c1">-- La façon la plus simple pour faire de l'IO est de faire un programme </span>
<span class="c1">-- fonction de String vers String. La fonction</span>
<span class="c1">--    interact :: (String -&gt; String) -&gt; IO ()</span>
<span class="c1">-- prend un texte, applique une fonction et affiche le résultat.</span>

<span class="n">countLines</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">countLines</span> <span class="o">=</span> <span class="n">show</span> <span class="o">.</span> <span class="n">length</span> <span class="o">.</span> <span class="n">lines</span>

<span class="n">main'</span> <span class="o">=</span> <span class="n">interact</span> <span class="n">countLines</span>

<span class="c1">-- Vous pouvez considérer qu'une valeur de type `IO ()` représente</span>
<span class="c1">-- une séquence d'actions que l'ordinateur exécute, un peu comme </span>
<span class="c1">-- dans un langage impératif. On peut utiliser la structure `do` </span>
<span class="c1">-- pour enchaîner des actions. Par exemple :</span>

<span class="n">sayHello</span> <span class="o">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">sayHello</span> <span class="o">=</span> <span class="kr">do</span> 
   <span class="n">putStrLn</span> <span class="s">"Quel est ton nom ?"</span>
   <span class="n">name</span> <span class="o">&lt;-</span> <span class="n">getLine</span> <span class="c1">-- prend une ligne et assigne sa valeur à `name`</span>
   <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">"Salut, "</span> <span class="o">++</span> <span class="n">name</span>

<span class="c1">-- Exercice : écrire votre propre version d'`interact` qui ne fait </span>
<span class="c1">--           que de lire une ligne d'entrée.</span>

<span class="c1">-- Le code de `sayHello` ne sera jamais exécuté, cependant. La seule</span>
<span class="c1">-- action qui sera exécutée est la valeur de `main`.</span>
<span class="c1">-- Pour lancer `sayHello`, commentez l'ancienne définition de `main`</span>
<span class="c1">-- et remplacez-le par :</span>
<span class="c1">--   main = sayHello</span>

<span class="c1">-- Essaions de mieux comprendre comment la fonction `getLine` que </span>
<span class="c1">-- nous venons d'utiliser. Son type est :</span>
<span class="c1">--    getLine :: IO String</span>
<span class="c1">-- vous pouvez considérer le type `IO a` comme un programme que</span>
<span class="c1">-- le programme va générer comme une valeur de type `a` quand</span>
<span class="c1">-- il sera exécuté. On peut l'enregistrer et la réutiliser en</span>
<span class="c1">-- utilisant `&lt;-`. On peut aussi faire nos propres actions</span>
<span class="c1">-- de type `IO String` :</span>

<span class="n">action</span> <span class="o">::</span> <span class="kt">IO</span> <span class="kt">String</span>
<span class="n">action</span> <span class="o">=</span> <span class="kr">do</span>
   <span class="n">putStrLn</span> <span class="s">"C'est une ligne. Heu"</span>
   <span class="n">input1</span> <span class="o">&lt;-</span> <span class="n">getLine</span> 
   <span class="n">input2</span> <span class="o">&lt;-</span> <span class="n">getLine</span>
   <span class="c1">-- Le type de la structure `do` est celui de sa dernière ligne.</span>
   <span class="c1">-- `return` n'est pas un mot clef, mais simplement une fonction.</span>
   <span class="n">return</span> <span class="p">(</span><span class="n">input1</span> <span class="o">++</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span> <span class="o">++</span> <span class="n">input2</span><span class="p">)</span> <span class="c1">-- return :: String -&gt; IO String</span>

<span class="c1">-- On peut maintenant l'utiliser comme on a utilisé `getLine`</span>
<span class="c1">-- tout à l'heure</span>

<span class="n">main''</span> <span class="o">=</span> <span class="kr">do</span>
    <span class="n">putStrLn</span> <span class="s">"Je vais afficher deux lignes !"</span>
    <span class="n">result</span> <span class="o">&lt;-</span> <span class="n">action</span> 
    <span class="n">putStrLn</span> <span class="n">result</span>
    <span class="n">putStrLn</span> <span class="s">"C'était tout !"</span>

<span class="c1">-- Le type `IO` est un exemple de « monade ». La façon dont Haskell utilise</span>
<span class="c1">-- une monade pour faire de l'IO lui permet d'être purement fonctionnel. N'importe</span>
<span class="c1">-- quelle fonction qui interagit avec le « monde extérieur » (c'est à dire fait de l'IO)</span>
<span class="c1">-- devient marqué comme `IO` dans la signature de son type. Ça nous montre</span>
<span class="c1">-- quelles fonctions sont « pures » (n'interagissent pas avec le monde extérieur</span>
<span class="c1">-- ou ne changent pas d'état) et quelles fonctions ne le sont pas.</span>

<span class="c1">-- C'est une fonctionnalité très puissante, car il est facile d'exécuter </span>
<span class="c1">-- des fonctions pures simultanément, et donc la concurrence en Haskell</span>
<span class="c1">-- est très facile.</span>


<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 9. Le REPL de Haskell</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Lancer le REPL en tapant `ghci`.</span>
<span class="c1">-- Vous pouvez maintenant taper du code Haskell.</span>
<span class="c1">-- Toutes les nouvelles valeurs peuvent être crées </span>
<span class="c1">-- avec `let` :</span>

<span class="kr">let</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">5</span>

<span class="c1">-- Vous pouvez voir le type de n'importe quelle valeur avec `:t` :</span>

<span class="o">&gt;:</span><span class="n">t</span> <span class="n">foo</span>
<span class="n">foo</span> <span class="o">::</span> <span class="kt">Integer</span>

<span class="c1">-- Vous pouvez également lancer des actions de type `IO ()`</span>

<span class="o">&gt;</span> <span class="n">sayHello</span>
<span class="kt">Quel</span> <span class="n">est</span> <span class="n">ton</span> <span class="n">nom</span> <span class="o">?</span>
<span class="kt">Ami</span>
<span class="kt">Salut</span><span class="p">,</span> <span class="kt">Ami</span> <span class="o">!</span>

</code></pre></div>
<p>Et Haskell ne se limite pas à ça, on trouve encore par exemple les classes de types et les monades. Il y a beaucoup de raisons qui font que coder en Haskell est si <em>fun</em>. Je vous laisse avec un dernier exemple : une implémentation de quicksort :</p>
<div class="highlight"><pre class="highlight haskell"><code><span class="n">qsort</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">qsort</span> <span class="p">(</span><span class="n">p</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">qsort</span> <span class="n">lesser</span> <span class="o">++</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">++</span> <span class="n">qsort</span> <span class="n">greater</span>
    <span class="kr">where</span> <span class="n">lesser</span>  <span class="o">=</span> <span class="n">filter</span> <span class="p">(</span><span class="o">&lt;</span> <span class="n">p</span><span class="p">)</span> <span class="n">xs</span>
          <span class="n">greater</span> <span class="o">=</span> <span class="n">filter</span> <span class="p">(</span><span class="o">&gt;=</span> <span class="n">p</span><span class="p">)</span> <span class="n">xs</span>
</code></pre></div>
<p>Haskell facile à installer. Téléchargez-le <a href="http://www.haskell.org/platform/">ici</a>.</p>

<p>Vous pouvez trouver une approche beaucoup plus douce avec les excellents
<a href="http://lyah.haskell.fr/">Learn you a Haskell</a> ou
<a href="http://book.realworldhaskell.org/">Real World Haskell (en)</a>.</p>

    <hr>
    <p>Vous avez une suggestion ? Peut-être une correction ? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Ouvrez un ticket</a> sur Github, ou faites vous-même une <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/fr-fr/haskell-fr.html.markdown">pull request</a> !
    </p>
    <p class="contributed">
    Version originale par Adit Bhargava, mis à jour par <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/fr-fr/haskell-fr.html.markdown">0 contributeur(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://adit.io">Adit Bhargava</a>
    </p>

    <p>
      Translated by:
        <a href="http://davidbaumgartner.ch">David Baumgartner</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>

        <script>
            var _gaq=[['_setAccount','UA-3525624-21'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>
</html>
