<!DOCTYPE html lang="pt-br" xml:lang="pt-br" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="pt-br">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Scala in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/pt-br/scala-pt/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fpt-br%2Fscala-pt%2F&text=Aprenda+X+em+Y+Minutos%2C+onde+X%3DScala">
        Compartilhe esta página
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Selecione o tema:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">claro</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">sombrio</button>
  </div>
  <h1><a href="/">Aprenda X em Y Minutos</a></h1>
  <h2>Onde X=Scala</h2>
    <p class="filelink">
    Baixar o código:
    <a href="/docs/files/learnscala-pt.scala">learnscala-pt.scala</a>
    </p>
  <div id="doc">
    <p>Scala - a linguagem escalável</p>
<div class="highlight"><pre class="highlight scala"><code>
<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 0. O básico</span>
<span class="c1">/////////////////////////////////////////////////</span>
<span class="cm">/*
  Configurando o Scala:

  1) Baixe o instalador do Scala - http://www.scala-lang.org/downloads
  2) Extraia (unzip ou tar) para sua localização favorita e coloque o subdiretório
  bin na variável de ambiente `PATH`
*/</span>

<span class="cm">/*
  Tente o REPL

  Scala tem uma ferramenta chamada REPL (Read-Eval-Print Loop) que é análogo a
  interpretadores de linha de comando de outras linguagens. Você pode digitar
  qualquer expressão de Scala e o resultado será calculado e impresso.

  O REPL é uma ferramenta muito conveniente para testar e verificar código. Use-o
  enquanto você lê o tutorial para explorar os conceitos rapidamente por conta própria.
*/</span>

<span class="c1">//Inicialize um REPL de Scala executando o comando scala no terminal. Você deve ver o prompt:</span>
<span class="n">$</span> <span class="n">scala</span>
<span class="n">scala</span><span class="o">&gt;</span>

<span class="c1">//Por padrão, cada expressão que você executa é salva como um novo valor enumerado:</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">4</span>

<span class="c1">// Valores padrões podem ser reutilizados. Observe o tipo do valor exibido no resultado...</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res0</span> <span class="o">+</span> <span class="mi">2</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">6</span>

<span class="c1">// Scala é uma linguagem fortemente tipada. Você pode usar o REPL para verfificar o tipo</span>
<span class="c1">// sem avaliar uma expressão.</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">:type</span> <span class="o">(</span><span class="kt">true</span><span class="o">,</span> <span class="err">2</span><span class="kt">.</span><span class="err">0</span><span class="o">)</span>
<span class="o">(</span><span class="nc">Boolean</span><span class="o">,</span> <span class="nc">Double</span><span class="o">)</span>

<span class="c1">// As sessões do REPL podem ser salvas</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="k">:</span><span class="kt">save</span> <span class="kt">/sites/repl-test.scala</span>

<span class="c1">//Arquivos podem ser carregados no REPL</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="k">:</span><span class="kt">load</span> <span class="kt">/sites/repl-test.scala</span>
<span class="nc">Loading</span> <span class="o">/</span><span class="n">sites</span><span class="o">/</span><span class="n">repl</span><span class="o">-</span><span class="nv">test</span><span class="o">.</span><span class="py">scala</span><span class="o">...</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">6</span>

<span class="c1">// Você pode pesquisar em seu histórico recente</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="k">:</span><span class="kt">h?</span>
<span class="err">1</span> <span class="err">2</span> <span class="kt">+</span> <span class="err">2</span>
<span class="err">2</span> <span class="kt">res0</span> <span class="kt">+</span> <span class="err">2</span>
<span class="err">3</span> <span class="kt">:save</span> <span class="kt">/sites/repl-test.scala</span>
<span class="mi">4</span> <span class="k">:</span><span class="kt">load</span> <span class="kt">/sites/repl-test.scala</span>
<span class="mi">5</span> <span class="k">:</span><span class="kt">h?</span>

<span class="c1">// Agora que você já sabe brincar, vamos aprender um pouco de Scala...</span>

<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 1. Introdução</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Comentários de uma linha começam com duas barras</span>

<span class="cm">/*
  Comentários com múltiplas linhas, como você já pode ver, são assim.
*/</span>

<span class="c1">// Imprimir e forçar uma linha na próxima impressão</span>
<span class="nf">println</span><span class="o">(</span><span class="s">"Hello world!"</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
<span class="c1">// Hello world!</span>
<span class="c1">// 10</span>

<span class="c1">//Imprimir sem forçar uma nova linha na próxima impressão</span>
<span class="nf">print</span><span class="o">(</span><span class="s">"Hello world"</span><span class="o">)</span>
<span class="nf">print</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
<span class="c1">// Hello world10</span>

<span class="c1">//A declaração de valores pode ser feita usando tanto o var quanto o val.</span>
<span class="c1">// Declarações feitas com `val` são imutáveis, enquanto que declarações feitas</span>
<span class="c1">// com var são mutáveis. Imutabilidade é uma coisa boa.</span>
<span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="mi">10</span> <span class="c1">// x is now 10</span>
<span class="n">x</span> <span class="k">=</span> <span class="mi">20</span>     <span class="c1">// error: reassignment to val</span>
<span class="k">var</span> <span class="n">y</span> <span class="k">=</span> <span class="mi">10</span>
 <span class="k">=</span> <span class="mi">20</span>     <span class="c1">// y agora é 20</span>

<span class="cm">/*
  Scala é uma linguagem estaticamente tipada. Observe ainda que nas declarações
  acima nós não especificamos um tipo. Isso se deve a um recurso da linguagem
  chamado de inferência. Na maioria dos casos, o compilador do Scala consegue
  adivinhar qual tipo é, de forma que você não precisa digitar sempre. Nós
  podemos declarar o tipo da variável de maneira explícita asim:
*/</span>

<span class="k">val</span> <span class="nv">z</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span>
<span class="k">val</span> <span class="nv">a</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="c1">// Note que a conversão automática de Int para Double, o resultado é 10.0, não 10</span>
<span class="k">val</span> <span class="nv">b</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mi">10</span>

<span class="c1">//Valores booleanos</span>
<span class="kc">true</span>
<span class="kc">false</span>

<span class="c1">//Operações booleanas</span>
<span class="o">!</span><span class="kc">true</span>         <span class="c1">// false</span>
<span class="o">!</span><span class="kc">false</span>        <span class="c1">// true</span>
<span class="kc">true</span> <span class="o">==</span> <span class="kc">false</span> <span class="c1">// false</span>
<span class="mi">10</span> <span class="o">&gt;</span> <span class="mi">5</span>        <span class="c1">// true</span>

<span class="c1">// Matemática é como o de costume</span>
<span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>   <span class="c1">// 2</span>
<span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>   <span class="c1">// 1</span>
<span class="mi">5</span> <span class="o">*</span> <span class="mi">3</span>   <span class="c1">// 15</span>
<span class="mi">6</span> <span class="o">/</span> <span class="mi">2</span>   <span class="c1">// 3</span>
<span class="mi">6</span> <span class="o">/</span> <span class="mi">4</span>   <span class="c1">// 1</span>
<span class="mf">6.0</span> <span class="o">/</span> <span class="mi">4</span> <span class="c1">// 1.5</span>
<span class="mi">6</span> <span class="o">/</span> <span class="mf">4.0</span> <span class="c1">// 1.5</span>

<span class="c1">// Calcular uma expressão no REPL te dá o tipo e o valor do resultado</span>
<span class="mi">1</span> <span class="o">+</span> <span class="mi">7</span>

<span class="cm">/* A linha acima resulta em:
  scala&gt; 1 + 7
  res29: Int = 8

  Isso significa que o resultado ao culcular  1 + 7 é um objeto do tipo Int com
  valor 8.

  Note que "res29" é o nome de uma variável gerada sequencialmente para guardar
  os resultados das expressões que você executa, logo seu nome pode ser
  diferente.
*/</span>

<span class="s">"Strings em Scala são delimitadas por aspas duplas"</span>
<span class="sc">'a'</span> <span class="c1">// Um caractere em Scala</span>
<span class="c1">// 'Strings com aspas simples não existem em Scala.' &lt;= isso causa um erro.</span>

<span class="c1">// Strings possuem os métodos comuns de Java definidos</span>
<span class="s">"hello world"</span><span class="o">.</span><span class="py">length</span>
<span class="s">"hello world"</span><span class="o">.</span><span class="py">substring</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>
<span class="s">"hello world"</span><span class="o">.</span><span class="py">replace</span><span class="o">(</span><span class="s">"C"</span><span class="o">,</span> <span class="s">"3"</span><span class="o">)</span>

<span class="c1">// Elas também possuem alguns métodos extras do Scala. Veja também:</span>
<span class="nv">scala</span><span class="o">.</span><span class="py">collection</span><span class="o">.</span><span class="py">immutable</span><span class="o">.</span><span class="py">StringOps</span>
<span class="s">"hello world"</span><span class="o">.</span><span class="py">take</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="s">"hello world"</span><span class="o">.</span><span class="py">drop</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>

<span class="c1">//Interpolação de string: observe o prefixo "s"</span>
<span class="k">val</span> <span class="nv">n</span> <span class="k">=</span> <span class="mi">45</span>
<span class="n">s</span><span class="s">"We have $n apples"</span> <span class="c1">// =&gt; "We have 45 apples"</span>

<span class="c1">// Também é possível ter expressões dentro de interpolação de strings</span>
<span class="k">val</span> <span class="nv">a</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">11</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>
<span class="n">s</span><span class="s">"My second daughter is ${a(0) - a(2)} years old."</span>    <span class="c1">// =&gt; "My second daughter is 5 years old."</span>
<span class="n">s</span><span class="s">"We have double the amount of ${n / 2.0} in apples."</span> <span class="c1">// =&gt; "We have double the amount of 22.5 in apples."</span>
<span class="n">s</span><span class="s">"Power of 2: ${math.pow(2, 2)}"</span>                      <span class="c1">// =&gt; "Power of 2: 4"</span>

<span class="c1">// Formatação de strings interpoladas com o prefixo "f"</span>
<span class="n">f</span><span class="s">"Power of 5: ${math.pow(5, 2)}%1.0f"</span>         <span class="c1">// "Power of 5: 25"</span>
<span class="n">f</span><span class="s">"Square root of 122: ${math.sqrt(122)}%1.4f"</span> <span class="c1">// "Square root of 122: 11.0454"</span>


<span class="c1">// Strings cruas, ignorando caracteres especiais</span>
<span class="n">raw</span><span class="s">"New line feed: \n. Carriage return: \r."</span> <span class="c1">// =&gt; "New line feed: \n. Carriage return: \r."</span>

<span class="c1">//Alguns caracteres precisam ser "escapados", ex. uma aspa dupla dentro de uma string</span>

<span class="s">"They stood outside the \"Rose and Crown\""</span> <span class="c1">// =&gt; "They stood outside the "Rose and Crown""</span>

<span class="c1">// Aspas triplas permitem strings a abrangerem múltiplas linhas e conter Aspas</span>
<span class="k">val</span> <span class="nv">html</span> <span class="k">=</span> <span class="s">"""&lt;form id="daform"&gt;
                &lt;p&gt;Press belo', Joe&lt;/p&gt;
                &lt;input type="submit"&gt;
              &lt;/form&gt;"""</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 2. Funções</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Funções são definidas da seguinte maneira:</span>
<span class="c1">//</span>
<span class="c1">//   def nomeDaFuncao(args ...): TipoDeRetorno = {body ...}</span>
<span class="c1">//</span>
<span class="c1">// Se você vem de linguagens mais tradicionais, note a omissão da palavra chave</span>
<span class="c1">//return. Em Scala a última expressão no bloco da função é o valor de retorno</span>
<span class="k">def</span> <span class="nf">sumOfSquares</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">x2</span> <span class="k">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
  <span class="k">val</span> <span class="nv">y2</span> <span class="k">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span>
  <span class="n">x2</span> <span class="o">+</span> <span class="n">y2</span>
<span class="o">}</span>

<span class="c1">// As { } podem ser omitidas se o corpo da função possui apenas uma expressão:</span>
<span class="k">def</span> <span class="nf">sumOfSquaresShort</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span>

<span class="c1">// A sintaxe para chamar funções é familiar:</span>
<span class="nf">sumOfSquares</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>  <span class="c1">// =&gt; 25</span>

<span class="c1">// Você poode usar o nome dos parâmetros para especificá-los numa ordem diferente</span>
<span class="k">def</span> <span class="nf">subtract</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>

<span class="nf">subtract</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>     <span class="c1">// =&gt; 7</span>
<span class="nf">subtract</span><span class="o">(</span><span class="n">y</span><span class="k">=</span><span class="mi">10</span><span class="o">,</span> <span class="n">x</span><span class="k">=</span><span class="mi">3</span><span class="o">)</span> <span class="c1">// =&gt; -7</span>

<span class="c1">// Na maioria dos casos (sendo funções recursivas a a exceção mais notável) o</span>
<span class="c1">// tipo de retorno da função pode ser omitido, e o mesmo tipo de inferência que</span>
<span class="c1">// vimos nas variáveis funcionará com o valor de retorno da função:</span>
<span class="k">def</span> <span class="nf">sq</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>  <span class="c1">// O compilador consegue adivinhar que o tipo de retorno é Int</span>

<span class="c1">// Funções podem ter parâmetros padrão:</span>
<span class="k">def</span> <span class="nf">addWithDefault</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="nf">addWithDefault</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="c1">// =&gt; 3</span>
<span class="nf">addWithDefault</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>    <span class="c1">// =&gt; 6</span>

<span class="c1">// Funções anônimas são semelhantes a essa:</span>
<span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="c1">// Diferente de defs, até mesmo a entrada de funções anônimas podem ser omitidas</span>
<span class="c1">// se o contexto deixar isso claro. Observe o tipo "Int =&gt; Int", que significa</span>
<span class="c1">// uma função que recebe umn Int e retorna um Int.</span>
<span class="k">val</span> <span class="nv">sq</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="c1">// Se cada argumento na sua função anônima é usado apenas uma vez, Scala te fornece</span>
<span class="c1">// uma maneira ainda mais curta de definí-lo. Estas funções anônimas acabam por</span>
<span class="c1">// ser muito comuns, como será mostrado na sessão de estrutura de dados.</span>
<span class="k">val</span> <span class="nv">addOne</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="k">_</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">val</span> <span class="nv">weirdSum</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="k">_</span> <span class="o">*</span> <span class="mi">3</span><span class="o">)</span>

<span class="nf">addOne</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>      <span class="c1">// =&gt; 6</span>
<span class="nf">weirdSum</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span> <span class="c1">// =&gt; 16</span>

<span class="c1">// A palavra chave return existe em Scala, mas só retorna do def mais profundo que o cerca.</span>
<span class="c1">//AVISO: O uso do return em Scala é propenso a erros e deve ser evitado.</span>
<span class="c1">//Não há efeito em funções anônimas. Per exemplo:</span>
<span class="k">def</span> <span class="nf">foo</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">anonFunc</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">{</span> <span class="n">z</span> <span class="k">=&gt;</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">z</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="o">)</span>
      <span class="k">return</span> <span class="n">z</span> <span class="c1">// Esta linha faz Z retornar o valor de foo!</span>
    <span class="k">else</span>
      <span class="n">z</span> <span class="o">+</span> <span class="mi">2</span>    <span class="c1">// Esta linha retorna o valor de anonFunc</span>
  <span class="o">}</span>
  <span class="nf">anonFunc</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="c1">// Esta linha retorna o valor de foo</span>
<span class="o">}</span>

<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 3. Controle de Fluxo</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="mi">1</span> <span class="n">to</span> <span class="mi">5</span>
<span class="k">val</span> <span class="nv">r</span> <span class="k">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">5</span>
<span class="nv">r</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>

<span class="n">r</span> <span class="n">foreach</span> <span class="n">println</span>
<span class="c1">///N.B.: Scala é bem flexível quando se fala de pontos e parêntesis - estude as regras</span>
<span class="c1">//separadamente. Isso ajuda a escrever DSLs e APIs que são lidas como inglês.</span>

<span class="o">(</span><span class="mi">5</span> <span class="n">to</span> <span class="mi">1</span> <span class="n">by</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="nf">foreach</span> <span class="o">(</span><span class="n">println</span><span class="o">)</span>

<span class="c1">// Um loop while</span>
<span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
<span class="nf">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"i "</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">}</span>

<span class="nf">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"i "</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">}</span>   <span class="c1">// Sim, de novo. O que aconteceu? Por quê?</span>

<span class="n">i</span>    <span class="c1">// Exibe o valor de i. Note que o while é um loop no senso clássico -</span>
     <span class="c1">// executa sequencialmente enquanto muda a variável do loop. While é muito</span>
     <span class="c1">// rápido, mas usar os combinadores e compreenões acima é mais fácil</span>
     <span class="c1">// para entender e paralizar</span>

<span class="c1">// Um loop do-while</span>
<span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">do</span> <span class="o">{</span>
  <span class="nf">println</span><span class="o">(</span><span class="s">"i ainda é menor que 10"</span><span class="o">)</span>
  <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="o">}</span> <span class="nf">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span>


<span class="c1">// Recursão é a forma mais idiomática de repetir uma ação em Scala (assim como na</span>
<span class="c1">// maioria das linguagens de programação funcional)</span>
<span class="c1">// Funções recursivas precisam de um tipo de retorno explícito, o compilador não</span>
<span class="c1">// consegue inferir;</span>
<span class="c1">// Aqui está o Unit</span>
<span class="k">def</span> <span class="nf">showNumbersInRange</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="nf">print</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
  <span class="nf">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">)</span>
    <span class="nf">showNumbersInRange</span><span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
<span class="o">}</span>
<span class="nf">showNumbersInRange</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">14</span><span class="o">)</span>

<span class="c1">// Condicionais</span>

<span class="n">al</span> <span class="n">x</span> <span class="k">=</span> <span class="mi">10</span>

<span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="nf">println</span><span class="o">(</span><span class="s">"yeah"</span><span class="o">)</span>
<span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">10</span><span class="o">)</span> <span class="nf">println</span><span class="o">(</span><span class="s">"yeah"</span><span class="o">)</span>
<span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">11</span><span class="o">)</span> <span class="nf">println</span><span class="o">(</span><span class="s">"yeah"</span><span class="o">)</span>
<span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">11</span><span class="o">)</span> <span class="nf">println</span><span class="o">(</span><span class="s">"yeah"</span><span class="o">)</span> <span class="k">else</span> <span class="nf">println</span><span class="o">(</span><span class="s">"nay"</span><span class="o">)</span>

<span class="nf">println</span><span class="o">(</span><span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">10</span><span class="o">)</span> <span class="s">"yeah"</span> <span class="k">else</span> <span class="s">"nope"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">text</span> <span class="k">=</span> <span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">10</span><span class="o">)</span> <span class="s">"yeah"</span> <span class="k">else</span> <span class="s">"nope"</span>

<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 4. Estrutura de Dados</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="k">val</span> <span class="nv">a</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">13</span><span class="o">)</span>
<span class="nf">a</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>     <span class="c1">// Int = 1</span>
<span class="nf">a</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>     <span class="c1">// Int = 5</span>
<span class="nf">a</span><span class="o">(</span><span class="mi">21</span><span class="o">)</span>    <span class="c1">// Lança uma exceção</span>

<span class="k">val</span> <span class="nv">safeM</span> <span class="k">=</span> <span class="nv">m</span><span class="o">.</span><span class="py">withDefaultValue</span><span class="o">(</span><span class="s">"no lo se"</span><span class="o">)</span>
<span class="nf">safeM</span><span class="o">(</span><span class="s">"bottle"</span><span class="o">)</span>   <span class="c1">// java.lang.String = no lo se</span>

<span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>
<span class="nf">s</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>      <span class="c1">// Boolean = false</span>
<span class="nf">s</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>      <span class="c1">// Boolean = true</span>

<span class="cm">/* Veja a documantação do map aqui -
 * http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Map
 * e garanta que você leia
 */</span>

 <span class="c1">// Tuplas</span>

 <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

 <span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

 <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="s">"three"</span><span class="o">)</span>

 <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="s">"three"</span><span class="o">)</span>

 <span class="c1">//Por que ter isso?</span>
 <span class="k">val</span> <span class="nv">divideInts</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="o">%</span> <span class="n">y</span><span class="o">)</span>

<span class="c1">//A função divideInts te dá o resultado e o resultado</span>
<span class="nf">divideInts</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>    <span class="c1">// (Int, Int) = (3,1)</span>

<span class="c1">//Para acessar os elementos de uma tupla, use _._n onde n é o índex do elemento</span>

<span class="k">val</span> <span class="nv">d</span> <span class="k">=</span> <span class="nf">divideInts</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>    <span class="c1">// (Int, Int) = (3,1)</span>

<span class="nv">d</span><span class="o">.</span><span class="py">_1</span>    <span class="c1">// Int = 3</span>
<span class="nv">d</span><span class="o">.</span><span class="py">_2</span>    <span class="c1">// Int = 1</span>

<span class="c1">// Alternativamente, você pode atribuir múltiplas variáveis para uma tupla, o</span>
<span class="c1">// que é mais conveniente e legível em muitos casos</span>
<span class="nf">val</span> <span class="o">(</span><span class="n">div</span><span class="o">,</span> <span class="n">mod</span><span class="o">)</span> <span class="k">=</span> <span class="nf">divideInts</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">div</span>     <span class="c1">// Int = 3</span>
<span class="n">mod</span>     <span class="c1">// Int = 1</span>

<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 5. Object Oriented Programming</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="cm">/*
    Tudo o que vimos até agora neste tutorial foram expressões simples (valores, funções, etc).
    Essas expressões são boas para digitar no interpretador da linha de comando para
    testes rápidos, mas elas não podem existir por si só em um arquivo Scala. Por exemplo,
    você não pode ter simplesmente "val x = 5" em um arquivo Scala. Ao invés disso, os únicos
    construtores de alto nível permitidos em Scala são:

    - objects
    - classes
    - case classes
    - traits

    E agora vamos explicar o que é cada um deles.
*/</span>

<span class="c1">//classes são similares a classes em outras linguagens. Os argumentos do construtor</span>
<span class="c1">// são declarados logo depois do nome da classe e a inicialização é feita no corpo da classe.</span>

<span class="k">class</span> <span class="nc">Dog</span><span class="o">(</span><span class="n">br</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// codigo do construtor aqui</span>
  <span class="k">var</span> <span class="n">breed</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">br</span>

  <span class="c1">// Define um método chamado bark que retorna uma String</span>
  <span class="k">def</span> <span class="nf">bark</span> <span class="k">=</span> <span class="s">"Woof, woof!"</span>

  <span class="c1">// Assume-se que os métodos e valores são públicos. As palavras chave "protected"</span>
  <span class="c1">// e "private" também estão disponíveis.</span>
  <span class="k">private</span> <span class="k">def</span> <span class="nf">sleep</span><span class="o">(</span><span class="n">hours</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span>
    <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"I'm sleeping for $hours hours"</span><span class="o">)</span>

  <span class="c1">// Métodos abstratos são simplesmente métodos sem corpo. Se a gente remover o</span>
  <span class="c1">// comentário da próxima linha a classe Dog teria que ser declarada como abstrata</span>

  <span class="c1">//   abstract class Dog(...) { ... }</span>
  <span class="c1">// def chaseAfter(what: String): String</span>
<span class="o">}</span>

<span class="c1">// A palavra chave "object" cria um tipo e uma instância singlenton desse tipo.</span>
<span class="c1">// É comum para classes em Scala ter um "companion object" (objeto companheiro),</span>
<span class="c1">// onde, por exemlo, o comportamento é capturado pelas classes em si, mas o comportamento</span>
<span class="c1">// relacionado a toda instância da classe vai em objects. A diferença é semelhante</span>
<span class="c1">// a métodos versus métodos estáticos em outras linguagens. Note que objects e</span>
<span class="c1">// classes podem ter o mesmo nome.</span>

<span class="k">object</span> <span class="nc">Dog</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">allKnownBreeds</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"pitbull"</span><span class="o">,</span> <span class="s">"shepherd"</span><span class="o">,</span> <span class="s">"retriever"</span><span class="o">)</span>
  <span class="k">def</span> <span class="nf">createDog</span><span class="o">(</span><span class="n">breed</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">(</span><span class="n">breed</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// Case classes são classes que possuem uma funcionalidade extra incorporada.</span>
<span class="c1">// Uma dúvida comum para iniciantes em Scala é quando usar classes e quando usar</span>
<span class="c1">// case classes. A linha é bem tênue, mas em geral classes tendem a focar em encapsulamento,</span>
<span class="c1">// polimorfismo e comportamento. Os valores nestas classes tendem a ser privados e</span>
<span class="c1">// apenas métodos ficam expostos. O propósito primário de uma case class é guardar</span>
<span class="c1">// dados imutáveis. Às vezes as case classes possuem alguns poucos métodos, os quais</span>
<span class="c1">// raramente possuem efeitos colaterais (side effects).</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">phoneNumber</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="c1">// Cria uma nova instância. Observe que case classes não precisam de usar "new" ao serem instanciadas</span>
<span class="k">val</span> <span class="nv">george</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"George"</span><span class="o">,</span> <span class="s">"1234"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">kate</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Kate"</span><span class="o">,</span> <span class="s">"4567"</span><span class="o">)</span>

<span class="c1">// Com case classes você ganha algumas regalias, como getters:</span>
<span class="c1">// With case classes, you get a few perks for free, like getters:</span>
<span class="nv">george</span><span class="o">.</span><span class="py">phoneNumber</span>  <span class="c1">// =&gt; "1234"</span>

<span class="c1">// Verificação de igualdade por campo (sem a necessidade de sobrescrever o método equals)</span>
<span class="nc">Person</span><span class="o">(</span><span class="s">"George"</span><span class="o">,</span> <span class="s">"1234"</span><span class="o">)</span> <span class="o">==</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Kate"</span><span class="o">,</span> <span class="s">"1236"</span><span class="o">)</span>  <span class="c1">// =&gt; false</span>

<span class="c1">// Uma maneira fácil de copiar</span>
<span class="c1">// otherGeorge == Person("george", "9876")</span>
<span class="k">val</span> <span class="nv">otherGeorge</span> <span class="k">=</span> <span class="nv">george</span><span class="o">.</span><span class="py">copy</span><span class="o">(</span><span class="n">phoneNumber</span> <span class="k">=</span> <span class="s">"9876"</span><span class="o">)</span>

<span class="c1">// E muitas outras. Case classes também possuem pattern matching de graça. Veja no próximo tópico.</span>

<span class="c1">// Traits a caminho.</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 6. Pattern Matching</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Pattern matching é um recurso muito poderoso e muito usado em Scala. Aqui</span>
<span class="c1">// mostramos como o seu pattern se adequa a uma case class.</span>
<span class="c1">// NB: Diferente de outras linguagens, Scala não precisa de quebras. Entrar em</span>
<span class="c1">// todas as condições do pattern matching simples não acontece.</span>

<span class="k">def</span> <span class="nf">matchPerson</span><span class="o">(</span><span class="n">person</span><span class="k">:</span> <span class="kt">Person</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">person</span> <span class="k">match</span> <span class="o">{</span>
  <span class="c1">// Enrão você especifica os padrões</span>
  <span class="k">case</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"George"</span><span class="o">,</span> <span class="n">number</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"We found George! His number is "</span> <span class="o">+</span> <span class="n">number</span>
  <span class="k">case</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Kate"</span><span class="o">,</span> <span class="n">number</span><span class="o">)</span>   <span class="k">=&gt;</span> <span class="s">"We found Kate! Her number is "</span> <span class="o">+</span> <span class="n">number</span>
  <span class="k">case</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">number</span><span class="o">)</span>     <span class="k">=&gt;</span> <span class="s">"We matched someone : "</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">", phone : "</span> <span class="o">+</span> <span class="n">number</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">email</span> <span class="k">=</span> <span class="s">"(.*)@(.*)"</span><span class="o">.</span><span class="py">r</span>  <span class="c1">// Define uma regex para o próximo exemplo.</span>

<span class="c1">// Pattern matching pode parecer com o comando switch nas liguagens da família C,</span>
<span class="c1">// mas é muito mais poderoso. Em Scala você pode encontrar mais correpondências:</span>

<span class="k">def</span> <span class="nf">matchEverything</span><span class="o">(</span><span class="n">obj</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">obj</span> <span class="k">match</span> <span class="o">{</span>
  <span class="c1">// Você pode encontrar valores correspondentes:</span>
  <span class="k">case</span> <span class="s">"Hello world"</span> <span class="k">=&gt;</span> <span class="s">"Got the string Hello world"</span>

  <span class="c1">// Você pode fazer correspondência por tipo:</span>
  <span class="k">case</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=&gt;</span> <span class="s">"Got a Double: "</span> <span class="o">+</span> <span class="n">x</span>

  <span class="c1">// Você pode especificar condições:</span>
  <span class="k">case</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span> <span class="kt">if</span> <span class="kt">x</span> <span class="kt">&gt;</span> <span class="err">10000</span> <span class="o">=&gt;</span> <span class="s">"Got a pretty big number!"</span>

  <span class="c1">// Você pode encontrar correspondência com case classes, como fizemos antes:</span>
  <span class="k">case</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">number</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"Got contact info for $name!"</span>

  <span class="c1">// Você pode encontrar correspondências por regex:</span>
  <span class="k">case</span> <span class="nf">email</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">domain</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"Got email address $name@$domain"</span>

  <span class="c1">// Você pode encontrar correspondencias por tuplas:</span>
  <span class="nf">case</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">c</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"Got a tuple: $a, $b, $c"</span>

  <span class="c1">// Você pode encontrar corresponências por estruturas de dados:</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"Got a list with three elements and starts with 1: 1, $b, $c"</span>

  <span class="c1">// Você pode aninhar padrões:</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="s">"YAY"</span><span class="o">)))</span> <span class="k">=&gt;</span> <span class="s">"Got a list of list of tuple"</span>

  <span class="c1">// Retornar qualquer valor (padrão - default) caso nenhuma das possibilidades é correspondente.</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"Got unknown object"</span>

  <span class="c1">// Na verdade, você pode fazer correspondência de padrão de qualquer objeto que</span>
  <span class="c1">// tenha o método "unnaply". Este recurso é tão poderoso que o Scala te deixa</span>
  <span class="c1">// criar funções inteiras como patterns:</span>

  <span class="k">val</span> <span class="nv">patternFunc</span><span class="k">:</span> <span class="kt">Person</span> <span class="o">=&gt;</span> <span class="nc">String</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"George"</span><span class="o">,</span> <span class="n">number</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"George's number: $number"</span>
    <span class="k">case</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">number</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"Random person's number: $number"</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 7. Programação Funcional</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Scala permite que métodos e funções recebam ou retornem outras funções ou métodos.</span>

<span class="k">val</span> <span class="nv">add10</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="k">_</span> <span class="o">+</span> <span class="mi">10</span> <span class="c1">// A function taking an Int and returning an Int</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="n">map</span> <span class="n">add10</span> <span class="c1">// List(11, 12, 13) - add10 is applied to each element</span>

<span class="c1">// Funções anônimas podem ser usadas ao invés de funções com nomes:</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">10</span><span class="o">)</span>

<span class="c1">// E o símbolo underline ("_") pode ser usado quando há apenas um argumento para a função anônima.</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">10</span><span class="o">)</span>

<span class="c1">// Se tanto o bloco animo quanto a função que você estiver usando receberem apenas</span>
<span class="c1">// um argumento, você pode inclusive omitir o símbolo _</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">10</span><span class="o">)</span>

<span class="c1">// Combinadores</span>

<span class="nv">s</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">sq</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">sSquared</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span> <span class="nf">map</span><span class="o">(</span><span class="n">sq</span><span class="o">)</span>

<span class="nv">sSquared</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="k">_</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span>

<span class="nv">sSquared</span><span class="o">.</span><span class="py">reduce</span> <span class="o">(</span><span class="k">_</span><span class="o">+</span><span class="k">_</span><span class="o">)</span>

<span class="c1">// A função filter recebe um predicado (uma função do tipo A -&gt; Boolean) e seleciona</span>
<span class="c1">// todos os elementos que satisfazem o predicado.</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="nf">filter</span> <span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="c1">// List(3)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(</span>
  <span class="nc">Person</span><span class="o">(</span><span class="n">name</span> <span class="k">=</span> <span class="s">"Dom"</span><span class="o">,</span> <span class="n">age</span> <span class="k">=</span> <span class="mi">23</span><span class="o">),</span>
  <span class="nc">Person</span><span class="o">(</span><span class="n">name</span> <span class="k">=</span> <span class="s">"Bob"</span><span class="o">,</span> <span class="n">age</span> <span class="k">=</span> <span class="mi">30</span><span class="o">)</span>
<span class="o">).</span><span class="py">filter</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">age</span> <span class="o">&gt;</span> <span class="mi">25</span><span class="o">)</span> <span class="c1">// List(Person("Bob", 30))</span>

<span class="c1">// Scala tem o método foreach definido em algumas collections em específico, o qual</span>
<span class="c1">// recebe um tipo e retorna Unit (um método void)</span>
<span class="k">val</span> <span class="nv">aListOfNumbers</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">100</span><span class="o">)</span>
<span class="n">aListOfNumbers</span> <span class="nf">foreach</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
<span class="n">aListOfNumbers</span> <span class="n">foreach</span> <span class="n">println</span>

<span class="cm">/* NB Ests não são laços for. A semântica dos laços for é 'repetir' enquanto um
  for-comprehension define um relacionamento entre dois conjuntos de dados */</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 8. Implicits</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="cm">/* ALERTA ALERTA:
  Implicits são um conjunto de recursos poderosos de Scala e consequentemente é
  fácil abusar deles. Iniciantes em Scala deveriam resistir a tentação de usá-los
  até que eles entendam não apenas como eles funcionam mas também as melhores práticas
  deles. Incluimos uma sessão neste tutorial sobre isso porque implicits são tão
  corriqueiros em bibliotecas do Scala que é impossível fazer qualqeuer coisa expressiva
  sem utilizar uma biblioteca que usa implicits. Isto é para você entender e trabalhar
  com implicits. Não declare seus próprios implicits por conta própria.
*/</span>

<span class="c1">// qualquer valor (val, function, objects, etc) pode ser declarado para ser implícito</span>
<span class="c1">// usando a, você adivinhou, palavra chave "implicit". Usaremos a classe Dog definida</span>
<span class="c1">// na sessão 5 para os próximos exemplos.</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="nv">myImplicitInt</span> <span class="k">=</span> <span class="mi">100</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="nf">myImplicitFunction</span><span class="o">(</span><span class="n">breed</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">(</span><span class="s">"Golden "</span> <span class="o">+</span> <span class="n">breed</span><span class="o">)</span>

<span class="c1">// A palavra chave implicit não muda o comportamento do valor por si só, então</span>
<span class="c1">// os valores acima podem ser usados como de costume.</span>
<span class="n">myImplicitInt</span> <span class="o">+</span> <span class="mi">2</span>                   <span class="c1">// =&gt; 102</span>
<span class="nf">myImplicitFunction</span><span class="o">(</span><span class="s">"Pitbull"</span><span class="o">).</span><span class="py">breed</span> <span class="c1">// =&gt; "Golden Pitbull"</span>

<span class="n">A</span> <span class="n">diferença</span> <span class="n">é</span> <span class="n">que</span> <span class="n">agora</span> <span class="n">esses</span> <span class="n">valores</span> <span class="n">são</span> <span class="n">elegíveis</span> <span class="n">para</span> <span class="n">serem</span> <span class="n">usados</span> <span class="n">quando</span> <span class="n">outra</span>
<span class="c1">// parte do código "precisa" de um valor implícito. Uma situação é uma função</span>
<span class="c1">// com argumentos implícitos:</span>
<span class="k">def</span> <span class="nf">sendGreetings</span><span class="o">(</span><span class="n">toWhom</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">howMany</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span>
  <span class="n">s</span><span class="s">"Hello $toWhom, $howMany blessings to you and yours!"</span>

<span class="c1">// Se fornecermos um valor para "howMany" a função se comporta como sempre</span>
<span class="nf">sendGreetings</span><span class="o">(</span><span class="s">"John"</span><span class="o">)(</span><span class="mi">1000</span><span class="o">)</span>  <span class="c1">// =&gt; "Hello John, 1000 blessings to you and yours!"</span>

<span class="c1">// Mas se omitirmos o parâmetro implícito um valor implícito de mesmo tipo é usado,</span>
<span class="c1">// neste caso, "myImplicitInt":</span>
<span class="nf">sendGreetings</span><span class="o">(</span><span class="s">"Jane"</span><span class="o">)</span>  <span class="c1">// =&gt; "Hello Jane, 100 blessings to you and yours!"</span>

<span class="c1">// Parâmetros implícitos de funções nos permitem simular type classes em outras</span>
<span class="c1">//linguagens funcionais. As linhas abaixo são a mesma coisa:</span>
<span class="c1">// def foo[T](implicit c: C[T]) = ...</span>
<span class="c1">// def foo[T : C] = ...</span>

<span class="c1">// Outro caso no qual o compilador procura por um implicit é quando você tem obj.method(...)</span>
<span class="c1">// mas "obj" não possui "method" como um método. Neste caso, se houver uma conversão</span>
<span class="c1">// de implicit do tipo A =&gt; B, onde A é o tipo do "obj" e B tem um método chamado</span>
<span class="c1">// "method", a conversão é aplicada. Então, tendo myImplicitFunction acima em escopo, podemos dizer:</span>
<span class="s">"Retriever"</span><span class="o">.</span><span class="py">breed</span> <span class="c1">// =&gt; "Golden Retriever"</span>
<span class="s">"Sheperd"</span><span class="o">.</span><span class="py">bark</span>    <span class="c1">// =&gt; "Woof, woof!"</span>

<span class="c1">// Aqui, a String é convertida para Dog usando nossa função acima, então o método</span>
<span class="c1">// apropriado é chamado. Isso é um recurso extremamente poderoso, mas de novo, não</span>
<span class="c1">// é para ser usado de maneira leviana. Na verdade, quando você define a função</span>
<span class="c1">// implícita, o seu compilador deve exibir um aviso de que você não deveria fazer isso,</span>
<span class="c1">// a menos que você realmente saiba o que você está fazendo.</span>

<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 9. Misc</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Importando coisas</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable.List</span>

<span class="c1">// Importando todos os sub pacotes</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable._</span>

<span class="c1">// Importando várias classes em um único comando</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable.</span><span class="o">{</span><span class="nc">List</span><span class="o">,</span> <span class="nc">Map</span><span class="o">}</span>

<span class="c1">// Renomeando um import usando '=&gt;'</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable.</span><span class="o">{</span><span class="nc">List</span> <span class="k">=&gt;</span> <span class="nc">ImmutableList</span><span class="o">}</span>

<span class="c1">// Importa todas as classes, com exceção de algumas. O import abaixo importa todas as classes excluindo Map e Set:</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable.</span><span class="o">{</span><span class="nc">Map</span> <span class="k">=&gt;</span> <span class="k">_</span><span class="o">,</span> <span class="nc">Set</span> <span class="k">=&gt;</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">}</span>

<span class="c1">// Classes Java também podem ser importadas. A syntaxe de Scala pode ser usada:</span>
<span class="k">import</span> <span class="nn">java.swing.</span><span class="o">{</span><span class="nc">JFrame</span><span class="o">,</span> <span class="nc">JWindow</span><span class="o">}</span>

<span class="c1">// O ponto de entrada do seu programa é definido em um arquivo Scala usando um object com um único método main:</span>
<span class="k">object</span> <span class="nc">Application</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="c1">// o código fica aqui</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Arquivos podem ter múltiplas classes e objects. Compile com scalac</span>

<span class="c1">// Entrada e saída</span>

<span class="c1">// Para ler um arquivo linha a linha</span>
<span class="k">import</span> <span class="nn">scala.io.Source</span>
<span class="nf">for</span><span class="o">(</span><span class="n">line</span> <span class="k">&lt;-</span> <span class="nv">Source</span><span class="o">.</span><span class="py">fromFile</span><span class="o">(</span><span class="s">"myfile.txt"</span><span class="o">).</span><span class="py">getLines</span><span class="o">())</span>
  <span class="nf">println</span><span class="o">(</span><span class="n">line</span><span class="o">)</span>

<span class="c1">// Para escrever um arquivo use o PrintWriter do Javaval writer = new PrintWriter("myfile.txt")</span>
<span class="nv">writer</span><span class="o">.</span><span class="py">write</span><span class="o">(</span><span class="s">"Writing line for line"</span> <span class="o">+</span> <span class="nv">util</span><span class="o">.</span><span class="py">Properties</span><span class="o">.</span><span class="py">lineSeparator</span><span class="o">)</span>
<span class="nv">writer</span><span class="o">.</span><span class="py">write</span><span class="o">(</span><span class="s">"Another line here"</span> <span class="o">+</span> <span class="nv">util</span><span class="o">.</span><span class="py">Properties</span><span class="o">.</span><span class="py">lineSeparator</span><span class="o">)</span>
<span class="nv">writer</span><span class="o">.</span><span class="py">close</span><span class="o">()</span>

<span class="o">#</span><span class="k">#</span>  <span class="nc">Recursos</span> <span class="n">adicionais</span>

<span class="o">*</span> <span class="o">[</span><span class="kt">Scala</span> <span class="kt">for</span> <span class="kt">the</span> <span class="kt">impatient</span><span class="o">](</span><span class="n">http</span><span class="o">://</span><span class="nv">horstmann</span><span class="o">.</span><span class="py">com</span><span class="o">/</span><span class="n">scala</span><span class="o">/)</span>
<span class="o">*</span> <span class="o">[</span><span class="kt">Twitter</span> <span class="kt">Scala</span> <span class="kt">school</span><span class="o">](</span><span class="n">http</span><span class="o">://</span><span class="nv">twitter</span><span class="o">.</span><span class="py">github</span><span class="o">.</span><span class="py">io</span><span class="o">/</span><span class="n">scala_school</span><span class="o">/)</span>
<span class="o">*</span> <span class="o">[</span><span class="kt">Documentação</span> <span class="kt">de</span> <span class="kt">Scala</span><span class="o">](</span><span class="n">http</span><span class="o">://</span><span class="nv">docs</span><span class="o">.</span><span class="py">scala</span><span class="o">-</span><span class="nv">lang</span><span class="o">.</span><span class="py">org</span><span class="o">/)</span>
<span class="o">*</span> <span class="o">[</span><span class="kt">Tente</span> <span class="kt">Scala</span> <span class="kt">no</span> <span class="kt">seu</span> <span class="kt">navegador</span><span class="o">](</span><span class="n">http</span><span class="o">://</span><span class="nv">scalatutorials</span><span class="o">.</span><span class="py">com</span><span class="o">/</span><span class="n">tour</span><span class="o">/)</span>
<span class="o">*</span> <span class="nc">Junte</span> <span class="o">[</span><span class="kt">Scala</span> <span class="kt">user</span> <span class="kt">group</span><span class="o">](</span><span class="n">https</span><span class="o">://</span><span class="nv">groups</span><span class="o">.</span><span class="py">google</span><span class="o">.</span><span class="py">com</span><span class="o">/</span><span class="n">forum</span><span class="o">/#!</span><span class="n">forum</span><span class="o">/</span><span class="n">scala</span><span class="o">-</span><span class="n">user</span><span class="o">)</span>
</code></pre></div>
    <hr>
    <p>Sugestões ou correções? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Abra uma issue</a> no repositório do Github, ou faça um <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/pt-br/scala-pt.html.markdown">pull request</a> você mesmo!
    </p>
    <p class="contributed">
    Originalmente contribuído por George Petrov e atualizado por <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/pt-br/scala-pt.html.markdown">3 colaborador(es)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://github.com/petrovg">George Petrov</a>,
        <a href="http://dbousamra.github.com">Dominic Bou-Samra</a>,
        <a href="http://geoffliu.me">Geoff Liu</a>,
        <a href="http://reference-error.org">Ha-Duong Nguyen</a>
    </p>

    <p>
      Translated by:
        <a href="https://github.com/FFrancieli">Francieli Viane</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>

        <script>
            var _gaq=[['_setAccount','UA-3525624-21'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>
</html>
