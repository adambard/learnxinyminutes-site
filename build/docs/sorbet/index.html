<!DOCTYPE html lang="en-us" xml:lang="en-us" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="en-us">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn sorbet in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/sorbet/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fsorbet%2F&text=Learn+X+in+Y+minutes%2C+where+X%3Dsorbet">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="/">Learn X in Y minutes</a></h1>
  <h2>Where X=sorbet</h2>
    <p class="filelink">
    Get the code:
    <a href="/docs/files/learnsorbet.rb">learnsorbet.rb</a>
    </p>
  <div id="doc">
    <p>Sorbet is a type checker for Ruby. It adds syntax for method signatures that
enable both static and runtime type checking.</p>

<p>The easiest way to see it in action is in the playground at
<a href="https://sorbet.run">sorbet.run</a>.</p>

<p>Try copying in one of the sections below! Each top-level <code>class</code> or <code>module</code>
is independent from the others.</p>
<div class="highlight"><pre class="highlight ruby"><code><span class="c1"># Every file should have a "typed sigil" that tells Sorbet how strict to be</span>
<span class="c1"># during static type checking.</span>
<span class="c1">#</span>
<span class="c1"># Strictness levels (lax to strict):</span>
<span class="c1">#</span>
<span class="c1"># ignore: Sorbet won't even read the file. This means its contents are not</span>
<span class="c1"># visible during type checking. Avoid this.</span>
<span class="c1">#</span>
<span class="c1"># false: Sorbet will only report errors related to constant resolution. This is</span>
<span class="c1"># the default if no sigil is included.</span>
<span class="c1">#</span>
<span class="c1"># true: Sorbet will report all static type errors. This is the sweet spot of</span>
<span class="c1"># safety for effort.</span>
<span class="c1">#</span>
<span class="c1"># strict: Sorbet will require that all methods, constants, and instance</span>
<span class="c1"># variables have static types.</span>
<span class="c1">#</span>
<span class="c1"># strong: Sorbet will no longer allow anything to be T.untyped, even</span>
<span class="c1"># explicitly. Almost nothing satisfies this.</span>

<span class="c1"># typed: true</span>

<span class="c1"># Include the runtime type-checking library. This lets you write inline sigs</span>
<span class="c1"># and have them checked at runtime (instead of running Sorbet as RBI-only).</span>
<span class="c1"># These runtime checks happen even for files with `ignore` or `false` sigils.</span>
<span class="nb">require</span> <span class="s1">'sorbet-runtime'</span>

<span class="k">class</span> <span class="nc">BasicSigs</span>
  <span class="c1"># Bring in the type definition helpers. You'll almost always need this.</span>
  <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>

  <span class="c1"># Sigs are defined with `sig` and a block. Define the return value type with</span>
  <span class="c1"># `returns`.</span>
  <span class="c1">#</span>
  <span class="c1"># This method returns a value whose class is `String`. These are the most</span>
  <span class="c1"># common types, and Sorbet calls them "class types".</span>
  <span class="n">sig</span> <span class="p">{</span> <span class="n">returns</span><span class="p">(</span><span class="no">String</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">greet</span>
    <span class="s1">'Hello, World!'</span>
  <span class="k">end</span>

  <span class="c1"># Define parameter value types with `params`.</span>
  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">n: </span><span class="no">Integer</span><span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">String</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">greet_repeat</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="n">n</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="n">greet</span> <span class="p">}.</span><span class="nf">join</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># Define keyword parameters the same way.</span>
  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">n: </span><span class="no">Integer</span><span class="p">,</span> <span class="ss">sep: </span><span class="no">String</span><span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">String</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">greet_repeat_2</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="ss">sep: </span><span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
    <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="n">n</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="n">greet</span> <span class="p">}.</span><span class="nf">join</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># Notice that positional/keyword and required/optional make no difference</span>
  <span class="c1"># here. They're all defined the same way in `params`.</span>

  <span class="c1"># For lots of parameters, it's nicer to use do..end and a multiline block</span>
  <span class="c1"># instead of curly braces.</span>
  <span class="n">sig</span> <span class="k">do</span>
    <span class="n">params</span><span class="p">(</span>
      <span class="ss">str: </span><span class="no">String</span><span class="p">,</span>
      <span class="ss">num: </span><span class="no">Integer</span><span class="p">,</span>
      <span class="ss">sym: </span><span class="no">Symbol</span><span class="p">,</span>
    <span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">String</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="k">def</span> <span class="nf">uhh</span><span class="p">(</span><span class="n">str</span><span class="p">:,</span> <span class="n">num</span><span class="p">:,</span> <span class="n">sym</span><span class="p">:)</span>
    <span class="s1">'What would you even do with these?'</span>
  <span class="k">end</span>

  <span class="c1"># For a method whose return value is useless, use `void`.</span>
  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">name: </span><span class="no">String</span><span class="p">).</span><span class="nf">void</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">say_hello</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="nb">puts</span> <span class="s2">"Hello, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">!"</span>
  <span class="k">end</span>

  <span class="c1"># Splats! Also known as "rest parameters", "*args", "**kwargs", and others.</span>
  <span class="c1">#</span>
  <span class="c1"># Type the value that a _member_ of `args` or `kwargs` will have, not `args`</span>
  <span class="c1"># or `kwargs` itself.</span>
  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">args: </span><span class="no">Integer</span><span class="p">,</span> <span class="ss">kwargs: </span><span class="no">String</span><span class="p">).</span><span class="nf">void</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">no_op</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="ss">:op</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'minus'</span>
      <span class="n">args</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="nb">puts</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">else</span>
      <span class="n">args</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="nb">puts</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># Most initializers should be `void`.</span>
  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">name: </span><span class="no">String</span><span class="p">).</span><span class="nf">void</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="nb">name</span><span class="p">:)</span>
    <span class="c1"># Instance variables must have annotated types to participate in static</span>
    <span class="c1"># type checking.</span>

    <span class="c1"># The value in `T.let` is checked statically and at runtime.</span>
    <span class="vi">@upname</span> <span class="o">=</span> <span class="no">T</span><span class="p">.</span><span class="nf">let</span><span class="p">(</span><span class="nb">name</span><span class="p">.</span><span class="nf">upcase</span><span class="p">,</span> <span class="no">String</span><span class="p">)</span>

    <span class="c1"># Sorbet can infer this one!</span>
    <span class="vi">@name</span> <span class="o">=</span> <span class="nb">name</span>
  <span class="k">end</span>

  <span class="c1"># Constants also need annotated types.</span>
  <span class="no">SORBET</span> <span class="o">=</span> <span class="no">T</span><span class="p">.</span><span class="nf">let</span><span class="p">(</span><span class="s1">'A delicious frozen treat'</span><span class="p">,</span> <span class="no">String</span><span class="p">)</span>

  <span class="c1"># Class variables too.</span>
  <span class="vc">@@the_answer</span> <span class="o">=</span> <span class="no">T</span><span class="p">.</span><span class="nf">let</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="no">Integer</span><span class="p">)</span>

  <span class="c1"># Sorbet knows about the `attr_*` family.</span>
  <span class="n">sig</span> <span class="p">{</span> <span class="n">returns</span><span class="p">(</span><span class="no">String</span><span class="p">)</span> <span class="p">}</span>
  <span class="nb">attr_reader</span> <span class="ss">:upname</span>

  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">write_only: </span><span class="no">Integer</span><span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">Integer</span><span class="p">)</span> <span class="p">}</span>
  <span class="nb">attr_writer</span> <span class="ss">:write_only</span>

  <span class="c1"># You say the reader part and Sorbet will say the writer part.</span>
  <span class="n">sig</span> <span class="p">{</span> <span class="n">returns</span><span class="p">(</span><span class="no">String</span><span class="p">)</span> <span class="p">}</span>
  <span class="nb">attr_accessor</span> <span class="ss">:name</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nn">Debugging</span>
  <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>

  <span class="c1"># Sometimes it's helpful to know what type Sorbet has inferred for an</span>
  <span class="c1"># expression. Use `T.reveal_type` to make type-checking show a special error</span>
  <span class="c1"># with that information.</span>
  <span class="c1">#</span>
  <span class="c1"># This is most useful if you have Sorbet integrated into your editor so you</span>
  <span class="c1"># can see the result as soon as you save the file.</span>

  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">obj: </span><span class="no">Object</span><span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">String</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">debug</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="no">T</span><span class="p">.</span><span class="nf">reveal_type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="c1"># Revealed type: Object</span>
    <span class="n">repr</span> <span class="o">=</span> <span class="n">obj</span><span class="p">.</span><span class="nf">inspect</span>

    <span class="c1"># Remember that Ruby methods can be called without arguments, so you can</span>
    <span class="c1"># save a couple characters!</span>
    <span class="no">T</span><span class="p">.</span><span class="nf">reveal_type</span> <span class="n">repr</span> <span class="c1"># Revealed type: String</span>

    <span class="s2">"DEBUG: "</span> <span class="o">+</span> <span class="n">repr</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nn">StandardLibrary</span>
  <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>
  <span class="c1"># Sorbet provides some helpers for typing the Ruby standard library.</span>

  <span class="c1"># Use T::Boolean to catch both `true` and `false`.</span>
  <span class="c1">#</span>
  <span class="c1"># For the curious, this is equivalent to</span>
  <span class="c1">#</span>
  <span class="c1">#     T.type_alias { T.any(TrueClass, FalseClass) }</span>
  <span class="c1">#</span>
  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">str: </span><span class="no">String</span><span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">T</span><span class="o">::</span><span class="no">Boolean</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">confirmed?</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
    <span class="n">str</span> <span class="o">==</span> <span class="s1">'yes'</span>
  <span class="k">end</span>

  <span class="c1"># Remember that the value `nil` is an instance of NilClass.</span>
  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">val: </span><span class="no">NilClass</span><span class="p">).</span><span class="nf">void</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">only_nil</span><span class="p">(</span><span class="n">val</span><span class="p">:);</span> <span class="k">end</span>

  <span class="c1"># To avoid modifying standard library classes, Sorbet provides wrappers to</span>
  <span class="c1"># support common generics.</span>
  <span class="c1">#</span>
  <span class="c1"># Here's the full list:</span>
  <span class="c1"># * T::Array</span>
  <span class="c1"># * T::Enumerable</span>
  <span class="c1"># * T::Enumerator</span>
  <span class="c1"># * T::Hash</span>
  <span class="c1"># * T::Range</span>
  <span class="c1"># * T::Set</span>
  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">config: </span><span class="no">T</span><span class="o">::</span><span class="no">Hash</span><span class="p">[</span><span class="no">Symbol</span><span class="p">,</span> <span class="no">String</span><span class="p">]).</span><span class="nf">returns</span><span class="p">(</span><span class="no">T</span><span class="o">::</span><span class="no">Array</span><span class="p">[</span><span class="no">String</span><span class="p">])</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">merge_values</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
    <span class="n">keyset</span> <span class="o">=</span> <span class="p">[</span><span class="ss">:old_key</span><span class="p">,</span> <span class="ss">:new_key</span><span class="p">]</span>
    <span class="n">config</span><span class="p">.</span><span class="nf">each_pair</span><span class="p">.</span><span class="nf">flat_map</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">|</span>
      <span class="n">keyset</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="p">?</span> <span class="n">value</span> <span class="p">:</span> <span class="s1">'sensible default'</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># Sometimes (usually dependency injection), a method will accept a reference</span>
  <span class="c1"># to a class rather than an instance of the class. Use `T.class_of(Dep)` to</span>
  <span class="c1"># accept the `Dep` class itself (or something that inherits from it).</span>
  <span class="k">class</span> <span class="nc">Dep</span><span class="p">;</span> <span class="k">end</span>

  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">dep: </span><span class="no">T</span><span class="p">.</span><span class="nf">class_of</span><span class="p">(</span><span class="no">Dep</span><span class="p">)).</span><span class="nf">returns</span><span class="p">(</span><span class="no">Dep</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">dependency_injection</span><span class="p">(</span><span class="n">dep</span><span class="p">:)</span>
    <span class="n">dep</span><span class="p">.</span><span class="nf">new</span>
  <span class="k">end</span>

  <span class="c1"># Blocks, procs, and lambdas, oh my! All of these are typed with `T.proc`.</span>
  <span class="c1">#</span>
  <span class="c1"># Limitations:</span>
  <span class="c1"># 1. All parameters are assumed to be required positional parameters.</span>
  <span class="c1"># 2. The only runtime check is that the value is a `Proc`. The argument types</span>
  <span class="c1">#    are only checked statically.</span>
  <span class="n">sig</span> <span class="k">do</span>
    <span class="n">params</span><span class="p">(</span>
      <span class="ss">data: </span><span class="no">T</span><span class="o">::</span><span class="no">Array</span><span class="p">[</span><span class="no">String</span><span class="p">],</span>
      <span class="ss">blk: </span><span class="no">T</span><span class="p">.</span><span class="nf">proc</span><span class="p">.</span><span class="nf">params</span><span class="p">(</span><span class="ss">val: </span><span class="no">String</span><span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">Integer</span><span class="p">),</span>
    <span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">Integer</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blk</span><span class="p">)</span>
    <span class="n">data</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blk</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">sig</span> <span class="p">{</span> <span class="n">returns</span><span class="p">(</span><span class="no">Integer</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">count_usage</span>
    <span class="n">count</span><span class="p">([</span><span class="s2">"one"</span><span class="p">,</span> <span class="s2">"two"</span><span class="p">,</span> <span class="s2">"three"</span><span class="p">])</span> <span class="p">{</span> <span class="o">|</span><span class="n">word</span><span class="o">|</span> <span class="n">word</span><span class="p">.</span><span class="nf">length</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="c1"># If the method takes an implicit block, Sorbet will infer `T.untyped` for</span>
  <span class="c1"># it. Use the explicit block syntax if the types are important.</span>
  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">str: </span><span class="no">String</span><span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">T</span><span class="p">.</span><span class="nf">untyped</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">implicit_block</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
    <span class="k">yield</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># If you're writing a DSL and will execute the block in a different context,</span>
  <span class="c1"># use `bind`.</span>
  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">num: </span><span class="no">Integer</span><span class="p">,</span> <span class="ss">blk: </span><span class="no">T</span><span class="p">.</span><span class="nf">proc</span><span class="p">.</span><span class="nf">bind</span><span class="p">(</span><span class="no">Integer</span><span class="p">).</span><span class="nf">void</span><span class="p">).</span><span class="nf">void</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">number_fun</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blk</span><span class="p">)</span>
    <span class="n">num</span><span class="p">.</span><span class="nf">instance_eval</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blk</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">num: </span><span class="no">Integer</span><span class="p">).</span><span class="nf">void</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">number_fun_usage</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="n">number_fun</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="p">{</span> <span class="nb">puts</span> <span class="n">digits</span><span class="p">.</span><span class="nf">join</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="c1"># If the block doesn't take any parameters, don't include `params`.</span>
  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">blk: </span><span class="no">T</span><span class="p">.</span><span class="nf">proc</span><span class="p">.</span><span class="nf">returns</span><span class="p">(</span><span class="no">Integer</span><span class="p">)).</span><span class="nf">returns</span><span class="p">(</span><span class="no">Integer</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">doubled_block</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blk</span><span class="p">)</span>
    <span class="mi">2</span> <span class="o">*</span> <span class="n">blk</span><span class="p">.</span><span class="nf">call</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nn">Combinators</span>
  <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>
  <span class="c1"># These methods let you define new types from existing types.</span>

  <span class="c1"># Use `T.any` when you have a value that can be one of many types. These are</span>
  <span class="c1"># sometimes known as "union types" or "sum types".</span>
  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">num: </span><span class="no">T</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="no">Integer</span><span class="p">,</span> <span class="no">Float</span><span class="p">)).</span><span class="nf">returns</span><span class="p">(</span><span class="no">Rational</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">hundreds</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="n">num</span><span class="p">.</span><span class="nf">rationalize</span>
  <span class="k">end</span>

  <span class="c1"># `T.nilable(Type)` is a convenient alias for `T.any(Type, NilClass)`.</span>
  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">val: </span><span class="no">T</span><span class="p">.</span><span class="nf">nilable</span><span class="p">(</span><span class="no">String</span><span class="p">)).</span><span class="nf">returns</span><span class="p">(</span><span class="no">Integer</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="n">val</span><span class="p">.</span><span class="nf">nil?</span> <span class="p">?</span> <span class="o">-</span><span class="mi">1</span> <span class="p">:</span> <span class="n">val</span><span class="p">.</span><span class="nf">length</span>
  <span class="k">end</span>

  <span class="c1"># Use `T.all` when you have a value that must satisfy multiple types. These</span>
  <span class="c1"># are sometimes known as "intersection types". They're most useful for</span>
  <span class="c1"># interfaces (described later), but can also describe helper modules.</span>

  <span class="k">module</span> <span class="nn">Reversible</span>
    <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>
    <span class="n">sig</span> <span class="p">{</span> <span class="n">void</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nf">reverse</span>
      <span class="c1"># Pretend this is actually implemented</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">module</span> <span class="nn">Sortable</span>
    <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>
    <span class="n">sig</span> <span class="p">{</span> <span class="n">void</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nf">sort</span>
      <span class="c1"># Pretend this is actually implemented</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">class</span> <span class="nc">List</span>
    <span class="kp">include</span> <span class="no">Reversible</span>
    <span class="kp">include</span> <span class="no">Sortable</span>
  <span class="k">end</span>

  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">list: </span><span class="no">T</span><span class="p">.</span><span class="nf">all</span><span class="p">(</span><span class="no">Reversible</span><span class="p">,</span> <span class="no">Sortable</span><span class="p">)).</span><span class="nf">void</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">rev_sort</span><span class="p">(</span><span class="n">list</span><span class="p">)</span>
    <span class="c1"># reverse from Reversible</span>
    <span class="n">list</span><span class="p">.</span><span class="nf">reverse</span>
    <span class="c1"># sort from Sortable</span>
    <span class="n">list</span><span class="p">.</span><span class="nf">sort</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">rev_sort_usage</span>
    <span class="n">rev_sort</span><span class="p">(</span><span class="no">List</span><span class="p">.</span><span class="nf">new</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># Sometimes, actually spelling out the type every time becomes more confusing</span>
  <span class="c1"># than helpful. Use type aliases to make them easier to work with.</span>
  <span class="no">JSONLiteral</span> <span class="o">=</span> <span class="no">T</span><span class="p">.</span><span class="nf">type_alias</span> <span class="p">{</span> <span class="no">T</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="no">Float</span><span class="p">,</span> <span class="no">String</span><span class="p">,</span> <span class="no">T</span><span class="o">::</span><span class="no">Boolean</span><span class="p">,</span> <span class="no">NilClass</span><span class="p">)</span> <span class="p">}</span>

  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">val: </span><span class="no">JSONLiteral</span><span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">String</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">stringify</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="n">val</span><span class="p">.</span><span class="nf">to_s</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nn">DataClasses</span>
  <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>
  <span class="c1"># Use `T::Struct` to create a new class with type-checked fields. It combines</span>
  <span class="c1"># the best parts of the standard Struct and OpenStruct, and then adds static</span>
  <span class="c1"># typing on top.</span>
  <span class="c1">#</span>
  <span class="c1"># Types constructed this way are sometimes known as "product types".</span>

  <span class="k">class</span> <span class="nc">Matcher</span> <span class="o">&lt;</span> <span class="no">T</span><span class="o">::</span><span class="no">Struct</span>
    <span class="c1"># Use `prop` to define a field with both a reader and writer.</span>
    <span class="n">prop</span> <span class="ss">:count</span><span class="p">,</span> <span class="no">Integer</span>
    <span class="c1"># Use `const` to only define the reader and skip the writer.</span>
    <span class="n">const</span> <span class="ss">:pattern</span><span class="p">,</span> <span class="no">Regexp</span>
    <span class="c1"># You can still set a default value with `default`.</span>
    <span class="n">const</span> <span class="ss">:message</span><span class="p">,</span> <span class="no">String</span><span class="p">,</span> <span class="ss">default: </span><span class="s1">'Found one!'</span>

    <span class="c1"># This is otherwise a normal class, so you can still define methods.</span>

    <span class="c1"># You'll still need to bring `sig` in if you want to use it though.</span>
    <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>

    <span class="n">sig</span> <span class="p">{</span> <span class="n">void</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nf">reset</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">text: </span><span class="no">String</span><span class="p">,</span> <span class="ss">matchers: </span><span class="no">T</span><span class="o">::</span><span class="no">Array</span><span class="p">[</span><span class="no">Matcher</span><span class="p">]).</span><span class="nf">void</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">awk</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">matchers</span><span class="p">)</span>
    <span class="n">matchers</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:reset</span><span class="p">)</span>
    <span class="n">text</span><span class="p">.</span><span class="nf">lines</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">line</span><span class="o">|</span>
      <span class="n">matchers</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">matcher</span><span class="o">|</span>
        <span class="k">if</span> <span class="n">matcher</span><span class="p">.</span><span class="nf">pattern</span> <span class="o">=~</span> <span class="n">line</span>
          <span class="no">Kernel</span><span class="p">.</span><span class="nf">puts</span> <span class="n">matcher</span><span class="p">.</span><span class="nf">message</span>
          <span class="n">matcher</span><span class="p">.</span><span class="nf">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># Gotchas and limitations</span>

  <span class="c1"># 1. `const` fields are not truly immutable. They don't have a writer method,</span>
  <span class="c1">#    but may be changed in other ways.</span>
  <span class="k">class</span> <span class="nc">ChangeMe</span> <span class="o">&lt;</span> <span class="no">T</span><span class="o">::</span><span class="no">Struct</span>
    <span class="n">const</span> <span class="ss">:list</span><span class="p">,</span> <span class="no">T</span><span class="o">::</span><span class="no">Array</span><span class="p">[</span><span class="no">Integer</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">change_me: </span><span class="no">ChangeMe</span><span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">T</span><span class="o">::</span><span class="no">Boolean</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">whoops!</span><span class="p">(</span><span class="n">change_me</span><span class="p">)</span>
    <span class="n">change_me</span> <span class="o">=</span> <span class="no">ChangeMe</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">list: </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
    <span class="n">change_me</span><span class="p">.</span><span class="nf">list</span><span class="p">.</span><span class="nf">reverse!</span>
    <span class="n">change_me</span><span class="p">.</span><span class="nf">list</span> <span class="o">==</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="c1"># 2. `T::Struct` inherits its equality method from `BasicObject`, which uses</span>
  <span class="c1">#    identity equality (also known as "reference equality").</span>
  <span class="k">class</span> <span class="nc">Coordinate</span> <span class="o">&lt;</span> <span class="no">T</span><span class="o">::</span><span class="no">Struct</span>
    <span class="n">const</span> <span class="ss">:row</span><span class="p">,</span> <span class="no">Integer</span>
    <span class="n">const</span> <span class="ss">:col</span><span class="p">,</span> <span class="no">Integer</span>
  <span class="k">end</span>

  <span class="n">sig</span> <span class="p">{</span> <span class="n">returns</span><span class="p">(</span><span class="no">T</span><span class="o">::</span><span class="no">Boolean</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">never_equal!</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="no">Coordinate</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">row: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">col: </span><span class="mi">2</span><span class="p">)</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="no">Coordinate</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">row: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">col: </span><span class="mi">2</span><span class="p">)</span>
    <span class="n">p1</span> <span class="o">!=</span> <span class="n">p2</span>
  <span class="k">end</span>

  <span class="c1"># Define your own `#==` method to check the fields, if that's what you want.</span>
  <span class="k">class</span> <span class="nc">Position</span> <span class="o">&lt;</span> <span class="no">T</span><span class="o">::</span><span class="no">Struct</span>
    <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>

    <span class="n">const</span> <span class="ss">:x</span><span class="p">,</span> <span class="no">Integer</span>
    <span class="n">const</span> <span class="ss">:y</span><span class="p">,</span> <span class="no">Integer</span>

    <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">other: </span><span class="no">Object</span><span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">T</span><span class="o">::</span><span class="no">Boolean</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nf">==</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
      <span class="c1"># There's a real implementation here:</span>
      <span class="c1"># https://github.com/tricycle/sorbet-struct-comparable</span>
      <span class="kp">true</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># Use `T::Enum` to define a fixed set of values that are easy to reference.</span>
  <span class="c1"># This is especially useful when you don't care what the values _are_ as much</span>
  <span class="c1"># as you care that the set of possibilities is closed and static.</span>
  <span class="k">class</span> <span class="nc">Crayon</span> <span class="o">&lt;</span> <span class="no">T</span><span class="o">::</span><span class="no">Enum</span>
    <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>

    <span class="c1"># Initialize members with `enums`.</span>
    <span class="n">enums</span> <span class="k">do</span>
      <span class="c1"># Define each member with `new`. Each of these is an instance of the</span>
      <span class="c1"># `Crayon` class.</span>
      <span class="no">Red</span> <span class="o">=</span> <span class="n">new</span>
      <span class="no">Orange</span> <span class="o">=</span> <span class="n">new</span>
      <span class="no">Yellow</span> <span class="o">=</span> <span class="n">new</span>
      <span class="no">Green</span> <span class="o">=</span> <span class="n">new</span>
      <span class="no">Blue</span> <span class="o">=</span> <span class="n">new</span>
      <span class="no">Violet</span> <span class="o">=</span> <span class="n">new</span>
      <span class="no">Brown</span> <span class="o">=</span> <span class="n">new</span>
      <span class="no">Black</span> <span class="o">=</span> <span class="n">new</span>
      <span class="c1"># The default value of the enum is its name in all-lowercase. To change</span>
      <span class="c1"># that, pass a value to `new`.</span>
      <span class="no">Gray90</span> <span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="s1">'light-gray'</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">sig</span> <span class="p">{</span> <span class="n">returns</span><span class="p">(</span><span class="no">String</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nf">to_hex</span>
      <span class="k">case</span> <span class="nb">self</span>
      <span class="k">when</span> <span class="no">Red</span>   <span class="k">then</span> <span class="s1">'#ff0000'</span>
      <span class="k">when</span> <span class="no">Green</span> <span class="k">then</span> <span class="s1">'#00ff00'</span>
      <span class="c1"># ...</span>
      <span class="k">else</span>            <span class="s1">'#ffffff'</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">crayon: </span><span class="no">Crayon</span><span class="p">,</span> <span class="ss">path: </span><span class="no">T</span><span class="o">::</span><span class="no">Array</span><span class="p">[</span><span class="no">Position</span><span class="p">]).</span><span class="nf">void</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="n">crayon</span><span class="p">:,</span> <span class="n">path</span><span class="p">:)</span>
    <span class="n">path</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">pos</span><span class="o">|</span>
      <span class="no">Kernel</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"(</span><span class="si">#{</span><span class="n">pos</span><span class="p">.</span><span class="nf">x</span><span class="si">}</span><span class="s2">, </span><span class="si">#{</span><span class="n">pos</span><span class="p">.</span><span class="nf">y</span><span class="si">}</span><span class="s2">) = "</span> <span class="o">+</span> <span class="n">crayon</span><span class="p">.</span><span class="nf">to_hex</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># To get all the values in the enum, use `.values`. For convenience there's</span>
  <span class="c1"># already a `#serialize` to get the enum string value.</span>

  <span class="n">sig</span> <span class="p">{</span> <span class="n">returns</span><span class="p">(</span><span class="no">T</span><span class="o">::</span><span class="no">Array</span><span class="p">[</span><span class="no">String</span><span class="p">])</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">crayon_names</span>
    <span class="no">Crayon</span><span class="p">.</span><span class="nf">values</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:serialize</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># Use the "deserialize" family to go from string to enum value.</span>

  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">name: </span><span class="no">String</span><span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">T</span><span class="p">.</span><span class="nf">nilable</span><span class="p">(</span><span class="no">Crayon</span><span class="p">))</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">crayon_from_name</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="k">if</span> <span class="no">Crayon</span><span class="p">.</span><span class="nf">has_serialized?</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
      <span class="c1"># If the value is not found, this will raise a `KeyError`.</span>
      <span class="no">Crayon</span><span class="p">.</span><span class="nf">deserialize</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="c1"># If the value is not found, this will return `nil`.</span>
    <span class="no">Crayon</span><span class="p">.</span><span class="nf">try_deserialize</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nn">FlowSensitivity</span>
  <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>
  <span class="c1"># Sorbet understands Ruby's control flow constructs and uses that information</span>
  <span class="c1"># to get more accurate types when your code branches.</span>

  <span class="c1"># You'll see this most often when doing nil checks.</span>
  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">name: </span><span class="no">T</span><span class="p">.</span><span class="nf">nilable</span><span class="p">(</span><span class="no">String</span><span class="p">)).</span><span class="nf">returns</span><span class="p">(</span><span class="no">String</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">greet_loudly</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">name</span><span class="p">.</span><span class="nf">nil?</span>
      <span class="s1">'HELLO, YOU!'</span>
    <span class="k">else</span>
      <span class="c1"># Sorbet knows that `name` must be a String here, so it's safe to call</span>
      <span class="c1"># `#upcase`.</span>
      <span class="s2">"HELLO, </span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">upcase</span><span class="si">}</span><span class="s2">!"</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># The nils are a special case of refining `T.any`.</span>
  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">id: </span><span class="no">T</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="no">Integer</span><span class="p">,</span> <span class="no">T</span><span class="o">::</span><span class="no">Array</span><span class="p">[</span><span class="no">Integer</span><span class="p">])).</span><span class="nf">returns</span><span class="p">(</span><span class="no">T</span><span class="o">::</span><span class="no">Array</span><span class="p">[</span><span class="no">String</span><span class="p">])</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">database_lookup</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">id</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Integer</span><span class="p">)</span>
      <span class="c1"># `ids` must be an Integer here.</span>
      <span class="p">[</span><span class="nb">id</span><span class="p">.</span><span class="nf">to_s</span><span class="p">]</span>
    <span class="k">else</span>
      <span class="c1"># `ids` must be a T::Array[Integer] here.</span>
      <span class="nb">id</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:to_s</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># Sorbet recognizes these methods that narrow type definitions:</span>
  <span class="c1"># * is_a?</span>
  <span class="c1"># * kind_of?</span>
  <span class="c1"># * nil?</span>
  <span class="c1"># * Class#===</span>
  <span class="c1"># * Class#&lt;</span>
  <span class="c1"># * block_given?</span>
  <span class="c1">#</span>
  <span class="c1"># Because they're so common, it also recognizes these Rails extensions:</span>
  <span class="c1"># * blank?</span>
  <span class="c1"># * present?</span>
  <span class="c1">#</span>
  <span class="c1"># Be careful to maintain Sorbet assumptions if you redefine these methods!</span>

  <span class="c1"># Have you ever written this line of code?</span>
  <span class="c1">#</span>
  <span class="c1">#     raise StandardError, "Can't happen"</span>
  <span class="c1">#</span>
  <span class="c1"># Sorbet can help you prove that statically (this is known as</span>
  <span class="c1"># "exhaustiveness") with `T.absurd`.  It's extra cool when combined with</span>
  <span class="c1"># `T::Enum`!</span>

  <span class="k">class</span> <span class="nc">Size</span> <span class="o">&lt;</span> <span class="no">T</span><span class="o">::</span><span class="no">Enum</span>
    <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>

    <span class="n">enums</span> <span class="k">do</span>
      <span class="no">Byte</span> <span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="s1">'B'</span><span class="p">)</span>
      <span class="no">Kibibyte</span> <span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="s1">'KiB'</span><span class="p">)</span>
      <span class="no">Mebibyte</span> <span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="s1">'MiB'</span><span class="p">)</span>
      <span class="c1"># "640K ought to be enough for anybody"</span>
    <span class="k">end</span>

    <span class="n">sig</span> <span class="p">{</span> <span class="n">returns</span><span class="p">(</span><span class="no">Integer</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nf">bytes</span>
      <span class="k">case</span> <span class="nb">self</span>
        <span class="k">when</span> <span class="no">Byte</span>     <span class="k">then</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="mi">0</span>
        <span class="k">when</span> <span class="no">Kibibyte</span> <span class="k">then</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span>
        <span class="k">when</span> <span class="no">Mebibyte</span> <span class="k">then</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span>
        <span class="k">else</span>
          <span class="c1"># Sorbet knows you've checked all the cases, so there's no possible</span>
          <span class="c1"># value that `self` could have here.</span>
          <span class="c1">#</span>
          <span class="c1"># But if you _do_ get here somehow, this will raise at runtime.</span>
          <span class="no">T</span><span class="p">.</span><span class="nf">absurd</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>

          <span class="c1"># If you're missing a case, Sorbet can even tell you which one it is!</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># We're gonna need `puts` and `raise` for this next part.</span>
  <span class="kp">include</span> <span class="no">Kernel</span>

  <span class="c1"># Sorbet knows that no code can execute after a `raise` statement because it</span>
  <span class="c1"># "never returns".</span>
  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">num: </span><span class="no">T</span><span class="p">.</span><span class="nf">nilable</span><span class="p">(</span><span class="no">Integer</span><span class="p">)).</span><span class="nf">returns</span><span class="p">(</span><span class="no">Integer</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">decrement</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s1">'¯\_(ツ)_/¯'</span> <span class="k">unless</span> <span class="n">num</span>

    <span class="n">num</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="k">end</span>

  <span class="k">class</span> <span class="nc">CustomError</span> <span class="o">&lt;</span> <span class="no">StandardError</span><span class="p">;</span> <span class="k">end</span>

  <span class="c1"># You can annotate your own error-raising methods with `T.noreturn`.</span>
  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">message: </span><span class="no">String</span><span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">T</span><span class="p">.</span><span class="nf">noreturn</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">oh_no</span><span class="p">(</span><span class="n">message</span> <span class="o">=</span> <span class="s1">'A bad thing happened'</span><span class="p">)</span>
    <span class="nb">puts</span> <span class="n">message</span>
    <span class="k">raise</span> <span class="no">CustomError</span><span class="p">,</span> <span class="n">message</span>
  <span class="k">end</span>

  <span class="c1"># Infinite loops also don't return.</span>
  <span class="n">sig</span> <span class="p">{</span> <span class="n">returns</span><span class="p">(</span><span class="no">T</span><span class="p">.</span><span class="nf">noreturn</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">loading</span>
    <span class="kp">loop</span> <span class="k">do</span>
      <span class="sx">%q(-\|/)</span><span class="p">.</span><span class="nf">each_char</span> <span class="k">do</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span>
        <span class="nb">print</span> <span class="s2">"</span><span class="se">\r</span><span class="si">#{</span><span class="n">c</span><span class="si">}</span><span class="s2"> reticulating splines..."</span>
        <span class="nb">sleep</span> <span class="mi">1</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># You may run into a situation where Sorbet "loses" your type refinement.</span>
  <span class="c1"># Remember that almost everything you do in Ruby is a method call that could</span>
  <span class="c1"># return a different value next time you call it. Sorbet doesn't assume that</span>
  <span class="c1"># any methods are pure (even those from `attr_reader` and `attr_accessor`).</span>
  <span class="n">sig</span> <span class="p">{</span> <span class="n">returns</span><span class="p">(</span><span class="no">T</span><span class="p">.</span><span class="nf">nilable</span><span class="p">(</span><span class="no">Integer</span><span class="p">))</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">answer</span>
    <span class="nb">rand</span> <span class="o">&gt;</span> <span class="mf">0.5</span> <span class="p">?</span> <span class="mi">42</span> <span class="p">:</span> <span class="kp">nil</span>
  <span class="k">end</span>

  <span class="n">sig</span> <span class="p">{</span> <span class="n">void</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">bad_typecheck</span>
    <span class="k">if</span> <span class="n">answer</span><span class="p">.</span><span class="nf">nil?</span>
      <span class="mi">0</span>
    <span class="k">else</span>
      <span class="c1"># But answer might return `nil` if we call it again!</span>
      <span class="n">answer</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="c1"># ^ Method + does not exist on NilClass component of T.nilable(Integer)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">sig</span> <span class="p">{</span> <span class="n">void</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">good_typecheck</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">answer</span>
    <span class="k">if</span> <span class="n">ans</span><span class="p">.</span><span class="nf">nil?</span>
      <span class="mi">0</span>
    <span class="k">else</span>
      <span class="c1"># This time, Sorbet knows that `ans` is non-nil.</span>
      <span class="n">ans</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nn">InheritancePatterns</span>
  <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>

  <span class="c1"># If you have a method that always returns the type of its receiver, use</span>
  <span class="c1"># `T.self_type`. This is common in fluent interfaces and DSLs.</span>
  <span class="c1">#</span>
  <span class="c1"># Warning: This feature is still experimental!</span>
  <span class="k">class</span> <span class="nc">Logging</span>
    <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>

    <span class="n">sig</span> <span class="p">{</span> <span class="n">returns</span><span class="p">(</span><span class="no">T</span><span class="p">.</span><span class="nf">self_type</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nf">log</span>
      <span class="n">pp</span> <span class="nb">self</span>
      <span class="nb">self</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">class</span> <span class="nc">Data</span> <span class="o">&lt;</span> <span class="no">Logging</span>
    <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>

    <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">x: </span><span class="no">Integer</span><span class="p">,</span> <span class="ss">y: </span><span class="no">String</span><span class="p">).</span><span class="nf">void</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="ss">x: </span><span class="mi">0</span><span class="p">,</span> <span class="ss">y: </span><span class="s1">''</span><span class="p">)</span>
      <span class="vi">@x</span> <span class="o">=</span> <span class="n">x</span>
      <span class="vi">@y</span> <span class="o">=</span> <span class="n">y</span>
    <span class="k">end</span>

    <span class="c1"># You don't _have_ to use `T.self_type` if there's only one relevant class.</span>
    <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">x: </span><span class="no">Integer</span><span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">Data</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nf">setX</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
      <span class="vi">@x</span> <span class="o">=</span> <span class="n">x</span>
      <span class="nb">self</span>
    <span class="k">end</span>

    <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">y: </span><span class="no">String</span><span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">Data</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nf">setY</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
      <span class="vi">@y</span> <span class="o">=</span> <span class="n">y</span>
      <span class="nb">self</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># Ta-da!</span>
  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">data: </span><span class="no">Data</span><span class="p">).</span><span class="nf">void</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">chaining</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">data</span><span class="p">.</span><span class="nf">setX</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">log</span><span class="p">.</span><span class="nf">setY</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># If it's a class method (a.k.a. singleton method), use `T.attached_class`.</span>
  <span class="c1">#</span>
  <span class="c1"># No warning here. This one is stable!</span>
  <span class="k">class</span> <span class="nc">Box</span>
    <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>

    <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">contents: </span><span class="no">String</span><span class="p">,</span> <span class="ss">weight: </span><span class="no">Integer</span><span class="p">).</span><span class="nf">void</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">contents</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>
      <span class="vi">@contents</span> <span class="o">=</span> <span class="n">contents</span>
      <span class="vi">@weight</span> <span class="o">=</span> <span class="n">weight</span>
    <span class="k">end</span>

    <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">contents: </span><span class="no">String</span><span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">T</span><span class="p">.</span><span class="nf">attached_class</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">pack</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
      <span class="n">new</span><span class="p">(</span><span class="n">contents</span><span class="p">,</span> <span class="n">contents</span><span class="p">.</span><span class="nf">chars</span><span class="p">.</span><span class="nf">uniq</span><span class="p">.</span><span class="nf">length</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">class</span> <span class="nc">CompanionCube</span> <span class="o">&lt;</span> <span class="no">Box</span>
    <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>

    <span class="n">sig</span> <span class="p">{</span> <span class="n">returns</span><span class="p">(</span><span class="no">String</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nf">pick_up</span>
      <span class="s2">"♥</span><span class="si">#{</span><span class="vi">@contents</span><span class="si">}</span><span class="s2">🤍"</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">sig</span> <span class="p">{</span> <span class="n">returns</span><span class="p">(</span><span class="no">String</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">befriend</span>
    <span class="no">CompanionCube</span><span class="p">.</span><span class="nf">pack</span><span class="p">(</span><span class="s1">''</span><span class="p">).</span><span class="nf">pick_up</span>
  <span class="k">end</span>

  <span class="c1"># Sorbet has support for abstract classes and interfaces. It can check that</span>
  <span class="c1"># all the concrete classes and implementations actually define the required</span>
  <span class="c1"># methods with compatible signatures.</span>

  <span class="c1"># Here's an abstract class:</span>

  <span class="k">class</span> <span class="nc">WorkflowStep</span>
    <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>

    <span class="c1"># Bring in the inheritance helpers.</span>
    <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Helpers</span>

    <span class="c1"># Mark this class as abstract. This means it cannot be instantiated with</span>
    <span class="c1"># `.new`, but it can still be subclassed.</span>
    <span class="n">abstract!</span>

    <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">args: </span><span class="no">T</span><span class="o">::</span><span class="no">Array</span><span class="p">[</span><span class="no">String</span><span class="p">]).</span><span class="nf">void</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
      <span class="n">pre_hook</span>
      <span class="n">execute</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
      <span class="n">post_hook</span>
    <span class="k">end</span>

    <span class="c1"># This is an abstract method, which means it _must_ be implemented by</span>
    <span class="c1"># subclasses. Add a signature with `abstract` to an empty method to tell</span>
    <span class="c1"># Sorbet about it.</span>
    <span class="c1">#</span>
    <span class="c1"># If this implementation of the method actually gets called at runtime, it</span>
    <span class="c1"># will raise `NotImplementedError`.</span>
    <span class="n">sig</span> <span class="p">{</span> <span class="n">abstract</span><span class="p">.</span><span class="nf">params</span><span class="p">(</span><span class="ss">args: </span><span class="no">T</span><span class="o">::</span><span class="no">Array</span><span class="p">[</span><span class="no">String</span><span class="p">]).</span><span class="nf">void</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="n">args</span><span class="p">);</span> <span class="k">end</span>

    <span class="c1"># The following non-abstract methods _can_ be implemented by subclasses,</span>
    <span class="c1"># but they're optional.</span>

    <span class="n">sig</span> <span class="p">{</span> <span class="n">void</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nf">pre_hook</span><span class="p">;</span> <span class="k">end</span>

    <span class="n">sig</span> <span class="p">{</span> <span class="n">void</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nf">post_hook</span><span class="p">;</span> <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">class</span> <span class="nc">Configure</span> <span class="o">&lt;</span> <span class="no">WorkflowStep</span>
    <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>

    <span class="n">sig</span> <span class="p">{</span> <span class="n">void</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nf">pre_hook</span>
      <span class="nb">puts</span> <span class="s1">'Configuring...'</span>
    <span class="k">end</span>

    <span class="c1"># To implement an abstract method, mark the signature with `override`.</span>
    <span class="n">sig</span> <span class="p">{</span> <span class="n">override</span><span class="p">.</span><span class="nf">params</span><span class="p">(</span><span class="ss">args: </span><span class="no">T</span><span class="o">::</span><span class="no">Array</span><span class="p">[</span><span class="no">String</span><span class="p">]).</span><span class="nf">void</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
      <span class="c1"># ...</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># And here's an interface:</span>

  <span class="k">module</span> <span class="nn">Queue</span>
    <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>

    <span class="c1"># Bring in the inheritance helpers.</span>
    <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Helpers</span>

    <span class="c1"># Mark this module as an interface. This adds the following restrictions:</span>
    <span class="c1"># 1. All of its methods must be abstract.</span>
    <span class="c1"># 2. It cannot have any private or protected methods.</span>
    <span class="n">interface!</span>

    <span class="n">sig</span> <span class="p">{</span> <span class="n">abstract</span><span class="p">.</span><span class="nf">params</span><span class="p">(</span><span class="ss">num: </span><span class="no">Integer</span><span class="p">).</span><span class="nf">void</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">num</span><span class="p">);</span> <span class="k">end</span>

    <span class="n">sig</span> <span class="p">{</span> <span class="n">abstract</span><span class="p">.</span><span class="nf">returns</span><span class="p">(</span><span class="no">T</span><span class="p">.</span><span class="nf">nilable</span><span class="p">(</span><span class="no">Integer</span><span class="p">))</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nf">pop</span><span class="p">;</span> <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">class</span> <span class="nc">PriorityQueue</span>
    <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>

    <span class="c1"># Include the interface to tell Sorbet that this class implements it.</span>
    <span class="c1"># Sorbet doesn't support implicitly implemented interfaces (also known as</span>
    <span class="c1"># "duck typing").</span>
    <span class="kp">include</span> <span class="no">Queue</span>

    <span class="n">sig</span> <span class="p">{</span> <span class="n">void</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nf">initialize</span>
      <span class="vi">@items</span> <span class="o">=</span> <span class="no">T</span><span class="p">.</span><span class="nf">let</span><span class="p">([],</span> <span class="no">T</span><span class="o">::</span><span class="no">Array</span><span class="p">[</span><span class="no">Integer</span><span class="p">])</span>
    <span class="k">end</span>

    <span class="c1"># Implement the Queue interface's abstract methods. Remember to use</span>
    <span class="c1"># `override`!</span>

    <span class="n">sig</span> <span class="p">{</span> <span class="n">override</span><span class="p">.</span><span class="nf">params</span><span class="p">(</span><span class="ss">num: </span><span class="no">Integer</span><span class="p">).</span><span class="nf">void</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
      <span class="vi">@items</span> <span class="o">&lt;&lt;</span> <span class="n">num</span>
      <span class="vi">@items</span><span class="p">.</span><span class="nf">sort!</span>
    <span class="k">end</span>

    <span class="n">sig</span> <span class="p">{</span> <span class="n">override</span><span class="p">.</span><span class="nf">returns</span><span class="p">(</span><span class="no">T</span><span class="p">.</span><span class="nf">nilable</span><span class="p">(</span><span class="no">Integer</span><span class="p">))</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nf">pop</span>
      <span class="vi">@items</span><span class="p">.</span><span class="nf">shift</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># If you use the `included` hook to get class methods from your modules,</span>
  <span class="c1"># you'll have to use `mixes_in_class_methods` to get them to type-check.</span>

  <span class="k">module</span> <span class="nn">Mixin</span>
    <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Helpers</span>
    <span class="n">interface!</span>

    <span class="k">module</span> <span class="nn">ClassMethods</span>
      <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>

      <span class="n">sig</span> <span class="p">{</span> <span class="n">void</span> <span class="p">}</span>
      <span class="k">def</span> <span class="nf">whisk</span>
        <span class="s1">'fskfskfsk'</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="n">mixes_in_class_methods</span><span class="p">(</span><span class="no">ClassMethods</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">class</span> <span class="nc">EggBeater</span>
    <span class="kp">include</span> <span class="no">Mixin</span>
  <span class="k">end</span>

  <span class="no">EggBeater</span><span class="p">.</span><span class="nf">whisk</span> <span class="c1"># Meringue!</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nn">EscapeHatches</span>
  <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>

  <span class="c1"># Ruby is a very dynamic language, and sometimes Sorbet can't infer the</span>
  <span class="c1"># properties you already know to be true. Although there are ways to rewrite</span>
  <span class="c1"># your code so Sorbet can prove safety, you can also choose to "break out" of</span>
  <span class="c1"># Sorbet using these "escape hatches".</span>

  <span class="c1"># Once you start using `T.nilable`, Sorbet will start telling you _all_ the</span>
  <span class="c1"># places you're not handling nils. Sometimes, you know a value can't be nil,</span>
  <span class="c1"># but it's not practical to fix the sigs so Sorbet can prove it. In that</span>
  <span class="c1"># case, you can use `T.must`.</span>
  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">maybe_str: </span><span class="no">T</span><span class="p">.</span><span class="nf">nilable</span><span class="p">(</span><span class="no">String</span><span class="p">)).</span><span class="nf">returns</span><span class="p">(</span><span class="no">String</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">no_nils_here</span><span class="p">(</span><span class="n">maybe_str</span><span class="p">)</span>
    <span class="c1"># If maybe_str _is_ actually nil, this will error at runtime.</span>
    <span class="n">str</span> <span class="o">=</span> <span class="no">T</span><span class="p">.</span><span class="nf">must</span><span class="p">(</span><span class="n">maybe_str</span><span class="p">)</span>
    <span class="n">str</span><span class="p">.</span><span class="nf">downcase</span>
  <span class="k">end</span>

  <span class="c1"># More generally, if you know that a value must be a specific type, you can</span>
  <span class="c1"># use `T.cast`.</span>
  <span class="n">sig</span> <span class="k">do</span>
    <span class="n">params</span><span class="p">(</span>
      <span class="ss">str_or_ary: </span><span class="no">T</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="no">String</span><span class="p">,</span> <span class="no">T</span><span class="o">::</span><span class="no">Array</span><span class="p">[</span><span class="no">String</span><span class="p">]),</span>
      <span class="ss">idx_or_range: </span><span class="no">T</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="no">Integer</span><span class="p">,</span> <span class="no">T</span><span class="o">::</span><span class="no">Range</span><span class="p">[</span><span class="no">Integer</span><span class="p">]),</span>
    <span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">T</span><span class="o">::</span><span class="no">Array</span><span class="p">[</span><span class="no">String</span><span class="p">])</span>
  <span class="k">end</span>
  <span class="k">def</span> <span class="nf">slice2</span><span class="p">(</span><span class="n">str_or_ary</span><span class="p">,</span> <span class="n">idx_or_range</span><span class="p">)</span>
    <span class="c1"># Let's say that, for some reason, we want individual characters from</span>
    <span class="c1"># strings or sub-arrays from arrays. The other options are not allowed.</span>
    <span class="k">if</span> <span class="n">str_or_ary</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">String</span><span class="p">)</span>
      <span class="c1"># Here, we know that `idx_or_range` must be a single index. If it's not,</span>
      <span class="c1"># this will error at runtime.</span>
      <span class="n">idx</span> <span class="o">=</span> <span class="no">T</span><span class="p">.</span><span class="nf">cast</span><span class="p">(</span><span class="n">idx_or_range</span><span class="p">,</span> <span class="no">Integer</span><span class="p">)</span>
      <span class="p">[</span><span class="n">str_or_ary</span><span class="p">.</span><span class="nf">chars</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span>
    <span class="k">else</span>
      <span class="c1"># Here, we know that `idx_or_range` must be a range. If it's not, this</span>
      <span class="c1"># will error at runtime.</span>
      <span class="n">range</span> <span class="o">=</span> <span class="no">T</span><span class="p">.</span><span class="nf">cast</span><span class="p">(</span><span class="n">idx_or_range</span><span class="p">,</span> <span class="no">T</span><span class="o">::</span><span class="no">Range</span><span class="p">[</span><span class="no">Integer</span><span class="p">])</span>
      <span class="n">str_or_ary</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="n">range</span><span class="p">)</span> <span class="o">||</span> <span class="p">[]</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># If you know that a method exists, but Sorbet doesn't, you can use</span>
  <span class="c1"># `T.unsafe` so Sorbet will let you call it. Although we tend to think of</span>
  <span class="c1"># this as being an "unsafe method call", `T.unsafe` is called on the receiver</span>
  <span class="c1"># rather than the whole expression.</span>
  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">count: </span><span class="no">Integer</span><span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">Date</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">the_future</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
    <span class="c1"># Let's say you've defined some extra date helpers that Sorbet can't find.</span>
    <span class="c1"># So `2.decades` is effectively `(2*10).years` from ActiveSupport.</span>
    <span class="no">Date</span><span class="p">.</span><span class="nf">today</span> <span class="o">+</span> <span class="no">T</span><span class="p">.</span><span class="nf">unsafe</span><span class="p">(</span><span class="n">count</span><span class="p">).</span><span class="nf">decades</span>
  <span class="k">end</span>

  <span class="c1"># If this is a method on the implicit `self`, you'll have to make that</span>
  <span class="c1"># explicit to use `T.unsafe`.</span>
  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">count: </span><span class="no">Integer</span><span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">Date</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">the_past</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
    <span class="c1"># Let's say that metaprogramming defines a `now` helper method for</span>
    <span class="c1"># `Time.new`. Using it would normally look like this:</span>
    <span class="c1">#</span>
    <span class="c1">#     now - 1234</span>
    <span class="c1">#</span>
    <span class="no">T</span><span class="p">.</span><span class="nf">unsafe</span><span class="p">(</span><span class="nb">self</span><span class="p">).</span><span class="nf">now</span> <span class="o">-</span> <span class="mi">1234</span>
  <span class="k">end</span>

  <span class="c1"># There's a special type in Sorbet called `T.untyped`. For any value of this</span>
  <span class="c1"># type, Sorbet will allow it to be used for any method argument and receive</span>
  <span class="c1"># any method call.</span>

  <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">num: </span><span class="no">Integer</span><span class="p">,</span> <span class="ss">anything: </span><span class="no">T</span><span class="p">.</span><span class="nf">untyped</span><span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">T</span><span class="p">.</span><span class="nf">untyped</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">def</span> <span class="nf">nothing_to_see_here</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">anything</span><span class="p">)</span>
    <span class="n">anything</span><span class="p">.</span><span class="nf">digits</span> <span class="c1"># Is it an Integer...</span>
    <span class="n">anything</span><span class="p">.</span><span class="nf">upcase</span> <span class="c1"># ... or a String?</span>

    <span class="c1"># Sorbet will not be able to infer anything about this return value because</span>
    <span class="c1"># it's untyped.</span>
    <span class="no">BasicObject</span><span class="p">.</span><span class="nf">new</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">see_here</span>
    <span class="c1"># It's actually nil!  This will crash at runtime, but Sorbet allows it.</span>
    <span class="n">nothing_to_see_here</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kp">nil</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># For a method without a sig, Sorbet infers the type of each argument and the</span>
  <span class="c1"># return value to be `T.untyped`.</span>
<span class="k">end</span>

<span class="c1"># The following types are not officially documented but are still useful. They</span>
<span class="c1"># may be experimental, deprecated, or not supported.</span>

<span class="k">module</span> <span class="nn">ValueSet</span>
  <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>

  <span class="c1"># A common pattern in Ruby is to have a method accept one value from a set of</span>
  <span class="c1"># options. Especially when starting out with Sorbet, it may not be practical</span>
  <span class="c1"># to refactor the code to use `T::Enum`. In this case, you can use `T.enum`.</span>
  <span class="c1">#</span>
  <span class="c1"># Note: Sorbet can't check this statically becuase it doesn't track the</span>
  <span class="c1"># values themselves.</span>
  <span class="n">sig</span> <span class="k">do</span>
    <span class="n">params</span><span class="p">(</span>
      <span class="ss">data: </span><span class="no">T</span><span class="o">::</span><span class="no">Array</span><span class="p">[</span><span class="no">Numeric</span><span class="p">],</span>
      <span class="ss">shape: </span><span class="no">T</span><span class="p">.</span><span class="nf">enum</span><span class="p">([</span><span class="ss">:circle</span><span class="p">,</span> <span class="ss">:square</span><span class="p">,</span> <span class="ss">:triangle</span><span class="p">])</span>
    <span class="p">).</span><span class="nf">void</span>
  <span class="k">end</span>
  <span class="k">def</span> <span class="nf">plot_points</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="ss">shape: :circle</span><span class="p">)</span>
    <span class="n">data</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">|</span>
      <span class="no">Kernel</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="n">x</span><span class="si">}</span><span class="s2">: </span><span class="si">#{</span><span class="n">y</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nn">Generics</span>
  <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>

  <span class="c1"># Generics are useful when you have a class whose method types change based</span>
  <span class="c1"># on the data it contains or a method whose method type changes based on what</span>
  <span class="c1"># its arguments are.</span>

  <span class="c1"># A generic method uses `type_parameters` to declare type variables and</span>
  <span class="c1"># `T.type_parameter` to refer back to them.</span>
  <span class="n">sig</span> <span class="k">do</span>
    <span class="n">type_parameters</span><span class="p">(</span><span class="ss">:element</span><span class="p">)</span>
      <span class="p">.</span><span class="nf">params</span><span class="p">(</span>
        <span class="ss">element: </span><span class="no">T</span><span class="p">.</span><span class="nf">type_parameter</span><span class="p">(</span><span class="ss">:element</span><span class="p">),</span>
        <span class="ss">count: </span><span class="no">Integer</span><span class="p">,</span>
      <span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">T</span><span class="o">::</span><span class="no">Array</span><span class="p">[</span><span class="no">T</span><span class="p">.</span><span class="nf">type_parameter</span><span class="p">(</span><span class="ss">:element</span><span class="p">)])</span>
  <span class="k">end</span>
  <span class="k">def</span> <span class="nf">repeat_value</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
    <span class="n">count</span><span class="p">.</span><span class="nf">times</span><span class="p">.</span><span class="nf">each_with_object</span><span class="p">([])</span> <span class="k">do</span> <span class="o">|</span><span class="n">elt</span><span class="p">,</span> <span class="n">ary</span><span class="o">|</span>
      <span class="n">ary</span> <span class="o">&lt;&lt;</span> <span class="n">elt</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">sig</span> <span class="k">do</span>
    <span class="n">type_parameters</span><span class="p">(</span><span class="ss">:element</span><span class="p">)</span>
      <span class="p">.</span><span class="nf">params</span><span class="p">(</span>
        <span class="ss">count: </span><span class="no">Integer</span><span class="p">,</span>
        <span class="ss">block: </span><span class="no">T</span><span class="p">.</span><span class="nf">proc</span><span class="p">.</span><span class="nf">returns</span><span class="p">(</span><span class="no">T</span><span class="p">.</span><span class="nf">type_parameter</span><span class="p">(</span><span class="ss">:element</span><span class="p">)),</span>
      <span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">T</span><span class="o">::</span><span class="no">Array</span><span class="p">[</span><span class="no">T</span><span class="p">.</span><span class="nf">type_parameter</span><span class="p">(</span><span class="ss">:element</span><span class="p">)])</span>
  <span class="k">end</span>
  <span class="k">def</span> <span class="nf">repeat_cached</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="n">elt</span> <span class="o">=</span> <span class="n">block</span><span class="p">.</span><span class="nf">call</span>
    <span class="n">ary</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">count</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
      <span class="n">ary</span> <span class="o">&lt;&lt;</span> <span class="n">elt</span>
    <span class="k">end</span>
    <span class="n">ary</span>
  <span class="k">end</span>

  <span class="c1"># A generic class uses `T::Generic.type_member` to define type variables that</span>
  <span class="c1"># can be like regular type names.</span>
  <span class="k">class</span> <span class="nc">BidirectionalHash</span>
    <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>
    <span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Generic</span>

    <span class="no">Left</span> <span class="o">=</span> <span class="n">type_member</span>
    <span class="no">Right</span> <span class="o">=</span> <span class="n">type_member</span>

    <span class="n">sig</span> <span class="p">{</span> <span class="n">void</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nf">initialize</span>
      <span class="vi">@left_hash</span> <span class="o">=</span> <span class="no">T</span><span class="p">.</span><span class="nf">let</span><span class="p">({},</span> <span class="no">T</span><span class="o">::</span><span class="no">Hash</span><span class="p">[</span><span class="no">Left</span><span class="p">,</span> <span class="no">Right</span><span class="p">])</span>
      <span class="vi">@right_hash</span> <span class="o">=</span> <span class="no">T</span><span class="p">.</span><span class="nf">let</span><span class="p">({},</span> <span class="no">T</span><span class="o">::</span><span class="no">Hash</span><span class="p">[</span><span class="no">Right</span><span class="p">,</span> <span class="no">Left</span><span class="p">])</span>
    <span class="k">end</span>

    <span class="c1"># Implement just enough to make the methods below work.</span>

    <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">lkey: </span><span class="no">Left</span><span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">T</span><span class="o">::</span><span class="no">Boolean</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nf">lhas?</span><span class="p">(</span><span class="n">lkey</span><span class="p">)</span>
      <span class="vi">@left_hash</span><span class="p">.</span><span class="nf">has_key?</span><span class="p">(</span><span class="n">lkey</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">sig</span> <span class="p">{</span> <span class="n">params</span><span class="p">(</span><span class="ss">rkey: </span><span class="no">Right</span><span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">T</span><span class="p">.</span><span class="nf">nilable</span><span class="p">(</span><span class="no">Left</span><span class="p">))</span> <span class="p">}</span>
    <span class="k">def</span> <span class="nf">rget</span><span class="p">(</span><span class="n">rkey</span><span class="p">)</span>
      <span class="vi">@right_hash</span><span class="p">[</span><span class="n">rkey</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># To specialize a generic type, use brackets.</span>
  <span class="n">sig</span> <span class="k">do</span>
    <span class="n">params</span><span class="p">(</span>
      <span class="ss">options: </span><span class="no">BidirectionalHash</span><span class="p">[</span><span class="no">Symbol</span><span class="p">,</span> <span class="no">Integer</span><span class="p">],</span>
      <span class="ss">choice: </span><span class="no">T</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="no">Symbol</span><span class="p">,</span> <span class="no">Integer</span><span class="p">),</span>
    <span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">T</span><span class="p">.</span><span class="nf">nilable</span><span class="p">(</span><span class="no">String</span><span class="p">))</span>
  <span class="k">end</span>
  <span class="k">def</span> <span class="nf">lookup</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">choice</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">choice</span>
    <span class="k">when</span> <span class="no">Symbol</span>
      <span class="n">options</span><span class="p">.</span><span class="nf">lhas?</span><span class="p">(</span><span class="n">choice</span><span class="p">)</span> <span class="p">?</span> <span class="n">choice</span><span class="p">.</span><span class="nf">to_s</span> <span class="p">:</span> <span class="kp">nil</span>
    <span class="k">when</span> <span class="no">Integer</span>
      <span class="n">options</span><span class="p">.</span><span class="nf">rget</span><span class="p">(</span><span class="n">choice</span><span class="p">).</span><span class="nf">to_s</span>
    <span class="k">else</span>
      <span class="no">T</span><span class="p">.</span><span class="nf">absurd</span><span class="p">(</span><span class="n">choice</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># To specialize through inheritance, re-declare the `type_member` with</span>
  <span class="c1"># `fixed`.</span>
  <span class="k">class</span> <span class="nc">Options</span> <span class="o">&lt;</span> <span class="no">BidirectionalHash</span>
    <span class="no">Left</span> <span class="o">=</span> <span class="n">type_member</span><span class="p">(</span><span class="ss">fixed: </span><span class="no">Symbol</span><span class="p">)</span>
    <span class="no">Right</span> <span class="o">=</span> <span class="n">type_member</span><span class="p">(</span><span class="ss">fixed: </span><span class="no">Integer</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">sig</span> <span class="k">do</span>
    <span class="n">params</span><span class="p">(</span>
      <span class="ss">options: </span><span class="no">Options</span><span class="p">,</span>
      <span class="ss">choice: </span><span class="no">T</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="no">Symbol</span><span class="p">,</span> <span class="no">Integer</span><span class="p">),</span>
    <span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">T</span><span class="p">.</span><span class="nf">nilable</span><span class="p">(</span><span class="no">String</span><span class="p">))</span>
  <span class="k">end</span>
  <span class="k">def</span> <span class="nf">lookup2</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">choice</span><span class="p">)</span>
    <span class="n">lookup</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">choice</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># There are other variance annotations you can add to `type_member`, but</span>
  <span class="c1"># they're rarely used.</span>
<span class="k">end</span>
</code></pre></div>
<h2>Additional resources</h2>

<ul>
<li><a href="https://sorbet.org/docs/overview">Official Documentation</a></li>
<li><a href="https://sorbet.run">sorbet.run</a> - Playground</li>
</ul>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/sorbet.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by Jeremy Kaplan, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/sorbet.html.markdown">0 contributor(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="https://jdkaplan.dev">Jeremy Kaplan</a>
    </p>

    <p>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>

        <script>
            var _gaq=[['_setAccount','UA-3525624-21'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>
</html>
