<!DOCTYPE html lang="pt-pt" xml:lang="pt-pt" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="pt-pt">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn swift in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/pt-pt/swift-pt/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fpt-pt%2Fswift-pt%2F&text=Aprende+X+em+Y+minutos%2C+onde+X%3Dswift">
        Partilha esta página
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Selecione o tema:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">claro</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">sombrio</button>
  </div>
  <h1><a href="/">Aprende X em Y minutos</a></h1>
  <h2>Onde X=swift</h2>
    <p class="filelink">
    Download do código:
    <a href="/docs/files/learnswift-pt.swift">learnswift-pt.swift</a>
    </p>
  <div id="doc">
    <p>Swift é uma linguagem de programação criada pela Apple para o desenvolvimento em iOS e macOS.
Desenhada de forma a coexistir com Objective-C e ser mais resiliente contra código errôneo, a linguagem Swift foi introduzida em 2014 na conferência para desenvolvedores WWDC da Apple.
Swift usa o compilador LLVM incluido no XCode 6+.</p>

<p>O livro oficial <a href="https://itunes.apple.com/us/book/swift-programming-language/id881256329">Swift Programming Language</a> da Apple está agora disponivel via iBooks.</p>

<p>Consulta também o <a href="https://developer.apple.com/library/prerelease/ios/referencelibrary/GettingStarted/DevelopiOSAppsSwift/">guia de iniciação</a> da Apple, que contêm um tutorial completo em Swift.</p>
<div class="highlight"><pre class="highlight swift"><code><span class="c1">// importar um módulo</span>
<span class="kd">import</span> <span class="kt">UIKit</span>

<span class="c1">//</span>
<span class="c1">// MARK: Básico</span>
<span class="c1">//</span>

<span class="c1">// O Xcode suporta landmarks para anotação de código e lista-as na jump bar</span>
<span class="c1">// MARK: Marco de secção (MARK)</span>
<span class="c1">// TODO: Algo a fazer em breve</span>
<span class="c1">// FIXME: Reparar este código</span>

<span class="c1">// Em Swift 2, println e print foram unidos num só método print. O print automaticamente acrescenta uma nova linha.</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Hello, world"</span><span class="p">)</span> <span class="c1">// println mudou para print</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Hello, world"</span><span class="p">,</span> <span class="nv">appendNewLine</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span> <span class="c1">// imprimir sem acrescentar uma nova linha</span>

<span class="c1">// variáveis (var) podem ser modificadas depois de inicializadas</span>
<span class="c1">// constantes (let) NÂO podem ser modificadas depois de inicializadas</span>

<span class="k">var</span> <span class="nv">myVariable</span> <span class="o">=</span> <span class="mi">42</span>
<span class="k">let</span> <span class="nv">øπΩ</span> <span class="o">=</span> <span class="s">"value"</span> <span class="c1">// nomes de variáveis em unicode</span>
<span class="k">let</span> <span class="nv">π</span> <span class="o">=</span> <span class="mf">3.1415926</span>
<span class="k">let</span> <span class="nv">convenience</span> <span class="o">=</span> <span class="s">"keyword"</span> <span class="c1">// nome de variável contextual</span>
<span class="k">let</span> <span class="nv">weak</span> <span class="o">=</span> <span class="s">"keyword"</span><span class="p">;</span> <span class="k">let</span> <span class="nv">override</span> <span class="o">=</span> <span class="s">"another keyword"</span> <span class="c1">// expressões podem ser separadas com ';'</span>
<span class="kd">let</span> <span class="p">`</span><span class="nv">class</span><span class="p">`</span> <span class="o">=</span> <span class="s">"keyword"</span> <span class="c1">// plicals permitem que keywords sejam usadas como nomes de vartiáveis</span>
<span class="k">let</span> <span class="nv">explicitDouble</span><span class="p">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mi">70</span>
<span class="k">let</span> <span class="nv">intValue</span> <span class="o">=</span> <span class="mo">0007</span> <span class="c1">// 7</span>
<span class="k">let</span> <span class="nv">largeIntValue</span> <span class="o">=</span> <span class="mi">77_000</span> <span class="c1">// 77000</span>
<span class="k">let</span> <span class="nv">label</span> <span class="o">=</span> <span class="s">"some text "</span> <span class="o">+</span> <span class="kt">String</span><span class="p">(</span><span class="n">myVariable</span><span class="p">)</span> <span class="c1">// Casting</span>
<span class="k">let</span> <span class="nv">piText</span> <span class="o">=</span> <span class="s">"Pi = </span><span class="se">\(</span><span class="n">π</span><span class="se">)</span><span class="s">, Pi 2 = </span><span class="se">\(</span><span class="n">π</span> <span class="o">*</span> <span class="mi">2</span><span class="se">)</span><span class="s">"</span> <span class="c1">// interpolação de Strings</span>

<span class="c1">// Valores especificos à build</span>
<span class="c1">// usam a configuração de build -D</span>
<span class="cp">#if false</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Not printed"</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">buildValue</span> <span class="o">=</span> <span class="mi">3</span>
<span class="cp">#else</span>
    <span class="k">let</span> <span class="nv">buildValue</span> <span class="o">=</span> <span class="mi">7</span>
<span class="cp">#endif</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Build value: </span><span class="se">\(</span><span class="n">buildValue</span><span class="se">)</span><span class="s">"</span><span class="p">)</span> <span class="c1">// Build value: 7</span>

<span class="cm">/*
    Optionals são um dos recursos de Swift, Optionals tanto podem conter
    um valor ou conter nil (sem valor) que indica que não existe um valor.
    Adicionar um ponto de exclamção (?) após definir o tipo declara
    esse valor como um Optional.

    Como Swift requere que todas as propriedades tenham um valor, até nil
    tem que ser explicitamente guardado como um valor Optional.

    Optional&lt;T&gt; é uma enumeração.
*/</span>
<span class="k">var</span> <span class="nv">someOptionalString</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span> <span class="o">=</span> <span class="s">"optional"</span> <span class="c1">// Pode assumir o valor nil</span>
<span class="c1">// Igual ao de cima, mas ? é um operando pósfixo (açúcar sintático)</span>
<span class="k">var</span> <span class="nv">someOptionalString2</span><span class="p">:</span> <span class="kt">Optional</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="s">"optional"</span>

<span class="k">if</span> <span class="n">someOptionalString</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="c1">// Não sou nil</span>
    <span class="k">if</span> <span class="n">someOptionalString</span><span class="o">!.</span><span class="nf">hasPrefix</span><span class="p">(</span><span class="s">"opt"</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"has the prefix"</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="nv">empty</span> <span class="o">=</span> <span class="n">someOptionalString</span><span class="p">?</span><span class="o">.</span><span class="n">isEmpty</span>
<span class="p">}</span>
<span class="n">someOptionalString</span> <span class="o">=</span> <span class="kc">nil</span>

<span class="cm">/*
    Tentar usar ! para aceder a Optional com valor não existente, ou seja, nil,
    causa em erro de execução.
    É necessário ter sempre a certeza que um Optional não tem valor nil
    antes de usar ! para fazer 'force-unwrap' ao seu valor.
*/</span>

<span class="c1">// Optional implicitamente desembrulhado</span>
<span class="k">var</span> <span class="nv">unwrappedString</span><span class="p">:</span> <span class="kt">String</span><span class="o">!</span> <span class="o">=</span> <span class="s">"Value is expected."</span>
<span class="c1">// O mesmo de cima, mas ! é um operando pósfixo (mais açúcar sintático)</span>
<span class="k">var</span> <span class="nv">unwrappedString2</span><span class="p">:</span> <span class="kt">ImplicitlyUnwrappedOptional</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="s">"Value is expected."</span>

<span class="k">if</span> <span class="k">let</span> <span class="nv">someOptionalStringConstant</span> <span class="o">=</span> <span class="n">someOptionalString</span> <span class="p">{</span>
    <span class="c1">// Tem um valor diferente de nil</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">someOptionalStringConstant</span><span class="o">.</span><span class="nf">hasPrefix</span><span class="p">(</span><span class="s">"ok"</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Não tem o prefixo</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Swift tem suporte para guardar valores de qualquer tipo.</span>
<span class="c1">// AnyObject == id</span>
<span class="c1">// Ao contrátio do `id` de Objective-C, AnyObject funciona com qualquer valor (Class, Int, struct, etc.)</span>
<span class="k">var</span> <span class="nv">anyObjectVar</span><span class="p">:</span> <span class="kt">AnyObject</span> <span class="o">=</span> <span class="mi">7</span>
<span class="n">anyObjectVar</span> <span class="o">=</span> <span class="s">"Changed value to a string, not good practice, but possible."</span>

<span class="cm">/*
    Comentar aqui

    /*
        Também é possível fazer comentários aninhados
    */
*/</span>

<span class="c1">//</span>
<span class="c1">// MARK: Coleções (Collections)</span>
<span class="c1">//</span>

<span class="cm">/*
    Os tipos Array e Dictionary são structs e, portanto, `let` e `var`
    também indicam se eles são mutáveis (var) or imutáveis (let)
    na altura em que se declaram estes tipos.
*/</span>

<span class="c1">// Array</span>
<span class="k">var</span> <span class="nv">shoppingList</span> <span class="o">=</span> <span class="p">[</span><span class="s">"catfish"</span><span class="p">,</span> <span class="s">"water"</span><span class="p">,</span> <span class="s">"lemons"</span><span class="p">]</span>
<span class="n">shoppingList</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">"bottle of water"</span>
<span class="k">let</span> <span class="nv">emptyArray</span> <span class="o">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">]()</span> <span class="c1">// let == imutável</span>
<span class="k">let</span> <span class="nv">emptyArray2</span> <span class="o">=</span> <span class="kt">Array</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span><span class="p">()</span> <span class="c1">// mesmo de cima</span>
<span class="k">var</span> <span class="nv">emptyMutableArray</span> <span class="o">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">]()</span> <span class="c1">// var == mutável</span>


<span class="c1">// Dictionary</span>
<span class="k">var</span> <span class="nv">occupations</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">"Malcolm"</span><span class="p">:</span> <span class="s">"Captain"</span><span class="p">,</span>
    <span class="s">"kaylee"</span><span class="p">:</span> <span class="s">"Mechanic"</span>
<span class="p">]</span>
<span class="n">occupations</span><span class="p">[</span><span class="s">"Jayne"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Public Relations"</span>
<span class="k">let</span> <span class="nv">emptyDictionary</span> <span class="o">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">Float</span><span class="p">]()</span> <span class="c1">// let == imutável</span>
<span class="k">let</span> <span class="nv">emptyDictionary2</span> <span class="o">=</span> <span class="kt">Dictionary</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Float</span><span class="o">&gt;</span><span class="p">()</span> <span class="c1">// mesmo de cima</span>
<span class="k">var</span> <span class="nv">emptyMutableDictionary</span> <span class="o">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">Float</span><span class="p">]()</span> <span class="c1">// var == mutável</span>


<span class="c1">//</span>
<span class="c1">// MARK: Controlo de Fluxo (Control Flow)</span>
<span class="c1">//</span>

<span class="c1">// for loop (array)</span>
<span class="k">let</span> <span class="nv">myArray</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="k">for</span> <span class="n">value</span> <span class="k">in</span> <span class="n">myArray</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"One!"</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Not one!"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// for loop (dictionary)</span>
<span class="k">var</span> <span class="nv">dict</span> <span class="o">=</span> <span class="p">[</span><span class="s">"one"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">"two"</span><span class="p">:</span> <span class="mi">2</span><span class="p">]</span>
<span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">in</span> <span class="n">dict</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">key</span><span class="se">)</span><span class="s">: </span><span class="se">\(</span><span class="n">value</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// ciclo for (limite)</span>
<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="o">-</span><span class="mi">1</span><span class="o">...</span><span class="n">shoppingList</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">shoppingList</span><span class="p">[</span><span class="mi">1</span><span class="o">...</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s">"steak"</span><span class="p">,</span> <span class="s">"peacons"</span><span class="p">]</span>
<span class="c1">// usar ..&lt; para excluir o último número</span>

<span class="c1">// ciclo while</span>
<span class="k">var</span> <span class="nv">i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">*=</span> <span class="mi">2</span>
<span class="p">}</span>

<span class="c1">// ciclo do-whie</span>
<span class="k">do</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"hello"</span><span class="p">)</span>
<span class="p">}</span> <span class="k">while</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">2</span>

<span class="c1">// Switch</span>
<span class="c1">// Muito poderoso, imagine `if`s com açúcar sintático</span>
<span class="c1">// Funciona para String, instâncias de objectos e primitivas (Int, Double, etc.)</span>
<span class="k">let</span> <span class="nv">vegetable</span> <span class="o">=</span> <span class="s">"red pepper"</span>
<span class="k">switch</span> <span class="n">vegetable</span> <span class="p">{</span>
<span class="k">case</span> <span class="s">"celery"</span><span class="p">:</span>
    <span class="k">let</span> <span class="nv">vegetableComment</span> <span class="o">=</span> <span class="s">"Add some raisins and make ants on a log."</span>
<span class="k">case</span> <span class="s">"cucumber"</span><span class="p">,</span> <span class="s">"watercress"</span><span class="p">:</span>
    <span class="k">let</span> <span class="nv">vegetableComment</span> <span class="o">=</span> <span class="s">"That would make a good tea sandwich."</span>
<span class="k">case</span> <span class="k">let</span> <span class="nv">localScopeValue</span> <span class="k">where</span> <span class="n">localScopeValue</span><span class="o">.</span><span class="nf">hasSuffix</span><span class="p">(</span><span class="s">"pepper"</span><span class="p">):</span>
    <span class="k">let</span> <span class="nv">vegetableComment</span> <span class="o">=</span> <span class="s">"Is it a spicy </span><span class="se">\(</span><span class="n">localScopeValue</span><span class="se">)</span><span class="s">?"</span>
<span class="k">default</span><span class="p">:</span> <span class="c1">// obrigatório (de forma a cobrir todos os possíveis inputs)</span>
    <span class="k">let</span> <span class="nv">vegetableComment</span> <span class="o">=</span> <span class="s">"Everything tastes good in soup."</span>
<span class="p">}</span>


<span class="c1">//</span>
<span class="c1">// MARK: Funções (Functions)</span>
<span class="c1">//</span>

<span class="c1">// Funções são tipos de primeira classe, o que significa que podem ser</span>
<span class="c1">// aninhadas dentro de outras funções e passadas como argumento</span>

<span class="c1">// Função em Swift com documentação no header</span>

<span class="cm">/**
    Função de cumprimento.

    - Um ponto em documentação
    - Outro ponto na documentação

    :param: nome Um nome
    :param: dia Um dia
    :returns: Uma string com um cumprimento contendo o nome e o dia.
*/</span>
<span class="kd">func</span> <span class="nf">greet</span><span class="p">(</span><span class="nv">nome</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="nv">dia</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">"Hello </span><span class="se">\(</span><span class="n">nome</span><span class="se">)</span><span class="s">, today is </span><span class="se">\(</span><span class="n">dia</span><span class="se">)</span><span class="s">."</span>
<span class="p">}</span>
<span class="nf">greet</span><span class="p">(</span><span class="s">"Bob"</span><span class="p">,</span> <span class="s">"Tuesday"</span><span class="p">)</span>

<span class="c1">// Semelhante ao método de cima excepto ao comportamento dos argumentos</span>
<span class="kd">func</span> <span class="nf">greet2</span><span class="p">(</span><span class="nv">#nomeObrigatório</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">nomeArgumentoExterno</span> <span class="nv">nomeArgumentoLocal</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">"Hello </span><span class="se">\(</span><span class="n">nomeObrigatório</span><span class="se">)</span><span class="s">, the day is </span><span class="se">\(</span><span class="n">nomeArgumentoLocal</span><span class="se">)</span><span class="s">"</span>
<span class="p">}</span>
<span class="nf">greet2</span><span class="p">(</span><span class="nv">nomeObrigatório</span><span class="p">:</span><span class="s">"John"</span><span class="p">,</span> <span class="nv">nomeArgumentoExterno</span><span class="p">:</span> <span class="s">"Sunday"</span><span class="p">)</span>

<span class="c1">// Função que devolve vários itens num tuplo</span>
<span class="kd">func</span> <span class="nf">getGasPrices</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Double</span><span class="p">,</span> <span class="kt">Double</span><span class="p">,</span> <span class="kt">Double</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">return</span> <span class="p">(</span><span class="mf">3.59</span><span class="p">,</span> <span class="mf">3.69</span><span class="p">,</span> <span class="mf">3.79</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">pricesTuple</span> <span class="o">=</span> <span class="nf">getGasPrices</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">price</span> <span class="o">=</span> <span class="n">pricesTuple</span><span class="o">.</span><span class="mi">2</span> <span class="c1">// 3.79</span>
<span class="c1">// Ignorar tuplos ou outros valores usando _ (underscore)</span>
<span class="k">let</span> <span class="p">(</span><span class="nv">_</span><span class="p">,</span> <span class="nv">price1</span><span class="p">,</span> <span class="nv">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">pricesTuple</span> <span class="c1">// price1 == 3.69</span>
<span class="nf">print</span><span class="p">(</span><span class="n">price1</span> <span class="o">==</span> <span class="n">pricesTuple</span><span class="o">.</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Gas price: </span><span class="se">\(</span><span class="n">price</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>

<span class="c1">// Argumentos variáveis</span>
<span class="kd">func</span> <span class="nf">setup</span><span class="p">(</span><span class="nv">numbers</span><span class="p">:</span> <span class="kt">Int</span><span class="o">...</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// é um array</span>
    <span class="k">let</span> <span class="nv">number</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">let</span> <span class="nv">argCount</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="n">count</span>
<span class="p">}</span>

<span class="c1">// Passar e devolver funções</span>
<span class="kd">func</span> <span class="nf">makeIncrementer</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">addOne</span><span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">number</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">addOne</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">increment</span> <span class="o">=</span> <span class="nf">makeIncrementer</span><span class="p">()</span>
<span class="nf">increment</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>

<span class="c1">// Passar por referência (inout)</span>
<span class="kd">func</span> <span class="nf">swapTwoInts</span><span class="p">(</span><span class="k">inout</span> <span class="nv">a</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="k">inout</span> <span class="nv">b</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">tempA</span> <span class="o">=</span> <span class="n">a</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">tempA</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">someIntA</span> <span class="o">=</span> <span class="mi">7</span>
<span class="k">var</span> <span class="nv">someIntB</span> <span class="o">=</span> <span class="mi">3</span>
<span class="nf">swapTwoInts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">someIntA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">someIntB</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">someIntB</span><span class="p">)</span> <span class="c1">// 7</span>


<span class="c1">//</span>
<span class="c1">// MARK: Closures</span>
<span class="c1">//</span>
<span class="k">var</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>

<span class="c1">// Funções são casos especiais de closures ({})</span>

<span class="c1">// Exemplo de um Closure.</span>
<span class="c1">// `-&gt;` separa o argumento e o tipo de retorno.</span>
<span class="c1">// `in` separa o cabeçalho do closure do corpo do closure.</span>
<span class="n">numbers</span><span class="o">.</span><span class="nf">map</span><span class="p">({</span>
    <span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="k">in</span>
    <span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">number</span>
    <span class="k">return</span> <span class="n">result</span>
<span class="p">})</span>

<span class="c1">// Quando o tipo é conhecido, como em cima, podemos fazer o seguinte</span>
<span class="n">numbers</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="nf">map</span><span class="p">({</span> <span class="n">number</span> <span class="k">in</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">number</span> <span class="p">})</span>
<span class="c1">// Ou até mesmo isto</span>
<span class="c1">//numbers = numbers.map({ $0 * 3 })</span>

<span class="nf">print</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="c1">// [3, 6, 18]</span>

<span class="c1">// Closure à direita (Trailing closure)</span>
<span class="n">numbers</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&gt;</span> <span class="nv">$1</span> <span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="c1">// [18, 6, 3]</span>

<span class="c1">// Super curto, pois o operador &lt; consegue inferir o tipo</span>

<span class="n">numbers</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="o">&lt;</span> <span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="c1">// [3, 6, 18]</span>

<span class="c1">//</span>
<span class="c1">// MARK: Estruturas (Structures)</span>
<span class="c1">//</span>

<span class="c1">// Estruturas (struct) e classes (class) têm capacidades muito semelhantes</span>
<span class="kd">struct</span> <span class="kt">NamesTable</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">names</span> <span class="o">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">]()</span>

    <span class="c1">// Custom subscript</span>
    <span class="nf">subscript</span><span class="p">(</span><span class="nv">index</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">names</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Estruturas têm um inicializador implicito que é automaticamente gerado</span>
<span class="k">let</span> <span class="nv">namesTable</span> <span class="o">=</span> <span class="kt">NamesTable</span><span class="p">(</span><span class="nv">names</span><span class="p">:</span> <span class="p">[</span><span class="s">"Me"</span><span class="p">,</span> <span class="s">"Them"</span><span class="p">])</span>
<span class="k">let</span> <span class="nv">name</span> <span class="o">=</span> <span class="n">namesTable</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Name is </span><span class="se">\(</span><span class="n">name</span><span class="se">)</span><span class="s">"</span><span class="p">)</span> <span class="c1">// Name is Them</span>

<span class="c1">//</span>
<span class="c1">// MARK: Classes</span>
<span class="c1">//</span>

<span class="c1">// Classes, estruturas e os seus membros têm três níveis de controlo de acesso</span>
<span class="c1">// Nomeadamente: interno (predefinição)(internal) , público (public), privado (private)</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="kt">Shape</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">getArea</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Todos os métodos e propriedades de uma classe são públicos.</span>
<span class="c1">// Se só for necessário guarda dados num</span>
<span class="c1">// objecto estruturado, então é melhor usar uma `struct`</span>

<span class="kd">internal</span> <span class="kd">class</span> <span class="kt">Rect</span><span class="p">:</span> <span class="kt">Shape</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">sideLength</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1">// Propriedade getter e setter personalizado</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">perimeter</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">sideLength</span>
        <span class="p">}</span>
        <span class="k">set</span> <span class="p">{</span>
            <span class="c1">// `newValue` é uma variável implicita disponível aos setters</span>
            <span class="n">sideLength</span> <span class="o">=</span> <span class="n">newValue</span> <span class="o">/</span> <span class="mi">4</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Carregar preguiçosamente uma propriedade</span>
    <span class="c1">// subShape permanece a nil (unintialized) até o getter ser invocado</span>
    <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">subShape</span> <span class="o">=</span> <span class="kt">Rect</span><span class="p">(</span><span class="nv">sideLength</span><span class="p">:</span> <span class="mi">4</span><span class="p">)</span>

    <span class="c1">// Se não for necessário um getter e setter personalizado,</span>
    <span class="c1">// mas se quiser correr o código antes e depois de modificar ou aceder</span>
    <span class="c1">// uma propriedade, é possível usar `willSet` e `didSet`</span>
    <span class="k">var</span> <span class="nv">identifier</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"defaultID"</span> <span class="p">{</span>
        <span class="c1">// o argumento de `willSet` é o nome da variável para o novo valor</span>
        <span class="nf">willSet</span><span class="p">(</span><span class="n">someIdentifier</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="n">someIdentifier</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">sideLength</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">sideLength</span> <span class="o">=</span> <span class="n">sideLength</span>
        <span class="c1">// invocar super.init no final do método de inicialização</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">shrink</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">sideLength</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">sideLength</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">override</span> <span class="kd">func</span> <span class="nf">getArea</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">sideLength</span> <span class="o">*</span> <span class="n">sideLength</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// A class `Square` estende (extends) a classe `Rect` (hierarquia)</span>
<span class="kd">class</span> <span class="kt">Square</span><span class="p">:</span> <span class="kt">Rect</span> <span class="p">{</span>
    <span class="kd">convenience</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">sideLength</span><span class="p">:</span> <span class="mi">5</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">mySquare</span> <span class="o">=</span> <span class="kt">Square</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="n">mySquare</span><span class="o">.</span><span class="nf">getArea</span><span class="p">())</span> <span class="c1">// 25</span>
<span class="n">mySquare</span><span class="o">.</span><span class="nf">shrink</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="n">mySquare</span><span class="o">.</span><span class="n">sideLength</span><span class="p">)</span> <span class="c1">// 4</span>

<span class="c1">// Cast de uma instância de `Square` para `Shape`</span>
<span class="k">let</span> <span class="nv">aShape</span> <span class="o">=</span> <span class="n">mySquare</span> <span class="k">as</span> <span class="kt">Shape</span>

<span class="c1">// Compara instâncias, não é igual a == , visto que == compara objects (igual a)</span>
<span class="k">if</span> <span class="n">mySquare</span> <span class="o">===</span> <span class="n">mySquare</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Yep, it's mySquare"</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Inicializador (init) com Optional</span>
<span class="kd">class</span> <span class="kt">Circle</span><span class="p">:</span> <span class="kt">Shape</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">radius</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">getArea</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">radius</span>
    <span class="p">}</span>

    <span class="c1">// Colocar um ponto de interrpgação depois de `init` cria um inicializador</span>
    <span class="c1">// Optional, o qual pode retornar nil</span>
    <span class="nf">init</span><span class="p">?(</span><span class="nv">radius</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">radius</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">myCircle</span> <span class="o">=</span> <span class="kt">Circle</span><span class="p">(</span><span class="nv">radius</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">myCircle</span><span class="p">?</span><span class="o">.</span><span class="nf">getArea</span><span class="p">())</span>    <span class="c1">// Optional(3)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">myCircle</span><span class="o">!.</span><span class="nf">getArea</span><span class="p">())</span>    <span class="c1">// 3</span>
<span class="k">var</span> <span class="nv">myEmptyCircle</span> <span class="o">=</span> <span class="kt">Circle</span><span class="p">(</span><span class="nv">radius</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">myEmptyCircle</span><span class="p">?</span><span class="o">.</span><span class="nf">getArea</span><span class="p">())</span>    <span class="c1">// "nil"</span>
<span class="k">if</span> <span class="k">let</span> <span class="nv">circle</span> <span class="o">=</span> <span class="n">myEmptyCircle</span> <span class="p">{</span>
    <span class="c1">// Não vai executar pois a variável myEmptyCircle é igual a nil</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"circle is not nil"</span><span class="p">)</span>
<span class="p">}</span>


<span class="c1">//</span>
<span class="c1">// MARK: Enumerações (Enums)</span>
<span class="c1">//</span>

<span class="c1">// Enums pode opcionalmente ser um tipo especifico ou não.</span>
<span class="c1">// Enums podem conter métodos tal como as classes.</span>

<span class="kd">enum</span> <span class="n">suit</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">spades</span><span class="p">,</span> <span class="n">hearts</span><span class="p">,</span> <span class="n">diamonds</span><span class="p">,</span> <span class="n">clubs</span>
    <span class="kd">func</span> <span class="nf">getIcon</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="k">self</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">spades</span><span class="p">:</span> <span class="k">return</span> <span class="s">"♤"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">hearts</span><span class="p">:</span> <span class="k">return</span> <span class="s">"♡"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">diamonds</span><span class="p">:</span> <span class="k">return</span> <span class="s">"♢"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">clubs</span><span class="p">:</span> <span class="k">return</span> <span class="s">"♧"</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Os valores de Enum permitem syntax reduzida, não é preciso escrever o tipo do enum</span>
<span class="c1">// quando a variável é explicitamente definida.</span>
<span class="k">var</span> <span class="nv">suitValue</span><span class="p">:</span> <span class="kt">Suit</span> <span class="o">=</span> <span class="o">.</span><span class="n">hearts</span>

<span class="c1">// Enums que não sejam inteiros obrigam a atribuições valor bruto (raw value) diretas</span>
<span class="kd">enum</span> <span class="kt">BookName</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">john</span> <span class="o">=</span> <span class="s">"John"</span>
    <span class="k">case</span> <span class="n">luke</span> <span class="o">=</span> <span class="s">"Luke"</span>
<span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Name: </span><span class="se">\(</span><span class="kt">BookName</span><span class="o">.</span><span class="n">john</span><span class="o">.</span><span class="n">rawValue</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>

<span class="c1">// Enum com valores associados</span>
<span class="kd">enum</span> <span class="kt">Furniture</span> <span class="p">{</span>
    <span class="c1">// Associar com um inteiro (Int)</span>
    <span class="k">case</span> <span class="nf">desk</span><span class="p">(</span><span class="nv">height</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>
    <span class="c1">// Associar com uma String e um Int</span>
    <span class="k">case</span> <span class="nf">chair</span><span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span>

    <span class="kd">func</span> <span class="nf">description</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="k">self</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nf">desk</span><span class="p">(</span><span class="k">let</span> <span class="nv">height</span><span class="p">):</span>
            <span class="k">return</span> <span class="s">"Desk with </span><span class="se">\(</span><span class="n">height</span><span class="se">)</span><span class="s"> cm"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nf">chair</span><span class="p">(</span><span class="k">let</span> <span class="nv">brand</span><span class="p">,</span> <span class="k">let</span> <span class="nv">height</span><span class="p">):</span>
            <span class="k">return</span> <span class="s">"Chair of </span><span class="se">\(</span><span class="n">brand</span><span class="se">)</span><span class="s"> with </span><span class="se">\(</span><span class="n">height</span><span class="se">)</span><span class="s"> cm"</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">desk</span><span class="p">:</span> <span class="kt">Furniture</span> <span class="o">=</span> <span class="o">.</span><span class="nf">desk</span><span class="p">(</span><span class="nv">height</span><span class="p">:</span> <span class="mi">80</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">desk</span><span class="o">.</span><span class="nf">description</span><span class="p">())</span>     <span class="c1">// "Desk with 80 cm"</span>
<span class="k">var</span> <span class="nv">chair</span> <span class="o">=</span> <span class="kt">Furniture</span><span class="o">.</span><span class="nf">chair</span><span class="p">(</span><span class="s">"Foo"</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">chair</span><span class="o">.</span><span class="nf">description</span><span class="p">())</span>    <span class="c1">// "Chair of Foo with 40 cm"</span>


<span class="c1">//</span>
<span class="c1">// MARK: Protocolos (Protocols)</span>
<span class="c1">//</span>

<span class="c1">// Protocolos (`protcol`s) obrigam a que os tipos tenham</span>
<span class="c1">// propriedades de instância, métodos de instância, métodos de tipo,</span>
<span class="c1">// operadores e subscripts específicos.</span>

<span class="kd">protocol</span> <span class="kt">ShapeGenerator</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">enabled</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span> <span class="k">get</span> <span class="k">set</span> <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">buildShape</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Shape</span>
<span class="p">}</span>

<span class="c1">// Protocolos definidos com @objc permitem funções com optional</span>
<span class="c1">// que permitem verificar se existem conformidade</span>
<span class="kd">@objc</span> <span class="kd">protocol</span> <span class="kt">TransformShape</span> <span class="p">{</span>
    <span class="kd">optional</span> <span class="kd">func</span> <span class="nf">reshaped</span><span class="p">()</span>
    <span class="kd">optional</span> <span class="kd">func</span> <span class="nf">canReshape</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">MyShape</span><span class="p">:</span> <span class="kt">Rect</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">delegate</span><span class="p">:</span> <span class="kt">TransformShape</span><span class="p">?</span>

    <span class="kd">func</span> <span class="nf">grow</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">sideLength</span> <span class="o">+=</span> <span class="mi">2</span>

        <span class="c1">// Coloca um ponto de interrogação após uma propriedade opcional, método</span>
        <span class="c1">// ou subscript para graciosamente ignorar um valor nil e retornar nil</span>
        <span class="c1">// em vez de provoar um erro em tempo de execução ("optional chaining").</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nv">allow</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">delegate</span><span class="p">?</span><span class="o">.</span><span class="nf">canReshape</span><span class="p">?()</span> <span class="p">{</span>
            <span class="c1">// testar o delegate e depois o método</span>
            <span class="k">self</span><span class="o">.</span><span class="n">delegate</span><span class="p">?</span><span class="o">.</span><span class="nf">reshaped</span><span class="p">?()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c1">//</span>
<span class="c1">// MARK: Outro</span>
<span class="c1">//</span>

<span class="c1">// extensões (`extension`s): Adiciona funcionalidade extra a um tipo já existente.</span>

<span class="c1">// Square agora "conforma" com o protocolo `Printable`</span>
<span class="kd">extension</span> <span class="kt">Square</span><span class="p">:</span> <span class="kt">Printable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">description</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">"Area: </span><span class="se">\(</span><span class="k">self</span><span class="o">.</span><span class="nf">getArea</span><span class="p">()</span><span class="se">)</span><span class="s"> - ID: </span><span class="se">\(</span><span class="k">self</span><span class="o">.</span><span class="n">identifier</span><span class="se">)</span><span class="s">"</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Square: </span><span class="se">\(</span><span class="n">mySquare</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>

<span class="c1">// Também é possível extender tipos já embutidos</span>
<span class="kd">extension</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">customProperty</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">"This is </span><span class="se">\(</span><span class="k">self</span><span class="se">)</span><span class="s">"</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">multiplyBy</span><span class="p">(</span><span class="nv">num</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">num</span> <span class="o">*</span> <span class="k">self</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="mi">7</span><span class="o">.</span><span class="n">customProperty</span><span class="p">)</span> <span class="c1">// "This is 7"</span>
<span class="nf">print</span><span class="p">(</span><span class="mi">14</span><span class="o">.</span><span class="nf">multiplyBy</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="c1">// 42</span>

<span class="c1">// Generics: Semelhante a Java e C#. Usa a palavra-chave `where` para</span>
<span class="c1">// especificar requisitos do `generics`.</span>

<span class="kd">func</span> <span class="n">findIndex</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">Equatable</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">array</span><span class="p">:</span> <span class="p">[</span><span class="kt">T</span><span class="p">],</span> <span class="nv">valueToFind</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="n">valueToFind</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">index</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">foundAtIndex</span> <span class="o">=</span> <span class="nf">findIndex</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">foundAtIndex</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// true</span>

<span class="c1">// Operadores:</span>
<span class="c1">// Operadores personalizados podem começar com caracteres:</span>
<span class="c1">//      / = - + * % &lt; &gt; ! &amp; | ^ . ~</span>
<span class="c1">// ou</span>
<span class="c1">// Caracteres Unicode matemáticos, símbolos, setas, dingbat e</span>
<span class="c1">// caracteres de desenho linha/caixa.</span>
<span class="n">operador</span> <span class="n">prefixo</span> <span class="o">!!!</span> <span class="p">{}</span>

<span class="c1">// Um operador prefixo que triplica o comprimento do lado quando usado</span>
<span class="k">prefix</span> <span class="kd">func</span> <span class="o">!!!</span> <span class="p">(</span><span class="k">inout</span> <span class="nv">shape</span><span class="p">:</span> <span class="kt">Square</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Square</span> <span class="p">{</span>
    <span class="n">shape</span><span class="o">.</span><span class="n">sideLength</span> <span class="o">*=</span> <span class="mi">3</span>
    <span class="k">return</span> <span class="n">shape</span>
<span class="p">}</span>

<span class="c1">// valor atual</span>
<span class="nf">print</span><span class="p">(</span><span class="n">mySquare</span><span class="o">.</span><span class="n">sideLength</span><span class="p">)</span> <span class="c1">// 4</span>

<span class="c1">// muda o comprimento deste lado usando o operador personalizado !!!, aumenta</span>
<span class="c1">// o comprimento 3x</span>
<span class="o">!!!</span><span class="n">mySquare</span>
<span class="nf">print</span><span class="p">(</span><span class="n">mySquare</span><span class="o">.</span><span class="n">sideLength</span><span class="p">)</span> <span class="c1">// 12</span>

<span class="c1">// Operadores também podem ser generics</span>
<span class="k">infix</span> <span class="k">operator</span> <span class="o">&lt;-&gt;</span> <span class="p">{}</span>
<span class="kd">func</span> <span class="o">&lt;-&gt;&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">Equatable</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">inout</span> <span class="nv">a</span><span class="p">:</span> <span class="kt">T</span><span class="p">,</span> <span class="k">inout</span> <span class="nv">b</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">c</span> <span class="o">=</span> <span class="n">a</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">c</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">foo</span><span class="p">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mi">10</span>
<span class="k">var</span> <span class="nv">bar</span><span class="p">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mi">20</span>

<span class="n">foo</span> <span class="o">&lt;-&gt;</span> <span class="n">bar</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"foo is </span><span class="se">\(</span><span class="n">foo</span><span class="se">)</span><span class="s">, bar is </span><span class="se">\(</span><span class="n">bar</span><span class="se">)</span><span class="s">"</span><span class="p">)</span> <span class="c1">// "foo is 20.0, bar is 10.0"</span>
</code></pre></div>
    <hr>
    <p>Tens alguma sugestão? Uma correção, talvez? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Abre um Issue</a> no repositório do Github, or faz um <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/pt-pt/swift-pt.html.markdown">pull request</a> tu mesmo!
    </p>
    <p class="contributed">
    Originalmente contribuido por Grant Timmerman, e atualizado por <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/pt-pt/swift-pt.html.markdown">4 contribuidor(es)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://github.com/grant">Grant Timmerman</a>,
        <a href="http://github.com/cbess">Christopher Bess</a>,
        <a href="http://github.com/kamidox">Joey Huang</a>,
        <a href="http://github.com/anthonyn60">Anthony Nguyen</a>,
        <a href="https://github.com/cwalk">Clayton Walker</a>
    </p>

    <p>
      Translated by:
        <a href="https://github.com/joaofcosta">João Costa</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>

        <script>
            var _gaq=[['_setAccount','UA-3525624-21'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>
</html>
