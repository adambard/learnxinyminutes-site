<!DOCTYPE html lang="pt-pt" xml:lang="pt-pt" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="pt-pt">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Scala in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/pt-pt/scala-pt/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fpt-pt%2Fscala-pt%2F&text=Aprende+X+em+Y+minutos%2C+onde+X%3DScala">
        Partilha esta página
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Selecione o tema:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">claro</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">sombrio</button>
  </div>
  <h1><a href="/">Aprende X em Y minutos</a></h1>
  <h2>Onde X=Scala</h2>
    <p class="filelink">
    Download do código:
    <a href="/docs/files/learnscala-pt.scala">learnscala-pt.scala</a>
    </p>
  <div id="doc">
    <p>Scala - a linguagem escalável</p>
<div class="highlight"><pre class="highlight scala"><code>
<span class="cm">/*
  Prepare tudo:

  1) Faça Download do Scala - http://www.scala-lang.org/downloads
  2) Faça unzip/untar para onde preferir e coloque o subdirectório `bin` na
     variável de ambiente `PATH`
  3) Inicie a REPL de Scala correndo o comando `scala`. Deve aparecer:

  scala&gt;

  Isto é chamado de REPL (Read-Eval-Print Loop / Lê-Avalia-Imprime Repete).
  Pode escrever qualquer expressão de Scala e o resultado será imprimido.
  Vamos mostrar ficheiros de Scala mais à frente neste tutorial mas, para já,
  vamos começar com os básicos.

*/</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 1. Basicos</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Uma linha de comentários é marcada com duas barras</span>

<span class="cm">/*
  Comentários de multiplas linhas, como se pode ver neste exemplo, são assim.
*/</span>

<span class="c1">// Imprimir, forçando uma nova linha no final</span>
<span class="nf">println</span><span class="o">(</span><span class="s">"Hello world!"</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>

<span class="c1">// Imprimir, sem forçar uma nova linha no final</span>
<span class="nf">print</span><span class="o">(</span><span class="s">"Hello world"</span><span class="o">)</span>

<span class="c1">// Valores são declarados com var ou val.</span>
<span class="c1">// As declarações val são imutáveis, enquanto que vars são mutáveis.</span>
<span class="c1">// A immutabilidade é uma propriedade geralmente vantajosa.</span>
<span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="mi">10</span> <span class="c1">// x é agora 10</span>
<span class="n">x</span> <span class="k">=</span> <span class="mi">20</span>     <span class="c1">// erro: reatribuição de um val</span>
<span class="k">var</span> <span class="n">y</span> <span class="k">=</span> <span class="mi">10</span>
<span class="n">y</span> <span class="k">=</span> <span class="mi">20</span>     <span class="c1">// y é agora 12</span>

<span class="cm">/*
  Scala é uma linguagem estaticamente tipada, no entanto, nas declarações acima
  não especificamos um tipo. Isto é devido a uma funcionalidade chamada
  inferência de tipos. Na maior parte dos casos, o compilador de scala consegue
  inferir qual o tipo de uma variável, pelo que não o temos de o declarar sempre.
  Podemos declarar o tipo de uma variável da seguinte forma:
*/</span>
<span class="k">val</span> <span class="nv">z</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span>
<span class="k">val</span> <span class="nv">a</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="c1">// Note a conversão automática de Int para Double: o resultado é 10.0, não 10</span>
<span class="k">val</span> <span class="nv">b</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mi">10</span>

<span class="c1">// Valores booleanos</span>
<span class="kc">true</span>
<span class="kc">false</span>

<span class="c1">// Operações booleanas</span>
<span class="o">!</span><span class="kc">true</span>         <span class="c1">// false</span>
<span class="o">!</span><span class="kc">false</span>        <span class="c1">// true</span>
<span class="kc">true</span> <span class="o">==</span> <span class="kc">false</span> <span class="c1">// false</span>
<span class="mi">10</span> <span class="o">&gt;</span> <span class="mi">5</span>        <span class="c1">// true</span>

<span class="c1">// A matemática funciona da maneira habitual</span>
<span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>   <span class="c1">// 2</span>
<span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>   <span class="c1">// 1</span>
<span class="mi">5</span> <span class="o">*</span> <span class="mi">3</span>   <span class="c1">// 15</span>
<span class="mi">6</span> <span class="o">/</span> <span class="mi">2</span>   <span class="c1">// 3</span>
<span class="mi">6</span> <span class="o">/</span> <span class="mi">4</span>   <span class="c1">// 1</span>
<span class="mf">6.0</span> <span class="o">/</span> <span class="mi">4</span> <span class="c1">// 1.5</span>


<span class="c1">// Avaliar expressões na REPL dá o tipo e valor do resultado</span>

<span class="mi">1</span> <span class="o">+</span> <span class="mi">7</span>

<span class="cm">/* A linha acima resulta em:

  scala&gt; 1 + 7
  res29: Int = 8

  Isto significa que o resultado de avaliar 1 + 7 é um objecto do tipo Int com
  o valor 8.

  Note que "res29" é um nome de uma variavel gerado sequencialmente para
  armazenar os resultados das expressões que escreveu, por isso o resultado
  pode ser ligeiramente diferente.
*/</span>

<span class="s">"Strings em scala são rodeadas por aspas"</span>
<span class="sc">'a'</span> <span class="c1">// Um caracter de Scala</span>
<span class="c1">// 'Strings entre plicas não existem' &lt;= Isto causa um erro</span>

<span class="c1">// Strings tem os métodos de Java habituais definidos</span>
<span class="s">"olá mundo"</span><span class="o">.</span><span class="py">length</span>
<span class="s">"olá mundo"</span><span class="o">.</span><span class="py">substring</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>
<span class="s">"olá mundo"</span><span class="o">.</span><span class="py">replace</span><span class="o">(</span><span class="s">"á"</span><span class="o">,</span> <span class="s">"é"</span><span class="o">)</span>

<span class="c1">// Para além disso, também possuem métodos de Scala.</span>
<span class="c1">// Ver: scala.collection.immutable.StringOps</span>
<span class="s">"olá mundo"</span><span class="o">.</span><span class="py">take</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="s">"olá mundo"</span><span class="o">.</span><span class="py">drop</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>

<span class="c1">// Interpolação de Strings: repare no prefixo "s"</span>
<span class="k">val</span> <span class="nv">n</span> <span class="k">=</span> <span class="mi">45</span>
<span class="n">s</span><span class="s">"Temos $n maçãs"</span> <span class="c1">// =&gt; "Temos 45 maçãs"</span>

<span class="c1">// Expressões dentro de Strings interpoladas também são possíveis</span>
<span class="k">val</span> <span class="nv">a</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">11</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>
<span class="n">s</span><span class="s">"A minha segunda filha tem ${a(0) - a(2)} anos."</span> <span class="c1">// =&gt; "A minha segunda filha tem 5 anos."</span>
<span class="n">s</span><span class="s">"Temos o dobro de ${n / 2.0} em maçãs."</span>          <span class="c1">// =&gt; "Temos o dobro de 22.5 em maçãs."</span>
<span class="n">s</span><span class="s">"Potência de 2: ${math.pow(2, 2)}"</span>               <span class="c1">// =&gt; "Potência de 2: 4"</span>

<span class="c1">// Strings interpoladas são formatadas com o prefixo "f"</span>
<span class="n">f</span><span class="s">"Potência de 5: ${math.pow(5, 2)}%1.0f"</span>     <span class="c1">// "Potência de 5: 25"</span>
<span class="n">f</span><span class="s">"Raíz quadrada 122: ${math.sqrt(122)}%1.4f"</span> <span class="c1">// "Raíz quadrada de 122: 11.0454"</span>

<span class="c1">// Strings prefixadas com "raw" ignoram caracteres especiais</span>
<span class="n">raw</span><span class="s">"Nova linha: \n. Retorno: \r."</span> <span class="c1">// =&gt; "Nova Linha: \n. Retorno: \r."</span>

<span class="c1">// Alguns caracteres tem de ser "escapados", e.g. uma aspa dentro de uma string:</span>
<span class="s">"Esperaram fora do  \"Rose and Crown\""</span> <span class="c1">// =&gt; "Esperaram fora do "Rose and Crown""</span>

<span class="c1">// Strings rodeadas por três aspas podem-se estender por varias linhas e conter aspas</span>
<span class="k">val</span> <span class="nv">html</span> <span class="k">=</span> <span class="s">"""&lt;form id="daform"&gt;
                &lt;p&gt;Carrega aqui, Zé&lt;/p&gt;
                &lt;input type="submit"&gt;
              &lt;/form&gt;"""</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 2. Funções</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Funções são definidas como:</span>
<span class="c1">//</span>
<span class="c1">//   def nomeDaFuncao(args...): TipoDeRetorno = { corpo... }</span>
<span class="c1">//</span>
<span class="c1">// Se vem de linugagens mais tradicionais, repare na omissão da palavra</span>
<span class="c1">// return keyword. Em Scala, a ultima expressão de um bloco é o seu</span>
<span class="c1">// valor de retorno</span>
<span class="k">def</span> <span class="nf">somaQuadrados</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">x2</span> <span class="k">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
  <span class="k">val</span> <span class="nv">y2</span> <span class="k">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span>
  <span class="n">x2</span> <span class="o">+</span> <span class="n">y2</span>
<span class="o">}</span>

<span class="c1">// As { } podem ser omitidas se o corpo da função for apenas uma expressão:</span>
<span class="k">def</span> <span class="nf">somaQuadradosCurto</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span>

<span class="c1">// A sintaxe para chamar funções deve ser familiar:</span>
<span class="nf">somaQuadrados</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>  <span class="c1">// =&gt; 25</span>

<span class="c1">// Na maior parte dos casos (sendo funções recursivas a principal excepção), o</span>
<span class="c1">// tipo de retorno da função pode ser omitido, sendo que a inferencia de tipos</span>
<span class="c1">// é aplicada aos valores de retorno</span>
<span class="k">def</span> <span class="nf">quadrado</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>  <span class="c1">// O compilador infere o tipo de retorno Int</span>

<span class="c1">// Funções podem ter parâmetros por omissão:</span>
<span class="k">def</span> <span class="nf">somaComOmissão</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="nf">somaComOmissão</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="c1">// =&gt; 3</span>
<span class="nf">somaComOmissão</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>    <span class="c1">// =&gt; 6</span>


<span class="c1">// Funções anónimas são definidas da seguinte forma:</span>
<span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="c1">// Ao contrário de defs, o tipo de input de funções anónimas pode ser omitido</span>
<span class="c1">// se o contexto o tornar óbvio. Note que o tipo "Int =&gt; Int" representa uma</span>
<span class="c1">// funão que recebe Int e retorna Int.</span>
<span class="k">val</span> <span class="nv">quadrado</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="c1">// Funcões anónimas são chamadas como funções normais:</span>
<span class="nf">quadrado</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>   <span class="c1">// =&gt; 100</span>

<span class="c1">// Se cada argumento de uma função anónima for usado apenas uma vez, existe</span>
<span class="c1">// uma forma ainda mais curta de os definir. Estas funções anónumas são</span>
<span class="c1">// extremamente comuns, como será visto na secção sobre estruturas de dados.</span>
<span class="k">val</span> <span class="nv">somaUm</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="k">_</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">val</span> <span class="nv">somaEstranha</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="k">_</span> <span class="o">*</span> <span class="mi">3</span><span class="o">)</span>

<span class="nf">somaUm</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>          <span class="c1">// =&gt; 6</span>
<span class="nf">somaEstranha</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span> <span class="c1">// =&gt; 16</span>


<span class="c1">// O código return existe em Scala, mas apenas retorna do def mais interior</span>
<span class="c1">// que o rodeia.</span>
<span class="c1">// AVISO: Usar return em Scala deve ser evitado, pois facilmente leva a erros.</span>
<span class="c1">// Não tem qualquer efeito em funções anónimas, por exemplo:</span>
<span class="k">def</span> <span class="nf">foo</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">funcAnon</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">{</span> <span class="n">z</span> <span class="k">=&gt;</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">z</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="o">)</span>
      <span class="k">return</span> <span class="n">z</span> <span class="c1">// Esta linha faz com que z seja o retorno de foo!</span>
    <span class="k">else</span>
      <span class="n">z</span> <span class="o">+</span> <span class="mi">2</span>    <span class="c1">// Esta linha define o retorno de funcAnon</span>
  <span class="o">}</span>
  <span class="nf">funcAnon</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>  <span class="c1">// Esta linha define o valor de retorno de foo</span>
<span class="o">}</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 3. Controlo de fluxo</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="mi">1</span> <span class="n">to</span> <span class="mi">5</span>
<span class="k">val</span> <span class="nv">r</span> <span class="k">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">5</span>
<span class="nv">r</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>

<span class="n">r</span> <span class="n">foreach</span> <span class="n">println</span>
<span class="c1">// NB: Scala é bastante brando no que toca a pontos e parentisis - estude as</span>
<span class="c1">// regras separadamente. Isto permite escrever APIs e DSLs bastante legiveis</span>

<span class="o">(</span><span class="mi">5</span> <span class="n">to</span> <span class="mi">1</span> <span class="n">by</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="nf">foreach</span> <span class="o">(</span><span class="n">println</span><span class="o">)</span>

<span class="c1">// Ciclos while</span>
<span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
<span class="nf">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"i "</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">}</span>

<span class="nf">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"i "</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">}</span>   <span class="c1">// Sim, outra vez. O que aconteceu? Porquê?</span>

<span class="n">i</span>    <span class="c1">// Mostra o valor de i. Note que o while é um ciclo no sentido clássico -</span>
     <span class="c1">// executa sequencialmente enquanto muda uma variável. Ciclos while são</span>
     <span class="c1">// rápidos, por vezes até mais que ciclos de Java, mas combinadores e</span>
     <span class="c1">// compreensões (usados anteriormente) são mais fáceis de entender e</span>
     <span class="c1">// paralelizar</span>

<span class="c1">// Um ciclo do while</span>
<span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">do</span> <span class="o">{</span>
  <span class="nf">println</span><span class="o">(</span><span class="s">"i ainda é menor que 10"</span><span class="o">)</span>
  <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="o">}</span> <span class="nf">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span>

<span class="c1">// A forma idiomática em Scala de definir acções recorrentes é através de</span>
<span class="c1">// recursão em cauda.</span>
<span class="c1">// Funções recursivas necessitam de um tipo de retorno definido explicitamente.</span>
<span class="c1">// Neste caso, é Unit.</span>
<span class="k">def</span> <span class="nf">mostraNumerosEntre</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="nf">print</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
  <span class="nf">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">)</span>
    <span class="nf">mostraNumerosEntre</span><span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
<span class="o">}</span>
<span class="nf">mostraNumerosEntre</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">14</span><span class="o">)</span>


<span class="c1">// Condicionais</span>

<span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="mi">10</span>

<span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="nf">println</span><span class="o">(</span><span class="s">"yeah"</span><span class="o">)</span>
<span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">10</span><span class="o">)</span> <span class="nf">println</span><span class="o">(</span><span class="s">"yeah"</span><span class="o">)</span>
<span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">11</span><span class="o">)</span> <span class="nf">println</span><span class="o">(</span><span class="s">"yeah"</span><span class="o">)</span>
<span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">11</span><span class="o">)</span> <span class="nf">println</span> <span class="o">(</span><span class="s">"yeah"</span><span class="o">)</span> <span class="k">else</span> <span class="nf">println</span><span class="o">(</span><span class="s">"nay"</span><span class="o">)</span>

<span class="nf">println</span><span class="o">(</span><span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">10</span><span class="o">)</span> <span class="s">"yeah"</span> <span class="k">else</span> <span class="s">"nope"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">text</span> <span class="k">=</span> <span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">10</span><span class="o">)</span> <span class="s">"yeah"</span> <span class="k">else</span> <span class="s">"nope"</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 4. Estruturas de dados</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="k">val</span> <span class="nv">a</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">13</span><span class="o">)</span>
<span class="nf">a</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="nf">a</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="nf">a</span><span class="o">(</span><span class="mi">21</span><span class="o">)</span>    <span class="c1">// Lança uma excepção</span>

<span class="k">val</span> <span class="nv">m</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"fork"</span> <span class="o">-&gt;</span> <span class="s">"tenedor"</span><span class="o">,</span> <span class="s">"spoon"</span> <span class="o">-&gt;</span> <span class="s">"cuchara"</span><span class="o">,</span> <span class="s">"knife"</span> <span class="o">-&gt;</span> <span class="s">"cuchillo"</span><span class="o">)</span>
<span class="nf">m</span><span class="o">(</span><span class="s">"fork"</span><span class="o">)</span>
<span class="nf">m</span><span class="o">(</span><span class="s">"spoon"</span><span class="o">)</span>
<span class="nf">m</span><span class="o">(</span><span class="s">"bottle"</span><span class="o">)</span>       <span class="c1">// Lança uma excepção</span>

<span class="k">val</span> <span class="nv">safeM</span> <span class="k">=</span> <span class="nv">m</span><span class="o">.</span><span class="py">withDefaultValue</span><span class="o">(</span><span class="s">"no lo se"</span><span class="o">)</span>
<span class="nf">safeM</span><span class="o">(</span><span class="s">"bottle"</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>
<span class="nf">s</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="nf">s</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="cm">/* Veja a documentação de mapas de scala em -
 * http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Map
 * e verifique que a consegue aceder
 */</span>


<span class="c1">// Tuplos</span>

<span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

<span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

<span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="s">"três"</span><span class="o">)</span>

<span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="s">"três"</span><span class="o">)</span>

<span class="c1">// Porquê ter isto?</span>
<span class="k">val</span> <span class="nv">divideInts</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="o">%</span> <span class="n">y</span><span class="o">)</span>

<span class="nf">divideInts</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="c1">// A função divideInts returna o resultado e o resto</span>

<span class="c1">// Para aceder aos elementos de um tuplo, pode-se usar _._n, onde n é o indice</span>
<span class="c1">// (começado em 1) do elemento</span>
<span class="k">val</span> <span class="nv">d</span> <span class="k">=</span> <span class="nf">divideInts</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="nv">d</span><span class="o">.</span><span class="py">_1</span>

<span class="nv">d</span><span class="o">.</span><span class="py">_2</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 5. Programação Orientada a Objectos</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="cm">/*
  Aparte: Até agora tudo o que fizemos neste tutorial foram expressões simples
  (valores, funções, etc). Estas expressões são suficientes para executar no
  interpretador da linha de comandos para testes rápidos, mas não podem existir
  isoladas num ficheiro de Scala. Por exemplo, não é possivel correr um
  ficheiro scala que apenas contenha "val x = 5". Em vez disso, as únicas
  construções de topo permitidas são:

  - object
  - class
  - case class
  - trait

  Vamos agora explicar o que são:
*/</span>

<span class="c1">// Classes são semelhantes a classes noutras linguagens. Os argumentos do</span>
<span class="c1">// construtor são declarados após o nome da classe, sendo a inicialização feita</span>
<span class="c1">// no corpo da classe.</span>
<span class="k">class</span> <span class="nc">Cão</span><span class="o">(</span><span class="n">rc</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// Código de construção</span>
  <span class="k">var</span> <span class="n">raça</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">rc</span>

  <span class="c1">// Define um método chamado "ladra", que retorna uma String</span>
  <span class="k">def</span> <span class="nf">ladra</span> <span class="k">=</span> <span class="s">"Woof, woof!"</span>

  <span class="c1">// Valores e métodos são assumidos como públicos, mas é possivel usar</span>
  <span class="c1">// os códigos "protected" and "private".</span>
  <span class="k">private</span> <span class="k">def</span> <span class="nf">dormir</span><span class="o">(</span><span class="n">horas</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span>
    <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Vou dormir por $horas horas"</span><span class="o">)</span>

  <span class="c1">// Métodos abstractos são métodos sem corpo. Se descomentarmos a próxima</span>
  <span class="c1">// linha, a classe Cão é declarada como abstracta</span>
  <span class="c1">//   abstract class Cão(...) { ... }</span>
  <span class="c1">// def persegue(oQue: String): String</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">oMeuCão</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cão</span><span class="o">(</span><span class="s">"greyhound"</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">oMeuCão</span><span class="o">.</span><span class="py">raça</span><span class="o">)</span>  <span class="c1">// =&gt; "greyhound"</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">oMeuCão</span><span class="o">.</span><span class="py">ladra</span><span class="o">)</span> <span class="c1">// =&gt; "Woof, woof!"</span>


<span class="c1">// O termo "object" cria um tipo e uma instancia singleton desse tipo. É comum</span>
<span class="c1">// que classes de Scala possuam um "objecto companheiro", onde o comportamento</span>
<span class="c1">// por instância é capturado nas classes, equanto que o comportamento</span>
<span class="c1">// relacionado com todas as instancias dessa classe ficam no objecto.</span>
<span class="c1">// A diferença é semelhante a métodos de classes e métodos estáticos noutras</span>
<span class="c1">// linguagens. Note que objectos e classes podem ter o mesmo nome.</span>
<span class="k">object</span> <span class="nc">Cão</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">raçasConhecidas</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"pitbull"</span><span class="o">,</span> <span class="s">"shepherd"</span><span class="o">,</span> <span class="s">"retriever"</span><span class="o">)</span>
  <span class="k">def</span> <span class="nf">criarCão</span><span class="o">(</span><span class="n">raça</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cão</span><span class="o">(</span><span class="n">raça</span><span class="o">)</span>
<span class="o">}</span>


<span class="c1">// Case classes são classes com funcionalidades extra incluidas. Uma questão</span>
<span class="c1">// comum de iniciantes de scala é quando devem usar classes e quando devem usar</span>
<span class="c1">// case classes. A linha é difusa mas, em geral, classes tendem a concentrar-se</span>
<span class="c1">// em encapsulamento, polimorfismo e comportamento. Os valores nestas classes</span>
<span class="c1">// tendem a ser privados, sendo apenas exposotos métodos. O propósito principal</span>
<span class="c1">// das case classes é armazenarem dados imutáveis. Geralmente possuem poucos</span>
<span class="c1">// métods, sendo que estes raramente possuem efeitos secundários.</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Pessoa</span><span class="o">(</span><span class="n">nome</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">telefone</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="c1">// Cria uma nova instancia. De notar que case classes não precisam de "new"</span>
<span class="k">val</span> <span class="nv">jorge</span> <span class="k">=</span> <span class="nc">Pessoa</span><span class="o">(</span><span class="s">"Jorge"</span><span class="o">,</span> <span class="s">"1234"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">cátia</span> <span class="k">=</span> <span class="nc">Pessoa</span><span class="o">(</span><span class="s">"Cátia"</span><span class="o">,</span> <span class="s">"4567"</span><span class="o">)</span>

<span class="c1">// Case classes trazem algumas vantagens de borla, como acessores:</span>
<span class="nv">jorge</span><span class="o">.</span><span class="py">telefone</span>  <span class="c1">// =&gt; "1234"</span>

<span class="c1">// Igualdade por campo (não é preciso fazer override do .equals)</span>
<span class="nc">Pessoa</span><span class="o">(</span><span class="s">"Jorge"</span><span class="o">,</span> <span class="s">"1234"</span><span class="o">)</span> <span class="o">==</span> <span class="nc">Pessoa</span><span class="o">(</span><span class="s">"Cátia"</span><span class="o">,</span> <span class="s">"1236"</span><span class="o">)</span>  <span class="c1">// =&gt; false</span>

<span class="c1">// Cópia simples</span>
<span class="c1">// outroJorge == Person("jorge", "9876")</span>
<span class="k">val</span> <span class="nv">outroJorge</span> <span class="k">=</span> <span class="nv">jorge</span><span class="o">.</span><span class="py">copy</span><span class="o">(</span><span class="n">telefone</span> <span class="k">=</span> <span class="s">"9876"</span><span class="o">)</span>

<span class="c1">// Entre outras. Case classes também suportam correspondência de padrões de</span>
<span class="c1">// borla, como pode ser visto de seguida.</span>


<span class="c1">// Traits em breve!</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 6. Correspondência de Padrões</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// A correspondência de padrões é uma funcionalidade poderosa e bastante</span>
<span class="c1">// utilizada em Scala. Eis como fazer correspondência de padrões numa case class:</span>
<span class="c1">// Nota: Ao contrário de outras linguagens, cases em scala não necessitam de</span>
<span class="c1">// breaks, a computação termina no primeiro sucesso.</span>

<span class="k">def</span> <span class="nf">reconhecePessoa</span><span class="o">(</span><span class="n">pessoa</span><span class="k">:</span> <span class="kt">Pessoa</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">pessoa</span> <span class="k">match</span> <span class="o">{</span>
  <span class="c1">// Agora, especifique os padrões:</span>
  <span class="k">case</span> <span class="nc">Pessoa</span><span class="o">(</span><span class="s">"Jorge"</span><span class="o">,</span> <span class="n">tel</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"Encontramos o Jorge! O seu número é "</span> <span class="o">+</span> <span class="n">tel</span>
  <span class="k">case</span> <span class="nc">Pessoa</span><span class="o">(</span><span class="s">"Cátia"</span><span class="o">,</span> <span class="n">tel</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"Encontramos a Cátia! O seu número é "</span> <span class="o">+</span> <span class="n">tel</span>
  <span class="k">case</span> <span class="nc">Pessoa</span><span class="o">(</span><span class="n">nome</span><span class="o">,</span> <span class="n">tel</span><span class="o">)</span>    <span class="k">=&gt;</span> <span class="s">"Econtramos alguém : "</span> <span class="o">+</span> <span class="n">nome</span> <span class="o">+</span> <span class="s">", telefone : "</span> <span class="o">+</span> <span class="n">tel</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">email</span> <span class="k">=</span> <span class="s">"(.*)@(.*)"</span><span class="o">.</span><span class="py">r</span>  <span class="c1">// Define uma regex para o próximo exemplo.</span>

<span class="c1">// A correspondência de padrões pode parecer familiar aos switches em linguagens</span>
<span class="c1">// derivadas de C, mas é muto mais poderoso. Em Scala, é possível fazer</span>
<span class="c1">// correspondências com muito mais:</span>
<span class="k">def</span> <span class="nf">correspondeTudo</span><span class="o">(</span><span class="n">obj</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">obj</span> <span class="k">match</span> <span class="o">{</span>
  <span class="c1">// Pode-se corresponder valores:</span>
  <span class="k">case</span> <span class="s">"Olá mundo"</span> <span class="k">=&gt;</span> <span class="s">"Recebi uma string Olá mundo."</span>

  <span class="c1">// Corresponder por tipo:</span>
  <span class="k">case</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=&gt;</span> <span class="s">"Recebi um Double: "</span> <span class="o">+</span> <span class="n">x</span>

  <span class="c1">// Corresponder tendo em conta condições especificas:</span>
  <span class="k">case</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span> <span class="kt">if</span> <span class="kt">x</span> <span class="kt">&gt;</span> <span class="err">10000</span> <span class="o">=&gt;</span> <span class="s">"Recebi um número bem grande!"</span>

  <span class="c1">// Fazer correspondências com case classes (visto anteriormente):</span>
  <span class="k">case</span> <span class="nc">Pessoa</span><span class="o">(</span><span class="n">nome</span><span class="o">,</span> <span class="n">tel</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"Recebi o contacto para $nome!"</span>

  <span class="c1">// Fazer correspondência com expressões regulares:</span>
  <span class="k">case</span> <span class="nf">email</span><span class="o">(</span><span class="n">nome</span><span class="o">,</span> <span class="n">dominio</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"Recebi o endereço de email $nome@$dominio"</span>

  <span class="c1">// Corresponder tuplos:</span>
  <span class="nf">case</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">c</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"Recebi o tuplo: $a, $b, $c"</span>

  <span class="c1">// Corresponder estruturas de dados:</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"Recebi uma lista de 3 elementos começada em 1: 1, $b, $c"</span>

  <span class="c1">// Combinar padrões:</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="s">"YAY"</span><span class="o">)))</span> <span class="k">=&gt;</span> <span class="s">"Recebi uma lista de lista de triplo"</span>
<span class="o">}</span>

<span class="c1">// Na realidade, é possível fazer correspondência com qualquer objecto que</span>
<span class="c1">// defina o método "unapply". Esta funcionalidade é tão poderosa que permite</span>
<span class="c1">// definir funções sob a forma de padrões:</span>
<span class="k">val</span> <span class="nv">funcPaddrao</span><span class="k">:</span> <span class="kt">Pessoa</span> <span class="o">=&gt;</span> <span class="nc">String</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Pessoa</span><span class="o">(</span><span class="s">"Jorge"</span><span class="o">,</span> <span class="n">tel</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"Número do Jorge: $tel"</span>
  <span class="k">case</span> <span class="nc">Pessoa</span><span class="o">(</span><span class="n">nome</span><span class="o">,</span> <span class="n">tel</span><span class="o">)</span>    <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"Número de alguém: $tel"</span>
<span class="o">}</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 7. Programação Funcional</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Scala permite que funções e métodos retornem, ou recebam como parámetros,</span>
<span class="c1">// outras funções ou métodos</span>

<span class="k">val</span> <span class="nv">soma10</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="k">_</span> <span class="o">+</span> <span class="mi">10</span> <span class="c1">// Função que recebe um Int e retorna um Int</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="n">map</span> <span class="n">soma10</span> <span class="c1">// List(11, 12, 13) - soma10 é aplicado a cada elemento</span>

<span class="c1">// Funções anónimas também podem ser usadas</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">10</span><span class="o">)</span>

<span class="c1">// Sendo que o símbolo _ também pode ser usado se a função anónima só receber</span>
<span class="c1">// um argumento. Este fica com o valor da variável</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">10</span><span class="o">)</span>

<span class="c1">// Se tanto o bloco como a função apenas receberem um argumento, o próprio</span>
<span class="c1">// _ pode ser omitido</span>
<span class="nc">List</span><span class="o">(</span><span class="s">"Dom"</span><span class="o">,</span> <span class="s">"Bob"</span><span class="o">,</span> <span class="s">"Natalia"</span><span class="o">)</span> <span class="n">foreach</span> <span class="n">println</span>


<span class="c1">// Combinadores</span>

<span class="nv">s</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">quadrado</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">sQuadrado</span> <span class="k">=</span> <span class="nv">s</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">quadrado</span><span class="o">)</span>

<span class="nv">sQuadrado</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="k">_</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span>

<span class="nv">sQuadrado</span><span class="o">.</span><span class="py">reduce</span> <span class="o">(</span><span class="k">_</span><span class="o">+</span><span class="k">_</span><span class="o">)</span>

<span class="c1">// O método filter recebe um predicado (uma função de A =&gt; Boolean) e escolhe</span>
<span class="c1">// todos os elementos que satisfazem o predicado</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="nf">filter</span> <span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="c1">// List(3)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Pessoa</span><span class="o">(</span><span class="n">nome</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">idade</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(</span>
  <span class="nc">Pessoa</span><span class="o">(</span><span class="n">nome</span> <span class="k">=</span> <span class="s">"Dom"</span><span class="o">,</span> <span class="n">idade</span> <span class="k">=</span> <span class="mi">23</span><span class="o">),</span>
  <span class="nc">Pessoa</span><span class="o">(</span><span class="n">nome</span> <span class="k">=</span> <span class="s">"Bob"</span><span class="o">,</span> <span class="n">idade</span> <span class="k">=</span> <span class="mi">30</span><span class="o">)</span>
<span class="o">).</span><span class="py">filter</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">idade</span> <span class="o">&gt;</span> <span class="mi">25</span><span class="o">)</span> <span class="c1">// List(Pessoa("Bob", 30))</span>


<span class="c1">// O método foreach recebe uma função de A =&gt; Unit, executando essa função em</span>
<span class="c1">// cada elemento da colecção</span>
<span class="k">val</span> <span class="nv">aListOfNumbers</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">100</span><span class="o">)</span>
<span class="n">aListOfNumbers</span> <span class="nf">foreach</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
<span class="n">aListOfNumbers</span> <span class="n">foreach</span> <span class="n">println</span>

<span class="c1">// Compreensões For</span>

<span class="k">for</span> <span class="o">{</span> <span class="n">n</span> <span class="k">&lt;-</span> <span class="n">s</span> <span class="o">}</span> <span class="k">yield</span> <span class="nf">quadrado</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">nQuadrado2</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span> <span class="n">n</span> <span class="k">&lt;-</span> <span class="n">s</span> <span class="o">}</span> <span class="k">yield</span> <span class="nf">quadrado</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>

<span class="k">for</span> <span class="o">{</span> <span class="n">n</span> <span class="k">&lt;-</span> <span class="n">nQuadrado2</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">}</span> <span class="k">yield</span> <span class="n">n</span>

<span class="k">for</span> <span class="o">{</span> <span class="n">n</span> <span class="k">&lt;-</span> <span class="n">s</span><span class="o">;</span> <span class="n">nQuadrado</span> <span class="k">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span> <span class="k">if</span> <span class="n">nQuadrado</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">}</span> <span class="k">yield</span> <span class="n">nQuadrado</span>

<span class="cm">/* Nota: isto não são ciclos for: A semântica de um ciclo é 'repetir', enquanto
   que uma compreensão define a relação entre dois conjuntos de dados. */</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 8. Implicitos</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="cm">/* AVISO IMPORTANTE: Implicitos são um conjunto de funcionalidades muito
 * poderosas em Scala, que podem ser fácilmente abusadas. Iniciantes devem
 * resistir a tentação de usá-los até que compreendam não só como funcionam,
 * mas também as melhores práticas. Apenas incluimos esta secção no tutorial
 * devido a estes serem tão comuns em bibliotecas de Scala que muitas delas
 * se tornam impossíveis de usar sem conhecer implicitos. Este capítulo serve
 * para compreender como trabalhar com implicitos, não como declará-los.
*/</span>

<span class="c1">// Qualquer valor (vals, funções, objectos, etc) pode ser declarado como</span>
<span class="c1">// implicito usando a palavra "implicit". Vamos usar a classe Cão da secção 5</span>
<span class="c1">// nestes exemplos</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">oMeuIntImplicito</span> <span class="k">=</span> <span class="mi">100</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="nf">aMinhaFunçãoImplicita</span><span class="o">(</span><span class="n">raça</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cão</span><span class="o">(</span><span class="s">"Golden "</span> <span class="o">+</span> <span class="n">raça</span><span class="o">)</span>

<span class="c1">// Por si só, a palavra implicit não altera o comportamento de um valor, sendo</span>
<span class="c1">// que estes podem ser usados da forma habitual.</span>
<span class="n">oMeuIntImplicito</span> <span class="o">+</span> <span class="mi">2</span>                   <span class="c1">// =&gt; 102</span>
<span class="nf">aMinhaFunçãoImplicita</span><span class="o">(</span><span class="s">"Pitbull"</span><span class="o">).</span><span class="py">raça</span> <span class="c1">// =&gt; "Golden Pitbull"</span>

<span class="c1">// A diferença é que estes valores podem ser utilizados quando outro pedaço de</span>
<span class="c1">// código "necessite" de uma valor implicito. Um exemplo são argumentos</span>
<span class="c1">// implicitos de funções:</span>
<span class="k">def</span> <span class="nf">enviaCumprimentos</span><span class="o">(</span><span class="n">aQuem</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">quantos</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span>
  <span class="n">s</span><span class="s">"Olá $aQuem, $quantos cumprimentos para ti e para os teus!"</span>

<span class="c1">// Se dermos um valor a "quantos", a função comporta-se normalmente</span>
<span class="nf">enviaCumprimentos</span><span class="o">(</span><span class="s">"João"</span><span class="o">)(</span><span class="mi">1000</span><span class="o">)</span>  <span class="c1">// =&gt; "Olá João, 1000 cumprimentos para ti e para os teus!"</span>

<span class="c1">// Mas, se omitirmos o parâmetro implicito, um valor implicito do mesmo tipo é</span>
<span class="c1">// usado, neste caso, "oMeuInteiroImplicito"</span>
<span class="nf">enviaCumprimentos</span><span class="o">(</span><span class="s">"Joana"</span><span class="o">)</span>  <span class="c1">// =&gt; "Olá Joana, 100 cumprimentos para ti e para os teus!"</span>

<span class="c1">// Parâmentros implicitos de funções permitem-nos simular classes de tipos de</span>
<span class="c1">// outras linguagens funcionais. Isto é tão comum que tem a sua própria notação.</span>
<span class="c1">// As seguintes linhas representam a mesma coisa</span>
<span class="c1">// def foo[T](implicit c: C[T]) = ...</span>
<span class="c1">// def foo[T : C] = ...</span>


<span class="c1">// Outra situação em que o compilador prouca um implicito é se encontrar uma</span>
<span class="c1">// expressão</span>
<span class="c1">//    obj.método(...)</span>
<span class="c1">// mas "obj" não possuir um método chamado "método". Neste cso, se houver uma</span>
<span class="c1">// conversão implicita A =&gt; B, onde A é o tipo de obj, e B possui um método</span>
<span class="c1">// chamado "método", a conversão é aplicada. Ou seja, tendo</span>
<span class="c1">// aMinhaFunçãoImplicita definida, podemos dizer</span>
<span class="s">"Retriever"</span><span class="o">.</span><span class="py">raça</span> <span class="c1">// =&gt; "Golden Retriever"</span>
<span class="s">"Sheperd"</span><span class="o">.</span><span class="py">ladra</span>  <span class="c1">// =&gt; "Woof, woof!"</span>

<span class="c1">// Neste caso, a String é primeiro convertida para Cão usando a nossa funão,</span>
<span class="c1">// sendo depois chamado o método apropriado. Esta é uma funcionalidade</span>
<span class="c1">// incrivelmente poderosa, sendo que deve ser usada com cautela. Na verdade,</span>
<span class="c1">// ao definir a função implicita, o compilador deve lançar um aviso a insisitir</span>
<span class="c1">// que só deve definir a função se souber o que está a fazer.</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 9. Misc</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Importar coisas</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable.List</span>

<span class="c1">// Importar todos os "sub pacotes"</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable._</span>

<span class="c1">// Importar multiplas classes numa linha</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable.</span><span class="o">{</span><span class="nc">List</span><span class="o">,</span> <span class="nc">Map</span><span class="o">}</span>

<span class="c1">// Renomear uma classe importada usando '=&gt;'</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable.</span><span class="o">{</span><span class="nc">List</span> <span class="k">=&gt;</span> <span class="nc">ImmutableList</span><span class="o">}</span>

<span class="c1">// Importar todas as classes excepto algumas. Set e Map são excluidos:</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable.</span><span class="o">{</span><span class="nc">Map</span> <span class="k">=&gt;</span> <span class="k">_</span><span class="o">,</span> <span class="nc">Set</span> <span class="k">=&gt;</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">}</span>

<span class="c1">// O ponto de entrada de um programa em Scala é definido por un ficheiro .scala</span>
<span class="c1">// com um método main:</span>
<span class="k">object</span> <span class="nc">Aplicação</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="c1">// código aqui.</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Ficheiros podem conter várias classes o objectos. Compilar com scalac</span>




<span class="c1">// Input e output</span>

<span class="c1">// Ler um ficheiro linha a linha</span>
<span class="k">import</span> <span class="nn">scala.io.Source</span>
<span class="nf">for</span><span class="o">(</span><span class="n">linha</span> <span class="k">&lt;-</span> <span class="nv">Source</span><span class="o">.</span><span class="py">fromFile</span><span class="o">(</span><span class="s">"ficheiro.txt"</span><span class="o">).</span><span class="py">getLines</span><span class="o">())</span>
  <span class="nf">println</span><span class="o">(</span><span class="n">linha</span><span class="o">)</span>

<span class="c1">// Escrever um ficheiro usando o PrintWriter de Java</span>
<span class="k">val</span> <span class="nv">writer</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PrintWriter</span><span class="o">(</span><span class="s">"ficheiro.txt"</span><span class="o">)</span>
<span class="nv">writer</span><span class="o">.</span><span class="py">write</span><span class="o">(</span><span class="s">"Escrevendo linha por linha"</span> <span class="o">+</span> <span class="nv">util</span><span class="o">.</span><span class="py">Properties</span><span class="o">.</span><span class="py">lineSeparator</span><span class="o">)</span>
<span class="nv">writer</span><span class="o">.</span><span class="py">write</span><span class="o">(</span><span class="s">"Outra linha aqui"</span> <span class="o">+</span> <span class="nv">util</span><span class="o">.</span><span class="py">Properties</span><span class="o">.</span><span class="py">lineSeparator</span><span class="o">)</span>
<span class="nv">writer</span><span class="o">.</span><span class="py">close</span><span class="o">()</span>

</code></pre></div>
<h2>Mais recursos</h2>

<ul>
<li><a href="http://horstmann.com/scala/">Scala for the impatient</a></li>
<li><a href="http://twitter.github.io/scala_school/">Twitter Scala school</a></li>
<li><a href="http://docs.scala-lang.org/">The scala documentation</a></li>
<li><a href="http://scalatutorials.com/tour/">Try Scala in your browser</a></li>
<li>Join the <a href="https://groups.google.com/forum/#!forum/scala-user">Scala user group</a></li>
</ul>

    <hr>
    <p>Tens alguma sugestão? Uma correção, talvez? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Abre um Issue</a> no repositório do Github, or faz um <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/pt-pt/scala-pt.html.markdown">pull request</a> tu mesmo!
    </p>
    <p class="contributed">
    Originalmente contribuido por George Petrov, e atualizado por <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/pt-pt/scala-pt.html.markdown">3 contribuidor(es)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://github.com/petrovg">George Petrov</a>,
        <a href="http://dbousamra.github.com">Dominic Bou-Samra</a>,
        <a href="http://geoffliu.me">Geoff Liu</a>,
        <a href="http://reference-error.org">Ha-Duong Nguyen</a>
    </p>

    <p>
      Translated by:
        <a href="http://joaocosta.eu">João Costa</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>

        <script>
            var _gaq=[['_setAccount','UA-3525624-21'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>
</html>
