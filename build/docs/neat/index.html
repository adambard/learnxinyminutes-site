<!DOCTYPE html lang="en-us" xml:lang="en-us" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="en-us">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn neat in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/neat/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fneat%2F&text=Learn+X+in+Y+minutes%2C+where+X%3Dneat">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="/">Learn X in Y minutes</a></h1>
  <h2>Where X=neat</h2>
    <p class="filelink">
    Get the code:
    <a href="/docs/files/LearnNeat.nt">LearnNeat.nt</a>
    </p>
  <div id="doc">
    <p>Neat is basically a smaller version of D1 with some experimental syntax and a focus on terseness without losing the basic C-like syntax.</p>

<p><a href="https://github.com/FeepingCreature/fcc/wiki">Read more here.</a></p>
<div class="highlight"><pre class="highlight c"><code><span class="c1">// single line comments start with //</span>
<span class="cm">/*
  multiline comments look like this
*/</span>
<span class="o">/+</span>
  <span class="n">or</span> <span class="n">this</span>
  <span class="o">/+</span> <span class="n">these</span> <span class="n">can</span> <span class="n">be</span> <span class="n">nested</span> <span class="n">too</span><span class="p">,</span> <span class="n">same</span> <span class="n">as</span> <span class="n">D</span> <span class="o">+/</span>
<span class="o">+/</span>

<span class="c1">// Module name. This has to match the filename/directory.</span>
<span class="n">module</span> <span class="n">LearnNeat</span><span class="p">;</span>

<span class="c1">// Make names from another module visible in this one.</span>
<span class="n">import</span> <span class="n">std</span><span class="p">.</span><span class="n">file</span><span class="p">;</span>
<span class="c1">// You can import multiple things at once.</span>
<span class="n">import</span> <span class="n">std</span><span class="p">.</span><span class="n">math</span><span class="p">,</span> <span class="n">std</span><span class="p">.</span><span class="n">util</span><span class="p">;</span>
<span class="c1">// You can even group up imports!</span>
<span class="n">import</span> <span class="n">std</span><span class="p">.(</span><span class="n">process</span><span class="p">,</span> <span class="n">socket</span><span class="p">);</span>

<span class="c1">// Global functions!</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

<span class="c1">// Main function, same as in C.</span>
<span class="c1">// string[] == "array of strings".</span>
<span class="c1">// "string" is just an alias for char[],</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Call functions with "function expression".</span>
  <span class="n">writeln</span> <span class="s">"Hello World"</span><span class="p">;</span>
  <span class="c1">// You can do it like in C too... if you really want.</span>
  <span class="n">writeln</span> <span class="p">(</span><span class="s">"Hello World"</span><span class="p">);</span>
  <span class="c1">// Declare a variable with "type identifier"</span>
  <span class="n">string</span> <span class="n">arg</span> <span class="o">=</span> <span class="p">(</span><span class="s">"Hello World"</span><span class="p">);</span>
  <span class="n">writeln</span> <span class="n">arg</span><span class="p">;</span>
  <span class="c1">// (expression, expression) forms a tuple.</span>
  <span class="c1">// There are no one-value tuples though.</span>
  <span class="c1">// So you can always use () in the mathematical sense.</span>
  <span class="c1">// (string) arg; &lt;- is an error</span>

  <span class="cm">/*
    byte: 8 bit signed integer
      char: 8 bit UTF-8 byte component.
    short: 16 bit signed integer
    int: 32 bit signed integer
    long: 64 bit signed integer

    float: 32 bit floating point
    double: 64 bit floating point
    real: biggest native size floating point (80 bit on x86).

    bool: true or false
  */</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="n">bool</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="c1">// as in C, &amp;&amp; and || are short-circuit evaluating.</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">&amp;&amp;</span> <span class="nb">false</span><span class="p">;</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="nb">false</span><span class="p">);</span>
  <span class="c1">// "" are "format strings". So $variable will be substituted at runtime</span>
  <span class="c1">// with a formatted version of the variable.</span>
  <span class="n">writeln</span> <span class="s">"$a"</span><span class="p">;</span>
  <span class="c1">// This will just print $a.</span>
  <span class="n">writeln</span> <span class="err">`$</span><span class="n">a</span><span class="err">`</span><span class="p">;</span>
  <span class="c1">// you can format expressions with $()</span>
  <span class="n">writeln</span> <span class="s">"$(2+2)"</span><span class="p">;</span>
  <span class="c1">// Note: there is no special syntax for characters.</span>
  <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="s">"a"</span><span class="p">;</span>
  <span class="c1">// Cast values by using type: expression.</span>
  <span class="c1">// There are three kinds of casts:</span>
  <span class="c1">// casts that just specify conversions that would be happening automatically</span>
  <span class="c1">// (implicit casts)</span>
  <span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="kt">float</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">f2</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// would also work</span>
  <span class="c1">// casts that require throwing away information or complicated computation -</span>
  <span class="c1">// those must always be done explicitly</span>
  <span class="c1">// (conversion casts)</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="kt">int</span><span class="o">:</span><span class="n">f</span><span class="p">;</span>
  <span class="c1">// int i = f; // would not work!</span>
  <span class="c1">// and, as a last attempt, casts that just reinterpret the raw data.</span>
  <span class="c1">// Those only work if the types have the same size.</span>
  <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"Hello World"</span><span class="p">;</span>
  <span class="c1">// Arrays are (length, pointer) pairs.</span>
  <span class="c1">// This is a tuple type. Tuple types are (type, type, type).</span>
  <span class="c1">// The type of a tuple expression is a tuple type. (duh)</span>
  <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">array</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">:</span> <span class="n">s</span><span class="p">;</span>
  <span class="c1">// You can index arrays and tuples using the expression[index] syntax.</span>
  <span class="n">writeln</span> <span class="s">"pointer is $(array[1]) and length is $(array[0])"</span><span class="p">;</span>
  <span class="c1">// You can slice them using the expression[from .. to] syntax.</span>
  <span class="c1">// Slicing an array makes another array.</span>
  <span class="n">writeln</span> <span class="s">"$(s[0..5]) World"</span><span class="p">;</span>
  <span class="c1">// Alias name = expression gives the expression a name.</span>
  <span class="c1">// As opposed to a variable, aliases do not have an address</span>
  <span class="c1">// and can not be assigned to. (Unless the expression is assignable)</span>
  <span class="n">alias</span> <span class="n">range</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">..</span> <span class="mi">5</span><span class="p">;</span>
  <span class="n">writeln</span> <span class="s">"$(s[range]) World"</span><span class="p">;</span>
  <span class="c1">// You can iterate over ranges.</span>
  <span class="k">for</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">&lt;-</span> <span class="n">range</span> <span class="p">{</span>
    <span class="n">write</span> <span class="s">"$(s[i])"</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">writeln</span> <span class="s">" World"</span><span class="p">;</span>
  <span class="c1">// Note that if "range" had been a variable, it would be 'empty' now!</span>
  <span class="c1">// Range variables can only be iterated once.</span>
  <span class="c1">// The syntax for iteration is "expression &lt;- iterable".</span>
  <span class="c1">// Lots of things are iterable.</span>
  <span class="k">for</span> <span class="kt">char</span> <span class="n">c</span> <span class="o">&lt;-</span> <span class="s">"Hello"</span> <span class="p">{</span> <span class="n">write</span> <span class="s">"$c"</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">writeln</span> <span class="s">" World"</span><span class="p">;</span>
  <span class="c1">// For loops are "for test statement";</span>
  <span class="n">alias</span> <span class="n">test</span> <span class="o">=</span> <span class="kt">char</span> <span class="n">d</span> <span class="o">&lt;-</span> <span class="s">"Hello"</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">test</span> <span class="n">write</span> <span class="s">"$d"</span><span class="p">;</span>
  <span class="n">writeln</span> <span class="s">" World</span><span class="se">\t\x05</span><span class="s">"</span><span class="p">;</span> <span class="c1">// note: escapes work</span>
  <span class="c1">// Pointers: function the same as in C, btw. The usual.</span>
  <span class="c1">// Do note: the pointer star sticks with the TYPE, not the VARIABLE!</span>
  <span class="n">string</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">null</span><span class="p">);</span> <span class="c1">// default initializer</span>
  <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">;</span>
  <span class="n">writeln</span> <span class="s">"$(*p)"</span><span class="p">;</span>
  <span class="c1">// Math operators are (almost) standard.</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">;</span>
  <span class="c1">// Note: XOR is "xor". ^ is reserved for exponentiation (once I implement that).</span>
  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">3</span> <span class="n">xor</span> <span class="mi">5</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">z</span><span class="o">++</span> <span class="o">==</span> <span class="mi">5</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="o">++</span><span class="n">z</span> <span class="o">==</span> <span class="mi">7</span><span class="p">);</span>
  <span class="n">writeln</span> <span class="s">"x $x y $y z $z"</span><span class="p">;</span>
  <span class="c1">// As in D, ~ concatenates.</span>
  <span class="n">string</span> <span class="n">hewo</span> <span class="o">=</span> <span class="s">"Hello "</span> <span class="o">~</span> <span class="s">"World"</span><span class="p">;</span>
  <span class="c1">// == tests for equality, "is" tests for identity.</span>
  <span class="n">assert</span>  <span class="p">(</span><span class="n">hewo</span> <span class="o">==</span> <span class="n">s</span><span class="p">);</span>
  <span class="n">assert</span> <span class="o">!</span><span class="p">(</span><span class="n">hewo</span> <span class="n">is</span> <span class="n">s</span><span class="p">);</span>
  <span class="c1">// same as</span>
  <span class="n">assert</span>  <span class="p">(</span><span class="n">hewo</span> <span class="o">!</span><span class="n">is</span> <span class="n">s</span><span class="p">);</span>

  <span class="c1">// Allocate arrays using "new array length"</span>
  <span class="kt">int</span><span class="p">[]</span> <span class="n">integers</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">int</span><span class="p">[]</span> <span class="mi">10</span><span class="p">;</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">integers</span><span class="p">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">10</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">integers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// zero is default initializer</span>
  <span class="n">integers</span> <span class="o">=</span> <span class="n">integers</span> <span class="o">~</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// This allocates a new array!</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">integers</span><span class="p">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">11</span><span class="p">);</span>

  <span class="c1">// This is an appender array.</span>
  <span class="c1">// Instead of (length, pointer), it tracks (capacity, length, pointer).</span>
  <span class="c1">// When you append to it, it will use the free capacity if it can.</span>
  <span class="c1">// If it runs out of space, it reallocates - but it will free the old array automatically.</span>
  <span class="c1">// This makes it convenient for building arrays.</span>
  <span class="kt">int</span><span class="p">[</span><span class="k">auto</span><span class="o">~</span><span class="p">]</span> <span class="n">appender</span><span class="p">;</span>
  <span class="n">appender</span> <span class="o">~=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">appender</span> <span class="o">~=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="n">appender</span><span class="p">.</span><span class="n">free</span><span class="p">();</span> <span class="c1">// same as {mem.free(appender.ptr); appender = null;}</span>

  <span class="c1">// Scope variables are automatically freed at the end of the current scope.</span>
  <span class="n">scope</span> <span class="kt">int</span><span class="p">[</span><span class="k">auto</span><span class="o">~</span><span class="p">]</span> <span class="n">someOtherAppender</span><span class="p">;</span>
  <span class="c1">// This is the same as:</span>
  <span class="kt">int</span><span class="p">[</span><span class="k">auto</span><span class="o">~</span><span class="p">]</span> <span class="n">someOtherAppender2</span><span class="p">;</span>
  <span class="n">onExit</span> <span class="p">{</span> <span class="n">someOtherAppender2</span><span class="p">.</span><span class="n">free</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// You can do a C for loop too</span>
  <span class="c1">// - but why would you want to?</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
  <span class="c1">// Otherwise, for and while are the same.</span>
  <span class="k">while</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">&lt;-</span> <span class="mi">0</span><span class="p">..</span><span class="mi">4</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span> <span class="c1">// continue works too</span>
  <span class="p">}</span> <span class="n">then</span> <span class="n">assert</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span> <span class="c1">// if we hadn't break'd, this would run at the end</span>
  <span class="c1">// This is the height of loopdom - the produce-test-consume loop.</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">5</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span> <span class="c1">// otherwise we'd go back up to do {</span>
  <span class="p">}</span>

  <span class="c1">// This is a nested function.</span>
  <span class="c1">// Nested functions can access the surrounding function.</span>
  <span class="n">string</span> <span class="n">returnS</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">s</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">writeln</span> <span class="n">returnS</span><span class="p">();</span>

  <span class="c1">// Take the address of a function using &amp;</span>
  <span class="c1">// The type of a global function is ReturnType function(ParameterTypeTuple).</span>
  <span class="kt">void</span> <span class="n">function</span><span class="p">()</span> <span class="n">foop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">foo</span><span class="p">;</span>

  <span class="c1">// Similarly, the type of a nested function is ReturnType delegate(ParameterTypeTuple).</span>
  <span class="n">string</span> <span class="n">delegate</span><span class="p">()</span> <span class="n">returnSp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">returnS</span><span class="p">;</span>
  <span class="n">writeln</span> <span class="n">returnSp</span><span class="p">();</span>
  <span class="c1">// Class member functions and struct member functions also fit into delegate variables.</span>
  <span class="c1">// In general, delegates are functions that carry an additional context pointer.</span>
  <span class="c1">// ("fat pointers" in C)</span>

  <span class="c1">// Allocate a "snapshot" with "new delegate".</span>
  <span class="c1">// Snapshots are not closures! I used to call them closures too,</span>
  <span class="c1">// but then my Haskell-using friends yelled at me so I had to stop.</span>
  <span class="c1">// The difference is that snapshots "capture" their surrounding context</span>
  <span class="c1">// when "new" is used.</span>
  <span class="c1">// This allows things like this</span>
  <span class="kt">int</span> <span class="n">delegate</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">add_a</span><span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// This does not work - the context of add_a becomes invalid</span>
    <span class="c1">// when add returns.</span>
    <span class="c1">// return &amp;add_a;</span>
    <span class="c1">// Instead:</span>
    <span class="k">return</span> <span class="n">new</span> <span class="o">&amp;</span><span class="n">add_a</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">int</span> <span class="n">delegate</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">dg</span> <span class="o">=</span> <span class="n">add</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">dg</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">);</span>
  <span class="c1">// or</span>
  <span class="n">assert</span> <span class="p">(((</span><span class="n">add</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">);</span>
  <span class="c1">// or</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">add</span> <span class="mi">2</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">5</span><span class="p">);</span>
  <span class="c1">// add can also be written as</span>
  <span class="kt">int</span> <span class="n">delegate</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">add2</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// this is an implicit, nameless nested function.</span>
    <span class="k">return</span> <span class="n">new</span> <span class="err">λ</span><span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// or even</span>
  <span class="k">auto</span> <span class="n">add3</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">new</span> <span class="err">λ</span><span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
  <span class="c1">// hahahaaa</span>
  <span class="k">auto</span> <span class="n">add4</span> <span class="o">=</span> <span class="err">λ</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">new</span> <span class="err">λ</span><span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">add4</span> <span class="mi">2</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">5</span><span class="p">);</span>
  <span class="c1">// If your keyboard doesn't have a λ (you poor sod)</span>
  <span class="c1">// you can use \ too.</span>
  <span class="k">auto</span> <span class="n">add5</span> <span class="o">=</span> <span class="err">\</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">new</span> <span class="err">\</span><span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
  <span class="c1">// Note!</span>
  <span class="k">auto</span> <span class="n">nestfun</span> <span class="o">=</span> <span class="err">λ</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// There is NO semicolon needed here!</span>
  <span class="c1">// "}" can always substitute for "};".</span>
  <span class="c1">// This provides syntactic consistency with built-in statements.</span>


  <span class="c1">// This is a class.</span>
  <span class="c1">// Note: almost all elements of Neat can be used on the module level</span>
  <span class="c1">//       or just as well inside a function.</span>
  <span class="n">class</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">writeA</span><span class="p">()</span> <span class="p">{</span> <span class="n">writeln</span> <span class="s">"$a"</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// It's a nested class - it exists in the context of main().</span>
    <span class="c1">// so if you leave main(), any instances of C become invalid.</span>
    <span class="kt">void</span> <span class="n">writeS</span><span class="p">()</span> <span class="p">{</span> <span class="n">writeln</span> <span class="s">"$s"</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">C</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">new</span> <span class="n">C</span><span class="p">;</span>
  <span class="c1">// cc is a *reference* to C. Classes are always references.</span>
  <span class="n">cc</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// Always used for property access.</span>
  <span class="k">auto</span> <span class="n">ccp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cc</span><span class="p">;</span>
  <span class="p">(</span><span class="o">*</span><span class="n">ccp</span><span class="p">).</span><span class="n">a</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
  <span class="c1">// or just</span>
  <span class="n">ccp</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
  <span class="n">cc</span><span class="p">.</span><span class="n">writeA</span><span class="p">();</span>
  <span class="n">cc</span><span class="p">.</span><span class="n">writeS</span><span class="p">();</span> <span class="c1">// to prove I'm not making things up</span>
  <span class="c1">// Interfaces work same as in D, basically. Or Java.</span>
  <span class="n">interface</span> <span class="n">E</span> <span class="p">{</span> <span class="kt">void</span> <span class="n">doE</span><span class="p">();</span> <span class="p">}</span>
  <span class="c1">// Inheritance works same as in D, basically. Or Java.</span>
  <span class="n">class</span> <span class="n">D</span> <span class="o">:</span> <span class="n">C</span><span class="p">,</span> <span class="n">E</span> <span class="p">{</span>
    <span class="n">override</span> <span class="kt">void</span> <span class="n">writeA</span><span class="p">()</span> <span class="p">{</span> <span class="n">writeln</span> <span class="s">"hahahahaha no"</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">override</span> <span class="kt">void</span> <span class="n">doE</span><span class="p">()</span> <span class="p">{</span> <span class="n">writeln</span> <span class="s">"eeeee"</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// all classes inherit from Object. (toString is defined in Object)</span>
    <span class="n">override</span> <span class="n">string</span> <span class="n">toString</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">"I am a D"</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">C</span> <span class="n">cd</span> <span class="o">=</span> <span class="n">new</span> <span class="n">D</span><span class="p">;</span>
  <span class="c1">// all methods are always virtual.</span>
  <span class="n">cd</span><span class="p">.</span><span class="n">writeA</span><span class="p">();</span>
  <span class="n">E</span> <span class="n">e</span> <span class="o">=</span> <span class="n">E</span><span class="o">:</span><span class="n">cd</span><span class="p">;</span> <span class="c1">// dynamic class cast!</span>
  <span class="n">e</span><span class="p">.</span><span class="n">doE</span><span class="p">();</span>
  <span class="n">writeln</span> <span class="s">"$e"</span><span class="p">;</span> <span class="c1">// all interfaces convert to Object implicitly.</span>

  <span class="c1">// Templates!</span>
  <span class="c1">// Templates are parameterized namespaces, taking a type as a parameter.</span>
  <span class="n">template</span> <span class="n">Templ</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">alias</span> <span class="n">hi</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">hii</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="c1">// Templates always have to include something with the same name as the template</span>
    <span class="c1">// - this will become the template's _value_.</span>
    <span class="c1">// Static ifs are evaluated statically, at compile-time.</span>
    <span class="c1">// Because of this, the test has to be a constant expression,</span>
    <span class="c1">// or something that can be optimized to a constant.</span>
    <span class="k">static</span> <span class="k">if</span> <span class="p">(</span><span class="n">types</span><span class="o">-</span><span class="n">equal</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="kt">int</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">alias</span> <span class="n">Templ</span> <span class="o">=</span> <span class="n">hi</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">alias</span> <span class="n">Templ</span> <span class="o">=</span> <span class="n">hii</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">Templ</span><span class="o">!</span><span class="kt">int</span> <span class="o">==</span> <span class="mi">5</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">Templ</span><span class="o">!</span><span class="kt">float</span> <span class="o">==</span> <span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h2>Topics Not Covered</h2>

<ul>
<li>Extended iterator types and expressions</li>
<li>Standard library</li>
<li>Conditions (error handling)</li>
<li>Macros</li>
</ul>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/neat.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by Feep, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/neat.html.markdown">0 contributor(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="https://github.com/FeepingCreature">Feep</a>
    </p>

    <p>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>

        <script>
            var _gaq=[['_setAccount','UA-3525624-21'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>
</html>
