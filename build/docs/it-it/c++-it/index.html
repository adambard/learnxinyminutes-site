<!DOCTYPE html lang="it-it" xml:lang="it-it" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="it-it">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn C++ in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/it-it/c++-it/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fit-it%2Fc%2B%2B-it%2F&text=Impara+X+in+Y+minuti%2C+dove+X%3DC%2B%2B">
        Condividi questa pagina
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Seleziona il tema:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">leggero</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">scuro</button>
  </div>
  <h1><a href="/">Impara X in Y minuti</a></h1>
  <h2>Dove X=C++</h2>
    <p class="filelink">
    Scarica il codice sorgente:
    <a href="/docs/files/learncpp-it.cpp">learncpp-it.cpp</a>
    </p>
  <div id="doc">
    <p>Il C++ è un linguaggio di programmazione il quale,
<a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">secondo il suo inventore Bjarne Stroustrup</a>,
è stato progettato per</p>

<ul>
<li>essere un &ldquo;miglior C&rdquo;</li>
<li>supportare l&#39;astrazione dei dati</li>
<li>supportare la programmazione orientata agli oggetti</li>
<li>supportare la programmazione generica</li>
</ul>

<p>Nonostante la sintassi possa risultare più difficile o complessa di linguaggi più recenti,
è usato in maniera vasta poichè viene compilato in istruzioni macchina che possono
essere eseguite direttamente dal processore ed offre un controllo stretto sull&#39;hardware (come il linguaggio C)
ed allo stesso tempo offre caratteristiche ad alto livello come i generici, le eccezioni, e le classi.
Questa combinazione di velocità e funzionalità rende il C++
uno dei più utilizzati linguaggi di programmazione.</p>
<div class="highlight"><pre class="highlight cpp"><code><span class="c1">//////////////////</span>
<span class="c1">// Confronto con il C</span>
<span class="c1">//////////////////</span>

<span class="c1">// Il C++ è _quasi_ un superset del C e con esso condivide la sintassi di base per</span>
<span class="c1">// la dichiarazione di variabili, tipi primitivi, e funzioni.</span>

<span class="c1">// Proprio come nel C, l'inizio del programma è una funzione chiamata</span>
<span class="c1">// main con un intero come tipo di ritorno,</span>
<span class="c1">// Questo valore serve come stato d'uscita del programma.</span>
<span class="c1">// Vedi http://it.wikipedia.org/wiki/Valore_di_uscita per maggiori informazioni.</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Gli argomenti a linea di comando sono passati tramite argc e argv così come</span>
    <span class="c1">// avviene in C.</span>
    <span class="c1">// argc indica il numero di argomenti,</span>
    <span class="c1">// e argv è un array di stringhe in stile-C (char*)</span>
    <span class="c1">// che rappresenta gli argomenti.</span>
    <span class="c1">// Il primo argomento è il nome che è stato assegnato al programma.</span>
    <span class="c1">// argc e argv possono essere omessi se non hai bisogno di argomenti,</span>
    <span class="c1">// in questa maniera la funzione avrà int main() come firma.</span>

    <span class="c1">// Lo stato di uscita 0 indica successo.</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Tuttavia, il C++ varia nei seguenti modi:</span>

<span class="c1">// In C++, i caratteri come letterali sono dei char.</span>
<span class="k">sizeof</span><span class="p">(</span><span class="sc">'c'</span><span class="p">)</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

<span class="c1">// In C, i caratteri come letterali sono degli interi.</span>
<span class="k">sizeof</span><span class="p">(</span><span class="sc">'c'</span><span class="p">)</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>


<span class="c1">// C++ ha prototipizzazione rigida</span>
<span class="kt">void</span> <span class="n">func</span><span class="p">();</span> <span class="c1">// funziona che non accetta argomenti</span>

<span class="c1">// In C</span>
<span class="kt">void</span> <span class="n">func</span><span class="p">();</span> <span class="c1">// funzione che può accettare un qualsiasi numero di argomenti</span>

<span class="c1">// Usa nullptr invece di NULL in C++</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">ip</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

<span class="c1">// Gli header C standard sono disponibili in C++,</span>
<span class="c1">// ma sono prefissati con "c" e non hanno il suffisso ".h".</span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Ciao, mondo!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">///////////////////////////////</span>
<span class="c1">// Overloading per le funzioni</span>
<span class="c1">//////////////////////////////</span>

<span class="c1">// Il C++ supporta l'overloading per le funzioni</span>
<span class="c1">// sia dato che ogni funzione accetta parametri diversi.</span>

<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">myString</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Stringa %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">myString</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="kt">int</span> <span class="n">myInt</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Il mio int è %d"</span><span class="p">,</span> <span class="n">myInt</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s">"Ciao"</span><span class="p">);</span> <span class="c1">// Viene chiamata void print(const char*)</span>
    <span class="n">print</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span> <span class="c1">//  Viene chiamata void print(int)</span>
<span class="p">}</span>

<span class="c1">////////////////////////</span>
<span class="c1">// Argomenti di default</span>
<span class="c1">///////////////////////</span>

<span class="c1">// Puoi fornire argomenti di default per una funzione</span>
<span class="c1">// se non sono forniti dal chiamante.</span>

<span class="kt">void</span> <span class="n">faiQualcosaConInteri</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// fai qualcosa con gli interi qui</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">faiQualcosaConInteri</span><span class="p">();</span>      <span class="c1">// a = 1,  b = 4</span>
    <span class="n">faiQualcosaConInteri</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>    <span class="c1">// a = 20, b = 4</span>
    <span class="n">faiQualcosaConInteri</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// a = 20, b = 5</span>
<span class="p">}</span>

<span class="c1">// Gli argomenti di default devono essere alla fine della lista degli argomenti.</span>

<span class="kt">void</span> <span class="n">dichiarazioneInvalida</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="c1">// Errore!</span>
<span class="p">{</span>
<span class="p">}</span>


<span class="c1">/////////////</span>
<span class="c1">// Namespaces</span>
<span class="c1">/////////////</span>

<span class="c1">// I namespaces forniscono visibilità separata per dichiarazioni di variabili, funzioni,</span>
<span class="c1">// ed altro.</span>
<span class="c1">// I namespaces possono essere annidati.</span>

<span class="k">namespace</span> <span class="n">Primo</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">Annidato</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"Questa è Primo::Annidato::foo</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="c1">// fine di namespace Annidato</span>
<span class="p">}</span> <span class="c1">// fine di namespace Primo</span>

<span class="k">namespace</span> <span class="n">Secondo</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Questa è Secondo::foo</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Questa è foo globale</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Include tutti i simboli del namespace Secondo nello scope attuale.</span>
    <span class="c1">// Osserva che chiamare semplicemente foo() non va più bene perché è ambiguo:</span>
    <span class="c1">// bisogna specificare se vogliamo chiamare foo definita nel namespace Secondo</span>
    <span class="c1">// o foo definita nel livello principale del programma.</span>

    <span class="k">using</span> <span class="k">namespace</span> <span class="n">Secondo</span><span class="p">;</span>

    <span class="n">Secondo</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span> <span class="c1">// stampa "Questa è Secondo::foo"</span>
    <span class="n">Primo</span><span class="o">::</span><span class="n">Annidato</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span> <span class="c1">// stampa "Questa è Primo::Annidato::foo"</span>
    <span class="o">::</span><span class="n">foo</span><span class="p">();</span> <span class="c1">// stampa "Questa è foo globale"</span>
<span class="p">}</span>

<span class="c1">///////////////</span>
<span class="c1">// Input/Output</span>
<span class="c1">///////////////</span>

<span class="c1">// L'input e l'output in C++ utilizza gli streams</span>
<span class="c1">// cin, cout, e cerr i quali rappresentano stdin, stdout, e stderr.</span>
<span class="c1">// &lt;&lt; è l'operatore di inserzione &gt;&gt; è l'operatore di estrazione.</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="c1"> // Include gli streams di I/O</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span> <span class="c1">// Gli streams sono nel namespace std (libreria standard)</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="kt">int</span> <span class="n">myInt</span><span class="p">;</span>

   <span class="c1">// Stampa su stdout (o terminalee/schermo)</span>
   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Inserisci il tuo numero preferito:</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
   <span class="c1">// Prende l'input</span>
   <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">myInt</span><span class="p">;</span>

   <span class="c1">// cout può anche essere formattato</span>
   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Il tuo numero preferito è "</span> <span class="o">&lt;&lt;</span> <span class="n">myInt</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
   <span class="c1">// stampa "Il tuo numero preferito è &lt;myInt&gt;"</span>

    <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Usato per messaggi di errore"</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">////////////</span>
<span class="c1">// Stringhe</span>
<span class="c1">///////////</span>

<span class="c1">// Le stringhe in C++ sono oggetti ed hanno molte funzioni membro</span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span> <span class="c1">// Anche le stringhe sono contenute nel namespace std (libreria standard)</span>

<span class="n">string</span> <span class="n">myString</span> <span class="o">=</span> <span class="s">"Ciao"</span><span class="p">;</span>
<span class="n">string</span> <span class="n">myOtherString</span> <span class="o">=</span> <span class="s">" Mondo"</span><span class="p">;</span>

<span class="c1">// + è usato per la concatenazione.</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">myString</span> <span class="o">+</span> <span class="n">myOtherString</span><span class="p">;</span> <span class="c1">// "Ciao Mondo"</span>

<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">myString</span> <span class="o">+</span> <span class="s">" Bella"</span><span class="p">;</span> <span class="c1">// "Ciao Bella"</span>

<span class="c1">// le stringhe in C++ possono essere modificate.</span>
<span class="n">myString</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">" Mario"</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">myString</span><span class="p">;</span> <span class="c1">// "Ciao Mario"</span>


<span class="c1">///////////////</span>
<span class="c1">// Riferimenti</span>
<span class="c1">//////////////</span>

<span class="c1">// Oltre ai puntatori come quelli in C,</span>
<span class="c1">// il C++ ha i _riferimenti_.</span>
<span class="c1">// Questi non sono tipi puntatori che non possono essere riassegnati una volta settati</span>
<span class="c1">// e non possono essere null.</span>
<span class="c1">// Inoltre, essi hanno la stessa sintassi della variabile stessa:</span>
<span class="c1">// * non è necessario per la dereferenziazione e</span>
<span class="c1">// &amp; ("indirizzo di") non è usato per l'assegnamento.</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">string</span> <span class="n">foo</span> <span class="o">=</span> <span class="s">"Io sono foo"</span><span class="p">;</span>
<span class="n">string</span> <span class="n">bar</span> <span class="o">=</span> <span class="s">"Io sono bar"</span><span class="p">;</span>


<span class="n">string</span><span class="o">&amp;</span> <span class="n">fooRef</span> <span class="o">=</span> <span class="n">foo</span><span class="p">;</span> <span class="c1">// Questo crea un riferimento a foo.</span>
<span class="n">fooRef</span> <span class="o">+=</span> <span class="s">". Ciao!"</span><span class="p">;</span> <span class="c1">// Modifica foo attraverso il riferimento</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">fooRef</span><span class="p">;</span> <span class="c1">// Stampa "Io sono foo. Ciao!"</span>

<span class="c1">// Non riassegna "fooRef". Questo è come scrivere "foo = bar", e</span>
<span class="c1">//   foo == "Io sono bar"</span>
<span class="c1">// dopo questa riga.</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">fooRef</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// Stampa l'indirizzo di foo</span>
<span class="n">fooRef</span> <span class="o">=</span> <span class="n">bar</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">fooRef</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// Stampa lo stesso l'indirizzo di foo</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">fooRef</span><span class="p">;</span>  <span class="c1">// Stampa "Io sono bar"</span>

<span class="c1">// L'indirizzo di fooRef rimane lo stesso, ovvero si riferisce ancora a foo.</span>


<span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">barRef</span> <span class="o">=</span> <span class="n">bar</span><span class="p">;</span> <span class="c1">// Crea un riferimento const a bar.</span>
<span class="c1">// Come in C, i valori const (i puntatori e i riferimenti) non possono essere modificati.</span>
<span class="n">barRef</span> <span class="o">+=</span> <span class="s">". Ciao!"</span><span class="p">;</span> <span class="c1">// Errore, i riferimenti const non possono essere modificati.</span>

<span class="c1">// Facciamo un piccolo excursus: prima di approfondire ancora i riferimenti, è necessario</span>
<span class="c1">// introdurre il concetto di oggetto temporaneo. Supponiamo di avere il seguente codice:</span>
<span class="n">string</span> <span class="n">tempObjectFun</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="n">string</span> <span class="n">retVal</span> <span class="o">=</span> <span class="n">tempObjectFun</span><span class="p">();</span>

<span class="c1">// Nella seconda riga si ha che:</span>
<span class="c1">//   - un oggetto di tipo stringa viene ritornato da tempObjectFun</span>
<span class="c1">//   - viene costruita una nuova stringa, utilizzando l'oggetto ritornato come</span>
<span class="c1">//     argomento per il costruttore</span>
<span class="c1">//   - l'oggetto ritornato da tempObjectFun viene distrutto</span>
<span class="c1">// L'oggetto ritornato da tempObjectFun viene detto oggetto temporaneo.</span>
<span class="c1">// Un oggetto temporaneo viene creato quando una funzione ritorna un oggetto, e viene</span>
<span class="c1">// distrutto quando l'espressione che lo racchiude termina la sua esecuzione - questo</span>
<span class="c1">// comportamento viene definito dallo standard, ma i compilatori possono modificarlo</span>
<span class="c1">// a piacere. Cerca su google "return value optimization" se vuoi approfondire.</span>
<span class="c1">// Dunque nel seguente codice:</span>
<span class="n">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">(</span><span class="n">tempObjectFun</span><span class="p">()))</span>

<span class="c1">// dando per scontato che foo e bar esistano, l'oggetto ritornato da tempObjectFun</span>
<span class="c1">// è passato a bar ed è distrutto prima dell'invocazione di foo.</span>

<span class="c1">// Tornando ai riferimenti, c'è un'eccezione a quanto appena detto.</span>
<span class="c1">// Infatti un oggetto temporaneo "viene distrutto quando l'espressione</span>
<span class="c1">// che lo racchiude termina la sua esecuzione", tranne quando è legato ad un</span>
<span class="c1">// riferimento di tipo const. In tal caso la sua vita viene estesa per tutto</span>
<span class="c1">// lo scope attuale:</span>

<span class="kt">void</span> <span class="n">constReferenceTempObjectFun</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// constRef riceve l'oggetto temporaneo, che non viene distrutto fino</span>
    <span class="c1">// alla fine di questa funzione.</span>
    <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">constRef</span> <span class="o">=</span> <span class="n">tempObjectFun</span><span class="p">();</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="c1">// Un altro tipo di riferimento introdotto nel C++11 è specifico per gli</span>
<span class="c1">// oggetti temporanei. Non puoi dichiarare una variabile di quel tipo, ma</span>
<span class="c1">// ha la precedenza nella risoluzione degli overload:</span>

<span class="kt">void</span> <span class="n">someFun</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>  <span class="c1">// Riferimento normale</span>
<span class="kt">void</span> <span class="n">someFun</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>  <span class="c1">// Riferimento ad un oggetto temporaneo</span>

<span class="n">string</span> <span class="n">foo</span><span class="p">;</span>
<span class="n">someFun</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>  <span class="c1">// Chiama la versione con il riferimento normale</span>
<span class="n">someFun</span><span class="p">(</span><span class="n">tempObjectFun</span><span class="p">());</span>  <span class="c1">// Chiama la versione con il riferimento temporaneo</span>

<span class="c1">// Ad esempio potrai vedere questi due costruttori per std::basic_string:</span>
<span class="n">basic_string</span><span class="p">(</span><span class="k">const</span> <span class="n">basic_string</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="n">basic_string</span><span class="p">(</span><span class="n">basic_string</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span>

<span class="c1">// L'idea è che se noi costruiamo una nuova stringa a partire da un oggetto temporaneo</span>
<span class="c1">// (che in ogni caso verrà distrutto), possiamo avere un costruttore più efficiente</span>
<span class="c1">// che in un certo senso "recupera" parti di quella stringa temporanea.</span>
<span class="c1">// Ci si riferisce a questo concetto come "move semantics".</span>

<span class="c1">/////////////////////</span>
<span class="c1">// Enum</span>
<span class="c1">/////////////////////</span>

<span class="c1">// Gli enum sono un modo per assegnare un valore ad una costante, e sono</span>
<span class="c1">// principalmente usati per rendere il codice più leggibile.</span>
<span class="k">enum</span> <span class="n">ETipiMacchine</span>
<span class="p">{</span>
  <span class="n">AlfaRomeo</span><span class="p">,</span>
  <span class="n">Ferrari</span><span class="p">,</span>
  <span class="n">SUV</span><span class="p">,</span>
  <span class="n">Panda</span>
<span class="p">};</span>

<span class="n">ETipiMacchine</span> <span class="n">GetPreferredCarType</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">ETipiMacchine</span><span class="o">::</span><span class="n">Ferrari</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Dal C++11 in poi c'è un modo molto semplice per assegnare un tipo ad un enum,</span>
<span class="c1">// che può essere utile per la serializzazione dei dati o per convertire gli enum</span>
<span class="c1">// tra il tipo desiderato e le rispettive costanti.</span>
<span class="k">enum</span> <span class="n">ETipiMacchine</span> <span class="o">:</span> <span class="kt">uint8_t</span>
<span class="p">{</span>
  <span class="n">AlfaRomeo</span><span class="p">,</span> <span class="c1">// 0</span>
  <span class="n">Ferrari</span><span class="p">,</span> <span class="c1">// 1</span>
  <span class="n">SUV</span> <span class="o">=</span> <span class="mi">254</span><span class="p">,</span> <span class="c1">// 254</span>
  <span class="n">Ibrida</span> <span class="c1">// 255</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">WriteByteToFile</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">InputValue</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Serializza InputValue in un file</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">WritePreferredCarTypeToFile</span><span class="p">(</span><span class="n">ETipiMacchine</span> <span class="n">InputCarType</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// L'enum viene implicitamente convertito ad un uint8_t poiché</span>
    <span class="c1">// è stato dichiarato come tale</span>
    <span class="n">WriteByteToFile</span><span class="p">(</span><span class="n">InputCarType</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// D'altro canto potresti voler evitare che un enum venga accidentalmente convertito</span>
<span class="c1">// in un intero o in un altro tipo, quindi è possibile create una classe enum che</span>
<span class="c1">// impedisce la conversione implicita.</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">ETipiMacchine</span> <span class="o">:</span> <span class="kt">uint8_t</span>
<span class="p">{</span>
  <span class="n">AlfaRomeo</span><span class="p">,</span> <span class="c1">// 0</span>
  <span class="n">Ferrari</span><span class="p">,</span> <span class="c1">// 1</span>
  <span class="n">SUV</span> <span class="o">=</span> <span class="mi">254</span><span class="p">,</span> <span class="c1">// 254</span>
  <span class="n">Ibrida</span> <span class="c1">// 255</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">WriteByteToFile</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">InputValue</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Serializza InputValue in un file</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">WritePreferredCarTypeToFile</span><span class="p">(</span><span class="n">ETipiMacchine</span> <span class="n">InputCarType</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Il compilatore darà errore anche se ETipiMacchine è un uint8_t: questo</span>
    <span class="c1">// perchè abbiamo dichiarato l'enum come "enum class"!</span>
    <span class="n">WriteByteToFile</span><span class="p">(</span><span class="n">InputCarType</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//////////////////////////////////////////////////</span>
<span class="c1">// Classi e programmazione orientata agli oggetti</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Primo esempio delle classi</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="c1">// Dichiara una classe.</span>
<span class="c1">// Le classi sono in genere dichiara in un header file (.h o .hpp).</span>
<span class="k">class</span> <span class="nc">Cane</span> <span class="p">{</span>
    <span class="c1">// Variabili e funzioni membro sono private di default.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">nome</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">peso</span><span class="p">;</span>

<span class="c1">// Tutti i membri dopo questo sono pubblici (public)</span>
<span class="c1">// finchè "private:" o "protected:" non compaiono.</span>
<span class="nl">public:</span>

    <span class="c1">// Costruttore di default</span>
    <span class="n">Cane</span><span class="p">();</span>

    <span class="c1">// Dichiarazioni di funzioni membro (le implentazioni sono a seguito)</span>
    <span class="c1">// Nota che stiamo usando std::string invece di porre</span>
    <span class="c1">// using namespace std;</span>
    <span class="c1">// sopra.</span>
    <span class="c1">// Mai usare uno statement "using namespace" in uno header.</span>
    <span class="kt">void</span> <span class="n">impostaNome</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">nomeCane</span><span class="p">);</span>

    <span class="kt">void</span> <span class="n">impostaPeso</span><span class="p">(</span><span class="kt">int</span> <span class="n">pesoCane</span><span class="p">);</span>

    <span class="c1">// Le funzioni che non modificano lo stato dell'oggetto</span>
    <span class="c1">// dovrebbero essere marcate come const.</span>
    <span class="c1">// Questo permette di chiamarle con un riferimento const all'oggetto.</span>
    <span class="c1">// Inoltre, nota che le funzioni devono essere dichiarate espliciamente come _virtual_</span>
    <span class="c1">// per essere sovrascritte in classi derivate.</span>
    <span class="c1">// Le funzioni non sono virtual di default per motivi di performance.</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// Le funzioni possono essere definite anche all'interno del corpo della classe.</span>
    <span class="c1">// Le funzioni definite in questo modo sono automaticamente inline.</span>
    <span class="kt">void</span> <span class="n">abbaia</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">nome</span> <span class="o">&lt;&lt;</span> <span class="s">" abbaia!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// Assieme con i costruttori, il C++ fornisce i distruttori.</span>
    <span class="c1">// Questi sono chiamati quando un oggetto è rimosso o esce dalla visibilità.</span>
    <span class="c1">// Questo permette paradigmi potenti come il RAII</span>
    <span class="c1">// (vedi sotto)</span>
    <span class="c1">// I distruttori devono essere virtual per permettere a classi di essere</span>
    <span class="c1">// derivate da questa; altrimenti, il distruttore della classe derivata</span>
    <span class="c1">// non viene chiamato se l'oggetto viene distrutto tramite un riferimento alla</span>
    <span class="c1">// classe da cui ha ereditato o tramite un puntatore.</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Dog</span><span class="p">();</span>

<span class="p">};</span> <span class="c1">// Un punto e virgola deve seguire la definizione della funzione</span>

<span class="c1">// Le funzioni membro di una classe sono generalmente implementate in files .cpp .</span>
<span class="n">Cane</span><span class="o">::</span><span class="n">Cane</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Un cane è stato costruito</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Gli oggetti (ad esempio le stringhe) devono essere passati per riferimento</span>
<span class="c1">// se li stai modificando o come riferimento const altrimenti.</span>
<span class="kt">void</span> <span class="n">Cane</span><span class="o">::</span><span class="n">impostaNome</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">nomeCane</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">nome</span> <span class="o">=</span> <span class="n">nomeCane</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cane</span><span class="o">::</span><span class="n">impostaPeso</span><span class="p">(</span><span class="kt">int</span> <span class="n">pesoCane</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">peso</span> <span class="o">=</span> <span class="n">pesoCane</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Notare che "virtual" è solamente necessario nelle dichiarazioni, non nelle definizioni.</span>
<span class="kt">void</span> <span class="n">Cane</span><span class="o">::</span><span class="n">print</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Il cane è "</span> <span class="o">&lt;&lt;</span> <span class="n">nome</span> <span class="o">&lt;&lt;</span> <span class="s">" e pesa "</span> <span class="o">&lt;&lt;</span> <span class="n">peso</span> <span class="o">&lt;&lt;</span> <span class="s">"kg</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Cane</span><span class="o">::~</span><span class="n">Cane</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ciao ciao "</span> <span class="o">&lt;&lt;</span> <span class="n">nome</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Cane</span> <span class="n">myDog</span><span class="p">;</span> <span class="c1">// stampa "Un cane è stato costruito"</span>
    <span class="n">myDog</span><span class="p">.</span><span class="n">impostaNome</span><span class="p">(</span><span class="s">"Barkley"</span><span class="p">);</span>
    <span class="n">myDog</span><span class="p">.</span><span class="n">impostaPeso</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">myDog</span><span class="p">.</span><span class="n">print</span><span class="p">();</span> <span class="c1">// stampa "Il cane è Barkley e pesa 10 kg"</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// stampa "Ciao ciao Barkley"</span>

<span class="c1">// Ereditarietà:</span>

<span class="c1">// Questa classe eredita tutto ciò che è public e protected dalla classe Cane,</span>
<span class="c1">// ma anche ciò che privato: tuttavia non potrà accedere direttamente a membri/metodi</span>
<span class="c1">// privati se non c'è un metodo pubblico o privato che permetta di farlo.</span>
<span class="k">class</span> <span class="nc">MioCane</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cane</span> <span class="p">{</span>

    <span class="kt">void</span> <span class="n">impostaProprietario</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">proprietarioCane</span><span class="p">);</span>

    <span class="c1">// Sovrascrivi il comportamento della funzione print per tutti i MioCane. Vedi</span>
    <span class="c1">// http://it.wikipedia.org/wiki/Polimorfismo_%28informatica%29</span>
    <span class="c1">// per una introduzione più generale se non sei familiare con</span>
    <span class="c1">// il polimorfismo.</span>
    <span class="c1">// La parola chiave override è opzionale ma fa sì che tu stia effettivamente</span>
    <span class="c1">// sovrascrivendo il metodo nella classe base.</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

<span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">proprietario</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Nel frattempo, nel file .cpp corrispondente:</span>

<span class="kt">void</span> <span class="n">MioCane</span><span class="o">::</span><span class="n">impostaProprietario</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">proprietarioCane</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">proprietario</span> <span class="o">=</span> <span class="n">proprietarioCane</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">MioCane</span><span class="o">::</span><span class="n">print</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">Cane</span><span class="o">::</span><span class="n">print</span><span class="p">();</span> <span class="c1">// Chiama la funzione print nella classe base Cane</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Il cane è di "</span> <span class="o">&lt;&lt;</span> <span class="n">proprietario</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="c1">// stampa "Il cane è &lt;nome&gt; e pesa &lt;peso&gt;"</span>
    <span class="c1">//        "Il cane è di &lt;proprietario&gt;"</span>
<span class="p">}</span>

<span class="c1">///////////////////////////////////////////////////</span>
<span class="c1">// Inizializzazione ed Overloading degli Operatori</span>
<span class="c1">//////////////////////////////////////////////////</span>

<span class="c1">// In C++ puoi sovrascrivere il comportamento di operatori come +, -, *, /, ecc...</span>
<span class="c1">// Questo è possibile definendo una funzione che viene chiamata</span>
<span class="c1">// ogniqualvolta l'operatore è usato.</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Punto</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Così si assegna alle variabili membro un valore di default.</span>
    <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// Definisce un costruttore di default che non fa nulla</span>
    <span class="c1">// ma inizializza il Punto ai valori di default (0, 0)</span>
    <span class="n">Punto</span><span class="p">()</span> <span class="p">{</span> <span class="p">};</span>

    <span class="c1">// La sintassi seguente è nota come lista di inizializzazione</span>
    <span class="c1">// ed è il modo appropriato di inizializzare i valori membro della classe</span>
    <span class="n">Punto</span> <span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span> <span class="o">:</span>
        <span class="n">x</span><span class="p">(</span><span class="n">a</span><span class="p">),</span>
        <span class="n">y</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="p">{</span> <span class="cm">/* Non fa nulla eccetto inizializzare i valori */</span> <span class="p">}</span>

    <span class="c1">// Sovrascrivi l'operatore +.</span>
    <span class="n">Punto</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// Sovrascrivi l'operatore +=</span>
    <span class="n">Punto</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>

    <span class="c1">// Avrebbe senso aggiungere gli operatori - e -=,</span>
    <span class="c1">// ma li saltiamo per rendere la guida più breve.</span>
<span class="p">};</span>

<span class="n">Punto</span> <span class="n">Punto</span><span class="o">::</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// Crea un nuovo punto come somma di questo e di rhs.</span>
    <span class="k">return</span> <span class="n">Punto</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Punto</span><span class="o">&amp;</span> <span class="n">Punto</span><span class="o">::</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span> <span class="n">Punto</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">x</span> <span class="o">+=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="n">y</span> <span class="o">+=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">Punto</span> <span class="n">su</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">Punto</span> <span class="n">destro</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="c1">// Questo chiama l'operatore + di Punto</span>
    <span class="c1">// Il Punto su chiama la funzione + con destro come argomento</span>
    <span class="n">Punto</span> <span class="n">risultato</span> <span class="o">=</span> <span class="n">su</span> <span class="o">+</span> <span class="n">destro</span><span class="p">;</span>
    <span class="c1">// Stampa "Risultato è spostato in (1,1)"</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Risultato è spostato ("</span> <span class="o">&lt;&lt;</span> <span class="n">risultato</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="sc">','</span> <span class="o">&lt;&lt;</span> <span class="n">risultato</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="s">")</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/////////////////</span>
<span class="c1">// Templates</span>
<span class="c1">////////////////</span>

<span class="c1">// Generalmente i templates in C++ sono utilizzati per programmazione generica, anche se</span>
<span class="c1">// sono molto più potenti dei costrutti generici in altri linguaggi. Inoltre,</span>
<span class="c1">// supportano specializzazione esplicita e parziale, classi in stile funzionale,</span>
<span class="c1">// e sono anche complete per Turing.</span>

<span class="c1">// Iniziamo con il tipo di programmazione generica con cui forse sei familiare. Per</span>
<span class="c1">// definire una classe o una funzione che prende un parametro di un dato tipo:</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Box</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// In questa classe, T può essere usato come qualsiasi tipo.</span>
    <span class="kt">void</span> <span class="n">inserisci</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Durante la compilazione, il compilatore in effetti genera copie di ogni template</span>
<span class="c1">// con i parametri sostituiti, e così la definizione completa della classe deve essere</span>
<span class="c1">// presente ad ogni invocazione. Questo è il motivo per cui vedrai le classi template definite</span>
<span class="c1">// interamente in header files.</span>

<span class="c1">// Per instanziare una classe template sullo stack:</span>
<span class="n">Box</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">intBox</span><span class="p">;</span>

<span class="c1">// e puoi usarla come aspettato:</span>
<span class="n">intBox</span><span class="p">.</span><span class="n">inserisci</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>

<span class="c1">//Puoi, ovviamente, innestare i templates:</span>
<span class="n">Box</span><span class="o">&lt;</span><span class="n">Box</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">boxOfBox</span><span class="p">;</span>
<span class="n">boxOfBox</span><span class="p">.</span><span class="n">inserisci</span><span class="p">(</span><span class="n">intBox</span><span class="p">);</span>

<span class="c1">// Fino al C++11, devi porre uno spazio tra le due '&gt;', altrimenti '&gt;&gt;'</span>
<span class="c1">// viene visto come l'operatore di shift destro.</span>

<span class="c1">// Qualche volta vedrai</span>
<span class="c1">// template&lt;typename T&gt;</span>
<span class="c1">// invece. La parole chiavi 'class' e 'typename' sono _generalmente_</span>
<span class="c1">// intercambiabili in questo caso. Per una spiegazione completa, vedi</span>
<span class="c1">// http://en.wikipedia.org/wiki/Typename</span>
<span class="c1">// (si, quella parola chiave ha una sua pagina di Wikipedia propria).</span>

<span class="c1">// Similmente, una funzione template:</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">abbaiaTreVolte</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">input</span><span class="p">.</span><span class="n">abbaia</span><span class="p">();</span>
    <span class="n">input</span><span class="p">.</span><span class="n">abbaia</span><span class="p">();</span>
    <span class="n">input</span><span class="p">.</span><span class="n">abbaia</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Nota che niente è specificato relativamente al tipo di parametri. Il compilatore</span>
<span class="c1">// genererà  e poi verificherà il tipo di ogni invocazione del template, così che</span>
<span class="c1">// la funzione di cui sopra funzione con ogni tipo 'T' che ha const 'abbaia' come metodo!</span>

<span class="n">Cane</span> <span class="n">fluffy</span><span class="p">;</span>
<span class="n">fluffy</span><span class="p">.</span><span class="n">impostaNome</span><span class="p">(</span><span class="s">"Fluffy"</span><span class="p">)</span>
<span class="n">abbaiaTreVolte</span><span class="p">(</span><span class="n">fluffy</span><span class="p">);</span> <span class="c1">// Stampa "Fluffy abbaia" tre volte.</span>

<span class="c1">// I parametri template non devono essere classi:</span>
<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">Y</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">stampaMessaggio</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Impara il C++ in "</span> <span class="o">&lt;&lt;</span> <span class="n">Y</span> <span class="o">&lt;&lt;</span> <span class="s">" minuti!"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// E poi esplicitamente specializzare i template per avere codice più efficiente. Ovviamente,</span>
<span class="c1">// la maggior parte delle casistiche reali non sono così triviali.</span>
<span class="c1">// Notare che avrai comunque bisogna di dichiarare la funzione (o classe) come un template</span>
<span class="c1">// anche se hai esplicitamente specificato tutti i parametri.</span>
<span class="k">template</span><span class="o">&lt;</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">stampaMessaggio</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Impara il C++ più velocemente in soli 10 minuti!"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">printMessage</span><span class="o">&lt;</span><span class="mi">20</span><span class="o">&gt;</span><span class="p">();</span>  <span class="c1">// Stampa "impara il C++ in 20 minuti!"</span>
<span class="n">printMessage</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span><span class="p">();</span>  <span class="c1">// Stampa "Impara il C++ più velocemente in soli 10 minuti!"                                   </span>

<span class="c1">////////////////////////////</span>
<span class="c1">// Gestione delle eccezioni</span>
<span class="c1">///////////////////////////</span>

<span class="c1">// La libreria standard fornisce un paio di tipi d'eccezioni</span>
<span class="c1">// (vedi http://en.cppreference.com/w/cpp/error/exception)</span>
<span class="c1">// ma ogni tipo può essere lanciato come eccezione</span>
<span class="cp">#include</span> <span class="cpf">&lt;exception&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdexcept&gt;</span><span class="cp">
</span>
<span class="c1">// Tutte le eccezioni lanciate all'interno del blocco _try_ possono essere catturate dai successivi</span>
<span class="c1">// handlers _catch_.</span>
<span class="k">try</span> <span class="p">{</span>
    <span class="c1">// Non allocare eccezioni nello heap usando _new_.</span>
    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"C'è stato un problema."</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Cattura le eccezioni come riferimenti const se sono oggetti</span>
<span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Cattura ogni eccezioni non catturata dal blocco _catch_ precedente</span>
<span class="k">catch</span> <span class="p">(...)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Catturata un'eccezione sconosciuta"</span><span class="p">;</span>
    <span class="k">throw</span><span class="p">;</span> <span class="c1">// Rilancia l'eccezione</span>
<span class="p">}</span>

<span class="c1">///////</span>
<span class="c1">// RAII</span>
<span class="c1">///////</span>

<span class="c1">// RAII sta per "Resource Allocation Is Initialization".</span>
<span class="c1">// Spesso viene considerato come il più potente paradigma in C++.</span>
<span class="c1">// È un concetto semplice: un costruttore di un oggetto</span>
<span class="c1">// acquisisce le risorse di tale oggetto ed il distruttore le rilascia.</span>

<span class="c1">// Per comprendere come questo sia vantaggioso,</span>
<span class="c1">// consideriamo una funzione che usa un gestore di file in C:</span>
<span class="kt">void</span> <span class="n">faiQualcosaConUnFile</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">nomefile</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Per cominciare, assumiamo che niente possa fallire.</span>

    <span class="kt">FILE</span><span class="o">*</span> <span class="n">fh</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">nomefile</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span> <span class="c1">// Apri il file in modalità lettura.</span>

    <span class="n">faiQualcosaConIlFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
    <span class="n">faiQualcosAltroConEsso</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>

    <span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span> <span class="c1">// Chiudi il gestore di file.</span>
<span class="p">}</span>

<span class="c1">// Sfortunatamente, le cose vengono complicate dalla gestione degli errori.</span>
<span class="c1">// Supponiamo che fopen fallisca, e che faiQualcosaConUnFile e</span>
<span class="c1">// faiQualcosAltroConEsso ritornano codici d'errore se falliscono.</span>
<span class="c1">//  (Le eccezioni sono la maniera preferita per gestire i fallimenti,</span>
<span class="c1">//   ma alcuni programmatori, specialmente quelli con un passato in C,</span>
<span class="c1">//   non sono d'accordo con l'utilità delle eccezioni).</span>
<span class="c1">// Adesso dobbiamo verificare che ogni chiamata per eventuali fallimenti e chiudere il gestore di file</span>
<span class="c1">// se un problema è avvenuto.</span>
<span class="kt">bool</span> <span class="n">faiQualcosaConUnFile</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">nomefile</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">FILE</span><span class="o">*</span> <span class="n">fh</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">nomefile</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span> <span class="c1">// Apre il file in modalità lettura</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fh</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="c1">// Il puntatore restituito è null in caso di fallimento.</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Riporta il fallimento al chiamante.</span>

    <span class="c1">// Assumiamo che ogni funzione ritorni false se ha fallito</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">faiQualcosaConIlFile</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span> <span class="c1">// Chiude il gestore di file così che non sprechi memoria.</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Propaga l'errore.</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">faiQualcosAltroConEsso</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span> <span class="c1">// Chiude il gestore di file così che non sprechi memoria.</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Propaga l'errore.</span>
    <span class="p">}</span>

    <span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span> <span class="c1">// Chiudi il gestore di file così che non sprechi memoria.</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// Indica successo</span>
<span class="p">}</span>

<span class="c1">// I programmatori C in genere puliscono questa procedura usando goto:</span>
<span class="kt">bool</span> <span class="n">faiQualcosaConUnFile</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">nomefile</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">FILE</span><span class="o">*</span> <span class="n">fh</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">nomefile</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fh</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">faiQualcosaConIlFile</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">fallimento</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">faiQualcosAltroConEsso</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">fallimento</span><span class="p">;</span>

    <span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span> <span class="c1">// Chiude il file</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// Indica successo</span>

<span class="nl">fallimento:</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Propaga l'errore</span>
<span class="p">}</span>

<span class="c1">// Se le funzioni indicano errori usando le eccezioni,</span>
<span class="c1">// le cose sono un pò più pulite, ma sono sempre sub-ottimali.</span>
<span class="kt">void</span> <span class="n">faiQualcosaConUnFile</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">nomefile</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">FILE</span><span class="o">*</span> <span class="n">fh</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">nomefile</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span> <span class="c1">// Apre il file in modalità lettura</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fh</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Errore nell'apertura del file."</span><span class="p">);</span>

    <span class="k">try</span> <span class="p">{</span>
        <span class="n">faiQualcosaConIlFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
        <span class="n">faiQualcosAltroConEsso</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
        <span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span> <span class="c1">// Fai sì che il file venga chiuso se si ha un errore.</span>
        <span class="k">throw</span><span class="p">;</span> <span class="c1">// Poi rilancia l'eccezione.</span>
    <span class="p">}</span>

    <span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span> <span class="c1">// Chiudi il file</span>
    <span class="c1">// Tutto è andato bene</span>
<span class="p">}</span>

<span class="c1">// Confronta questo con l'utilizzo della classe C++ file stream (fstream)</span>
<span class="c1">// fstream usa i distruttori per chiudere il file.</span>
<span class="c1">// Come detto sopra, i distruttori sono automaticamente chiamati</span>
<span class="c1">// ogniqualvolta un oggetto esce dalla visibilità.</span>
<span class="kt">void</span> <span class="n">faiQualcosaConUnFile</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">nomefile</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ifstream è l'abbreviazione di input file stream</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">fh</span><span class="p">(</span><span class="n">nomefile</span><span class="p">);</span> <span class="c1">// Apre il file</span>

    <span class="c1">// Fai qualcosa con il file</span>
    <span class="n">faiQualcosaConIlFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
    <span class="n">faiQualcosAltroConEsso</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>

<span class="p">}</span> <span class="c1">// Il file viene chiuso automaticamente chiuso qui dal distruttore</span>

<span class="c1">// Questo ha vantaggi _enormi_:</span>
<span class="c1">// 1. Può succedere di tutto ma</span>
<span class="c1">//    la risorsa (in questo caso il file handler) verrà ripulito.</span>
<span class="c1">//    Una volta che scrivi il distruttore correttamente,</span>
<span class="c1">//    È _impossibile_ scordarsi di chiudere l'handler e sprecare memoria.</span>
<span class="c1">// 2. Nota che il codice è molto più pulito.</span>
<span class="c1">//    Il distruttore gestisce la chiusura del file dietro le scene</span>
<span class="c1">//    senza che tu debba preoccupartene.</span>
<span class="c1">// 3. Il codice è sicuro da eccezioni.</span>
<span class="c1">//    Una eccezione può essere lanciata in qualunque punto nella funzione e la ripulitura</span>
<span class="c1">//    avverrà lo stesso.</span>

<span class="c1">// Tutto il codice C++ idiomatico usa RAII in maniera vasta su tutte le risorse.</span>
<span class="c1">// Esempi aggiuntivi includono</span>
<span class="c1">// - Utilizzo della memoria con unique_ptr e shared_ptr</span>
<span class="c1">// - I contenitori - la lista della libreria standard,</span>
<span class="c1">//   vettori (i.e. array auto-aggiustati), mappe hash, e così via</span>
<span class="c1">//   sono tutti automaticamente distrutti con i loro contenuti quando escono dalla visibilità.</span>
<span class="c1">// - I mutex usano lock_guard e unique_lock</span>

<span class="c1">// I contenitori che utilizzano chiavi non-primitive (classi personalizzate)</span>
<span class="c1">// richiedono la funzione di confronto nell'oggetto stesso, o tramite un puntatore a funzione.</span>
<span class="c1">// Le chiavi primitive hanno funzioni di confronto già definite, ma puoi sovrascriverle.</span>
<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
    <span class="n">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">j</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nc">funzioneDiConfronto</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// Questo non è permesso, anche se qualche compilatore potrebbe non dare problemi</span>
<span class="c1">//std::map&lt;Foo, int&gt; fooMap;</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">funzioneDiConfronto</span><span class="o">&gt;</span> <span class="n">fooMap</span><span class="p">;</span>
<span class="n">fooMap</span><span class="p">[</span><span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">fooMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span> <span class="o">--</span> <span class="n">vero</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Espressioni Lambda (C++11 e superiori)</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// Le espressioni lambda (più semplicemente "lambda") sono utilizzate</span>
<span class="c1">// per definire una funzione anonima nel punto in cui viene invocata, o</span>
<span class="c1">// dove viene passata come argomento ad una funzione</span>

<span class="c1">// Ad esempio, consideriamo l'ordinamento di un vettore costituito da una</span>
<span class="c1">// coppia di interi, utilizzando il secondo elemento per confrontare</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">tester</span><span class="p">;</span>
<span class="n">tester</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">));</span>
<span class="n">tester</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">));</span>
<span class="n">tester</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

<span class="c1">// Passiamo una lambda come terzo argomento alla funzione di ordinamento</span>
<span class="c1">// `sort` è contenuta nell'header &lt;algorithm&gt;</span>
<span class="n">sort</span><span class="p">(</span><span class="n">tester</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">tester</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">const</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<span class="p">});</span>

<span class="c1">// Nota bene la sintassi utilizzata nelle lambda:</span>
<span class="c1">// [] serve per "catturare" le variabili.</span>
<span class="c1">// La "Lista di Cattura" definisce tutte le variabili esterne che devono essere disponibili</span>
<span class="c1">// all'interno della funzione, e in che modo.</span>
<span class="c1">// La lista può contenere:</span>
<span class="c1">//     1. un valore: [x]</span>
<span class="c1">//     2. un riferimento: [&amp;x]</span>
<span class="c1">//     3. qualunque variabile nello scope corrente, per riferimento [&amp;]</span>
<span class="c1">//     4. qualunque variabile nello scope corrente, per valore [=]</span>
<span class="c1">// Esempio:</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">id_cani</span><span class="p">;</span>
<span class="c1">// numero_cani = 3;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">id_cani</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">pesi</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">30</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">10</span><span class="p">};</span>

<span class="c1">// Mettiamo che vuoi ordinare id_cani in base al peso dei cani</span>
<span class="c1">// Alla fine, id_cani sarà: [2, 0, 1]</span>

<span class="c1">// Le lambda vengono in aiuto</span>

<span class="n">sort</span><span class="p">(</span><span class="n">id_cani</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">id_cani</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">pesi</span><span class="p">](</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">pesi</span><span class="p">[</span><span class="n">lhs</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pesi</span><span class="p">[</span><span class="n">rhs</span><span class="p">];</span>
<span class="p">});</span>
<span class="c1">// Nota come abbiamo catturato "pesi" per riferimento nell'esempio.</span>
<span class="c1">// Altre informazioni sulle lambda in C++: http://stackoverflow.com/questions/7627098/what-is-a-lambda-expression-in-c11</span>

<span class="c1">///////////////////////////////</span>
<span class="c1">// Ciclo For semplificato(C++11 e superiori)</span>
<span class="c1">///////////////////////////////</span>

<span class="c1">// Puoi usare un ciclo for per iterare su un tipo di dato contenitore</span>
<span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>

<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">elem</span><span class="o">:</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Puoi usare "auto" senza preoccuparti del tipo degli elementi nel contenitore</span>
<span class="c1">// Ad esempio:</span>

<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">elem</span><span class="o">:</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Fai qualcosa con `elem`</span>
<span class="p">}</span>

<span class="c1">///////////////////////</span>
<span class="c1">// Roba divertente</span>
<span class="c1">//////////////////////</span>

<span class="c1">// Aspetti del C++ che potrebbero sbalordire i nuovi arrivati (e anche qualche veterano).</span>
<span class="c1">// Questa sezione è, sfortunatamente, selvaggiamente incompleta; il C++ è uno dei linguaggi</span>
<span class="c1">// più facili con cui puoi spararti da solo nel piede.</span>

<span class="c1">// Puoi sovrascrivere metodi privati!</span>
<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">bar</span><span class="p">();</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">FooSub</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">bar</span><span class="p">();</span>  <span class="c1">// Sovrascrive Foo::bar!</span>
<span class="p">};</span>


<span class="c1">// 0 == false == NULL (la maggior parte delle volte)!</span>
<span class="kt">bool</span><span class="o">*</span> <span class="n">pt</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">bool</span><span class="p">;</span>
<span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Setta il valore puntato da 'pt' come falso.</span>
<span class="n">pt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// Setta 'pt' al puntatore null. Entrambe le righe vengono compilate senza warnings.</span>

<span class="c1">// nullptr dovrebbe risolvere alcune di quei problemi:</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">pt2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>
<span class="o">*</span><span class="n">pt2</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="c1">// Non compila</span>
<span class="n">pt2</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>  <span class="c1">// Setta pt2 a null.</span>

<span class="c1">// C'è un'eccezione per i bool.</span>
<span class="c1">// Questo permette di testare un puntatore a null con if(!ptr), ma</span>
<span class="c1">// come conseguenza non puoi assegnare nullptr a un bool direttamente!</span>
<span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>  <span class="c1">// Questo compila, anche se '*pt' è un bool!</span>


<span class="c1">// '=' != '=' != '='!</span>
<span class="c1">// Chiama Foo::Foo(const Foo&amp;) o qualche variante (vedi "move semantics")</span>
<span class="c1">// del costruttore di copia.</span>
<span class="n">Foo</span> <span class="n">f2</span><span class="p">;</span>
<span class="n">Foo</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">f2</span><span class="p">;</span>

<span class="c1">// Chiama Foo::Foo(const Foo&amp;) o qualche variante, ma solo copie di 'Foo' che fanno parte di</span>
<span class="c1">// 'fooSub'. Ogni altro membro di 'fooSub' viene scartato. Questo comportamento</span>
<span class="c1">// orribile viene chiamato "object slicing."</span>
<span class="n">FooSub</span> <span class="n">fooSub</span><span class="p">;</span>
<span class="n">Foo</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">fooSub</span><span class="p">;</span>

<span class="c1">// Chiama Foo::operator=(Foo&amp;) o una sua variante.</span>
<span class="n">Foo</span> <span class="n">f1</span><span class="p">;</span>
<span class="n">f1</span> <span class="o">=</span> <span class="n">f2</span><span class="p">;</span>


<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Tuple (C++11 e superiori)</span>
<span class="c1">///////////////////////////////////////</span>

<span class="cp">#include</span><span class="cpf">&lt;tuple&gt;</span><span class="cp">
</span>
<span class="c1">// Concettualmente le tuple sono simili alle strutture del C, ma invece di avere</span>
<span class="c1">// i membri rappresentati con dei nomi, l'accesso agli elementi avviene tramite</span>
<span class="c1">// il loro ordine all'interno della tupla.</span>

<span class="c1">// Cominciamo costruendo una tupla.</span>
<span class="c1">// Inserire i valori in una tupla</span>
<span class="k">auto</span> <span class="n">prima</span> <span class="o">=</span> <span class="n">make_tuple</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="sc">'A'</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">maxN</span> <span class="o">=</span> <span class="mf">1e9</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">maxL</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">seconda</span> <span class="o">=</span> <span class="n">make_tuple</span><span class="p">(</span><span class="n">maxN</span><span class="p">,</span> <span class="n">maxL</span><span class="p">);</span>

<span class="c1">// Vediamo gli elementi contenuti nella tupla "prima"</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">prima</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">prima</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// stampa : 10 A</span>

<span class="c1">// Vediamo gli elementi contenuti nella tupla "seconda"</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">seconda</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">seconda</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// stampa: 1000000000 15</span>

<span class="c1">// Estrarre i valori dalla tupla, salvandoli nelle variabili</span>
<span class="kt">int</span> <span class="n">primo_intero</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">primo_char</span><span class="p">;</span>
<span class="n">tie</span><span class="p">(</span><span class="n">primo_intero</span><span class="p">,</span> <span class="n">primo_char</span><span class="p">)</span> <span class="o">=</span> <span class="n">prima</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">primo_intero</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">primo_char</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>  <span class="c1">// stampa : 10 A</span>

<span class="c1">// E' possibile creare tuple anche in questo modo</span>
<span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">terza</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="sc">'A'</span><span class="p">,</span> <span class="mf">3.14141</span><span class="p">);</span>

<span class="c1">// tuple_size ritorna il numero di elementi in una tupla (come constexpr)</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tuple_size</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">terza</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// stampa: 3</span>

<span class="c1">// tuple_cat concatena gli elementi di tutte le tuple, nell'esatto ordine</span>
<span class="c1">// in cui sono posizionati all'interno delle tuple stesse</span>
<span class="k">auto</span> <span class="n">tupla_concatenata</span> <span class="o">=</span> <span class="n">tuple_cat</span><span class="p">(</span><span class="n">prima</span><span class="p">,</span> <span class="n">seconda</span><span class="p">,</span> <span class="n">terza</span><span class="p">);</span>
<span class="c1">// tupla_concatenata diventa = (10, 'A', 1e9, 15, 11, 'A' ,3.14141)</span>

<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tupla_concatenata</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// stampa: 10</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tupla_concatenata</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// stampa: 15</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tupla_concatenata</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// stampa: 'A'</span>


<span class="c1">/////////////////////</span>
<span class="c1">// Contenitori</span>
<span class="c1">/////////////////////</span>

<span class="c1">// I Contenitori della "Standard Template Library", ovvero la libreria standard</span>
<span class="c1">// dei template contenuti nel C++, sono template predefiniti.</span>
<span class="c1">// I Contenitori si occupano di come allocare lo spazio per gli elementi contenuti,</span>
<span class="c1">// e forniscono funzioni per accedervi e manipolarli</span>

<span class="c1">// Vediamo alcuni tipi di contenitori:</span>

<span class="c1">// Vector (array dinamici/vettori)</span>
<span class="c1">// Permettono di definire un vettore, o una lista di oggetti, a runtime</span>
<span class="cp">#include</span><span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tipo_Dato</span><span class="o">&gt;</span> <span class="n">nome_vettore</span><span class="p">;</span> <span class="c1">// usato per inizializzare un vettore</span>
<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">val</span><span class="p">;</span>
<span class="n">nome_vettore</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">val</span><span class="p">);</span> <span class="c1">// inserisce il valore di "val" nel vettore</span>

<span class="c1">// Per iterare in un vettore, abbiamo due possibilità:</span>
<span class="c1">// Ciclo normale</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nome_vettore</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="c1">// Cicla dall'indice zero fino all'ultimo</span>

<span class="c1">// Iteratore</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">Tipo_Dato</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="p">;</span> <span class="c1">// inizializza l'iteratore per il vettore</span>
<span class="k">for</span><span class="p">(</span><span class="n">it</span><span class="o">=</span><span class="n">nome_vettore</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span><span class="o">!=</span><span class="n">nome_vettore</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="o">++</span><span class="n">it</span><span class="p">)</span>
<span class="c1">// Nota che adesso non cicla più sugli indici, ma direttamente sugli elementi!</span>

<span class="c1">// Per accedere agli elementi del vettore</span>
<span class="c1">// Operatore []</span>
<span class="n">var</span> <span class="o">=</span> <span class="n">nome_vettore</span><span class="p">[</span><span class="n">indice</span><span class="p">];</span> <span class="c1">// Assegna a "var" il valore del vettore all'indice dato</span>


<span class="c1">// Set (insiemi)</span>
<span class="c1">// Gli insiemi sono contenitori che memorizzano elementi secondo uno specifico ordine.</span>
<span class="c1">// Gli insiemi vengono per lo più utilizzati per memorizzare valori unici, secondo</span>
<span class="c1">// un ordine, senza scrivere ulteriore codice.</span>

<span class="cp">#include</span><span class="cpf">&lt;set&gt;</span><span class="cp">
</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">insieme</span><span class="p">;</span>    <span class="c1">// Inizializza un insieme di interi</span>
<span class="n">insieme</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>  <span class="c1">// Inserisce il valore 30 nell'insieme</span>
<span class="n">insieme</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>  <span class="c1">// Inserisce il valore 10 nell'insieme</span>
<span class="n">insieme</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>  <span class="c1">// Inserisce il valore 20 nell'insieme</span>
<span class="n">insieme</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>  <span class="c1">// Inserisce il valore 30 nell'insieme</span>
<span class="c1">// Gli elementi dell'insieme sono:</span>
<span class="c1">//  10 20 30</span>

<span class="c1">// Per cancellare un elemento</span>
<span class="n">insieme</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>  <span class="c1">// Cancella l'elemento con valore 20</span>
<span class="c1">// L'insieme contiene adesso: 10 30</span>

<span class="c1">// Per iterare su un insieme, usiamo gli iteratori</span>
<span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="n">it</span><span class="o">=</span><span class="n">insieme</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="n">it</span><span class="o">&lt;</span><span class="n">insieme</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// Stampa:</span>
<span class="c1">// 10</span>
<span class="c1">// 30</span>

<span class="c1">// Per svuotare il contenitore usiamo il metodo "clear"</span>
<span class="n">insieme</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">insieme</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="c1">// Stampa: 0</span>

<span class="c1">// Nota: per permettere elementi duplicati, possiamo usare "multiset"</span>

<span class="c1">// Map (mappa/tabella di hash)</span>
<span class="c1">// Le mappe servono per memorizzare un elemento, detto chiave, a cui viene</span>
<span class="c1">// associato un valore, il tutto secondo uno specifico ordine.</span>

<span class="cp">#include</span><span class="cpf">&lt;map&gt;</span><span class="cp">
</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">mia_mappa</span><span class="p">;</span>  <span class="c1">// Inizializza una mappa che usa i char come chiave, e gli interi come valore</span>

<span class="n">mia_mappa</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="sc">'A'</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
<span class="c1">// Inserisce il valore 1 per la chiave A</span>
<span class="n">mia_mappa</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="sc">'Z'</span><span class="p">,</span><span class="mi">26</span><span class="p">));</span>
<span class="c1">// Inserisce il valore 26 per la chiave Z</span>

<span class="c1">// Per iterare</span>
<span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">it</span><span class="o">=</span><span class="n">mia_mappa</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span><span class="o">!=</span><span class="n">mia_mappa</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">"-&gt;"</span> <span class="o">&lt;&lt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="c1">// Stampa:</span>
<span class="c1">// A-&gt;1</span>
<span class="c1">// Z-&gt;26</span>

<span class="c1">// Per trovare il valore corrispondente ad una data chiave</span>
<span class="n">it</span> <span class="o">=</span> <span class="n">mia_mappa</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">'Z'</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
<span class="c1">// Stampa: 26</span>


<span class="c1">///////////////////////////////////</span>
<span class="c1">// Operatori logici e bitwise(bit-a-bit)</span>
<span class="c1">//////////////////////////////////</span>

<span class="c1">// La maggior parte di questi operatori in C++ sono gli stessi degli altri linguaggi</span>

<span class="c1">// Operatori logici</span>

<span class="c1">// Il C++ usa la "Short-circuit evaluation" per le espressioni booleane. Cosa significa?</span>
<span class="c1">// In pratica, in una condizione con due argomenti, il secondo viene considerato solo se</span>
<span class="c1">// il primo non basta a determinate il valore finale dell'espresione.</span>

<span class="nb">true</span> <span class="o">&amp;&amp;</span> <span class="nb">false</span> <span class="c1">// Effettua il **and logico** e ritorna falso</span>
<span class="nb">true</span> <span class="o">||</span> <span class="nb">false</span> <span class="c1">// Effettua il **or logico** e ritorna vero</span>
<span class="o">!</span> <span class="nb">true</span>        <span class="c1">// Effettua il **not logico** e ritorna falso</span>

<span class="c1">// Invece di usare i simboli, si possono usare le keyword equivalenti</span>
<span class="nb">true</span> <span class="n">and</span> <span class="nb">false</span> <span class="c1">// Effettua il **and logico** e ritorna falso</span>
<span class="nb">true</span> <span class="n">or</span> <span class="nb">false</span>  <span class="c1">// Effettua il **or logico** e ritorna vero</span>
<span class="n">not</span> <span class="nb">true</span>       <span class="c1">// Effettua il **not logico** e ritorna falso</span>

<span class="c1">// Operatori bitwise(bit-a-bit)</span>

<span class="c1">// **&lt;&lt;** Operatore di Shift a Sinistra</span>
<span class="c1">// &lt;&lt; sposta i bit a sinistra</span>
<span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="c1">// Sposta a sinistra di 1 i bit di 4, ottenendo 8</span>
<span class="c1">// x &lt;&lt; n in pratica realizza x * 2^n</span>


<span class="c1">// **&gt;&gt;** Operatore di Shift a Destra</span>
<span class="c1">// &gt;&gt; sposta i bit a destra</span>
<span class="mi">4</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span> <span class="c1">// Sposta a destra di 1 i bit di 4, ottenendo 2</span>
<span class="c1">// x &gt;&gt; n in pratica realizza x / 2^n</span>

<span class="o">~</span><span class="mi">4</span>    <span class="c1">// Effettua il NOT bit-a-bit</span>
<span class="mi">4</span> <span class="o">|</span> <span class="mi">3</span> <span class="c1">// Effettua il OR bit-a-bit</span>
<span class="mi">4</span> <span class="o">&amp;</span> <span class="mi">3</span> <span class="c1">// Effettua il AND bit-a-bit</span>
<span class="mi">4</span> <span class="o">^</span> <span class="mi">3</span> <span class="c1">// Effettua il XOR bit-a-bit</span>

<span class="c1">// Le keyword equivalenti sono</span>
<span class="n">compl</span> <span class="mi">4</span>    <span class="c1">// Effettua il NOT bit-a-bit</span>
<span class="mi">4</span> <span class="n">bitor</span> <span class="mi">3</span>  <span class="c1">// Effettua il OR bit-a-bit</span>
<span class="mi">4</span> <span class="n">bitand</span> <span class="mi">3</span> <span class="c1">// Effettua il AND bit-a-bit</span>
<span class="mi">4</span> <span class="n">xor</span> <span class="mi">3</span>    <span class="c1">// Effettua il XOR bit-a-bit</span>

</code></pre></div>
<p>Letture consigliate:</p>

<ul>
<li>Un riferimento aggiornato del linguaggio può essere trovato qui <a href="http://cppreference.com/w/cpp">CPP Reference</a>.</li>
<li>Risorse addizionali possono essere trovate qui <a href="http://cplusplus.com">CPlusPlus</a>.</li>
<li>Un tutorial che copre le basi del linguaggio e l&#39;impostazione dell&#39;ambiente di codifica è disponibile su <a href="https://www.youtube.com/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb">TheChernoProject - C ++</a>.</li>
</ul>

    <hr>
    <p>Hai un suggerimento? Oppure una correzione? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Apri un issue</a> sul Github, o fa un <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/it-it/c++-it.html.markdown">pull request</a> da solo!
    </p>
    <p class="contributed">
    In origine contribuita da Steven Basart, e modificata da <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/it-it/c++-it.html.markdown">3 contributore(i)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://github.com/xksteven">Steven Basart</a>,
        <a href="https://github.com/mrkline">Matt Kline</a>,
        <a href="http://geoffliu.me">Geoff Liu</a>,
        <a href="http://github.com/connorwaters">Connor Waters</a>
    </p>

    <p>
      Translated by:
        <a href="http://github.com/sinkswim/">Robert Margelli</a>
        <a href="http://github.com/neslinesli93/">Tommaso Pifferi</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>

        <script>
            var _gaq=[['_setAccount','UA-3525624-21'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>
</html>
