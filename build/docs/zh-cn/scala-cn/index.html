<!DOCTYPE html lang="zh-cn" xml:lang="zh-cn" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="zh-cn">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Scala in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/zh-cn/scala-cn/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fzh-cn%2Fscala-cn%2F&text=Y%E5%88%86%E9%92%9F%E9%80%9F%E6%88%90X%2C+%E5%85%B6%E4%B8%AD+X%3DScala">
        分享此页
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">选择主题：</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">亮</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">暗</button>
  </div>
  <h1><a href="/">Y分钟速成X</a></h1>
  <h2>其中 X=Scala</h2>
    <p class="filelink">
    源代码下载：
    <a href="/docs/files/learnscala-zh.scala">learnscala-zh.scala</a>
    </p>
  <div id="doc">
    <p>Scala - 一门可拓展的语言</p>
<div class="highlight"><pre class="highlight scala"><code>
<span class="cm">/*
  自行设置:

  1) 下载 Scala - http://www.scala-lang.org/downloads
  2) unzip/untar 到您喜欢的地方，并把 bin 子目录添加到 path 环境变量
  3) 在终端输入 scala，启动 Scala 的 REPL，您会看到提示符：

  scala&gt;

  这就是所谓的 REPL (读取-求值-输出循环，英语： Read-Eval-Print Loop)，
  您可以在其中输入合法的表达式，结果会被打印。
  在教程中我们会进一步解释 Scala 文件是怎样的，但现在先了解一点基础。
*/</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 1. 基础</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">//  单行注释开始于两个斜杠</span>

<span class="cm">/*
  多行注释，如您之前所见，看起来像这样
*/</span>

<span class="c1">// 打印并强制换行</span>
<span class="nf">println</span><span class="o">(</span><span class="s">"Hello world!"</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>

<span class="c1">// 没有强制换行的打印</span>
<span class="nf">print</span><span class="o">(</span><span class="s">"Hello world"</span><span class="o">)</span>

<span class="c1">// 通过 var 或者 val 来声明变量</span>
<span class="c1">// val 声明是不可变的，var 声明是可修改的。不可变性是好事。</span>
<span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="mi">10</span> <span class="c1">// x 现在是 10</span>
<span class="n">x</span> <span class="k">=</span> <span class="mi">20</span> <span class="c1">// 错误: 对 val 声明的变量重新赋值</span>
<span class="k">var</span> <span class="n">y</span> <span class="k">=</span> <span class="mi">10</span> 
<span class="n">y</span> <span class="k">=</span> <span class="mi">20</span>  <span class="c1">// y 现在是 20</span>

<span class="cm">/*
  Scala 是静态语言，但注意上面的声明方式，我们没有指定类型。
  这是因为类型推导的语言特性。大多数情况， Scala 编译器可以推测变量的类型，
  所以您不需要每次都输入。可以像这样明确声明变量类型：
*/</span>
<span class="k">val</span> <span class="nv">z</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span>
<span class="k">val</span> <span class="nv">a</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="c1">// 注意从 Int 到 Double 的自动转型，结果是 10.0, 不是 10</span>
<span class="k">val</span> <span class="nv">b</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mi">10</span>

<span class="c1">// 布尔值</span>
<span class="kc">true</span>
<span class="kc">false</span>

<span class="c1">// 布尔操作</span>
<span class="o">!</span><span class="kc">true</span> <span class="c1">// false</span>
<span class="o">!</span><span class="kc">false</span> <span class="c1">// true</span>
<span class="kc">true</span> <span class="o">==</span> <span class="kc">false</span> <span class="c1">// false</span>
<span class="mi">10</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="c1">// true</span>

<span class="c1">// 数学运算像平常一样</span>
<span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// 2</span>
<span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">// 1</span>
<span class="mi">5</span> <span class="o">*</span> <span class="mi">3</span> <span class="c1">// 15</span>
<span class="mi">6</span> <span class="o">/</span> <span class="mi">2</span> <span class="c1">// 3</span>
<span class="mi">6</span> <span class="o">/</span> <span class="mi">4</span> <span class="c1">// 1</span>
<span class="mf">6.0</span> <span class="o">/</span> <span class="mi">4</span> <span class="c1">// 1.5</span>


<span class="c1">// 在 REPL 计算一个表达式会返回给您结果的类型和值</span>

<span class="mi">1</span> <span class="o">+</span> <span class="mi">7</span>

<span class="cm">/* 上行的结果是：

  scala&gt; 1 + 7
  res29: Int = 8

  这意味着计算 1 + 7 的结果是一个 Int 类型的对象，其值为 8

  注意 "res29" 是一个连续生成的变量名，用以存储您输入的表达式结果，
  您看到的输出可能不一样。
*/</span>

<span class="s">"Scala strings are surrounded by double quotes"</span>
<span class="sc">'a'</span> <span class="c1">// Scala 的字符</span>
<span class="c1">// '不存在单引号字符串' &lt;= 这会导致错误</span>

<span class="c1">// String 有常见的 Java 字符串方法</span>
<span class="s">"hello world"</span><span class="o">.</span><span class="py">length</span>
<span class="s">"hello world"</span><span class="o">.</span><span class="py">substring</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>
<span class="s">"hello world"</span><span class="o">.</span><span class="py">replace</span><span class="o">(</span><span class="s">"C"</span><span class="o">,</span> <span class="s">"3"</span><span class="o">)</span>

<span class="c1">// 也有一些额外的 Scala 方法，另请参见：scala.collection.immutable.StringOps</span>
<span class="s">"hello world"</span><span class="o">.</span><span class="py">take</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="s">"hello world"</span><span class="o">.</span><span class="py">drop</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>

<span class="c1">// 字符串改写：留意前缀 "s"</span>
<span class="k">val</span> <span class="nv">n</span> <span class="k">=</span> <span class="mi">45</span>
<span class="n">s</span><span class="s">"We have $n apples"</span> <span class="c1">// =&gt; "We have 45 apples"</span>

<span class="c1">// 在要改写的字符串中使用表达式也是可以的</span>
<span class="k">val</span> <span class="nv">a</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">11</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>
<span class="n">s</span><span class="s">"My second daughter is ${a(0) - a(2)} years old."</span> <span class="c1">// =&gt; "My second daughter is 5 years old."</span>
<span class="n">s</span><span class="s">"We have double the amount of ${n / 2.0} in apples."</span> <span class="c1">// =&gt; "We have double the amount of 22.5 in apples."</span>
<span class="n">s</span><span class="s">"Power of 2: ${math.pow(2, 2)}"</span> <span class="c1">// =&gt; "Power of 2: 4"</span>

<span class="c1">// 添加 "f" 前缀对要改写的字符串进行格式化</span>
<span class="n">f</span><span class="s">"Power of 5: ${math.pow(5, 2)}%1.0f"</span> <span class="c1">// "Power of 5: 25"</span>
<span class="n">f</span><span class="s">"Square root of 122: ${math.sqrt(122)}%1.4f"</span> <span class="c1">// "Square root of 122: 11.0454"</span>

<span class="c1">// 未处理的字符串，忽略特殊字符。</span>
<span class="n">raw</span><span class="s">"New line feed: \n. Carriage return: \r."</span> <span class="c1">// =&gt; "New line feed: \n. Carriage return: \r."</span>

<span class="c1">// 一些字符需要转义，比如字符串中的双引号</span>
<span class="s">"They stood outside the \"Rose and Crown\""</span> <span class="c1">// =&gt; "They stood outside the "Rose and Crown""</span>

<span class="c1">// 三个双引号可以使字符串跨越多行，并包含引号</span>
<span class="k">val</span> <span class="nv">html</span> <span class="k">=</span> <span class="s">"""&lt;form id="daform"&gt;
                &lt;p&gt;Press belo', Joe&lt;/p&gt;
                &lt;input type="submit"&gt;
              &lt;/form&gt;"""</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 2. 函数</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// 函数可以这样定义:</span>
<span class="c1">//</span>
<span class="c1">//   def functionName(args...): ReturnType = { body... }</span>
<span class="c1">//</span>
<span class="c1">// 如果您以前学习过传统的编程语言，注意 return 关键字的省略。</span>
<span class="c1">// 在 Scala 中， 函数代码块最后一条表达式就是返回值。</span>
<span class="k">def</span> <span class="nf">sumOfSquares</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">x2</span> <span class="k">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
  <span class="k">val</span> <span class="nv">y2</span> <span class="k">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span>
  <span class="n">x2</span> <span class="o">+</span> <span class="n">y2</span>
<span class="o">}</span>

<span class="c1">// 如果函数体是单行表达式，{ } 可以省略：</span>
<span class="k">def</span> <span class="nf">sumOfSquaresShort</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span>

<span class="c1">// 函数调用的语法是熟知的：</span>
<span class="nf">sumOfSquares</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>  <span class="c1">// =&gt; 25</span>

<span class="c1">// 在多数情况下 (递归函数是需要注意的例外), 函数返回值可以省略，</span>
<span class="c1">// 变量所用的类型推导一样会应用到函数返回值中：</span>
<span class="k">def</span> <span class="nf">sq</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>  <span class="c1">// 编译器会推断得知返回值是 Int</span>

<span class="c1">// 函数可以有默认参数</span>
<span class="k">def</span> <span class="nf">addWithDefault</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="nf">addWithDefault</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>  <span class="c1">// =&gt; 3</span>
<span class="nf">addWithDefault</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>  <span class="c1">// =&gt; 6</span>


<span class="c1">// 匿名函数是这样的：</span>
<span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="c1">// 和 def 不同，如果语义清晰，匿名函数的参数类型也可以省略。</span>
<span class="c1">// 类型 "Int =&gt; Int" 意味着这个函数接收一个 Int 并返回一个 Int。</span>
<span class="k">val</span> <span class="nv">sq</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="c1">// 匿名函数的调用也是类似的：</span>
<span class="nf">sq</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>   <span class="c1">// =&gt; 100</span>

<span class="c1">// 如果您的匿名函数中每个参数仅使用一次，</span>
<span class="c1">// Scala 提供一个更简洁的方式来定义他们。这样的匿名函数极为常见，</span>
<span class="c1">// 在数据结构部分会明显可见。</span>
<span class="k">val</span> <span class="nv">addOne</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="k">_</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">val</span> <span class="nv">weirdSum</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="k">_</span> <span class="o">*</span> <span class="mi">3</span><span class="o">)</span>

<span class="nf">addOne</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>  <span class="c1">// =&gt; 6</span>
<span class="nf">weirdSum</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>  <span class="c1">// =&gt; 16</span>


<span class="c1">// return 关键字是存在的，但它只从最里面包裹了 return 的 def 函数中返回。</span>
<span class="c1">// 警告： 在 Scala 中使用 return 容易出错，应该避免使用。</span>
<span class="c1">// 在匿名函数中没有效果，例如：</span>
<span class="k">def</span> <span class="nf">foo</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">anonFunc</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">{</span> <span class="n">z</span> <span class="k">=&gt;</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">z</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="o">)</span>
      <span class="k">return</span> <span class="n">z</span>  <span class="c1">// 这一行令 z 成为 foo 函数的返回值！</span>
    <span class="k">else</span>
      <span class="n">z</span> <span class="o">+</span> <span class="mi">2</span>  <span class="c1">// 这一行是 anonFunc 函数的返回值</span>
  <span class="o">}</span>
  <span class="nf">anonFunc</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>  <span class="c1">// 这一行是 foo 函数的返回值</span>
<span class="o">}</span>

<span class="cm">/*
 * 译者注：此处是指匿名函数中的 return z 成为最后执行的语句，
 *    在 anonFunc(x) 下面的表达式（假设存在）不再执行。如果 anonFunc
 *    是用 def 定义的函数， return z 仅返回到 anonFunc(x) ，
 *    在 anonFunc(x) 下面的表达式（假设存在）会继续执行。
 */</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 3. 控制语句</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="mi">1</span> <span class="n">to</span> <span class="mi">5</span>
<span class="k">val</span> <span class="nv">r</span> <span class="k">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">5</span>
<span class="nv">r</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span> <span class="n">println</span> <span class="o">)</span>

<span class="n">r</span> <span class="n">foreach</span> <span class="n">println</span>
<span class="c1">// 附注： Scala 对点和括号的要求想当宽松，注意其规则是不同的。</span>
<span class="c1">// 这有助于写出读起来像英语的 DSL(领域特定语言) 和 API(应用编程接口)。</span>

<span class="o">(</span><span class="mi">5</span> <span class="n">to</span> <span class="mi">1</span> <span class="n">by</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="nf">foreach</span> <span class="o">(</span> <span class="n">println</span> <span class="o">)</span>

<span class="c1">// while 循环</span>
<span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
<span class="nf">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span>  <span class="nf">println</span><span class="o">(</span><span class="s">"i "</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span> <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>  <span class="o">}</span>

<span class="nf">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span>  <span class="nf">println</span><span class="o">(</span><span class="s">"i "</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span> <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>  <span class="o">}</span>   <span class="c1">// 没错，再执行一次，发生了什么？为什么？</span>

<span class="n">i</span>    <span class="c1">// 显示 i 的值。注意 while 是经典的循环方式，它连续执行并改变循环中的变量。</span>
     <span class="c1">// while 执行很快，比 Java 的循环快，但像上面所看到的那样用组合子和推导式</span>
     <span class="c1">// 更易于理解和并行化。</span>

<span class="c1">// do while 循环</span>
<span class="k">do</span> <span class="o">{</span>
  <span class="nf">println</span><span class="o">(</span><span class="s">"x is still less than 10"</span><span class="o">);</span>
  <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="o">}</span> <span class="nf">while</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span>

<span class="c1">// Scala 中尾递归是一种符合语言习惯的递归方式。</span>
<span class="c1">// 递归函数需要清晰的返回类型，编译器不能推断得知。</span>
<span class="c1">// 这是一个 Unit。</span>
<span class="k">def</span> <span class="nf">showNumbersInRange</span><span class="o">(</span><span class="n">a</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span><span class="k">:</span><span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="nf">print</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
  <span class="nf">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">)</span>
    <span class="nf">showNumbersInRange</span><span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
<span class="o">}</span>
<span class="nf">showNumbersInRange</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">14</span><span class="o">)</span>


<span class="c1">// 条件语句</span>

<span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="mi">10</span>

<span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="nf">println</span><span class="o">(</span><span class="s">"yeah"</span><span class="o">)</span>
<span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">10</span><span class="o">)</span> <span class="nf">println</span><span class="o">(</span><span class="s">"yeah"</span><span class="o">)</span>
<span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">11</span><span class="o">)</span> <span class="nf">println</span><span class="o">(</span><span class="s">"yeah"</span><span class="o">)</span>
<span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">11</span><span class="o">)</span> <span class="nf">println</span> <span class="o">(</span><span class="s">"yeah"</span><span class="o">)</span> <span class="k">else</span> <span class="nf">println</span><span class="o">(</span><span class="s">"nay"</span><span class="o">)</span>

<span class="nf">println</span><span class="o">(</span><span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">10</span><span class="o">)</span> <span class="s">"yeah"</span> <span class="k">else</span> <span class="s">"nope"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">text</span> <span class="k">=</span> <span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">10</span><span class="o">)</span> <span class="s">"yeah"</span> <span class="k">else</span> <span class="s">"nope"</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 4. 数据结构</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="k">val</span> <span class="nv">a</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">13</span><span class="o">)</span>
<span class="nf">a</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="nf">a</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="nf">a</span><span class="o">(</span><span class="mi">21</span><span class="o">)</span>    <span class="c1">// 抛出异常</span>

<span class="k">val</span> <span class="nv">m</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"fork"</span> <span class="o">-&gt;</span> <span class="s">"tenedor"</span><span class="o">,</span> <span class="s">"spoon"</span> <span class="o">-&gt;</span> <span class="s">"cuchara"</span><span class="o">,</span> <span class="s">"knife"</span> <span class="o">-&gt;</span> <span class="s">"cuchillo"</span><span class="o">)</span>
<span class="nf">m</span><span class="o">(</span><span class="s">"fork"</span><span class="o">)</span>
<span class="nf">m</span><span class="o">(</span><span class="s">"spoon"</span><span class="o">)</span>
<span class="nf">m</span><span class="o">(</span><span class="s">"bottle"</span><span class="o">)</span>       <span class="c1">// 抛出异常</span>

<span class="k">val</span> <span class="nv">safeM</span> <span class="k">=</span> <span class="nv">m</span><span class="o">.</span><span class="py">withDefaultValue</span><span class="o">(</span><span class="s">"no lo se"</span><span class="o">)</span>
<span class="nf">safeM</span><span class="o">(</span><span class="s">"bottle"</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>
<span class="nf">s</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="nf">s</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="cm">/* 这里查看 map 的文档 -
 * http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Map
 * 并确保你会阅读
 */</span>


<span class="c1">// 元组</span>

<span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

<span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

<span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="s">"three"</span><span class="o">)</span>

<span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="s">"three"</span><span class="o">)</span>

<span class="c1">// 为什么有这个？</span>
<span class="k">val</span> <span class="nv">divideInts</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="o">%</span> <span class="n">y</span><span class="o">)</span>

<span class="nf">divideInts</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span> <span class="c1">// 函数 divideInts 同时返回结果和余数</span>

<span class="c1">// 要读取元组的元素，使用 _._n，n是从1开始的元素索引</span>
<span class="k">val</span> <span class="nv">d</span> <span class="k">=</span> <span class="nf">divideInts</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span>

<span class="nv">d</span><span class="o">.</span><span class="py">_1</span>

<span class="nv">d</span><span class="o">.</span><span class="py">_2</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 5. 面向对象编程</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="cm">/*
  旁白: 教程中到现在为止我们所做的一切只是简单的表达式（值，函数等）。
  这些表达式可以输入到命令行解释器中作为快速测试，但它们不能独立存在于 Scala 
  文件。举个例子，您不能在 Scala 文件上简单的写上 "val x = 5"。相反 Scala 文件
  允许的顶级结构是：

  - objects
  - classes
  - case classes
  - traits

  现在来解释这些是什么。
*/</span>

<span class="c1">// 类和其他语言的类相似，构造器参数在类名后声明，初始化在类结构体中完成。</span>
<span class="k">class</span> <span class="nc">Dog</span><span class="o">(</span><span class="n">br</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// 构造器代码在此</span>
  <span class="k">var</span> <span class="n">breed</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">br</span>

  <span class="c1">// 定义名为 bark 的方法，返回字符串</span>
  <span class="k">def</span> <span class="nf">bark</span> <span class="k">=</span> <span class="s">"Woof, woof!"</span>

  <span class="c1">// 值和方法作用域假定为 public。"protected" 和 "private" 关键字也是可用的。</span>
  <span class="k">private</span> <span class="k">def</span> <span class="nf">sleep</span><span class="o">(</span><span class="n">hours</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span>
    <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"I'm sleeping for $hours hours"</span><span class="o">)</span>

  <span class="c1">// 抽象方法是没有方法体的方法。如果取消下面那行注释，Dog 类必须被声明为 abstract</span>
  <span class="c1">//   abstract class Dog(...) { ... }</span>
  <span class="c1">// def chaseAfter(what: String): String</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">mydog</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">(</span><span class="s">"greyhound"</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">mydog</span><span class="o">.</span><span class="py">breed</span><span class="o">)</span> <span class="c1">// =&gt; "greyhound"</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">mydog</span><span class="o">.</span><span class="py">bark</span><span class="o">)</span> <span class="c1">// =&gt; "Woof, woof!"</span>


<span class="c1">// "object" 关键字创造一种类型和该类型的单例。</span>
<span class="c1">// Scala 的 class 常常也含有一个 “伴生对象”，class 中包含每个实例的行为，所有实例</span>
<span class="c1">// 共用的行为则放入 object 中。两者的区别和其他语言中类方法和静态方法类似。</span>
<span class="c1">// 请注意 object 和 class 可以同名。</span>
<span class="k">object</span> <span class="nc">Dog</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">allKnownBreeds</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"pitbull"</span><span class="o">,</span> <span class="s">"shepherd"</span><span class="o">,</span> <span class="s">"retriever"</span><span class="o">)</span>
  <span class="k">def</span> <span class="nf">createDog</span><span class="o">(</span><span class="n">breed</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">(</span><span class="n">breed</span><span class="o">)</span>
<span class="o">}</span>


<span class="c1">// Case 类是有额外内建功能的类。Scala 初学者常遇到的问题之一便是何时用类</span>
<span class="c1">// 和何时用 case 类。界线比较模糊，但通常类倾向于封装，多态和行为。类中的值</span>
<span class="c1">// 的作用域一般为 private ， 只有方法是暴露的。case 类的主要目的是放置不可变</span>
<span class="c1">// 数据。它们通常只有几个方法，且方法几乎没有副作用。</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">phoneNumber</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="c1">// 创造新实例，注意 case 类不需要使用 "new" 关键字</span>
<span class="k">val</span> <span class="nv">george</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"George"</span><span class="o">,</span> <span class="s">"1234"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">kate</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Kate"</span><span class="o">,</span> <span class="s">"4567"</span><span class="o">)</span>

<span class="c1">// 使用 case 类，您可以轻松得到一些功能，像 getters:</span>
<span class="nv">george</span><span class="o">.</span><span class="py">phoneNumber</span>  <span class="c1">// =&gt; "1234"</span>

<span class="c1">// 每个字段的相等性比较（无需覆盖 .equals）</span>
<span class="nc">Person</span><span class="o">(</span><span class="s">"George"</span><span class="o">,</span> <span class="s">"1234"</span><span class="o">)</span> <span class="o">==</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Kate"</span><span class="o">,</span> <span class="s">"1236"</span><span class="o">)</span>  <span class="c1">// =&gt; false</span>

<span class="c1">// 简单的拷贝方式</span>
<span class="c1">// otherGeorge == Person("george", "9876")</span>
<span class="k">val</span> <span class="nv">otherGeorge</span> <span class="k">=</span> <span class="nv">george</span><span class="o">.</span><span class="py">copy</span><span class="o">(</span><span class="n">phoneNumber</span> <span class="k">=</span> <span class="s">"9876"</span><span class="o">)</span>

<span class="c1">// 还有很多。case 类同时可以用于模式匹配，接下来会看到。</span>


<span class="c1">// 敬请期待 Traits ！</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 6. 模式匹配</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// 模式匹配是一个强大和常用的 Scala 特性。这是用模式匹配一个 case 类的例子。</span>
<span class="c1">// 附注：不像其他语言， Scala 的 case 不需要 break， 其他语言中 switch 语句的</span>
<span class="c1">// fall-through 现象不会发生。</span>

<span class="k">def</span> <span class="nf">matchPerson</span><span class="o">(</span><span class="n">person</span><span class="k">:</span> <span class="kt">Person</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">person</span> <span class="k">match</span> <span class="o">{</span>
  <span class="c1">// Then you specify the patterns:</span>
  <span class="k">case</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"George"</span><span class="o">,</span> <span class="n">number</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"We found George! His number is "</span> <span class="o">+</span> <span class="n">number</span>
  <span class="k">case</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Kate"</span><span class="o">,</span> <span class="n">number</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"We found Kate! Her number is "</span> <span class="o">+</span> <span class="n">number</span>
  <span class="k">case</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">number</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"We matched someone : "</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">", phone : "</span> <span class="o">+</span> <span class="n">number</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">email</span> <span class="k">=</span> <span class="s">"(.*)@(.*)"</span><span class="o">.</span><span class="py">r</span>  <span class="c1">// 定义下一个例子会用到的正则</span>

<span class="c1">// 模式匹配看起来和 C语言家族的 switch 语句相似，但更为强大。</span>
<span class="c1">// Scala 中您可以匹配很多东西：</span>
<span class="k">def</span> <span class="nf">matchEverything</span><span class="o">(</span><span class="n">obj</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">obj</span> <span class="k">match</span> <span class="o">{</span>
  <span class="c1">// 匹配值：</span>
  <span class="k">case</span> <span class="s">"Hello world"</span> <span class="k">=&gt;</span> <span class="s">"Got the string Hello world"</span>

  <span class="c1">// 匹配类型：</span>
  <span class="k">case</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=&gt;</span> <span class="s">"Got a Double: "</span> <span class="o">+</span> <span class="n">x</span>

  <span class="c1">// 匹配时指定条件</span>
  <span class="k">case</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span> <span class="kt">if</span> <span class="kt">x</span> <span class="kt">&gt;</span> <span class="err">10000</span> <span class="o">=&gt;</span> <span class="s">"Got a pretty big number!"</span>

  <span class="c1">// 像之前一样匹配 case 类：</span>
  <span class="k">case</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">number</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"Got contact info for $name!"</span>

  <span class="c1">// 匹配正则表达式：</span>
  <span class="k">case</span> <span class="nf">email</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">domain</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"Got email address $name@$domain"</span>

  <span class="c1">// 匹配元组：</span>
  <span class="nf">case</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">c</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"Got a tuple: $a, $b, $c"</span>

  <span class="c1">// 匹配数据结构：</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"Got a list with three elements and starts with 1: 1, $b, $c"</span>

  <span class="c1">// 模式可以嵌套</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span><span class="s">"YAY"</span><span class="o">)))</span> <span class="k">=&gt;</span> <span class="s">"Got a list of list of tuple"</span>
<span class="o">}</span>

<span class="c1">// 事实上，你可以对任何有 "unapply" 方法的对象进行模式匹配。</span>
<span class="c1">// 这个特性如此强大以致于 Scala 允许定义一个函数作为模式匹配：</span>
<span class="k">val</span> <span class="nv">patternFunc</span><span class="k">:</span> <span class="kt">Person</span> <span class="o">=&gt;</span> <span class="nc">String</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"George"</span><span class="o">,</span> <span class="n">number</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"George's number: $number"</span>
  <span class="k">case</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">number</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"Random person's number: $number"</span>
<span class="o">}</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 7. 函数式编程</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Scala 允许方法和函数作为其他方法和函数的参数和返回值。</span>

<span class="k">val</span> <span class="nv">add10</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="k">_</span> <span class="o">+</span> <span class="mi">10</span> <span class="c1">// 一个接受一个 Int 类型参数并返回一个 Int 类型值的函数</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="n">map</span> <span class="n">add10</span> <span class="c1">// List(11, 12, 13) - add10 被应用到每一个元素</span>

<span class="c1">// 匿名函数可以被使用来代替有命名的函数：</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">10</span><span class="o">)</span>

<span class="c1">// 如果匿名函数只有一个参数可以用下划线作为变量</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">10</span><span class="o">)</span>

<span class="c1">// 如果您所应用的匿名块和匿名函数都接受一个参数，那么你甚至可以省略下划线</span>
<span class="nc">List</span><span class="o">(</span><span class="s">"Dom"</span><span class="o">,</span> <span class="s">"Bob"</span><span class="o">,</span> <span class="s">"Natalia"</span><span class="o">)</span> <span class="n">foreach</span> <span class="n">println</span>


<span class="c1">// 组合子</span>

<span class="c1">// 译注: val sq: Int =&gt; Int = x =&gt; x * x</span>
<span class="nv">s</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">sq</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">sSquared</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span> <span class="nf">map</span><span class="o">(</span><span class="n">sq</span><span class="o">)</span>

<span class="nv">sSquared</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="k">_</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span>

<span class="nv">sSquared</span><span class="o">.</span><span class="py">reduce</span> <span class="o">(</span><span class="k">_</span><span class="o">+</span><span class="k">_</span><span class="o">)</span>

<span class="c1">// filter 函数接受一个 predicate （函数根据条件 A 返回 Boolean）并选择</span>
<span class="c1">// 所有满足 predicate 的元素</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="nf">filter</span> <span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="c1">// List(3)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="k">:</span><span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(</span>
  <span class="nc">Person</span><span class="o">(</span><span class="n">name</span> <span class="k">=</span> <span class="s">"Dom"</span><span class="o">,</span> <span class="n">age</span> <span class="k">=</span> <span class="mi">23</span><span class="o">),</span>
  <span class="nc">Person</span><span class="o">(</span><span class="n">name</span> <span class="k">=</span> <span class="s">"Bob"</span><span class="o">,</span> <span class="n">age</span> <span class="k">=</span> <span class="mi">30</span><span class="o">)</span>
<span class="o">).</span><span class="py">filter</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">age</span> <span class="o">&gt;</span> <span class="mi">25</span><span class="o">)</span> <span class="c1">// List(Person("Bob", 30))</span>


<span class="c1">// Scala 的 foreach 方法定义在某些集合中，接受一个函数并返回 Unit （void 方法）</span>
<span class="c1">// 另请参见：</span>
<span class="c1">// http://www.scala-lang.org/api/current/index.html#scala.collection.IterableLike@foreach(f:A=&gt;Unit):Unit</span>
<span class="k">val</span> <span class="nv">aListOfNumbers</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">100</span><span class="o">)</span>
<span class="n">aListOfNumbers</span> <span class="nf">foreach</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
<span class="n">aListOfNumbers</span> <span class="n">foreach</span> <span class="n">println</span>

<span class="c1">// For 推导式</span>

<span class="k">for</span> <span class="o">{</span> <span class="n">n</span> <span class="k">&lt;-</span> <span class="n">s</span> <span class="o">}</span> <span class="k">yield</span> <span class="nf">sq</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">nSquared2</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span> <span class="n">n</span> <span class="k">&lt;-</span> <span class="n">s</span> <span class="o">}</span> <span class="k">yield</span> <span class="nf">sq</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>

<span class="k">for</span> <span class="o">{</span> <span class="n">n</span> <span class="k">&lt;-</span> <span class="n">nSquared2</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">}</span> <span class="k">yield</span> <span class="n">n</span>

<span class="k">for</span> <span class="o">{</span> <span class="n">n</span> <span class="k">&lt;-</span> <span class="n">s</span><span class="o">;</span> <span class="n">nSquared</span> <span class="k">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span> <span class="k">if</span> <span class="n">nSquared</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">}</span> <span class="k">yield</span> <span class="n">nSquared</span>

<span class="cm">/* 注意，这些不是 for 循环，for 循环的语义是‘重复’，然而 for 推导式定义
   两个数据集合的关系。 */</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 8. 隐式转换</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="cm">/* 警告 警告: 隐式转换是 Scala 中一套强大的特性，因此容易被滥用。
 * Scala 初学者在理解它们的工作原理和最佳实践之前，应抵制使用它的诱惑。
 * 我们加入这一章节仅因为它们在 Scala 的库中太过常见，导致没有用隐式转换的库
 * 就不可能做有意义的事情。这章节主要让你理解和使用隐式转换，而不是自己声明。
 */</span>

<span class="c1">// 可以通过 "implicit" 声明任何值（val, 函数，对象等）为隐式值，</span>
<span class="c1">// 请注意这些例子中，我们用到第5部分的 Dog 类。</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="nv">myImplicitInt</span> <span class="k">=</span> <span class="mi">100</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="nf">myImplicitFunction</span><span class="o">(</span><span class="n">breed</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">(</span><span class="s">"Golden "</span> <span class="o">+</span> <span class="n">breed</span><span class="o">)</span>

<span class="c1">// implicit 关键字本身不改变值的行为，所以上面的值可以照常使用。</span>
<span class="n">myImplicitInt</span> <span class="o">+</span> <span class="mi">2</span>  <span class="c1">// =&gt; 102</span>
<span class="nf">myImplicitFunction</span><span class="o">(</span><span class="s">"Pitbull"</span><span class="o">).</span><span class="py">breed</span>  <span class="c1">// =&gt; "Golden Pitbull"</span>

<span class="c1">// 区别在于，当另一段代码“需要”隐式值时，这些值现在有资格作为隐式值。</span>
<span class="c1">// 一种情况是隐式函数参数。</span>
<span class="k">def</span> <span class="nf">sendGreetings</span><span class="o">(</span><span class="n">toWhom</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">howMany</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span>
  <span class="n">s</span><span class="s">"Hello $toWhom, $howMany blessings to you and yours!"</span>

<span class="c1">// 如果提供值给 “howMany”，函数正常运行</span>
<span class="nf">sendGreetings</span><span class="o">(</span><span class="s">"John"</span><span class="o">)(</span><span class="mi">1000</span><span class="o">)</span>  <span class="c1">// =&gt; "Hello John, 1000 blessings to you and yours!"</span>

<span class="c1">// 如果省略隐式参数，会传一个和参数类型相同的隐式值，</span>
<span class="c1">// 在这个例子中， 是 “myImplicitInt":</span>
<span class="nf">sendGreetings</span><span class="o">(</span><span class="s">"Jane"</span><span class="o">)</span>  <span class="c1">// =&gt; "Hello Jane, 100 blessings to you and yours!"</span>

<span class="c1">// 隐式的函数参数使我们可以模拟其他函数式语言的 type 类（type classes）。</span>
<span class="c1">// 它经常被用到所以有特定的简写。这两行代码是一样的：</span>
<span class="k">def</span> <span class="nf">foo</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="k">implicit</span> <span class="n">c</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">def</span> <span class="nf">foo</span><span class="o">[</span><span class="kt">T</span> <span class="kt">:</span> <span class="kt">C</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="c1">// 编译器寻找隐式值另一种情况是你调用方法时</span>
<span class="c1">//   obj.method(...)</span>
<span class="c1">// 但 "obj" 没有一个名为 "method" 的方法。这样的话，如果有一个参数类型为 A</span>
<span class="c1">// 返回值类型为 B 的隐式转换，obj 的类型是 A，B 有一个方法叫 "method" ，这样</span>
<span class="c1">// 转换就会被应用。所以作用域里有上面的 myImplicitFunction, 我们可以这样做：</span>
<span class="s">"Retriever"</span><span class="o">.</span><span class="py">breed</span>  <span class="c1">// =&gt; "Golden Retriever"</span>
<span class="s">"Sheperd"</span><span class="o">.</span><span class="py">bark</span>  <span class="c1">// =&gt; "Woof, woof!"</span>

<span class="c1">// 这里字符串先被上面的函数转换为 Dog 对象，然后调用相应的方法。</span>
<span class="c1">// 这是相当强大的特性，但再次提醒，请勿轻率使用。</span>
<span class="c1">// 事实上，当你定义上面的隐式函数时，编译器会作出警告，除非你真的了解</span>
<span class="c1">// 你正在做什么否则不要使用。</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 9. 杂项</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// 导入类</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable.List</span>

<span class="c1">// 导入所有子包</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable._</span>

<span class="c1">// 一条语句导入多个类</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable.</span><span class="o">{</span><span class="nc">List</span><span class="o">,</span> <span class="nc">Map</span><span class="o">}</span>

<span class="c1">// 使用 ‘=&gt;’ 对导入进行重命名</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable.</span><span class="o">{</span> <span class="nc">List</span> <span class="k">=&gt;</span> <span class="nc">ImmutableList</span> <span class="o">}</span>

<span class="c1">// 导入所有类，排除其中一些。下面的语句排除了 Map 和 Set：</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable.</span><span class="o">{</span><span class="nc">Map</span> <span class="k">=&gt;</span> <span class="k">_</span><span class="o">,</span> <span class="nc">Set</span> <span class="k">=&gt;</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">}</span>

<span class="c1">// 在 Scala 文件用 object 和单一的 main 方法定义程序入口：</span>
<span class="k">object</span> <span class="nc">Application</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="c1">// stuff goes here.</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 文件可以包含多个 class 和 object，用 scalac 编译源文件</span>




<span class="c1">// 输入和输出</span>

<span class="c1">// 按行读文件</span>
<span class="k">import</span> <span class="nn">scala.io.Source</span>
<span class="nf">for</span><span class="o">(</span><span class="n">line</span> <span class="k">&lt;-</span> <span class="nv">Source</span><span class="o">.</span><span class="py">fromFile</span><span class="o">(</span><span class="s">"myfile.txt"</span><span class="o">).</span><span class="py">getLines</span><span class="o">())</span>
  <span class="nf">println</span><span class="o">(</span><span class="n">line</span><span class="o">)</span>

<span class="c1">// 用 Java 的 PrintWriter 写文件</span>
<span class="k">val</span> <span class="nv">writer</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PrintWriter</span><span class="o">(</span><span class="s">"myfile.txt"</span><span class="o">)</span>
<span class="nv">writer</span><span class="o">.</span><span class="py">write</span><span class="o">(</span><span class="s">"Writing line for line"</span> <span class="o">+</span> <span class="nv">util</span><span class="o">.</span><span class="py">Properties</span><span class="o">.</span><span class="py">lineSeparator</span><span class="o">)</span>
<span class="nv">writer</span><span class="o">.</span><span class="py">write</span><span class="o">(</span><span class="s">"Another line here"</span> <span class="o">+</span> <span class="nv">util</span><span class="o">.</span><span class="py">Properties</span><span class="o">.</span><span class="py">lineSeparator</span><span class="o">)</span>
<span class="nv">writer</span><span class="o">.</span><span class="py">close</span><span class="o">()</span>

</code></pre></div>
<h2>更多的资源</h2>

<p><a href="http://horstmann.com/scala/">为没耐心的人准备的 Scala</a></p>

<p><a href="http://twitter.github.io/scala_school/">Twitter Scala school</a></p>

<p><a href="http://www.scala-lang.org/documentation/">The Scala documentation</a></p>

<p><a href="http://scalatutorials.com/tour/">在浏览器尝试 Scala</a></p>

<p>加入 <a href="https://groups.google.com/forum/#!forum/scala-user">Scala 用户组</a></p>

    <hr>
    <p>有建议？或者发现什么错误？在Github上<a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">开一个issue</a>，或者发起<a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/zh-cn/scala-cn.html.markdown">pull request</a>！
    </p>
    <p class="contributed">
    原著George Petrov，并由<a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/zh-cn/scala-cn.html.markdown">2个好心人</a>修改。
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://github.com/petrovg">George Petrov</a>,
        <a href="http://dbousamra.github.com">Dominic Bou-Samra</a>,
        <a href="http://geoffliu.me">Geoff Liu</a>
    </p>

    <p>
      Translated by:
        <a href="">Peiyong Lin</a>
        <a href="http://github.com/alwayswithme">Jinchang Ye</a>
        <a href="https://github.com/jasonqu">Guodong Qu</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>

        <script>
            var _gaq=[['_setAccount','UA-3525624-21'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>
</html>
