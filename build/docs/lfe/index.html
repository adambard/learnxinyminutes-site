<!DOCTYPE html lang="en-us" xml:lang="en-us" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="en-us">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Lisp Flavoured Erlang(LFE) in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/lfe/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Flfe%2F&text=Learn+X+in+Y+minutes%2C+where+X%3DLisp+Flavoured+Erlang%28LFE%29">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="/">Learn X in Y minutes</a></h1>
  <h2>Where X=Lisp Flavoured Erlang(LFE)</h2>
    <p class="filelink">
    Get the code:
    <a href="/docs/files/lispflavourederlang.lfe">lispflavourederlang.lfe</a>
    </p>
  <div id="doc">
    <p>Lisp Flavoured Erlang(LFE) is a functional, concurrent, general-purpose programming 
language and Lisp dialect(Lisp-2) built on top of Core Erlang and the Erlang Virtual Machine(BEAM). </p>

<p>LFE can be obtained from <a href="https://github.com/rvirding/lfe">LFE</a></p>

<p>The classic starting point is <a href="http://docs.lfe.io">LFE DOCS.</a></p>

<p>Another new site is being built to replace it.<a href="http://docs.lfe.io/dev">LFE DEV.</a></p>
<div class="highlight"><pre class="highlight common_lisp"><code>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;;; 0. Syntax</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;;; General form.</span>

<span class="c1">;; Lisp comprises of two syntax called: the ATOM and the S-expression.</span>
<span class="c1">;; `forms` are known as grouped S-expressions.</span>

<span class="mi">8</span>  <span class="c1">; an atom; it evaluates to itself</span>

<span class="ss">:ERLANG</span> <span class="c1">;Atom; evaluates to the symbol :ERLANG.</span>

<span class="no">t</span>  <span class="c1">; another atom which denotes true.</span>

<span class="p">(</span><span class="nb">*</span> <span class="mi">2</span> <span class="mi">21</span><span class="p">)</span> <span class="c1">; an S- expression</span>

<span class="o">'</span><span class="p">(</span><span class="mi">8</span> <span class="ss">:foo</span> <span class="no">t</span><span class="p">)</span>  <span class="c1">;another one</span>


<span class="c1">;;; Comments</span>

<span class="c1">;; Single line comments start with a semicolon; use two for normal</span>
<span class="c1">;; comments, three for section comments, and four fo file-level</span>
<span class="c1">;; comments.</span>

<span class="c1">;; Block Comment</span>

   <span class="cm">#| comment text |#</span>

<span class="c1">;;; Environment</span>

<span class="c1">;; LFE is the de-facto standard.</span>

<span class="c1">;; Libraries can be used directly from the Erlang ecosystem. Rebar3 is the build tool.</span>

<span class="c1">;; LFE is usually developed with a text editor(preferably Emacs) and a REPL</span>
<span class="c1">;; (Read Evaluate Print Loop) running at the same time. The REPL </span>
<span class="c1">;; allows for interactive exploration of the program as it is "live"</span>
<span class="c1">;; in the system.</span>

<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;;; 1. Literals and Special Syntactic Rules</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;;; Integers</span>

<span class="mi">1234</span> <span class="mi">-123</span>           <span class="c1">; Regular decimal notation</span>
<span class="m">#b0</span> <span class="m">#b10101</span>         <span class="c1">; Binary notation</span>
<span class="err">#</span><span class="mi">0</span> <span class="err">#</span><span class="mi">10101</span>           <span class="c1">; Binary notation (alternative form)</span>
<span class="mo">#o377</span> <span class="mo">#o-111</span>        <span class="c1">; Octal notation</span>
<span class="err">#</span><span class="nv">d123456789</span> <span class="err">#</span><span class="nv">d+123</span>  <span class="c1">; Explicitly decimal notation</span>
<span class="m">#xc0ffe</span> <span class="nv">0x-01</span>       <span class="c1">; Hexadecimal notation</span>
<span class="err">#</span><span class="nv">2r1010</span> <span class="err">#</span><span class="nv">8r377</span>      <span class="c1">;Notation with explicit base (up to 36)</span>
<span class="sc">#\a</span> <span class="err">#</span><span class="nv">$</span> <span class="sc">#\√§</span> <span class="sc">#\üê≠</span>     <span class="c1">;Character notation (the value is the Unicode code point of the character)</span>
<span class="sc">#\x1f42d</span><span class="c1">;           ;Character notation with the value in hexadecimal</span>

<span class="c1">;;; Floating point numbers</span>
<span class="mf">1.0</span> <span class="mf">+2.0</span> <span class="mf">-1.5</span> <span class="mf">1.0e10</span> <span class="mf">1.111e-10</span>     

<span class="c1">;;; Strings</span>

<span class="s">"any text between double quotes where \" and other special characters like \n can be escaped"</span><span class="o">.</span>
<span class="c1">; List String</span>
<span class="s">"Cat: \x1f639;"</span> <span class="c1">; writing unicode in string for regular font ending with semicolon.</span>

<span class="ss">#"This is a binary string \n with some \"escaped\" and quoted (\x1f639;) characters"</span>
<span class="c1">; Binary strings are just strings but function different in the VM. </span>
<span class="c1">; Other ways of writing it are:  #B("a"), #"a", and #B(97).</span>


<span class="c1">;;; Character escaping</span>

<span class="nv">\b</span>  <span class="c1">; =&gt; Backspace</span>
<span class="nv">\t</span>  <span class="c1">; =&gt; Tab</span>
<span class="nv">\n</span>  <span class="c1">; =&gt; Newline</span>
<span class="nv">\v</span>  <span class="c1">; =&gt; Vertical tab</span>
<span class="nv">\f</span>  <span class="c1">; =&gt; Form Feed</span>
<span class="nv">\r</span>  <span class="c1">; =&gt; Carriage Return</span>
<span class="nv">\e</span>  <span class="c1">; =&gt; Escape</span>
<span class="nv">\s</span>  <span class="c1">; =&gt; Space</span>
<span class="nv">\d</span>  <span class="c1">; =&gt; Delete</span>

<span class="c1">;;; Binaries</span>
<span class="c1">;; It is used to create binaries with any contents.</span>
<span class="err">#</span><span class="nv">B</span><span class="p">((</span><span class="ss">#"a"</span> <span class="nv">binary</span><span class="p">)</span> <span class="p">(</span><span class="ss">#"b"</span> <span class="nv">binary</span><span class="p">))</span>                <span class="c1">; #"ab" (Evaluated form)</span>

<span class="c1">;;; Lists are: () or (foo bar baz)</span>

<span class="c1">;;; Tuples are written in: #(value1 value2 ...). Empty tuple #() is also valid.</span>

<span class="c1">;;; Maps are written as: #M(key1 value1 key2 value2 ...). Empty map #M() is also valid.</span>

<span class="c1">;;; Symbols: Things that cannot be parsed. Eg: foo, Foo, foo-bar, :foo</span>
<span class="nv">| foo |</span> <span class="c1">; explicit construction of symbol by wrapping vertical bars.</span>

<span class="c1">;;; Evaluation </span>

<span class="c1">;; #.(... some expression ...). E.g. '#.(+ 1 1) will evaluate the (+ 1 1) while it            ;; reads the expression and then be effectively '2.</span>

<span class="c1">;; List comprehension in LFE REPL</span>

<span class="nv">lfe&gt;</span> <span class="p">(</span><span class="nv">list-comp</span>
          <span class="p">((</span><span class="nv">&lt;-</span> <span class="nv">x</span> <span class="o">'</span><span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)))</span>
          <span class="p">(</span><span class="nv">trunc</span> <span class="p">(</span><span class="nv">math:pow</span> <span class="mi">3</span> <span class="nv">x</span><span class="p">)))</span>
       <span class="p">(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">9</span> <span class="mi">27</span><span class="p">)</span>


<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; 2. Core forms</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;; These forms are same as those found at Common Lisp and Scheme.</span>

<span class="p">(</span><span class="k">quote</span> <span class="nv">e</span><span class="p">)</span>
<span class="p">(</span><span class="nb">cons</span> <span class="nv">head</span> <span class="nv">tail</span><span class="p">)</span>
<span class="p">(</span><span class="nb">car</span> <span class="nv">e</span><span class="p">)</span>
<span class="p">(</span><span class="nb">cdr</span> <span class="nv">e</span><span class="p">)</span>
<span class="p">(</span><span class="nb">list</span> <span class="nv">e</span> <span class="o">...</span> <span class="p">)</span>
<span class="p">(</span><span class="nv">tuple</span> <span class="nv">e</span> <span class="o">...</span> <span class="p">)</span>
<span class="p">(</span><span class="nv">binary</span> <span class="nv">seg</span> <span class="o">...</span> <span class="p">)</span>
<span class="p">(</span><span class="nb">map</span> <span class="nv">key</span> <span class="nv">val</span> <span class="o">...</span><span class="p">)</span><span class="o">,</span> <span class="p">(</span><span class="nv">map-get</span> <span class="nv">m</span> <span class="nv">k</span><span class="p">)</span><span class="o">,</span> <span class="p">(</span><span class="nv">map-set</span> <span class="nv">m</span> <span class="nv">k</span> <span class="nv">v</span> <span class="o">...</span><span class="p">)</span><span class="o">,</span> <span class="p">(</span><span class="nv">map-update</span> <span class="nv">m</span> <span class="nv">k</span> <span class="nv">v</span> <span class="o">...</span><span class="p">)</span>

<span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">arg</span> <span class="o">...</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">match-lambda</span>
    <span class="p">((</span><span class="nv">arg</span> <span class="o">...</span> <span class="p">)</span> <span class="nv">{{</span><span class="p">(</span><span class="nb">when</span> <span class="nv">e</span> <span class="o">...</span><span class="p">)</span><span class="nv">}}</span> <span class="o">...</span><span class="p">)</span> <span class="c1">; Matches clauses</span>
    <span class="o">...</span> <span class="p">)</span>
<span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">pat</span> <span class="nv">{{</span><span class="p">(</span><span class="nb">when</span> <span class="nv">e</span> <span class="o">...</span><span class="p">)</span><span class="nv">}}</span> <span class="nv">e</span><span class="p">)</span>
      <span class="o">...</span><span class="p">)</span>
  <span class="o">...</span> <span class="p">)</span>
<span class="p">(</span><span class="nv">let-function</span> <span class="p">((</span><span class="nv">name</span> <span class="k">lambda</span><span class="nv">|match-lambda) ; Only define local
               ... )                      ; functions
  ... )
(letrec-function ((name lambda|match-lambda</span><span class="p">)</span> <span class="c1">; Only define local</span>
                  <span class="o">...</span> <span class="p">)</span>                      <span class="c1">; functions</span>
  <span class="o">...</span> <span class="p">)</span>
<span class="p">(</span><span class="nv">let-macro</span> <span class="p">((</span><span class="nv">name</span> <span class="nv">lambda-match-lambda</span><span class="p">)</span> <span class="c1">; Only define local</span>
            <span class="o">...</span><span class="p">)</span>                       <span class="c1">; macros</span>
  <span class="o">...</span><span class="p">)</span>
<span class="p">(</span><span class="k">progn</span> <span class="o">...</span> <span class="p">)</span>
<span class="p">(</span><span class="k">if</span> <span class="nv">test</span> <span class="nv">true-expr</span> <span class="nv">{{false-expr}}</span><span class="p">)</span>
<span class="p">(</span><span class="nb">case</span> <span class="nv">e</span>
  <span class="p">(</span><span class="nv">pat</span> <span class="nv">{{</span><span class="p">(</span><span class="nb">when</span> <span class="nv">e</span> <span class="o">...</span><span class="p">)</span><span class="nv">}}</span> <span class="o">...</span><span class="p">)</span>
   <span class="o">...</span> <span class="p">)</span><span class="err">)</span>
<span class="p">(</span><span class="nv">receive</span>
  <span class="p">(</span><span class="nv">pat</span> <span class="nv">{{</span><span class="p">(</span><span class="nb">when</span> <span class="nv">e</span> <span class="o">...</span><span class="p">)</span><span class="nv">}}</span> <span class="o">...</span> <span class="p">)</span>
  <span class="o">...</span>
  <span class="p">(</span><span class="nv">after</span> <span class="nv">timeout</span> <span class="o">...</span> <span class="p">))</span>
<span class="p">(</span><span class="k">catch</span> <span class="o">...</span> <span class="p">)</span>
<span class="p">(</span><span class="nv">try</span>
  <span class="nv">e</span>
  <span class="nv">{{</span><span class="p">(</span><span class="nb">case</span> <span class="p">((</span><span class="nv">pat</span> <span class="nv">{{</span><span class="p">(</span><span class="nb">when</span> <span class="nv">e</span> <span class="o">...</span><span class="p">)</span><span class="nv">}}</span> <span class="o">...</span> <span class="p">)</span>
          <span class="o">...</span> <span class="p">))</span><span class="nv">}}</span>
  <span class="nv">{{</span><span class="p">(</span><span class="k">catch</span>
     <span class="c1">; Next must be tuple of length 3!</span>
     <span class="p">(((</span><span class="nv">tuple</span> <span class="k">type</span> <span class="nv">value</span> <span class="k">ignore</span><span class="p">)</span> <span class="nv">{{</span><span class="p">(</span><span class="nb">when</span> <span class="nv">e</span> <span class="o">...</span><span class="p">)</span><span class="nv">}}</span>
      <span class="o">...</span> <span class="p">)</span>
     <span class="o">...</span> <span class="p">)</span><span class="nv">}}</span>
  <span class="nv">{{</span><span class="p">(</span><span class="nv">after</span> <span class="o">...</span> <span class="p">)</span><span class="nv">}}</span><span class="p">)</span>

<span class="p">(</span><span class="nb">funcall</span> <span class="nv">func</span> <span class="nv">arg</span> <span class="o">...</span> <span class="p">)</span>
<span class="p">(</span><span class="nv">call</span> <span class="nb">mod</span> <span class="nv">func</span> <span class="nv">arg</span> <span class="o">...</span> <span class="p">)</span> <span class="nb">-</span> <span class="nv">Call</span> <span class="nv">to</span> <span class="nv">Erlang</span> <span class="nv">Mod:Func</span><span class="p">(</span><span class="nv">Arg,</span> <span class="o">...</span> <span class="p">)</span>
<span class="p">(</span><span class="nv">define-module</span> <span class="nv">name</span> <span class="nv">declaration</span> <span class="o">...</span> <span class="p">)</span>
<span class="p">(</span><span class="nv">extend-module</span> <span class="nv">declaration</span> <span class="o">...</span> <span class="p">)</span> <span class="nb">-</span> <span class="nv">Define/extend</span> <span class="nv">module</span> <span class="nb">and</span> <span class="nv">declarations.</span>
<span class="p">(</span><span class="nv">define-function</span> <span class="nv">name</span> <span class="k">lambda</span><span class="nv">|match-lambda)
(define-macro name lambda|match-lambda</span><span class="p">)</span> <span class="nb">-</span> <span class="nv">Define</span> <span class="nv">functions/macros</span> <span class="nv">at</span> <span class="nv">top-level.</span>

<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; 3. Macros</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;; Macros are part of the language to allow you to create abstractions </span>
<span class="c1">;; on top of the core language and standard library that move you closer </span>
<span class="c1">;; toward being able to directly express the things you want to express.</span>

<span class="c1">;; Top-level function</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">name</span> <span class="p">(</span><span class="nv">arg</span> <span class="o">...</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>

<span class="c1">;; Adding comments in functions</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">name</span>
  <span class="s">"Toplevel function with pattern-matching arguments"</span>
  <span class="p">((</span><span class="nv">argpat</span> <span class="o">...</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
  <span class="o">...</span><span class="p">)</span>

<span class="c1">;; Top-level macro</span>

<span class="p">(</span><span class="nb">defmacro</span> <span class="nv">name</span> <span class="p">(</span><span class="nv">arg</span> <span class="o">...</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
<span class="p">(</span><span class="nb">defmacro</span> <span class="nv">name</span> <span class="nv">arg</span> <span class="o">...</span><span class="p">)</span>

<span class="c1">;; Top-level macro with pattern matching arguments</span>

<span class="p">(</span><span class="nb">defmacro</span> <span class="nv">name</span>
  <span class="p">((</span><span class="nv">argpat</span> <span class="o">...</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
  <span class="o">...</span><span class="p">)</span>

<span class="c1">;; Top-level macro using Scheme inspired syntax-rules format </span>

<span class="p">(</span><span class="nv">defsyntax</span> <span class="nv">name</span>
  <span class="p">(</span><span class="nv">pat</span> <span class="nb">exp</span><span class="p">)</span>
  <span class="o">...</span><span class="p">)</span>

<span class="c1">;;; Local macros in macro or syntax-rule format</span>

<span class="p">(</span><span class="k">macrolet</span> <span class="p">((</span><span class="nv">name</span> <span class="p">(</span><span class="nv">arg</span> <span class="o">...</span> <span class="p">)</span> <span class="o">...</span> <span class="p">)</span>
            <span class="o">...</span> <span class="p">)</span>
    <span class="o">...</span> <span class="p">)</span>

<span class="p">(</span><span class="nv">syntaxlet</span> <span class="p">((</span><span class="nv">name</span> <span class="p">(</span><span class="nv">pat</span> <span class="nb">exp</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
             <span class="o">...</span><span class="p">)</span>
 <span class="o">...</span><span class="p">)</span>

<span class="c1">;; Like CLISP</span>

<span class="p">(</span><span class="nb">prog1</span> <span class="o">...</span><span class="p">)</span>
<span class="p">(</span><span class="nb">prog2</span> <span class="o">...</span><span class="p">)</span>

<span class="c1">;; Erlang LFE module</span>

<span class="p">(</span><span class="nv">defmodule</span> <span class="nv">name</span> <span class="o">...</span><span class="p">)</span>

<span class="c1">;; Erlang LFE record</span>

<span class="p">(</span><span class="nv">defrecord</span> <span class="nv">name</span> <span class="o">...</span><span class="p">)</span>

<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; 4. Patterns and Guards</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;; Using patterns in LFE compared to that of Erlang</span>

<span class="c1">;; Erlang                     ;; LFE</span>
<span class="c1">;; {ok, X}                       (tuple 'ok x)</span>
<span class="c1">;; error                         'error</span>
<span class="c1">;; {yes, [X|Xs]}                 (tuple 'yes (cons x xs))</span>
<span class="c1">;; &lt;&lt;34,F/float&gt;&gt;                (binary 34 (f float))</span>
<span class="c1">;; [P|Ps]=All                    (= (cons p ps) all)</span>

  <span class="nv">_</span>    <span class="c1">; =&gt; is don't care while pattern matching</span>

  <span class="p">(</span><span class="nb">=</span> <span class="nv">pattern1</span> <span class="nv">pattern2</span><span class="p">)</span>     <span class="c1">; =&gt; easier, better version of pattern matching</span>

<span class="c1">;; Guards</span>

<span class="c1">;; Whenever pattern occurs(let, case, receive, lc, etc) it can be followed by an optional</span>
<span class="c1">;; guard which has the form (when test ...).</span>

<span class="p">(</span><span class="k">progn</span> <span class="nv">gtest</span> <span class="o">...</span><span class="p">)</span>             <span class="c1">;; =&gt; Sequence of guard tests</span>
<span class="p">(</span><span class="k">if</span> <span class="nv">gexpr</span> <span class="nv">gexpr</span> <span class="nv">gexpr</span><span class="p">)</span>
<span class="p">(</span><span class="nv">type-test</span> <span class="nv">e</span><span class="p">)</span>
<span class="p">(</span><span class="nv">guard-bif</span> <span class="o">...</span><span class="p">)</span>               <span class="c1">;; =&gt; Guard BIFs, arithmetic, boolean and comparison operators</span>

<span class="c1">;;; REPL</span>

<span class="nv">lfe&gt;</span><span class="p">(</span><span class="nb">set</span> <span class="p">(</span><span class="nv">tuple</span> <span class="nv">len</span> <span class="nv">status</span> <span class="nv">msg</span><span class="p">)</span> <span class="o">#(</span><span class="mi">8</span> <span class="nv">ok</span> <span class="s">"Trillian"</span><span class="p">))</span>
    <span class="o">#(</span><span class="mi">8</span> <span class="nv">ok</span> <span class="s">"Trillian"</span><span class="p">)</span>
<span class="nv">lfe&gt;msg</span>
    <span class="s">"Trillian"</span>

<span class="c1">;;; Program illustrating use of Guards</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">right-number?</span>
        <span class="p">((</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nv">orelse</span> <span class="p">(</span><span class="nv">==</span> <span class="nv">x</span> <span class="mi">42</span><span class="p">)</span> <span class="p">(</span><span class="nv">==</span> <span class="nv">x</span> <span class="mi">276709</span><span class="p">)))</span>
          <span class="ss">'true</span><span class="p">)</span>
        <span class="p">((</span><span class="nv">_</span><span class="p">)</span> <span class="ss">'false</span><span class="p">))</span>

<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; 5. Functions</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;; A simple function using if.</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nb">max</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="s">"The max function."</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&gt;=</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>

<span class="c1">;; Same function using more clause</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nb">max</span>
  <span class="s">"The max function."</span>
  <span class="p">((</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nb">&gt;=</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">((</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">y</span><span class="p">))</span>

<span class="c1">;; Same function using similar style but using local functions defined by flet or fletrec</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">foo</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="s">"The max function."</span>
  <span class="p">(</span><span class="k">flet</span> <span class="p">((</span><span class="nv">m</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="s">"Local comment."</span>
            <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&gt;=</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">m</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>

<span class="c1">;; LFE being Lisp-2 has separate namespaces for variables and functions</span>
<span class="c1">;; Both variables and function/macros are lexically scoped.</span>
<span class="c1">;; Variables are bound by lambda, match-lambda and let.</span>
<span class="c1">;; Functions are bound by top-level defun, flet and fletrec.</span>
<span class="c1">;; Macros are bound by top-level defmacro/defsyntax and by macrolet/syntaxlet.</span>

<span class="c1">;; (funcall func arg ...) like CL to call lambdas/match-lambdas </span>
<span class="c1">;; (funs) bound to variables are used.</span>

<span class="c1">;; separate bindings and special for apply.</span>
<span class="nb">apply</span> <span class="nv">_F</span> <span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="o">,</span> 
<span class="nb">apply</span> <span class="nv">_F/3</span> <span class="p">(</span> <span class="nv">a1,</span> <span class="nv">a2,</span> <span class="nv">a3</span> <span class="p">)</span>

<span class="c1">;; Cons'ing in function heads</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">sum</span> <span class="p">(</span><span class="nv">l</span><span class="p">)</span> <span class="p">(</span><span class="nv">sum</span> <span class="nv">l</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">defun</span> <span class="nv">sum</span>
    <span class="p">((</span><span class="o">'</span><span class="p">()</span> <span class="nv">total</span><span class="p">)</span> <span class="nv">total</span><span class="p">)</span>
    <span class="p">(((</span><span class="nb">cons</span> <span class="nv">h</span> <span class="no">t</span><span class="p">)</span> <span class="nv">total</span><span class="p">)</span> <span class="p">(</span><span class="nv">sum</span> <span class="no">t</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">h</span> <span class="nv">total</span><span class="p">))))</span>

<span class="c1">;; ``cons`` literal instead of constructor form</span>
      <span class="p">(</span><span class="nb">defun</span> <span class="nv">sum</span> <span class="p">(</span><span class="nv">l</span><span class="p">)</span> <span class="p">(</span><span class="nv">sum</span> <span class="nv">l</span> <span class="mi">0</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">defun</span> <span class="nv">sum</span>
        <span class="p">((</span><span class="o">'</span><span class="p">()</span> <span class="nv">total</span><span class="p">)</span> <span class="nv">total</span><span class="p">)</span>
        <span class="p">((</span><span class="o">`</span><span class="p">(</span><span class="o">,</span><span class="nv">h</span> <span class="o">.</span> <span class="o">,</span><span class="no">t</span><span class="p">)</span> <span class="nv">total</span><span class="p">)</span> <span class="p">(</span><span class="nv">sum</span> <span class="no">t</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">h</span> <span class="nv">total</span><span class="p">))))</span>

<span class="c1">;; Matching records in function heads</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">handle_info</span>
  <span class="p">((</span><span class="ss">'ping</span> <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nv">match-state</span> <span class="nv">remote-pid</span> <span class="ss">'undefined</span><span class="p">)</span> <span class="nv">state</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">gen_server:cast</span> <span class="p">(</span><span class="nv">self</span><span class="p">)</span> <span class="ss">'ping</span><span class="p">)</span>
    <span class="o">`#(</span><span class="nv">noreply</span> <span class="o">,</span><span class="nv">state</span><span class="p">))</span>
  <span class="p">((</span><span class="ss">'ping</span> <span class="nv">state</span><span class="p">)</span>
   <span class="o">`#(</span><span class="nv">noreply</span> <span class="o">,</span><span class="nv">state</span><span class="p">)))</span>

<span class="c1">;; Receiving Messages</span>
      <span class="p">(</span><span class="nb">defun</span> <span class="nv">universal-server</span> <span class="p">()</span>
        <span class="p">(</span><span class="nv">receive</span>
          <span class="p">((</span><span class="nv">tuple</span> <span class="ss">'become</span> <span class="nv">func</span><span class="p">)</span>
           <span class="p">(</span><span class="nb">funcall</span> <span class="nv">func</span><span class="p">))))</span>

<span class="c1">;; another way for receiving messages</span>

 <span class="p">(</span><span class="nb">defun</span> <span class="nv">universal-server</span> <span class="p">()</span>
        <span class="p">(</span><span class="nv">receive</span>
          <span class="p">(</span><span class="o">`#(</span><span class="nv">become</span> <span class="o">,</span><span class="nv">func</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">funcall</span> <span class="nv">func</span><span class="p">))))</span>

<span class="c1">;; Composing a complete function for specific tasks</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">compose</span> <span class="p">(</span><span class="nv">f</span> <span class="nv">g</span><span class="p">)</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">funcall</span> <span class="nv">f</span>
     <span class="p">(</span><span class="nb">funcall</span> <span class="nv">g</span> <span class="nv">x</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">check</span> <span class="p">()</span>
  <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">sin-asin</span> <span class="p">(</span><span class="nv">compose</span> <span class="nf">#'</span><span class="nv">sin/1</span> <span class="nf">#'</span><span class="nv">asin/1</span><span class="p">))</span>
         <span class="p">(</span><span class="nv">expected</span> <span class="p">(</span><span class="nb">sin</span> <span class="p">(</span><span class="nb">asin</span> <span class="mf">0.5</span><span class="p">)))</span>
         <span class="p">(</span><span class="nv">compose-result</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nv">sin-asin</span> <span class="mf">0.5</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">io:format</span> <span class="s">"Expected answer: ~p~n"</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">expected</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">io:format</span> <span class="s">"Answer with compose: ~p~n"</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">compose-result</span><span class="p">))))</span>


<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; 6. Concurrency</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;; Message passing as done by Erlang's light-weight "processes".</span>

<span class="p">(</span><span class="nv">defmodule</span> <span class="nv">messenger-back</span>
 <span class="p">(</span><span class="nb">export</span> <span class="p">(</span><span class="nv">print-result</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nv">send-message</span> <span class="mi">2</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">print-result</span> <span class="p">()</span>
  <span class="p">(</span><span class="nv">receive</span>
    <span class="p">((</span><span class="nv">tuple</span> <span class="nv">pid</span> <span class="nv">msg</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">io:format</span> <span class="s">"Received message: '~s'~n"</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">msg</span><span class="p">))</span>
      <span class="p">(</span><span class="nv">io:format</span> <span class="s">"Sending message to process ~p ...~n"</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">pid</span><span class="p">))</span>
      <span class="p">(</span><span class="nv">!</span> <span class="nv">pid</span> <span class="p">(</span><span class="nv">tuple</span> <span class="nv">msg</span><span class="p">))</span>
      <span class="p">(</span><span class="nv">print-result</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">send-message</span> <span class="p">(</span><span class="nv">calling-pid</span> <span class="nv">msg</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">spawned-pid</span> <span class="p">(</span><span class="nv">spawn</span> <span class="ss">'messenger-back</span> <span class="ss">'print-result</span> <span class="p">())))</span>
    <span class="p">(</span><span class="nv">!</span> <span class="nv">spawned-pid</span> <span class="p">(</span><span class="nv">tuple</span> <span class="nv">calling-pid</span> <span class="nv">msg</span><span class="p">))))</span>

<span class="c1">;; Multiple simultaneous HTTP Requests:</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">parse-args</span> <span class="p">(</span><span class="nv">flag</span><span class="p">)</span>
  <span class="s">"Given one or more command-line arguments, extract the passed values.

  For example, if the following was passed via the command line:

    $ erl -my-flag my-value-1 -my-flag my-value-2

  One could then extract it in an LFE program by calling this function:

    (let ((args (parse-args 'my-flag)))
      ...
      )
  In this example, the value assigned to the arg variable would be a list
  containing the values my-value-1 and my-value-2."</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="o">`#(</span><span class="nv">ok</span> <span class="o">,</span><span class="nv">data</span><span class="p">)</span> <span class="p">(</span><span class="nv">init:get_argument</span> <span class="nv">flag</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">lists:merge</span> <span class="nv">data</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">get-pages</span> <span class="p">()</span>
  <span class="s">"With no argument, assume 'url parameter was passed via command line."</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">urls</span> <span class="p">(</span><span class="nv">parse-args</span> <span class="ss">'url</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">get-pages</span> <span class="nv">urls</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">get-pages</span> <span class="p">(</span><span class="nv">urls</span><span class="p">)</span>
  <span class="s">"Start inets and make (potentially many) HTTP requests."</span>
  <span class="p">(</span><span class="nv">inets:start</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">plists:map</span>
    <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">get-page</span> <span class="nv">x</span><span class="p">))</span> <span class="nv">urls</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">get-page</span> <span class="p">(</span><span class="nv">url</span><span class="p">)</span>
  <span class="s">"Make a single HTTP request."</span>
  <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nc">method</span> <span class="ss">'get</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">headers</span> <span class="o">'</span><span class="p">())</span>
         <span class="p">(</span><span class="nv">request-data</span> <span class="o">`#(,</span><span class="nv">url</span> <span class="o">,</span><span class="nv">headers</span><span class="p">))</span>
         <span class="p">(</span><span class="nv">http-options</span> <span class="p">())</span>
         <span class="p">(</span><span class="nv">request-options</span> <span class="o">'</span><span class="p">(</span><span class="o">#(</span><span class="nv">sync</span> <span class="nv">false</span><span class="p">))))</span>
    <span class="p">(</span><span class="nv">httpc:request</span> <span class="nc">method</span> <span class="nv">request-data</span> <span class="nv">http-options</span> <span class="nv">request-options</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">receive</span>
      <span class="p">(</span><span class="o">`#(</span><span class="nv">http</span> <span class="o">#(,</span><span class="nv">request-id</span> <span class="o">#(</span><span class="nb">error</span> <span class="o">,</span><span class="nv">reason</span><span class="p">)))</span>
       <span class="p">(</span><span class="nv">io:format</span> <span class="s">"Error: ~p~n"</span> <span class="o">`</span><span class="p">(</span><span class="o">,</span><span class="nv">reason</span><span class="p">)))</span>
      <span class="p">(</span><span class="o">`#(</span><span class="nv">http</span> <span class="o">#(,</span><span class="nv">request-id</span> <span class="o">,</span><span class="nv">result</span><span class="p">))</span>
       <span class="p">(</span><span class="nv">io:format</span> <span class="s">"Result: ~p~n"</span> <span class="o">`</span><span class="p">(</span><span class="o">,</span><span class="nv">result</span><span class="p">))))))</span>


<span class="c1">;; Check out Erlang's documentation for more concurrency and OTP docs.</span>
</code></pre></div>
<h2>Further Reading</h2>

<ul>
<li>   <a href="http://docs.lfe.io">LFE DOCS</a></li>
<li>   <a href="https://lfe.gitbooks.io/reference-guide/index.html">LFE GitBook</a></li>
<li>   <a href="https://en.wikipedia.org/wiki/LFE_(programming_language)">LFE Wiki</a></li>
</ul>

<h2>Extra Info</h2>

<ul>
<li>   <a href="http://www.erlang-factory.com/upload/presentations/61/Robertvirding-LispFlavouredErlang.pdf">LFE PDF</a></li>
<li>   <a href="https://groups.google.com/d/msg/lisp-flavoured-erlang/XA5HeLbQQDk/TUHabZCHXB0J">LFE mail</a></li>
</ul>

<h2>Credits</h2>

<p>Lots of thanks to Robert Virding for creating LFE, Duncan McGreggor for documenting it and other LFE contributors who made LFE awesome.</p>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/lfe.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by Pratik Karki, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/lfe.html.markdown">0 contributor(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="https://github.com/prertik">Pratik Karki</a>
    </p>

    <p>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>

        <script>
            var _gaq=[['_setAccount','UA-3525624-21'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>
</html>
