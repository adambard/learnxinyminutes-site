<!DOCTYPE html lang="uk-ua" xml:lang="uk-ua" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="uk-ua">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn javascript in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/uk-ua/javascript-ua/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fuk-ua%2Fjavascript-ua%2F&text=Learn+X+in+Y+minutes%2C+where+X%3Djavascript">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="/">Learn X in Y minutes</a></h1>
  <h2>Where X=javascript</h2>
    <p class="filelink">
    Get the code:
    <a href="/docs/files/javascript-uk.js">javascript-uk.js</a>
    </p>
  <div id="doc">
    <p>JavaScript було створено в 1995 році Бренданом Айком, який працював у компанії Netscape.
Він був задуманий як проста мова сценаріїв для веб-сайтів, який би доповнював Java
для більш складних веб-застосунків. Але тісна інтеграція з веб-сторінками і
вбудована підтримка браузерами призвела до того, що JavaScript став популярніший
за власне Java.</p>

<p>Зараз JavaScript не обмежується тільки веб-браузером. Наприклад, Node.js,
програмна платформа, що дозволяє виконувати JavaScript код з використанням
рушія V8 від браузера Google Chrome, стає все більш і більш популярною.</p>
<div class="highlight"><pre class="highlight javascript"><code><span class="c1">// С-подібні коментарі. Однорядкові коментарі починаються з двох символів /(слеш)</span>
<span class="cm">/* а багаторядкові коментарі починаються з послідовності слеша та зірочки і
   закінчуються символами зірочка-слеш */</span>

<span class="c1">//Інструкції можуть закінчуватися крапкою з комою ;</span>
<span class="nx">doStuff</span><span class="p">();</span>

<span class="c1">// ... але не обов’язково, тому що крапка з комою автоматично вставляється на</span>
<span class="c1">// місці символу нового рядка, крім деяких випадків.</span>
<span class="nx">doStuff</span><span class="p">()</span>

<span class="c1">// Ми завжди будемо використовувати крапку з комою в цьому посібнику, тому що ці</span>
<span class="c1">// винятки можуть призвести до неочікуваних результатів</span>

<span class="c1">///////////////////////////////////</span>
<span class="c1">// 1. Числа, Рядки і Оператори</span>

<span class="c1">// В JavaScript числа зберігаються тільки в одному форматі (64-bit IEEE 754 double)</span>
<span class="c1">// Цей тип має 52-бітну мантису, якої достатньо для збереження чисел з</span>
<span class="c1">// точністю до 9✕10¹⁵.</span>
<span class="mi">3</span><span class="p">;</span> <span class="c1">// = 3</span>
<span class="mf">1.5</span><span class="p">;</span> <span class="c1">// = 1.5</span>

<span class="c1">// Деякі прості арифметичні операції працюють так, як ми очікуємо.</span>
<span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// = 2</span>
<span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.2</span><span class="p">;</span> <span class="c1">// = 0.30000000000000004 (а деякі - ні)</span>
<span class="mi">8</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// = 7</span>
<span class="mi">10</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// = 20</span>
<span class="mi">35</span> <span class="o">/</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// = 7</span>

<span class="c1">// В тому числі ділення з остачею</span>
<span class="mi">5</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// = 2.5</span>

<span class="c1">// В JavaScript є побітові операції; коли ви виконуєте таку операцію,</span>
<span class="c1">// число з плаваючою точкою переводиться в ціле зі знаком</span>
<span class="c1">// довжиною *до* 32 розрядів.</span>
<span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// = 4</span>

<span class="c1">// Пріоритет у виразах можна задати явно круглими дужками</span>
<span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// = 8</span>

<span class="c1">// Є три спеціальні значення, які не є реальними числами:</span>
<span class="kc">Infinity</span><span class="p">;</span> <span class="c1">// "нескінченність", наприклад, як результат ділення на 0</span>
<span class="o">-</span><span class="kc">Infinity</span><span class="p">;</span> <span class="c1">// "мінус нескінченність", як результат ділення від’ємного числа на 0</span>
<span class="kc">NaN</span><span class="p">;</span> <span class="c1">// "не число", наприклад, ділення 0/0</span>

<span class="c1">// Логічні типи</span>
<span class="kc">true</span><span class="p">;</span>
<span class="kc">false</span><span class="p">;</span>

<span class="c1">// Рядки створюються за допомогою подвійних та одинарних лапок</span>
<span class="dl">'</span><span class="s1">абв</span><span class="dl">'</span><span class="p">;</span>
<span class="dl">"</span><span class="s2">Привіт, світе!</span><span class="dl">"</span><span class="p">;</span>

<span class="c1">// Для логічного заперечення використовується знак оклику.</span>
<span class="o">!</span><span class="kc">true</span><span class="p">;</span> <span class="c1">// = false</span>
<span class="o">!</span><span class="kc">false</span><span class="p">;</span> <span class="c1">// = true</span>

<span class="c1">// Строга рівність ===</span>
<span class="mi">1</span> <span class="o">===</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// = true</span>
<span class="mi">2</span> <span class="o">===</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// = false</span>

<span class="c1">// Строга нерівність !==</span>
<span class="mi">1</span> <span class="o">!==</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// = false</span>
<span class="mi">2</span> <span class="o">!==</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// = true</span>

<span class="c1">// Інші оператори порівняння</span>
<span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// = true</span>
<span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// = false</span>
<span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// = true</span>
<span class="mi">2</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// = true</span>

<span class="c1">// Рядки об’єднуються за допомогою оператора +</span>
<span class="dl">"</span><span class="s2">hello, </span><span class="dl">"</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">world!</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// = "hello, world!"</span>

<span class="c1">// І порівнюються за допомогою &gt; та &lt;</span>
<span class="dl">"</span><span class="s2">a</span><span class="dl">"</span> <span class="o">&lt;</span> <span class="dl">"</span><span class="s2">b</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// = true</span>

<span class="c1">// Перевірка на рівність з приведнням типів здійснюється оператором ==</span>
<span class="dl">"</span><span class="s2">5</span><span class="dl">"</span> <span class="o">==</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// = true</span>
<span class="kc">null</span> <span class="o">==</span> <span class="kc">undefined</span><span class="p">;</span> <span class="c1">// = true</span>

<span class="c1">// ... але приведення не виконується при ===</span>
<span class="dl">"</span><span class="s2">5</span><span class="dl">"</span> <span class="o">===</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// = false</span>
<span class="kc">null</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">;</span> <span class="c1">// = false</span>

<span class="c1">// ... приведення типів може призвести до дивних результатів</span>
<span class="mi">13</span> <span class="o">+</span> <span class="o">!</span><span class="mi">0</span><span class="p">;</span> <span class="c1">// 14</span>
<span class="dl">"</span><span class="s2">13</span><span class="dl">"</span> <span class="o">+</span> <span class="o">!</span><span class="mi">0</span><span class="p">;</span> <span class="c1">// '13true'</span>

<span class="c1">// Можна отримати доступ до будь-якого символа рядка за допомгою charAt</span>
<span class="dl">"</span><span class="s2">Це рядок</span><span class="dl">"</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  <span class="c1">// = 'Ц'</span>

<span class="c1">// ... або використати метод substring, щоб отримати більший кусок</span>
<span class="dl">"</span><span class="s2">Hello, world</span><span class="dl">"</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// = "Hello"</span>

<span class="c1">// length - це не метод, а поле</span>
<span class="dl">"</span><span class="s2">Hello</span><span class="dl">"</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="c1">// = 5</span>

<span class="c1">// Типи null и undefined</span>
<span class="kc">null</span><span class="p">;</span> <span class="c1">// навмисна відсутність результату</span>
<span class="kc">undefined</span><span class="p">;</span> <span class="c1">// використовується для позначення відсутності присвоєного значення</span>

<span class="c1">// false, null, undefined, NaN, 0 та "" — хиба; все інше - істина.</span>
<span class="c1">// Потрібно відмітити, що 0 — це хиба, а "0" — істина, не зважаючи на те що:</span>
<span class="c1">// 0 == "0".</span>

<span class="c1">///////////////////////////////////</span>
<span class="c1">// 2. Змінні, Масиви, Об’єкти</span>

<span class="c1">// Змінні оголошуються за допомогою ключового слова var. JavaScript — мова з</span>
<span class="c1">// динамічною типізацією, тому не потрібно явно вказувати тип. Для присвоєння</span>
<span class="c1">// значення змінної використовується символ =</span>
<span class="kd">var</span> <span class="nx">someVar</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

<span class="c1">// якщо пропустити слово var, ви не отримаєте повідомлення про помилку, ...</span>
<span class="nx">someOtherVar</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

<span class="c1">// ... але вашу змінну буде створено в глобальному контексті, а не там, де</span>
<span class="c1">// ви її оголосили</span>

<span class="c1">// Змінні, які оголошені без присвоєння, автоматично приймають значення undefined</span>
<span class="kd">var</span> <span class="nx">someThirdVar</span><span class="p">;</span> <span class="c1">// = undefined</span>

<span class="c1">// У математичних операцій є скорочені форми:</span>
<span class="nx">someVar</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// як someVar = someVar + 5;</span>
<span class="nx">someVar</span> <span class="o">*=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// тепер someVar = 100</span>

<span class="c1">// Інкремент і декремент</span>
<span class="nx">someVar</span><span class="o">++</span><span class="p">;</span> <span class="c1">// тепер someVar дорівнює 101</span>
<span class="nx">someVar</span><span class="o">--</span><span class="p">;</span> <span class="c1">// а зараз 100</span>

<span class="c1">// Масиви — це нумеровані списки, які зберігають значення будь-якого типу.</span>
<span class="kd">var</span> <span class="nx">myArray</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">Привіт</span><span class="dl">"</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="kc">true</span><span class="p">];</span>

<span class="c1">// Доступ до елементів можна отримати за допомогою синтаксиса з квадратними дужками</span>
<span class="c1">// Індексація починається з нуля</span>
<span class="nx">myArray</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// = 45</span>

<span class="c1">// Масиви в JavaScript змінюють свою довжину при додаванні нових елементів</span>
<span class="nx">myArray</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="dl">"</span><span class="s2">Привіт</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">myArray</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="c1">// = 4</span>

<span class="c1">// Додавання і редагування елементів</span>
<span class="nx">myArray</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">світ</span><span class="dl">"</span><span class="p">;</span>

<span class="c1">// Об’єкти в JavaScript схожі на словники або асоціативні масиви в інших мовах</span>
<span class="kd">var</span> <span class="nx">myObj</span> <span class="o">=</span> <span class="p">{</span><span class="na">key1</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Hello</span><span class="dl">"</span><span class="p">,</span> <span class="na">key2</span><span class="p">:</span> <span class="dl">"</span><span class="s2">World</span><span class="dl">"</span><span class="p">};</span>

<span class="c1">// Ключі - це рядки, але лапки не обов’язкові, якщо ключ задовольняє</span>
<span class="c1">// правилам формування назв змінних. Значення можуть бути будь-яких типів.</span>
<span class="kd">var</span> <span class="nx">myObj</span> <span class="o">=</span> <span class="p">{</span><span class="na">myKey</span><span class="p">:</span> <span class="dl">"</span><span class="s2">myValue</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">my other key</span><span class="dl">"</span><span class="p">:</span> <span class="mi">4</span><span class="p">};</span>

<span class="c1">// Атрибути можна отримати використовуючи квадратні дужки</span>
<span class="nx">myObj</span><span class="p">[</span><span class="dl">"</span><span class="s2">my other key</span><span class="dl">"</span><span class="p">];</span> <span class="c1">// = 4</span>

<span class="c1">// Або через точку, якщо ключ є правильним ідентифікатором</span>
<span class="nx">myObj</span><span class="p">.</span><span class="nx">myKey</span><span class="p">;</span> <span class="c1">// = "myValue"</span>

<span class="c1">// Об’єкти можна динамічно змінювати й додавати нові поля</span>
<span class="nx">myObj</span><span class="p">.</span><span class="nx">myThirdKey</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>

<span class="c1">// Коли ви звертаєтесь до поля, що не існує, ви отримуєте значення undefined</span>
<span class="nx">myObj</span><span class="p">.</span><span class="nx">myFourthKey</span><span class="p">;</span> <span class="c1">// = undefined</span>

<span class="c1">///////////////////////////////////</span>
<span class="c1">// 3. Керуючі конструкції</span>

<span class="c1">// Синтаксис для цього розділу майже такий самий, як у Java</span>

<span class="c1">// Умовна конструкція</span>
<span class="kd">var</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">count</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// виконується, якщо count дорівнює 3</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">count</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ..</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// ...  цикл while.</span>
<span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">){</span>
    <span class="c1">// Нескінченний цикл!</span>
<span class="p">}</span>

<span class="c1">// Цикл do-while такий самий, як while, але завжди виконується принаймні один раз.</span>
<span class="kd">var</span> <span class="nx">input</span>
<span class="k">do</span> <span class="p">{</span>
    <span class="nx">input</span> <span class="o">=</span> <span class="nx">getInput</span><span class="p">();</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nx">isValid</span><span class="p">(</span><span class="nx">input</span><span class="p">))</span>

<span class="c1">// цикл for такий самий, як в C і Java:</span>
<span class="c1">// ініціалізація; умова; крок.</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// виконається 5 разів</span>
<span class="p">}</span>

<span class="c1">// &amp;&amp; — логічне І, || — логічне АБО</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">house</span><span class="p">.</span><span class="nx">size</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">big</span><span class="dl">"</span> <span class="o">&amp;&amp;</span> <span class="nx">house</span><span class="p">.</span><span class="nx">color</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">blue</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">house</span><span class="p">.</span><span class="nx">contains</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">bear</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">color</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">red</span><span class="dl">"</span> <span class="o">||</span> <span class="nx">color</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">blue</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// колір червоний або синій</span>
<span class="p">}</span>

<span class="c1">// &amp;&amp; та || використовують скорочене обчислення</span>
<span class="c1">// тому їх можна використовувати для задання значень за замовчуванням.</span>
<span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">otherName</span> <span class="o">||</span> <span class="dl">"</span><span class="s2">default</span><span class="dl">"</span><span class="p">;</span>

<span class="c1">// Оператор switch виконує перевірку на рівність за допомогою ===</span>
<span class="c1">// використовуйте break, щоб призупити виконання наступного case,  </span>
<span class="nx">grade</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="k">switch</span> <span class="p">(</span><span class="nx">grade</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="mi">5</span><span class="p">:</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Відмінно</span><span class="dl">"</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="mi">4</span><span class="p">:</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Добре</span><span class="dl">"</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="mi">3</span><span class="p">:</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Можна краще</span><span class="dl">"</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="nl">default</span><span class="p">:</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Погано!</span><span class="dl">"</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">///////////////////////////////////</span>
<span class="c1">// 4. Функції, область видимості і замикання</span>

<span class="c1">// Функції в  JavaScript оголошуються за допомогою ключового слова function.</span>
<span class="kd">function</span> <span class="nx">myFunction</span><span class="p">(</span><span class="nx">thing</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">thing</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">();</span>
<span class="p">}</span>
<span class="nx">myFunction</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// = "FOO"</span>

<span class="c1">// Зверніть увагу, що значення яке буде повернено, повинно починатися на тому ж</span>
<span class="c1">// рядку, що і ключове слово return, інакше завжди буде повертатися значення undefined</span>
<span class="c1">// через автоматичну вставку крапки з комою</span>
<span class="kd">function</span> <span class="nx">myFunction</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="c1">// &lt;- крапка з комою вставляється автоматично</span>
    <span class="p">{</span>
        <span class="na">thisIsAn</span><span class="p">:</span> <span class="dl">'</span><span class="s1">object literal</span><span class="dl">'</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">myFunction</span><span class="p">();</span> <span class="c1">// = undefined</span>

<span class="c1">// В JavaScript функції - це об`єкти першого класу, тому вони можуть присвоюватися</span>
<span class="c1">// іншим змінним і передаватися іншим функціям, наприклад, щоб визначити обробник</span>
<span class="c1">// події.</span>
<span class="kd">function</span> <span class="nx">myFunction</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// код буде виконано через 5 сек.</span>
<span class="p">}</span>
<span class="nx">setTimeout</span><span class="p">(</span><span class="nx">myFunction</span><span class="p">,</span> <span class="mi">5000</span><span class="p">);</span>
<span class="c1">// setTimeout не є частиною мови, але реалізований в браузерах і Node.js</span>

<span class="c1">// Функції не обов’язково мають мати ім’я при оголошенні — ви можете написати</span>
<span class="c1">// анонімну функцію як аргумент іншої функції</span>
<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Цей код буде виконано через п’ять секунд</span>
<span class="p">},</span> <span class="mi">5000</span><span class="p">);</span>

<span class="c1">// В JavaScript реалізована концепція області видимості; функції мають свою</span>
<span class="c1">// область видимості, а інші блоки не мають</span>
<span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">i</span><span class="p">;</span> <span class="c1">// = 5, а не undefined, як це звичайно буває в інших мовах</span>

<span class="c1">// Така особливість призвела до шаблону "анонімних функцій, які викликають самих себе"</span>
<span class="c1">// що дозволяє уникнути проникнення змінних в глобальну область видимості</span>
<span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">temporary</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="c1">// об’єкт window зберігає глобальний контекст; таким чином ми можемо також додавати</span>
    <span class="c1">// змінні до глобальної області</span>
    <span class="nb">window</span><span class="p">.</span><span class="nx">permanent</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">})();</span>
<span class="nx">temporary</span><span class="p">;</span> <span class="c1">// повідомлення про помилку ReferenceError</span>
<span class="nx">permanent</span><span class="p">;</span> <span class="c1">// = 10</span>

<span class="c1">// Замикання - один з найпотужніших інструментів JavaScript. Якщо функція визначена</span>
<span class="c1">// всередині іншої функції, то внутрішня функція має доступ до змінних зовнішньої</span>
<span class="c1">// функції навіть після того, як код буде виконуватися поза контекстом зовнішньої функції</span>
<span class="kd">function</span> <span class="nx">sayHelloInFiveSeconds</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">prompt</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Привіт, </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">name</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">!</span><span class="dl">"</span><span class="p">;</span>
    <span class="c1">// Внутрішня функція зберігається в локальній області так,</span>
    <span class="c1">// ніби функція була оголошена за допомогою ключового слова var</span>
    <span class="kd">function</span> <span class="nx">inner</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">alert</span><span class="p">(</span><span class="nx">prompt</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">inner</span><span class="p">,</span> <span class="mi">5000</span><span class="p">);</span>
    <span class="c1">// setTimeout асинхронна, тому функція sayHelloInFiveSeconds одразу завершиться,</span>
    <span class="c1">// після чого setTimeout викличе функцію inner. Але функція inner</span>
    <span class="c1">// «замкнута» кругом sayHelloInFiveSeconds, вона все рівно має доступ до змінної prompt</span>
<span class="p">}</span>
<span class="nx">sayHelloInFiveSeconds</span><span class="p">(</span><span class="dl">"</span><span class="s2">Адам</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// Через 5 с відкриється вікно «Привіт, Адам!»</span>

<span class="c1">///////////////////////////////////</span>
<span class="c1">// 5. Об’єкти: конструктори і прототипи</span>

<span class="c1">// Об’єкти можуть містити функції</span>
<span class="kd">var</span> <span class="nx">myObj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">myFunc</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="dl">"</span><span class="s2">Hello, world!</span><span class="dl">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="nx">myObj</span><span class="p">.</span><span class="nx">myFunc</span><span class="p">();</span> <span class="c1">// = "Hello, world!"</span>

<span class="c1">// Функції, що прикріплені до об’єктів мають доступ до поточного об’єкта за</span>
<span class="c1">// допомогою ключового слова this.</span>
<span class="nx">myObj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">myString</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Hello, world!</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">myFunc</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">myString</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="nx">myObj</span><span class="p">.</span><span class="nx">myFunc</span><span class="p">();</span> <span class="c1">// = "Hello, world!"</span>

<span class="c1">// Значення this залежить від того, як функція викликається</span>
<span class="c1">// а не від того, де вона визначена. Таким чином наша функція не працює, якщо</span>
<span class="c1">// вона викликана не в контексті об’єкта</span>
<span class="kd">var</span> <span class="nx">myFunc</span> <span class="o">=</span> <span class="nx">myObj</span><span class="p">.</span><span class="nx">myFunc</span><span class="p">;</span>
<span class="nx">myFunc</span><span class="p">();</span> <span class="c1">// = undefined</span>

<span class="c1">// Функція може бути присвоєна іншому об’єкту. Тоді вона матиме доступ до</span>
<span class="c1">// цього об’єкта через this</span>
<span class="kd">var</span> <span class="nx">myOtherFunc</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">myString</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">();</span>
<span class="p">}</span>
<span class="nx">myObj</span><span class="p">.</span><span class="nx">myOtherFunc</span> <span class="o">=</span> <span class="nx">myOtherFunc</span><span class="p">;</span>
<span class="nx">myObj</span><span class="p">.</span><span class="nx">myOtherFunc</span><span class="p">();</span> <span class="c1">// = "HELLO, WORLD!"</span>

<span class="c1">// Контекст виконання функції можна задати за допомогою сall або apply</span>
<span class="kd">var</span> <span class="nx">anotherFunc</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">myString</span> <span class="o">+</span> <span class="nx">s</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">anotherFunc</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">myObj</span><span class="p">,</span> <span class="dl">"</span><span class="s2"> Hello!</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// = "Hello, world! Hello!"</span>

<span class="c1">// Функцiя apply приймає в якості аргументу масив</span>
<span class="nx">anotherFunc</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">myObj</span><span class="p">,</span> <span class="p">[</span><span class="dl">"</span><span class="s2"> Hello!</span><span class="dl">"</span><span class="p">]);</span> <span class="c1">// = "Hello, world! Hello!"</span>

<span class="c1">// apply можна використати, коли функція працює послідовністю аргументів, а</span>
<span class="c1">// ви хочете передати масив</span>
<span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">27</span><span class="p">);</span> <span class="c1">// = 6</span>
<span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">([</span><span class="mi">42</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">27</span><span class="p">]);</span> <span class="c1">// = NaN (Ой-ой!)</span>
<span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nb">Math</span><span class="p">,</span> <span class="p">[</span><span class="mi">42</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">27</span><span class="p">]);</span> <span class="c1">// = 6</span>

<span class="c1">// Але call і apply — тимчасові. Коли ми хочемо зв’язати функцію і об’єкт</span>
<span class="c1">// використовують bind</span>
<span class="kd">var</span> <span class="nx">boundFunc</span> <span class="o">=</span> <span class="nx">anotherFunc</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">myObj</span><span class="p">);</span>
<span class="nx">boundFunc</span><span class="p">(</span><span class="dl">"</span><span class="s2"> Hello!</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// = "Hello world, Hello!"</span>

<span class="c1">// Bind можна використати для задання аргументів</span>
<span class="kd">var</span> <span class="nx">product</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">b</span><span class="p">;</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nx">doubler</span> <span class="o">=</span> <span class="nx">product</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="nx">doubler</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span> <span class="c1">// = 16</span>

<span class="c1">// Коли ви викликаєте функцію за допомогою ключового слова new, створюється новий об’єкт,</span>
<span class="c1">// доступний функції за допомогою this. Такі функції називають конструкторами.</span>
<span class="kd">var</span> <span class="nx">MyConstructor</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">myNumber</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">myNewObj</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyConstructor</span><span class="p">();</span> <span class="c1">// = {myNumber: 5}</span>
<span class="nx">myNewObj</span><span class="p">.</span><span class="nx">myNumber</span><span class="p">;</span> <span class="c1">// = 5</span>

<span class="c1">// У кожного об’єкта є прототип. Коли ви звертаєтесь до поля, яке не існує в цьому</span>
<span class="c1">// об’єкті, інтерпретатор буде шукати поле в прототипі</span>

<span class="c1">// Деякі реалізації мови дозволяють отримати доступ до прототипа об’єкта через</span>
<span class="c1">// "магічну" властивість __proto__. Це поле не є частиною стандарта, але існують</span>
<span class="c1">// стандартні способи використання прототипів, які ми побачимо пізніше</span>
<span class="kd">var</span> <span class="nx">myObj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">myString</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Hello, world!</span><span class="dl">"</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">myPrototype</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">meaningOfLife</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span>
    <span class="na">myFunc</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">myString</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="nx">myObj</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">myPrototype</span><span class="p">;</span>
<span class="nx">myObj</span><span class="p">.</span><span class="nx">meaningOfLife</span><span class="p">;</span> <span class="c1">// = 42</span>

<span class="c1">// Аналогічно для функцій</span>
<span class="nx">myObj</span><span class="p">.</span><span class="nx">myFunc</span><span class="p">();</span> <span class="c1">// = "hello, world!"</span>

<span class="c1">// Якщо інтерпретатор не знайде властивості в прототипі, то він продовжить пошук</span>
<span class="c1">// в прототипі прототипа і так далі</span>
<span class="nx">myPrototype</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">myBoolean</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">};</span>
<span class="nx">myObj</span><span class="p">.</span><span class="nx">myBoolean</span><span class="p">;</span> <span class="c1">// = true</span>

<span class="c1">// Кожен об’єкт зберігає посилання на свій прототип. Це значить, що ми можемо змінити</span>
<span class="c1">// наш прототип, і наші зміни будуть всюди відображені.</span>
<span class="nx">myPrototype</span><span class="p">.</span><span class="nx">meaningOfLife</span> <span class="o">=</span> <span class="mi">43</span><span class="p">;</span>
<span class="nx">myObj</span><span class="p">.</span><span class="nx">meaningOfLife</span><span class="p">;</span> <span class="c1">// = 43</span>

<span class="c1">// Ми сказали, що властивість __proto__ нестандартна, і нема ніякого стандартного способу</span>
<span class="c1">// змінити прототип об’єкта, що вже існує. Але є два способи створити новий об’єкт із заданим</span>
<span class="c1">// прототипом</span>

<span class="c1">// Перший спосіб — це Object.create, який з’явився в JavaScript недавно,</span>
<span class="c1">// а тому в деяких реалізаціях може бути недоступним.</span>
<span class="kd">var</span> <span class="nx">myObj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">myPrototype</span><span class="p">);</span>
<span class="nx">myObj</span><span class="p">.</span><span class="nx">meaningOfLife</span><span class="p">;</span> <span class="c1">// = 43</span>

<span class="c1">// Другий спосіб: у конструкторів є властивість з іменем prototype. Це *не*</span>
<span class="c1">// прототип функції-конструктора, це прототип для нових об’єктів, які будуть створені</span>
<span class="c1">// цим конструктором і ключовим словом new.</span>
<span class="nx">MyConstructor</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">myNumber</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
    <span class="na">getMyNumber</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">myNumber</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">myNewObj2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyConstructor</span><span class="p">();</span>
<span class="nx">myNewObj2</span><span class="p">.</span><span class="nx">getMyNumber</span><span class="p">();</span> <span class="c1">// = 5</span>
<span class="nx">myNewObj2</span><span class="p">.</span><span class="nx">myNumber</span> <span class="o">=</span> <span class="mi">6</span>
<span class="nx">myNewObj2</span><span class="p">.</span><span class="nx">getMyNumber</span><span class="p">();</span> <span class="c1">// = 6</span>

<span class="c1">// У вбудованих типів(рядок, число) теж є конструктори, які створють еквівалентні</span>
<span class="c1">// об’єкти-обгортки</span>
<span class="kd">var</span> <span class="nx">myNumber</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">myNumberObj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Number</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span>
<span class="nx">myNumber</span> <span class="o">==</span> <span class="nx">myNumberObj</span><span class="p">;</span> <span class="c1">// = true</span>

<span class="c1">// Але вони не ідентичні</span>
<span class="k">typeof</span> <span class="nx">myNumber</span><span class="p">;</span> <span class="c1">// = 'number'</span>
<span class="k">typeof</span> <span class="nx">myNumberObj</span><span class="p">;</span> <span class="c1">// = 'object'</span>
<span class="nx">myNumber</span> <span class="o">===</span> <span class="nx">myNumberObj</span><span class="p">;</span> <span class="c1">// = false</span>

<span class="c1">// Об’єкти-обгортки і вбудовані типи мають спільні прототипи, тому</span>
<span class="c1">// ви можете розширити функціонал рядків:</span>
<span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">firstCharacter</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="dl">"</span><span class="s2">abc</span><span class="dl">"</span><span class="p">.</span><span class="nx">firstCharacter</span><span class="p">();</span> <span class="c1">// = "a"</span>

<span class="c1">// Такий прийом часто використовуються в поліфілах, які реалізують нові можливості</span>
<span class="c1">// JavaScript в старій реалізації мови, так що вони можуть бути використані в старих</span>
<span class="c1">// середовищах</span>

<span class="c1">// Наприклад, Object.create доступний не у всіх реалізаціях, але ми можемо</span>
<span class="c1">// використати функції за допомогою наступного поліфіла:</span>
<span class="k">if</span> <span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">create</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// не перезаписуємо метод, якщо він існує</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">proto</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Створюємо правильний конструктор з правильним прототипом</span>
        <span class="kd">var</span> <span class="nx">Constructor</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){};</span>
        <span class="nx">Constructor</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">proto</span><span class="p">;</span>

        <span class="k">return</span> <span class="k">new</span> <span class="nx">Constructor</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h2>Що почитати</h2>

<ul>
<li>[1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript</li>
<li>[2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/A<em>re-introduction</em>to_JavaScript</li>
<li>[3]: https://developer.mozilla.org/en-US/docs/Using<em>the</em>W3C<em>DOM</em>Level<em>1</em>Core</li>
<li>[4]: http://www.learneroo.com/modules/64/nodes/350</li>
<li>[5]: http://bonsaiden.github.io/JavaScript-Garden/</li>
<li>[6]: http://www.amazon.com/gp/product/0596805527/</li>
<li>[7]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/A<em>re-introduction</em>to_JavaScript</li>
<li>[8]: http://eloquentjavascript.net/</li>
<li>[9]: http://jstherightway.org/</li>
</ul>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/uk-ua/javascript-ua.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by Leigh Brenecki, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/uk-ua/javascript-ua.html.markdown">2 contributor(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="https://leigh.net.au">Leigh Brenecki</a>,
        <a href="http://www.learneroo.com">Ariel Krakowski</a>,
        <a href="https://github.com/clearsense">clearsense</a>
    </p>

    <p>
      Translated by:
        <a href="https://github.com/IvanEh">Ivan</a>
        <a href="https://github.com/Serg-Maximchuk">Serhii Maksymchuk</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>

        <script>
            var _gaq=[['_setAccount','UA-3525624-21'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>
</html>
