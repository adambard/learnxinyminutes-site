<!DOCTYPE html lang="uk-ua" xml:lang="uk-ua" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="uk-ua">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn C in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/uk-ua/c-ua/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fuk-ua%2Fc-ua%2F&text=Learn+X+in+Y+minutes%2C+where+X%3DC">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="/">Learn X in Y minutes</a></h1>
  <h2>Where X=C</h2>
    <p class="filelink">
    Get the code:
    <a href="/docs/files/learnc-ua.c">learnc-ua.c</a>
    </p>
  <div id="doc">
    <p>О, C! Досі мова для сучасних обчислень у високопродуктивних продуктах.</p>

<p>C це імовірно найбільш низькорівнева мова, яку будуть використовувати більшість програмістів. Проте, вона компенсує це не тільки швидкістю виконання. Як тільки ви оціните її можливість ручного управління пам&#39;яттю, С зможе відвести саме в ті місця, в які вам потрібно було потрапити.</p>

<blockquote>
<p><strong>Дещо про прапори компілятора</strong></p>

<p>За замовчуванням, gcc та clang досить тихо інформують про попередження та помилки
при компіляції, хоч це і може бути дуже корисною інформацією. Тому рекомендується
використовувати більш вимогливий компілятор. Ось кілька рекомендацій:</p>

<p><code>-Wall -Wextra -Werror -O2 -std=c99 -pedantic</code></p>

<p>За інформацією про ці та інші прапори зверніться до головної сторінки man вашого 
компілятора C (наприклад, <code>man 1 gcc</code>) або ж просто заґуґліть.</p>
</blockquote>
<div class="highlight"><pre class="highlight c"><code><span class="c1">// Однорядкові коментарі починаються з //</span>
<span class="c1">// Проте вони з'явились тільки після С99.</span>

<span class="cm">/*
Багаторядкові коментарі мають такий вигляд. І працюють в C89.
*/</span>

<span class="cm">/*
Багаторядкові коментарі не можуть вкладатись один в одний. 
/* Будьте обережними */</span> <span class="c1">// коментар закінчується на цьому рядку...</span>
<span class="err">*/</span> <span class="c1">// ...а не на цьому!</span>

<span class="c1">// Константа: #define &lt;keyword&gt;</span>
<span class="c1">// Назви констант, як правило, пишуться великими літерами, проте це не вимога</span>
<span class="cp">#define DAYS_IN_YEAR 365
</span>
<span class="c1">// Ще одним способом оголосити константи є перелічення констант.</span>
<span class="c1">// До речі, всі вирази мають закінчуватись крапкою з комою.</span>
<span class="k">enum</span> <span class="n">days</span> <span class="p">{</span><span class="n">SUN</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MON</span><span class="p">,</span> <span class="n">TUE</span><span class="p">,</span> <span class="n">WED</span><span class="p">,</span> <span class="n">THU</span><span class="p">,</span> <span class="n">FRI</span><span class="p">,</span> <span class="n">SAT</span><span class="p">};</span>
<span class="c1">// MON отримає значення 2 автоматично, TUE дорівнюватиме 3 і т.д.</span>

<span class="c1">// Імпортувати заголовки можна за допомогою #include</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="c1">// (Заголовки із стандартної бібліотеки С вказуються між &lt;кутовими дужками&gt;.)</span>
<span class="c1">// Щоб додати власні заголовки, потрібно використовувати "подвійні лапки" </span>
<span class="c1">// замість кутових:</span>
<span class="c1">//#include "my_header.h"</span>

<span class="c1">// Сигнатури функцій попередньо оголошуються в .h файлах або на початку .с файлів.</span>
<span class="kt">void</span> <span class="nf">function_1</span><span class="p">();</span>
<span class="kt">int</span> <span class="nf">function_2</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="c1">// Потрібно оголосити 'прототип функції' перед main(), реалізація функцій </span>
<span class="c1">// відбувається після функції main().</span>
<span class="kt">int</span> <span class="nf">add_two_ints</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">);</span> <span class="c1">// прототип функції</span>
<span class="c1">// Варіант `int add_two_ints(int, int);` теж правильний (не потрібно називати </span>
<span class="c1">// аргументи). Рекомендується також називати аргументи в прототипі для </span>
<span class="c1">// кращого розуміння.</span>

<span class="c1">// Вхідною точкою програми є функція під назвою main. Вона повертає чисельний тип.</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// реалізація програми</span>
<span class="p">}</span>

<span class="c1">// Аргументи командного рядка, вказані при запуску програми, також передаються</span>
<span class="c1">// у функцію main.</span>
<span class="c1">// argc - це кількість переданих аргументів</span>
<span class="c1">// argv — це масив масивів символів, що містить самі аргументи</span>
<span class="c1">// argv[0] - назва програми, argv[1] - перший аргумент, і т.д.</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// printf дозволяє вивести на екран значення, вивід - це форматований рядок, </span>
  <span class="c1">// в даному випадку %d позначає чисельне значення, \n — це новий рядок</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// =&gt; Виводить 0</span>

  <span class="c1">///////////////////////////////////////</span>
  <span class="c1">// Типи</span>
  <span class="c1">///////////////////////////////////////</span>

  <span class="c1">// Всі змінні повинні бути оголошені на початку поточного блоку області видимості.</span>
  <span class="c1">// В цьому коді вони оголошуються динамічно. С99-сумісні компілятори</span>
  <span class="c1">// дозволяють оголошення близько до місця, де значення використовується.</span>

  <span class="c1">// int (цілочисельний знаковий тип) зазвичай займає 4 байти</span>
  <span class="kt">int</span> <span class="n">x_int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// short (цілочисельний знаковий тип) зазвичай займає 2 байти</span>
  <span class="c1">// </span>
  <span class="kt">short</span> <span class="n">x_short</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// Символьний тип char гарантовано займає 1 байт</span>
  <span class="kt">char</span> <span class="n">x_char</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">y_char</span> <span class="o">=</span> <span class="sc">'y'</span><span class="p">;</span> <span class="c1">// Символьні літерали позначаються ''</span>

  <span class="c1">// long (цілочисельний знаковий тип) має розмір від 4 до 8 байтів; великі значення  </span>
  <span class="c1">// типу long гарантовано займають 8 байтів</span>
  <span class="kt">long</span> <span class="n">x_long</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">long</span> <span class="kt">long</span> <span class="n">x_long_long</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// Тип float - це зазвичай 32-бітове число з плаваючою крапкою</span>
  <span class="kt">float</span> <span class="n">x_float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span> <span class="c1">// Суфікс 'f' позначає літерал з плаваючою крапкою</span>

  <span class="c1">// Тип double - це зазвийчай 64-бітове число з плаваючою крапкою</span>
  <span class="kt">double</span> <span class="n">x_double</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span> <span class="c1">// дійсне число без суфіксів має тип double</span>

  <span class="c1">// Цілочисельні типи можуть не мати знаку (бути більше, або ж рівними нулю)</span>
  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ux_short</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ux_int</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ux_long_long</span><span class="p">;</span>

  <span class="c1">// Char всередині одинарних лапок інтерпретуються як числа в наборі </span>
  <span class="c1">// символів комп'ютера.</span>
  <span class="sc">'0'</span><span class="p">;</span> <span class="c1">// =&gt; 48 в таблиці ASCII.</span>
  <span class="sc">'A'</span><span class="p">;</span> <span class="c1">// =&gt; 65 в таблиці ASCII.</span>

  <span class="c1">// sizeof(T) повертає розмір змінної типу Т в байтах</span>
  <span class="c1">// sizeof(obj) віддає розмір виразу (змінна, літерал, і т.п.)</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span> <span class="c1">// =&gt; 4 (на більшості пристроїв з 4-байтним словом)</span>

  <span class="c1">// Якщо аргумент оператора `sizeof` — це вираз, тоді його аргументи не оцінюються</span>
  <span class="c1">// (крім масивів, розмір яких залежить від змінної).</span>
  <span class="c1">// Значення, що повертається в цьому випадку, - це константа часу компіляції.</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="c1">// size_t - беззнаковий чисельний тип розміром щонайменше 2 байти, який</span>
  <span class="c1">// використовується для відображення розміру об'єкта.</span>
  <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="o">++</span><span class="p">);</span> <span class="c1">// a++ не оцінюється</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"sizeof(a++) = %zu where a = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
  <span class="c1">// Виводить "sizeof(a++) = 4 where a = 1" (на 32-бітній архітектурі)</span>

  <span class="c1">// Масиви повинні бути проініціалізовані з конкретним розміром.</span>
  <span class="kt">char</span> <span class="n">my_char_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span> <span class="c1">// Цей масив займає 1 * 20 = 20 байтів</span>
  <span class="kt">int</span> <span class="n">my_int_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span> <span class="c1">// Цей масив займає 4 * 20 = 80 байтів</span>
  <span class="c1">// (припускаючи 4-байтні числа)</span>

  <span class="c1">// Таким чином можна проініціалізувати масив нулем:</span>
  <span class="kt">char</span> <span class="n">my_array</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
  <span class="c1">// де "{0}" називається "ініціалізатором масиву".</span>

  <span class="c1">// Зазначте, можна явно не оголошувати розмір масиву, ЯКЩО ви проініціалізуєте </span>
  <span class="c1">// масив у тому ж рядку. Тому, наступне оголошення еквівалентне:</span>
  <span class="kt">char</span> <span class="n">my_array</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
  <span class="c1">// АЛЕ, потрібно визначити розмір масиву під час виконання, як тут:</span>
  <span class="kt">size_t</span> <span class="n">my_array_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_array</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

  <span class="c1">// ПОПЕРЕДЖЕННЯ якщо ви вирішили використовувати даний підхід, потрібно </span>
  <span class="c1">// визначити розмір **перед тим**, як ви почнете передавати масив у функцію</span>
  <span class="c1">// (побачите дискусію пізніше). Масиви перетворюються на вказівники при</span>
  <span class="c1">// передачі як аргументи у функцію, тому попереднє твердження буде видавати</span>
  <span class="c1">// хибний результат всередині функції.</span>

  <span class="c1">// Індексація по масиву така ж сама, як і в інших мовах програмування або,</span>
  <span class="c1">// скоріше, як у інших с-подібних мовах.</span>
  <span class="n">my_array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// =&gt; 0</span>

  <span class="c1">// Масиви незмінні, це просто частина пам'яті!</span>
  <span class="n">my_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">my_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// =&gt; 2</span>

  <span class="c1">// Масиви, розмір яких залежить від змінної, в С99 (та в С11 як вибірковий </span>
  <span class="c1">// функціонал) можуть бути оголошені також. Розмір такого масиву не має бути</span>
  <span class="c1">// константою під час компіляції:</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Enter the array size: "</span><span class="p">);</span> <span class="c1">// спитати користувача розмір масиву</span>
  <span class="kt">int</span> <span class="n">array_size</span><span class="p">;</span>
  <span class="n">fscanf</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">array_size</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">var_length_array</span><span class="p">[</span><span class="n">array_size</span><span class="p">];</span> <span class="c1">// оголосити масив</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"sizeof array = %zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">var_length_array</span><span class="p">);</span>

  <span class="c1">// Приклад:</span>
  <span class="c1">// &gt; Enter the array size: 10</span>
  <span class="c1">// &gt; sizeof array = 40</span>

  <span class="c1">// Рядки - це просто масиви символьних літералів (char), що закінчуються NULL </span>
  <span class="c1">// (0x00) байтом, представленим у рядках як спеціальний символ '\0'.</span>
  <span class="c1">// (Не потрібно включати байт NULL в рядкові літерали; компілятор сам вставляє</span>
  <span class="c1">// його наприкінці масиву.)</span>
  <span class="kt">char</span> <span class="n">a_string</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="s">"This is a string"</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a_string</span><span class="p">);</span> <span class="c1">// %s форматує рядок</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a_string</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span> <span class="c1">// =&gt; 0</span>
  <span class="c1">// тобто, байт #17 - це 0 (так само, як і 18-ий, 19-ий, та 20-ий)</span>

  <span class="c1">// Якщо між одинарними лапками є букви, тоді це символьний літерал.</span>
  <span class="c1">// Він має тип `int`, а не `char` (так історично склалось).</span>
  <span class="kt">int</span> <span class="n">cha</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span> <span class="c1">// добре</span>
  <span class="kt">char</span> <span class="n">chb</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span> <span class="c1">// також добре (неявне перетворення з int на char)</span>

  <span class="c1">// Багатовимірні масиви:</span>
  <span class="kt">int</span> <span class="n">multi_array</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">},</span>
    <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
  <span class="p">};</span>
  <span class="c1">// Доступ до елементів:</span>
  <span class="kt">int</span> <span class="n">array_int</span> <span class="o">=</span> <span class="n">multi_array</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// =&gt; 3</span>

  <span class="c1">///////////////////////////////////////</span>
  <span class="c1">// Оператори</span>
  <span class="c1">///////////////////////////////////////</span>

  <span class="c1">// Скорочення для багатьох оголошень:</span>
  <span class="kt">int</span> <span class="n">i1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">f1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">f2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// Арифметичні операції</span>
  <span class="n">i1</span> <span class="o">+</span> <span class="n">i2</span><span class="p">;</span> <span class="c1">// =&gt; 3</span>
  <span class="n">i2</span> <span class="o">-</span> <span class="n">i1</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>
  <span class="n">i2</span> <span class="o">*</span> <span class="n">i1</span><span class="p">;</span> <span class="c1">// =&gt; 2</span>
  <span class="n">i1</span> <span class="o">/</span> <span class="n">i2</span><span class="p">;</span> <span class="c1">// =&gt; 0 (0.5 округлено до 0)</span>

  <span class="c1">// Потрібно перетворити хоча б одну з цілочисельних змінних на float, щоб </span>
  <span class="c1">// отримати результат з плаваючою крапкою</span>
  <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">i1</span> <span class="o">/</span> <span class="n">i2</span><span class="p">;</span> <span class="c1">// =&gt; 0.5f</span>
  <span class="n">i1</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">i2</span><span class="p">;</span> <span class="c1">// =&gt; 0.5 // Так само і для типу double</span>
  <span class="n">f1</span> <span class="o">/</span> <span class="n">f2</span><span class="p">;</span> <span class="c1">// =&gt; 0.5, з певною точністю</span>
  <span class="c1">// Такі обчислення не є точними</span>

  <span class="c1">// Ділення за модулем також є</span>
  <span class="mi">11</span> <span class="o">%</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// =&gt; 2, остача від ділення</span>

  <span class="c1">// Оператори порівняння ймовірно схожі, проте в С немає логічного типу.</span>
  <span class="c1">// Натомість використовується int.</span>
  <span class="c1">// (Або _Bool або bool в C99.)</span>
  <span class="c1">// 0 - хибно (false), всі інші значення - правда (true). Оператори</span>
  <span class="c1">// порівняння завжди повертають 0 або 1.</span>
  <span class="mi">3</span> <span class="o">==</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 0 (false)</span>
  <span class="mi">3</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 1 (true)</span>
  <span class="mi">3</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>
  <span class="mi">3</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 0</span>
  <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>
  <span class="mi">2</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>

  <span class="c1">// C - це не Python, порівняння не утворюють ланцюги.</span>
  <span class="c1">// Попередження: Рядок нижче скомпілюється, але він означає `(0 &lt; a) &lt; 2`.</span>
  <span class="c1">// В даному випадку, це 1, тому що (0 &lt; 1).</span>
  <span class="kt">int</span> <span class="n">between_0_and_2</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span>
  <span class="c1">// Натомість потрібно використати:</span>
  <span class="kt">int</span> <span class="n">between_0_and_2</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span>

  <span class="c1">// Логічні оператори з числами</span>
  <span class="o">!</span><span class="mi">3</span><span class="p">;</span> <span class="c1">// =&gt; 0 (Логічне НЕ)</span>
  <span class="o">!</span><span class="mi">0</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>
  <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 1 (Логічне І)</span>
  <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 0</span>
  <span class="mi">0</span> <span class="o">||</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 1 (Логічне АБО)</span>
  <span class="mi">0</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// =&gt; 0</span>

  <span class="c1">// Тернарний вираз з умовою ( ? : )</span>
  <span class="kt">int</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">z</span><span class="p">;</span>
  <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">e</span> <span class="o">&gt;</span> <span class="n">f</span><span class="p">)</span> <span class="o">?</span> <span class="n">e</span> <span class="o">:</span> <span class="n">f</span><span class="p">;</span> <span class="c1">// =&gt; 10 "if e &gt; f return e, else return f."</span>

  <span class="c1">// Оператори збільшення та зменшення на 1:</span>
  <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">j</span><span class="o">++</span><span class="p">;</span> <span class="c1">// Повернути j ПОТІМ збільшити j. (s = 0, j = 1)</span>
  <span class="n">s</span> <span class="o">=</span> <span class="o">++</span><span class="n">j</span><span class="p">;</span> <span class="c1">// Збільшити j ПОТІМ повернути j. (s = 2, j = 2)</span>
  <span class="c1">// так само і для j-- та --j</span>

  <span class="c1">// Побітові операції!</span>
  <span class="o">~</span><span class="mh">0x0F</span><span class="p">;</span> <span class="c1">// =&gt; 0xFFFFFFF0 (побітове заперечення, "перше доповнення", результат </span>
  <span class="c1">// для 32-бітного int)</span>
  <span class="mh">0x0F</span> <span class="o">&amp;</span> <span class="mh">0xF0</span><span class="p">;</span> <span class="c1">// =&gt; 0x00 (побітове І)</span>
  <span class="mh">0x0F</span> <span class="o">|</span> <span class="mh">0xF0</span><span class="p">;</span> <span class="c1">// =&gt; 0xFF (побітове АБО)</span>
  <span class="mh">0x04</span> <span class="o">^</span> <span class="mh">0x0F</span><span class="p">;</span> <span class="c1">// =&gt; 0x0B (побітове XOR)</span>
  <span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 0x02 (побітовий зсув вліво (на 1))</span>
  <span class="mh">0x02</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 0x01 (побітовий зсув вправо (на 1))</span>

  <span class="c1">// Будьте обережними при зсуві цілочисельних значень зі знаком.  </span>
  <span class="c1">// Наступні дії дають невизначений результат:</span>
  <span class="c1">// - зсув на біт, що зберігає знак числа (int a = 1 &lt;&lt; 31)</span>
  <span class="c1">// - зсув вліво на від'ємне число (int a = -1 &lt;&lt; 2)</span>
  <span class="c1">// - зсув на число, що більше за ширину типу </span>
  <span class="c1">// TODO: LHS</span>
  <span class="c1">// - зсув на зміщення, що &gt;= ширині типу в лівій частині виразу:</span>
  <span class="c1">//   int a = 1 &lt;&lt; 32; // Невизначена поведінка, якщо ширина int 32 біти.</span>

  <span class="c1">///////////////////////////////////////</span>
  <span class="c1">// Структури розгалуження</span>
  <span class="c1">///////////////////////////////////////</span>

  <span class="c1">// Оператор умови</span>
  <span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"I am never run</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="c1">// ніколи не буде виконано</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"I am also never run</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="c1">// теж ніколи не буде виконано</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"I print</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>    <span class="c1">// це буде надруковано</span>
  <span class="p">}</span>

  <span class="c1">// Цикл з передумовою</span>
  <span class="kt">int</span> <span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">ii</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// БУДЬ-ЯКЕ значення, що менше 10 - правда.</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d, "</span><span class="p">,</span> <span class="n">ii</span><span class="o">++</span><span class="p">);</span> <span class="c1">// ii++ збільшує ii на 1 ПІСЛЯ передачі поточного значення.</span>
  <span class="p">}</span> <span class="c1">// =&gt; надрукує "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

  <span class="c1">// Цикл з післяумовою</span>
  <span class="kt">int</span> <span class="n">kk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d, "</span><span class="p">,</span> <span class="n">kk</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">kk</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">);</span> <span class="c1">// ++kk збільшує kk на 1 ПЕРЕД передачою поточного значення.</span>
  <span class="c1">// =&gt; надрукує "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

  <span class="c1">// Цикл з лічильником</span>
  <span class="kt">int</span> <span class="n">jj</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">jj</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">jj</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">jj</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d, "</span><span class="p">,</span> <span class="n">jj</span><span class="p">);</span>
  <span class="p">}</span> <span class="c1">// =&gt; виводить "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

  <span class="c1">// *****Додатково*****:</span>
  <span class="c1">// Цикли та функції обов'язково повинні мати тіло. Якщо тіло не потрібно:</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">;</span> <span class="c1">// використовуйте крапку з комою, щоб симулювати тіло (пусте твердження)</span>
  <span class="p">}</span>
  <span class="c1">// Або</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">);</span>

  <span class="c1">// Розгалуження з множинним вибором: switch()</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="mi">0</span><span class="p">:</span> <span class="c1">// значення повинні бути *константними* виразами і мати вбудований тип</span>
          <span class="c1">//(наприклад, перелічення)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Hey, 'a' equals 0!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span> <span class="c1">// якщо не використати break, то управління буде передано наступному блоку</span>
  <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Huh, 'a' equals 1!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
    <span class="c1">// Будьте обережними, виконання продовжиться до тих пір, поки</span>
    <span class="c1">// не зустрінеться наступний "break".</span>
  <span class="k">case</span> <span class="mi">3</span><span class="p">:</span>
  <span class="k">case</span> <span class="mi">4</span><span class="p">:</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Look at that.. 'a' is either 3, or 4</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="nl">default:</span>
    <span class="c1">// якщо вираз a не співпадає з описаними значеннями, то виконується </span>
    <span class="c1">// блок default</span>
    <span class="n">fputs</span><span class="p">(</span><span class="s">"Error!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/*
  Використання "goto" в С
  */</span>
  <span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span> <span class="p">}</span> <span class="n">bool</span><span class="p">;</span>
  <span class="c1">// вводимо таке перелічення, оскільки С не має логічного типу до С99</span>
  <span class="n">bool</span> <span class="n">disaster</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">150</span><span class="p">)</span>
        <span class="n">disaster</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">disaster</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">error</span> <span class="o">:</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Error occurred at i = %d &amp; j = %d.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
  <span class="cm">/*
  https://ideone.com/GuPhd6
  Даний приклад виведе "Error occurred at i = 51 &amp; j = 99."
  */</span>

  <span class="c1">///////////////////////////////////////</span>
  <span class="c1">// Приведення до типів</span>
  <span class="c1">///////////////////////////////////////</span>

  <span class="c1">// Кожне значенння в С має тип, але можна перевести значення з одного типу в </span>
  <span class="c1">// інший, якщо потрібно (із деякими обмеженнями).</span>

  <span class="kt">int</span> <span class="n">x_hex</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span> <span class="c1">// Змінним можна присвоювати літерали в шістнадцятковій </span>
                    <span class="c1">// системі числення</span>

  <span class="c1">// Приведення до типу призведе до спроби зберегти чисельне значення</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x_hex</span><span class="p">);</span> <span class="c1">// =&gt; Виводить 1</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">short</span><span class="p">)</span> <span class="n">x_hex</span><span class="p">);</span> <span class="c1">// =&gt; Виводить 1</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="n">x_hex</span><span class="p">);</span> <span class="c1">// =&gt; Виводить 1</span>

  <span class="c1">// В данному випадку попередження не виникатиме, якщо значення виходить за межі </span>
  <span class="c1">// значення типу</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="mi">257</span><span class="p">);</span> <span class="c1">// =&gt; 1 (максимальне значення char = 255, </span>
  <span class="c1">// якщо char має довжину 8 біт)</span>

  <span class="c1">// Для того, щоб дізнатись максимальний розмір `char`, `signed char` або ж </span>
  <span class="c1">// `unsigned char`, потрібно використати макроси CHAR_MAX, SCHAR_MAX та UCHAR_MAX</span>
  <span class="c1">// відповідно з &lt;limits.h&gt;. </span>

  <span class="c1">// Вбудовані типи можуть бути приведені до типу із плаваючою крапкою і навпаки.</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="mi">100</span><span class="p">);</span> <span class="c1">// %f завжди перетворює число на double...</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span>  <span class="mi">100</span><span class="p">);</span> <span class="c1">// ...навіть, якщо це float.</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mi">100</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>

  <span class="c1">///////////////////////////////////////</span>
  <span class="c1">// Вказівники</span>
  <span class="c1">///////////////////////////////////////</span>

  <span class="c1">// Вказівник - це змінна, що зберігає адресу у пам'яті. Оголошення вказівника </span>
  <span class="c1">// також потребує інформації про тип об'єкта, на який він вказує. Можна </span>
  <span class="c1">// отримати адресу пам'яті будь-якої змінної, а потім працювати з нею.</span>

  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span> <span class="c1">// Оператор &amp; повертає адресу змінної у пам'яті</span>
  <span class="c1">// (%p форматує об'єкт вказівника типу void *)</span>
  <span class="c1">// =&gt; Виводить деяку адресу в пам'яті</span>

  <span class="c1">// Для оголошення вказівника потрібно поставити * перед його назвою.</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">px</span><span class="p">,</span> <span class="n">not_a_pointer</span><span class="p">;</span> <span class="c1">// px - це вказівник на цілочисельне значення (int)</span>
  <span class="n">px</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span> <span class="c1">// Зберігає адресу змінної x в px</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">px</span><span class="p">);</span> <span class="c1">// =&gt; Виводить адресу в пам'яті</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%zu, %zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">px</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">not_a_pointer</span><span class="p">));</span>
  <span class="c1">// =&gt; Виводить "8, 4" на звичайній 64-бітній системі</span>

  <span class="c1">// Щоб прочитати значення, яке зберігається за адресою, на яку вказує вказівник,</span>
  <span class="c1">// потрібно поставити знак * перед назвою змінної. </span>
  <span class="c1">// Так, * використовується одночасно і для оголошення вказівника, і для отримання </span>
  <span class="c1">// значення за адресою. Звучить заплутано, проте тільки спочатку.</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">px</span><span class="p">);</span> <span class="c1">// =&gt; Виводить 0, значення x</span>

  <span class="c1">// Можна також змінити значення, на яке посилається вказівник.</span>
  <span class="c1">// Тут звернення до адреси обернене у круглі дужки, тому що </span>
  <span class="c1">// ++ має вищий пріоритет виконання, ніж *.</span>
  <span class="p">(</span><span class="o">*</span><span class="n">px</span><span class="p">)</span><span class="o">++</span><span class="p">;</span> <span class="c1">// Збільшити значення, на яке вказує px, на 1</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">px</span><span class="p">);</span> <span class="c1">// =&gt; Виводить 1</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// =&gt; Виводить 1</span>

  <span class="c1">// Масиви зручно використовувати для виділення неперервного блоку пам'яті.</span>
  <span class="kt">int</span> <span class="n">x_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span> <span class="c1">// оголошує масив з 20 елементів (розмір можна задати лише один раз)</span>
  <span class="kt">int</span> <span class="n">xx</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">xx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">xx</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">xx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x_array</span><span class="p">[</span><span class="n">xx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">-</span> <span class="n">xx</span><span class="p">;</span>
  <span class="p">}</span> <span class="c1">// Ініціалізує x_array значеннями 20, 19, 18,... 2, 1</span>

  <span class="c1">// Оголосити вказівник типу int, який посилається на масив x_array</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">x_ptr</span> <span class="o">=</span> <span class="n">x_array</span><span class="p">;</span>
  <span class="c1">// x_ptr тепер вказує на перший елемент масиву (число 20).</span>
  <span class="c1">//  </span>
  <span class="c1">// Це працює, тому що при зверненні до імені масиву повертається вказівник </span>
  <span class="c1">// на перший елемент. Наприклад, коли масив передається у функцію або присвоюється</span>
  <span class="c1">// вказівнику, він неявно приводиться до вказівника.</span>
  <span class="c1">// Виключення: </span>
  <span class="c1">// - коли вказівник передається як аргумент із оператором `&amp;`:</span>
  <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr_to_arr</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">;</span> <span class="c1">// &amp;arr НЕ має тип `int *`!</span>
  <span class="c1">// Він має тип "вказівник на масив" (з 10 чисел).</span>
  <span class="c1">// - коли масив - це рядковий літерал, що використовується для ініціалізації</span>
  <span class="c1">// масив символів:</span>
  <span class="kt">char</span> <span class="n">otherarr</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"foobarbazquirk"</span><span class="p">;</span>
  <span class="c1">// - коли масив - це аргумент операторів `sizeof` або `alignof`:</span>
  <span class="kt">int</span> <span class="n">arraythethird</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">arraythethird</span><span class="p">;</span> <span class="c1">// те ж саме, що з int *ptr = &amp;arr[0];</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%zu, %zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arraythethird</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ptr</span><span class="p">));</span>
  <span class="c1">// Ймовірно, виводить "40, 4" або "40, 8"</span>

  <span class="c1">// Інкрементація та декрементація вказівника залежить від його типу.</span>
  <span class="c1">// (так звана арифметика вказівників)</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">x_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span> <span class="c1">// =&gt; Виводить 19</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// =&gt; Виводить 19</span>

  <span class="c1">// Можна також динамічно виділити послідовні блоки в пам'яті за допомогою</span>
  <span class="c1">// функції malloc зі стандартної бібліотеки. malloc приймає один аргумент типу</span>
  <span class="c1">// size_t, що описує кількість байтів для виділення (зазвичай із купи, проте це</span>
  <span class="c1">// може бути неправдою на вбудованих системах - стандарт С нічого про це не повідомляє).</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">my_ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">my_ptr</span><span class="p">)</span> <span class="o">*</span> <span class="mi">20</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">xx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">xx</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">xx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="p">(</span><span class="n">my_ptr</span> <span class="o">+</span> <span class="n">xx</span><span class="p">)</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">-</span> <span class="n">xx</span><span class="p">;</span> <span class="c1">// my_ptr[xx] = 20-xx</span>
  <span class="p">}</span> <span class="c1">// Проініціалізувати пам'ять значеннями 20, 19, 18, 17... 2, 1 (як int)</span>

  <span class="c1">// Будьте обережними із передачею значень, що надаються користувачем, в malloc!</span>
  <span class="c1">// Про всяк випадок, використовуйте calloc в таких ситуаціях (який, на відміну від </span>
  <span class="c1">// malloc, також заповнює пам'ять нулями).</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">my_other_ptr</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

  <span class="c1">// Немає стандартного способу визначити розмір динамічно виділеного масиву в С.</span>
  <span class="c1">// Через це, якщо масиви будуть часто передаватись в програмі, потрібна інша змінна,</span>
  <span class="c1">// яка буде відслідковувати кількість елементів в масиві. Детальніше в розділі </span>
  <span class="c1">// про функції.</span>
  <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">my_arr</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
  <span class="c1">// Додати елемент до масиву.</span>
  <span class="n">size</span><span class="o">++</span><span class="p">;</span>
  <span class="n">my_arr</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">my_arr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">size</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">my_arr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Не забувайте перевіряти результат виконання realloc на помилки!</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="n">my_arr</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

  <span class="c1">// Робота з вказівниками може призводити до неочікуваних і непрогнозованих </span>
  <span class="c1">// результатів, якщо звернутись до пам'яті, що не була виділена вами.</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">my_ptr</span> <span class="o">+</span> <span class="mi">21</span><span class="p">));</span> <span class="c1">// =&gt; Хто зна, що буде виведено. </span>
                                    <span class="c1">// Може навіть вилетіти з помилкою.</span>

  <span class="c1">// Після закінчення роботи із виділеною за допомогою malloc пам'яттю, її обов'язково</span>
  <span class="c1">// потрібно звільнити. Інакше ніхто не зможе нею скористатися, аж поки програма не</span>
  <span class="c1">// завершить свою роботу (така ситуація називається "витоком пам'яті").</span>
  <span class="n">free</span><span class="p">(</span><span class="n">my_ptr</span><span class="p">);</span>

  <span class="c1">// Рядки - це масиви символів, проте вони найчастіше представлені як </span>
  <span class="c1">// вказівник на символ (тобто, вказівник на перший елемент масиву). Вважається</span>
  <span class="c1">// хорошим підходом використовувати `const char *', посилаючись на об'єкт</span>
  <span class="c1">// рядка, оскільки його не можна змінити ("foo"[0] = 'a' ЗАБОРОНЕНО).</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">my_str</span> <span class="o">=</span> <span class="s">"This is my very own string literal"</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%c</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">my_str</span><span class="p">);</span> <span class="c1">// =&gt; 'T'</span>

  <span class="c1">// Це не працюватиме, якщо рядок - це масив (потенційно створений за допомогою </span>
  <span class="c1">// рядкового літерала), що зберігається у частині пам'яті, яку можна перезаписувати:</span>
  <span class="kt">char</span> <span class="n">foo</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"foo"</span><span class="p">;</span>
  <span class="n">foo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span> <span class="c1">// Дозволяється, foo тепер містить "aoo"</span>

  <span class="n">function_1</span><span class="p">();</span>
<span class="p">}</span> <span class="c1">// Кінець функції main</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Функції</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// Синтаксис оголошення функції:</span>
<span class="c1">// &lt;тип повернення&gt; &lt;назва функції&gt;(&lt;аргументи&gt;)</span>

<span class="kt">int</span> <span class="nf">add_two_ints</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="p">;</span> <span class="c1">// Використовуйте return, щоб повернути значення</span>
<span class="p">}</span>

<span class="cm">/*
Дані у функцію передають за значенням. Коли функція викликається, аргументи, що
передаються у функцію, копіюються з оригіналів (окрім масивів). Всі зміни над 
значенням аргументів всередині функції не впливають на значення оригіналів.

Використовуйте вказівники, якщо потрібно редагувати безпосередньо оригінальні 
значення аргументів.

Приклад: замінити рядок на обернений.
*/</span>

<span class="c1">// void означає, що функція нічого не повертає</span>
<span class="kt">void</span> <span class="nf">str_reverse</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str_in</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str_in</span><span class="p">);</span> <span class="c1">// `strlen()` це частина стандартної бібліотеки С</span>
                               <span class="c1">// Зауважте: довжина, яку повертає `strlen`, не включає</span>
                               <span class="c1">//           термінальний NULL байт ('\0')</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">ii</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// в C99 можна напряму оголошувати тип `ii` в циклі</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">str_in</span><span class="p">[</span><span class="n">ii</span><span class="p">];</span>
    <span class="n">str_in</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">str_in</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">// ii-й символ з кінця</span>
    <span class="n">str_in</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// Зауважте: для використання strlen() потрібно завантажити файл заголовку string.h</span>

<span class="cm">/*
char c[] = "This is a test.";
str_reverse(c);
printf("%s\n", c); // =&gt; ".tset a si sihT"
*/</span>
<span class="cm">/*
Оскільки можна повертати тільки одну змінну, для зміни значення більшої 
кількості змінних можна використовувати виклик за посиланням
*/</span>
<span class="kt">void</span> <span class="nf">swapTwoNumbers</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
    <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
    <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
int first = 10;
int second = 20;
printf("first: %d\nsecond: %d\n", first, second);
swapTwoNumbers(&amp;first, &amp;second);
printf("first: %d\nsecond: %d\n", first, second);
// змінні обмінюються значеннями
*/</span>

<span class="cm">/*
Масиви завжди передаються у функції як вказівники, не зважаючи на тип масиву 
(статичний чи динамічний). Тому всередині функція не знає про розмір масиву.
*/</span>
<span class="c1">// Розмір масиву завжди має передаватись разом із масивом!</span>
<span class="kt">void</span> <span class="nf">printIntArray</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"arr[%d] is: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*
int my_arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
int size = 10;
printIntArray(my_arr, size);
// виведе "arr[0] is: 1" і т.д.
*/</span>

<span class="c1">// Ключове слово extern використовується, якщо всередині функції потрібно звернутись</span>
<span class="c1">// до змінної, що була оголошена поза функцією.</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">testFunc</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">extern</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// використовуємо зовнішню змінну i</span>
<span class="p">}</span>

<span class="c1">// Зробити зовнішню змінну приватною у вихідному файлі за допомогою static:</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// інші файли, що використовують testFunc2(), </span>
                  <span class="c1">// не матимуть доступу до змінної j</span>
<span class="kt">void</span> <span class="nf">testFunc2</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">extern</span> <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// Ключове слово static робить змінну недоступною для коду поза даною одиницею </span>
<span class="c1">// компіляції. (На більшості систем, одиниця компіляції - це файл). </span>
<span class="c1">// static можна використовувати до глобальних змінних, функцій, локальних</span>
<span class="c1">// змінних у функціях. Локальні змінні, проініціалізовані static, поводять</span>
<span class="c1">// себе як глобальні змінні, проте тільки в межах даного файлу. Статичні</span>
<span class="c1">// змінні ініціалізуються 0, якщо інше значення не було вказане.</span>
<span class="c1">// **Як варіант, функції можна зробити приватними оголосивши їх як static**</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Користувацькі типи та структури</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// Ключове слово typedef використовується, щоб створити псевдонім типу</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">my_type</span><span class="p">;</span>
<span class="n">my_type</span> <span class="n">my_type_var</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// Структури - це такі собі колекції з даними. Пам'ять для полів виділяється </span>
<span class="c1">// послідовно, в порядку їх написання:</span>
<span class="k">struct</span> <span class="n">rectangle</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">width</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">height</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Проте це не означає, що </span>
<span class="c1">// sizeof(struct rectangle) == sizeof(int) + sizeof(int)</span>
<span class="c1">// в зв'язку з вирівнюванням пам'яті [1]</span>

<span class="kt">void</span> <span class="nf">function_1</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">rectangle</span> <span class="n">my_rec</span><span class="p">;</span>

  <span class="c1">// Доступ до полів структури відбувається через .</span>
  <span class="n">my_rec</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="n">my_rec</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

  <span class="c1">// Можна створити вказівники на структуру</span>
  <span class="k">struct</span> <span class="n">rectangle</span> <span class="o">*</span><span class="n">my_rec_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_rec</span><span class="p">;</span>

  <span class="c1">// Звернення до структури через вказівник та зміна значень поля:</span>
  <span class="p">(</span><span class="o">*</span><span class="n">my_rec_ptr</span><span class="p">).</span><span class="n">width</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>

  <span class="c1">// Але є й альтернативний спосіб звернутись до поля через вказівник, використовуючи </span>
  <span class="c1">// оператор -&gt; (краще читається)</span>
  <span class="n">my_rec_ptr</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// Те ж саме, що (*my_rec_ptr).height = 10;</span>
<span class="p">}</span>

<span class="c1">// Можна використати typedef перед struct</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">rectangle</span> <span class="n">rect</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">area</span><span class="p">(</span><span class="n">rect</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">r</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">r</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Якщо ваша структура доволі громіздка, можна звертатись до неї через вказівник, </span>
<span class="c1">// щоб уникнути копіювання всієї структури:</span>
<span class="kt">int</span> <span class="nf">areaptr</span><span class="p">(</span><span class="k">const</span> <span class="n">rect</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">*</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Вказівники на функції</span>
<span class="c1">///////////////////////////////////////</span>
<span class="cm">/*
Під час виконання функції знаходяться за відомими адресами в пам'яті. Вказівники 
на функції - це ті ж самі вказівники, що зберігають адресу у пам'яті, проте можуть
використовуватись, щоб викликати функції напряму і передавати обробники (або функції зі 
зворотнім зв'язком). Хоча, синтаксис спочатку може бути доволі незрозумілим.

Приклад: use str_reverse from a pointer
*/</span>
<span class="kt">void</span> <span class="nf">str_reverse_through_pointer</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str_in</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Оголосити вказівник на функцію під назвою f.</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span> <span class="c1">// Сигнатура повинна точно співпадати із цільовою функцією.</span>
  <span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">str_reverse</span><span class="p">;</span> <span class="c1">// Присвойте адресу певної функції (визначається під час виконання)</span>
  <span class="c1">// f = str_reverse; повинно працювати також</span>
  <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="n">str_in</span><span class="p">);</span> <span class="c1">// Виклик функції через вказівник</span>
  <span class="c1">// f(str_in); // Це альтернативний, але теж вірний синтаксис виклику функції.</span>
<span class="p">}</span>

<span class="cm">/*
Якщо сигнатури функцій співпадають, можна присвоїти будь-яку функцію тому ж 
самому вказівнику. Вказівники на функції зазвичай використовуються як псевдоніми 
для спрощення та покращення читабельності коду. Приклад:
*/</span>

<span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">my_fnp_type</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span>

<span class="c1">// Використання при оголошенні змінної вказівника:</span>
<span class="c1">// ...</span>
<span class="c1">// my_fnp_type f;</span>


<span class="c1">// Спеціальні символи:</span>
<span class="cm">/*
'\a'; // символ попередження (дзвінок)
'\n'; // символ нового рядка
'\t'; // символ табуляції (вирівнювання по лівому краю)
'\v'; // вертикальна табуляція
'\f'; // нова сторінка
'\r'; // повернення каретки
'\b'; // стирання останнього символу
'\0'; // нульовий символ. Зазвичай розташовується в кінці рядка.
//   hello\n\0. \0 використовується для позначення кінця рядка.
'\\'; // зворотній слеш
'\?'; // знак питання
'\''; // одинарні лапки
'\"'; // подвійні лапки
'\xhh'; // шістнадцяткове число. Наприклад: '\xb' = символ вертикальної табуляції
'\0oo'; // вісімкове число. Наприклад: '\013' = символ вертикальної табуляції

// форматування виводу:
"%d";    // ціле число (int)
"%3d";   // ціле число, щонайменше 3 символи (вирівнювання по правому краю)
"%s";    // рядок
"%f";    // число з плаваючою крапкою (float)
"%ld";   // велике ціле число (long)
"%3.2f"; // число з плаваючою крапкою, щонайменше 3 цифри зліва і 2 цифри справа 
"%7.4s"; // (аналогічно для рядків)
"%c";    // символ
"%p";    // вказівник. Зазначте: потребує перетворення типу на (void *) перед 
         //                      використанням у `printf`.
"%x";    // шістнадцяткове число
"%o";    // вісімкове число
"%%";    // друкує %
*/</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Порядок виконання</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">//---------------------------------------------------//</span>
<span class="c1">//        Оператори                  | Асоціативність//</span>
<span class="c1">//---------------------------------------------------//</span>
<span class="c1">// () [] -&gt; .                        | зліва направо //</span>
<span class="c1">// ! ~ ++ -- + = *(type)sizeof       | справа наліво //</span>
<span class="c1">// * / %                             | зліва направо //</span>
<span class="c1">// + -                               | зліва направо //</span>
<span class="c1">// &lt;&lt; &gt;&gt;                             | зліва направо //</span>
<span class="c1">// &lt; &lt;= &gt; &gt;=                         | зліва направо //</span>
<span class="c1">// == !=                             | зліва направо //</span>
<span class="c1">// &amp;                                 | зліва направо //</span>
<span class="c1">// ^                                 | зліва направо //</span>
<span class="c1">// |                                 | зліва направо //</span>
<span class="c1">// &amp;&amp;                                | зліва направо //</span>
<span class="c1">// ||                                | зліва направо //</span>
<span class="c1">// ?:                                | справа наліво //</span>
<span class="c1">// = += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;= | справа наліво //</span>
<span class="c1">// ,                                 | зліва направо //</span>
<span class="c1">//---------------------------------------------------//</span>

<span class="cm">/****************************** Файли заголовків *********************************

Файли заголовків важливі в С. Вони розділяють вихідний код та визначення на різні 
файли, що робить їх кращими для розуміння. 

Файли заголовків синтаксично подібні до вихідних файлів С, проте описуються у".h"
файлах. Їх можна додати в код за допомогою директиви #include "example.h", якщо
example.h існує в тому ж каталозі, що і файл С.
*/</span>

<span class="cm">/* 
Так можна запобігти тому, що заголовок буде оголошений кілька разів. Така ситуація
виникає у випадку циклічної залежності, тобто коли вміст заголовку вже було
оголошено.                                                         
*/</span>
<span class="cp">#ifndef EXAMPLE_H </span><span class="cm">/* якщо EXAMPLE_H ще не оголошено. */</span><span class="cp">
#define EXAMPLE_H </span><span class="cm">/* Визначити макрос EXAMPLE_H. */</span><span class="cp">
</span>
<span class="cm">/* 
Заголовки можна додавати в інші заголовки, таким чином вони разом додаються
у подальшому.                      
*/</span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="cm">/* 
Макроси можуть бути визначені також у заголовку та використовуватись у файлах,
що містять цей заголовок. 
*/</span>
<span class="cp">#define EXAMPLE_NAME "Dennis Ritchie"
</span>
<span class="cm">/* Макроси функції також можна визначити.  */</span>
<span class="cp">#define ADD(a, b) ((a) + (b))
</span><span class="cm">/*
Зверніть увагу на круглі дужки навколо аргументів! Важливо переконатись, що 
a та b не можна проінтерпретувати інакше. Наприклад:
MUL(x, y) (x * y); 
MUL(1 + 2, 3) -&gt; (1 + 2 * 3), що є помилкою
*/</span>

<span class="cm">/* Struct та typedef можуть використовуватись для узгодженості між файлами. */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Node</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Node</span><span class="p">;</span>

<span class="cm">/* Так само і перелічення. */</span>
<span class="k">enum</span> <span class="n">traffic_light_state</span> <span class="p">{</span><span class="n">GREEN</span><span class="p">,</span> <span class="n">YELLOW</span><span class="p">,</span> <span class="n">RED</span><span class="p">};</span>

<span class="cm">/* 
Прототипи функцій також можна оголосити так, щоб використовувати у кількох 
файлах. Але так робити не варто. Краще оголосити їх у С файлі.
*/</span>
<span class="n">Node</span> <span class="nf">createLinkedList</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">vals</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/*
Окрім вище згаданих випадків, всі інші визначення мають описуватись у С файлах.
*/</span>

<span class="cp">#endif </span><span class="cm">/* Кінець директиви передкомпіляції if. */</span><span class="cp">
</span>
</code></pre></div>
<h2>Додаткові матеріали</h2>

<p>Кращим посібником для вивчення С буде книга авторства Деніса Рітчі (творець С) та Браяна Кернігана, 
<a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">K&amp;R, aka &ldquo;The C Programming Language&rdquo;</a>.
Але обережно з нею, книга старезна і містить неточності (ідеї, що вже вважаються не надто прийнятними).</p>

<p>Ще одним хорошим ресурсом є книга &ldquo;Learn C The Hard Way&rdquo; (наявна тільки англійською).</p>

<p>На деякі часті запитання дасть відповідь англомовний ресурс <a href="http://c-faq.com">compl.lang.c Frequently Asked Questions</a>.</p>

<p>Нагадаю, що важливо використовувати правильні інтервали, відступи та загалом мати узгоджений стиль коду.
Зручний для читання код краще, ніж складний код або зроблений нашвидкоруч. За прикладом можна звернутись до
<a href="https://www.kernel.org/doc/Documentation/process/coding-style.rst">Linux kernel coding style</a>.</p>

<p>Щодо всього іншого, Ґуґл на допомогу!</p>

<p>[1] <a href="http://stackoverflow.com/questions/119123/why-isnt-sizeof-for-a-struct-equal-to-the-sum-of-sizeof-of-each-member">Чому розмір структури не дорівнює сумі розмірів її полів? (англ.)</a></p>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/uk-ua/c-ua.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by Adam Bard, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/uk-ua/c-ua.html.markdown">7 contributor(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://adambard.com/">Adam Bard</a>,
        <a href="http://twitter.com/H2CO3_iOS">Árpád Goretity</a>,
        <a href="http://cbs.stgn.pl">Jakub Trzebiatowski</a>,
        <a href="https://marcoms.github.io">Marco Scannadinari</a>,
        <a href="https://github.io/zfergus2">Zachary Ferguson</a>,
        <a href="https://github.com/himanshu81494">himanshu</a>,
        <a href="https://github.com/JoshuaRLi">Joshua Li</a>,
        <a href="https://github.com/dchirila">Dragos B. Chirila</a>
    </p>

    <p>
      Translated by:
        <a href="https://github.com/AstiaSun">AstiaSun</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>

        <script>
            var _gaq=[['_setAccount','UA-3525624-21'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>
</html>
