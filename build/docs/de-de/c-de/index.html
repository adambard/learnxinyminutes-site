<!DOCTYPE html lang="de-de" xml:lang="de-de" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="de-de">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn C in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/de-de/c-de/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fde-de%2Fc-de%2F&text=Lerne+X+in+Y+Minuten%2C+wobei+X%3DC">
        Teile diese Seite mit anderen
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Thema wählen:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">licht</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dunkles</button>
  </div>
  <h1><a href="/">Lerne X in Y Minuten</a></h1>
  <h2>Wobei X=C</h2>
    <p class="filelink">
    Lade den Code herunter:
    <a href="/docs/files/learnc-de.c">learnc-de.c</a>
    </p>
  <div id="doc">
    <p>Ach, C. Immer noch <strong>die</strong> Sprache für modernes High-Performance Computing.</p>

<p>C ist wahrscheinlich die Programmiersprache mit dem niedrigsten Abstraktionsnvieau,
welche die meisten Programmierer je brauchen werden.
Die Geschwindigkeit von C ist enorm, allerdings muss man sich stets der
manuellen Speicherverwaltung bewusst sein.</p>

<blockquote>
<p><strong>Über Compiler Optionen</strong></p>

<p>Standardmäßig sind <code>gcc</code> und <code>clang</code> ziemlich ruhig bezüglich Warnungen und 
Fehlern, obwohl dies sehr nützliche Informationen sein können. Es wird
empfohlen, strengere Compiler Optionen zu verwenden. Hier sind einige empfohlene
Standards:
<code>-Wall -Wextra -Werror -O2 -std=c99 -pedantic</code></p>

<p>Da gewisse Optionen (inbesondere der C-Standard) sehr stark vom Projekt
abhängen, lohnt es sich, wenn die unterschiedlichen Optionen genauer
angeschaut werden. Eine Übersicht über die Compiler-Optionen findet man unter
<a href="https://stackoverflow.com/questions/3375697/useful-gcc-flags-for-c">diesem</a> Stackoverflow-Beitrag.</p>

<p>Für weitere Informationen, was diese und weitere Optionen genau machen,
sollte die Man-Page des C-Compilers aufgerufen werden (z.B. <code>man 1 gcc</code>).
Alternativ kann auch online nach den unterschiedlichen Optionen gesucht werden.</p>
</blockquote>
<div class="highlight"><pre class="highlight c"><code><span class="c1">// einzeilige Kommentare starten mit // - nur in C99 und später vorhanden.</span>

<span class="cm">/*
mehrzeilige Kommentare sehen so aus. Diese funktionieren auch in C89
*/</span>

<span class="cm">/* 
mehrzeilige Kommentare können nicht verschachtelt werden /* Sei Vorsichtig! */</span> <span class="c1">// Kommentar endet auf dieser Linie ...</span>
<span class="err">*/</span> <span class="c1">// ... nicht bei dieser!</span>

<span class="c1">// Konstanten: #define &lt;keyword&gt;</span>
<span class="c1">// Konstanten werden laut der Konvention immer in GROSSBUCHSTABEN geschrieben</span>
<span class="cp">#define DAYS_IN_YEAR 365
</span>
<span class="c1">// Konstanten können auch als Aufzählungskonstanten (Enums) definiert werden.</span>
<span class="c1">// Alle Anweisungen müssen mit einem Semikolon beendet werden.</span>
<span class="k">enum</span> <span class="n">days</span> <span class="p">{</span><span class="n">SUN</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MON</span><span class="p">,</span> <span class="n">TUE</span><span class="p">,</span> <span class="n">WED</span><span class="p">,</span> <span class="n">THU</span><span class="p">,</span> <span class="n">FRI</span><span class="p">,</span> <span class="n">SAT</span><span class="p">};</span>
<span class="c1">// MON wird automatisch zu 2, TUE zu 3 etc.</span>

<span class="c1">// Importiere Header-Dateien mit #include</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="c1">// Dateien, welche zwischen &lt;spitzen Klammern&gt; stehen, sind Header-Dateien aus</span>
<span class="c1">// der C-Standard-Bibliothek.</span>
<span class="c1">// Für deine eigenen Header müssen Anführungszeichen verwendet werden, z.B.:</span>
<span class="c1">// #include "mein_header.h"</span>

<span class="c1">// Funktionssignaturen werden entweder vorher in einer .h-Datei deklariert oder</span>
<span class="c1">// am Anfang der .c-Datei.</span>
<span class="kt">void</span> <span class="nf">function_1</span><span class="p">();</span>
<span class="kt">int</span> <span class="nf">funkcion_2</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="c1">// Es muss ein Funktionsprototyp deklariert werden vor der `main()` Funktion,</span>
<span class="c1">// wenn die Funktion nach der `main()` Funktion gebraucht wird.</span>
<span class="kt">int</span> <span class="nf">add_two_ints</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">);</span> <span class="c1">// Funktionsprototyp</span>
<span class="c1">// Auch wenn der Ausdrck `int add_two_ints(int, int)` auch valid wäre, </span>
<span class="c1">// ist es empfohlen, dass man die Namen der Argumente hinschreibt für eine</span>
<span class="c1">// einfachere Analyse.</span>

<span class="c1">// Der Einstiegspunkt deines Programms ist eine Funktion mit dem Namen main und </span>
<span class="c1">// einem Integer als Rückgabewert.</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// dein Programm</span>
<span class="p">}</span>

<span class="c1">// Die Kommandozeilenargumente, welche gebraucht werden, damit dein Programm </span>
<span class="c1">// läuft, werden als Argumente der `main`-Funktion mitgegeben.</span>
<span class="c1">// argc (argument counter) steht für die Anzahl von Argumenten.</span>
<span class="c1">// Der Programmname ist das erste Argument.</span>
<span class="c1">// argv (argument vector) ist ein Array von Zeichenarrays, welche die</span>
<span class="c1">// Argumente beinhaltet.</span>
<span class="c1">// argv[0] = Name des Programms</span>
<span class="c1">// argv[1] = erstes Argument usw.</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Ausgabe mit Hilfe von printf (print formatted)</span>
    <span class="c1">// %d ist ein Integer.</span>
    <span class="c1">// \n steht für eine neue Zeile</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// =&gt; Gibt 0 aus.</span>

    <span class="c1">////////////////////////////////////////////////</span>
    <span class="c1">// Operatoren</span>
    <span class="c1">////////////////////////////////////////////////</span>

    <span class="c1">// Kurzschreibweise für mehrere Deklarationen</span>
    <span class="kt">int</span> <span class="n">i1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">flaot</span> <span class="n">f1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">f2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// Arithmetik ist unkompliziert</span>
    <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 3</span>
    <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>
    <span class="mi">2</span> <span class="o">*</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 2</span>
    <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 0 (0.5, aber abgeschnitten, da es int sind.)</span>

    <span class="c1">// Man muss mindestens ein Integer zu einen float konvertieren, damit man als</span>
    <span class="c1">// Resultat eine Gleitkommazahl erhält.</span>
    <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 0.5f</span>
    <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 0.5 // das gleiche mit dem Typ `double`</span>
    <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span> <span class="c1">// =&gt; 0.5, plus oder minus Epsilon</span>
    <span class="c1">// Gleitkommazahlen und deren Berechnungen sind nicht exakt.</span>

    <span class="c1">// Es gibt auch die Möglichkeit, Modulo zu rechnen</span>
    <span class="mi">11</span> <span class="o">%</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// =&gt; 2</span>

    <span class="c1">// Vergleichsoperatoren sind vielleicht schon bekannt, aber in C gibt es</span>
    <span class="c1">// keinen Boolean-Typ. In C verwenden wir `int`. (Oder _Bool oder bool in C99)</span>
    <span class="c1">// 0 ist falsch, alles andere ist wahr (Die Vergleichsoperatoren ergeben</span>
    <span class="c1">// immer 1 oder 0.</span>
    <span class="mi">3</span> <span class="o">==</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 0 (falsch)</span>
    <span class="mi">3</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 1 (wahr)</span>
    <span class="mi">3</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>
    <span class="mi">3</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 0</span>
    <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>
    <span class="mi">2</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>

    <span class="c1">// C ist nicht Python - Vergleiche können nicht einfach verkettet werden.</span>
    <span class="c1">// Warnung: die folgende Zeile wird kompilieren, aber es bedeutet `(0 &lt; a) &lt; 2`.</span>
    <span class="c1">// Dieser Ausdruck ist immer wahr, weil (0 &lt; a) kann entweder 1 oder 0 sein.</span>
    <span class="c1">// In diesem Falle ist es 1, weil (0 &lt; 1).</span>
    <span class="kt">int</span> <span class="n">zwischen_0_und_2</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span>
    <span class="c1">// Benutze stattdessen folgende Schreibweise:</span>
    <span class="kt">int</span> <span class="n">zwischen_0_und_2</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span>

    <span class="c1">// Logik funktioniert auch mit ints</span>
    <span class="o">!</span><span class="mi">3</span><span class="p">;</span> <span class="c1">// =&gt; 0 (logisches Nicht)</span>
    <span class="o">!</span><span class="mi">0</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>
    <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 1 (logisches Und)</span>
    <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 0</span>
    <span class="mi">0</span> <span class="o">||</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 1 (logisches Oder)</span>
    <span class="mi">0</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// =&gt; 0</span>

    <span class="c1">// Bedingter ternärer Ausdruck ( ? : )</span>
    <span class="kt">int</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">z</span><span class="p">;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="p">(</span> <span class="n">e</span> <span class="o">&gt;</span> <span class="n">f</span> <span class="p">)</span> <span class="o">?</span> <span class="n">e</span> <span class="o">:</span> <span class="n">f</span><span class="p">;</span> <span class="c1">// =&gt; // =&gt; 10 "wenn e &gt; f ist, gib e zurück, sonst f."</span>

    <span class="c1">// Inkrementierungs- und Dekrementierungsoperatoren</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">j</span><span class="o">++</span><span class="p">;</span> <span class="c1">// gib j zurück und erhöhe danach j. (s = 0, j = 1)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="o">++</span><span class="n">j</span><span class="p">;</span> <span class="c1">// erhöhe zuerst j und gib dann j zurück (s = 2, j = 2)</span>
    <span class="c1">// das gleiche gilt für j-- und --j</span>

    <span class="c1">// Bitweise Operatoren</span>
    <span class="o">~</span><span class="mh">0x0F</span><span class="p">;</span> <span class="c1">// =&gt; 0xFFFFFFF0 (Bitweise Negation, "Einer-Komplement",</span>
           <span class="c1">// Beispielresultat für 32-Bit int)</span>
    <span class="mh">0x0F</span> <span class="o">&amp;</span> <span class="mh">0xF0</span><span class="p">;</span> <span class="c1">// =&gt; 0x00 (Bitweises UND)</span>
    <span class="mh">0x0F</span> <span class="o">|</span> <span class="mh">0xF0</span><span class="p">;</span> <span class="c1">// =&gt; 0xFF (Bitweises ODER)</span>
    <span class="mh">0x04</span> <span class="o">^</span> <span class="mh">0x0F</span><span class="p">;</span> <span class="c1">// =&gt; 0x0B (Bitweises XOR)</span>
    <span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 0x02 (Bitweises  Linksverschiebung (left shift) (um 1))</span>
    <span class="mh">0x02</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 0x01 (Bitweises Rechtsverschiebung (right shift) (um 1))</span>

    <span class="c1">// Sei vorsichtig beim Shift mit vorzeichenbehafteten Integern</span>
    <span class="c1">// folgende Ausdrücke sind nicht definiert:</span>
    <span class="c1">// - Verschiebung in das Vorzeichenbit (int a = 1 &lt;&lt; 31)</span>
    <span class="c1">// - Linksshift einer negativen Zahl (int a = -1 &lt;&lt; 2)</span>
    <span class="c1">// - Shift um einen Offset, welcher &gt;= die Breite des linken Ausdrucks ist.</span>
    <span class="c1">// int a = 1 &lt;&lt; 32; // undefiniertes Verhalten, wenn int 32-Bit ist.</span>


    <span class="c1">////////////////////////////////////////////////</span>
    <span class="c1">// Typen</span>
    <span class="c1">////////////////////////////////////////////////</span>

    <span class="c1">// Compiler, welche nicht C99-kompatibel sind, verlangen, dass sämtliche</span>
    <span class="c1">// Variablen zu Beginn des Blocks deklariert werden.</span>
    <span class="c1">// C99-Konforme Compiler erlauben die Variablendeklaration an dem Punkt, an</span>
    <span class="c1">// welchem die Variable verwendet wird.</span>
    <span class="c1">// Wir deklarieren die Variablen dynamisch im Code um die Lesbarkeit im</span>
    <span class="c1">// Tutorial zu verbessern.</span>

    <span class="c1">// integer sind normalerweise 4 Bytes groß</span>
    <span class="kt">int</span> <span class="n">x_int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// shorts sind normalerweise 2 Bytes groß</span>
    <span class="kt">short</span> <span class="n">x_short</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// chars sind garantiert 1 Byte groß</span>
    <span class="kt">char</span> <span class="n">x_char</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">y_char</span> <span class="o">=</span> <span class="sc">'y'</span><span class="p">;</span> <span class="c1">// Charakterliterale werden mit '' gekennzeichnet.</span>

    <span class="c1">// longs sind oft 4 bis 8 Bytes groß. long long sind garantiert mindestens </span>
    <span class="c1">// 8 Bytes groß.</span>
    <span class="kt">long</span> <span class="n">x_long</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">x_long_long</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// floats sind normalerweise 32-Bit Gleitkommazahlen</span>
    <span class="kt">float</span> <span class="n">x_float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span> <span class="c1">// 'f'-Suffix beschreibt eine Gleitkommazahl.</span>

    <span class="c1">// doubles sind normalerweise 64-Bit Gleitkommazahlen</span>
    <span class="kt">double</span> <span class="n">x_double</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span> <span class="c1">// echte Zahlen ohne Suffix sind vom Typ double</span>

    <span class="c1">// integer-Typen können vorzeichenlos (unsigned) sein</span>
    <span class="c1">// (größer oder kleiner als 0)</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ux_short</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ux_int</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ux_long_long</span><span class="p">;</span>

    <span class="c1">// Zeichen innerhalb von einfachen Anführungszeichen sind Integers im</span>
    <span class="c1">// Maschinenzeichensatz</span>
    <span class="sc">'0'</span><span class="p">;</span> <span class="c1">// =&gt; 48 im ASCII-Zeichensatz</span>
    <span class="sc">'A'</span><span class="p">;</span> <span class="c1">// =&gt; 65 im ASCII-Zeichensatz</span>

    <span class="c1">// sizeof(T) gibt die Größe einer Variablen des Typen T in Bytes zurück.</span>
    <span class="c1">// sizeof(obj) ergibt die Größe des Ausdrucks (Variable, Literal usw.)</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"%zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span> <span class="c1">// =&gt; 4 (auf den Rechnern mit einem 4-Byte-Wort)</span>

    <span class="c1">// Wenn das Argument des `sizeof`-Operator ein Ausdruck ist, dann wird das</span>
    <span class="c1">// Argument nicht ausgewertet (außer Arrays mit variabler Länge)</span>
    <span class="c1">// Der Wert, der in diesem Fall zurückgegeben wird, ist eine Konstante zur </span>
    <span class="c1">// Kompillierzeit.</span>

    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="c1">//size_t ist ein vorzeichenloser Integer Typ mit mindestens 2 Byte um die </span>
    <span class="c1">// Größe eines Objekts zu repräsentieren.</span>
    <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="o">++</span><span class="p">);</span> <span class="c1">// a++ wird nicht ausgewertet</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"sizeof(a++) = %zu, wobei a=%d ist</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="c1">// Gibt "sizeof(a++) = 4, wobei a=1 ist" aus (mit einer 32-Bit-Architektur)</span>

    <span class="c1">// Arrays müssen mit einer Größe initialisiert werden.</span>
    <span class="kt">char</span> <span class="n">my_char_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span> <span class="c1">// Dieses Array beinhaltet 1 * 20 = 20 Bytes</span>
    <span class="kt">int</span> <span class="n">my_int_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span> <span class="c1">// Dieses Array beinhaltet 4 * 20 = 80 Bytes.</span>
    <span class="c1">// unter der Voraussetzung eines 4-Byte-Worts.</span>

    <span class="c1">// Ein Array kann auf diese Weise mit 0 initialisiert werden.</span>
    <span class="kt">char</span> <span class="n">my_array</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="c1">// Hierbei ist der Teil "{0}" der "Array Initialisierer".</span>
    <span class="c1">// Beachte, dass die Länge des Arrays nicht explizit definiert werden muss, </span>
    <span class="c1">// wenn er auf derselben Linie initialisiert wird.</span>
    <span class="c1">// Folgende Deklaration ist gleichwertig:</span>
    <span class="kt">char</span> <span class="n">my_array</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="c1">// Allerdings muss die Länge des Arrays dann zur Laufzeit ausgewertet werden:</span>
    <span class="kt">size_t</span> <span class="n">my_array_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_array</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="c1">// WARNUNG: Wenn dieser Ansatz gewählt wird, muss man sicherstellen, dass die</span>
    <span class="c1">// Größe des Arrays ermittelt werden *bevor* dieser einer Funktion als</span>
    <span class="c1">// Argument weitergegeben wird (siehe Diskussion weiter unten), weil Arrays</span>
    <span class="c1">// einer Funktion nur als Zeiger übergeben werden. =&gt; Das obere Statement</span>
    <span class="c1">// würde innerhalb einer Funktion ein falsches Resultat liefern.</span>

    <span class="c1">// Das Indexieren eines Arrays funktioniert wie in anderen Sprache - resp.</span>
    <span class="c1">// in anderen Sprachen funktioniert es gleich wie in C.</span>
    <span class="n">my_array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// =&gt; 0</span>

    <span class="c1">// Arrays sind veränderbar; es ist nur Arbeitsspeicher!</span>
    <span class="n">my_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">my_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// =&gt; 2</span>

    <span class="c1">// In C99 (und als optionales Feature in C11) können Arrays mit variabler</span>
    <span class="c1">// Länge deklariert werden. Die Größe eines solchen Array muss eine Konstante</span>
    <span class="c1">// zur Kompilierzeit sein.</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Geben Sie die Arraygröße an: "</span><span class="p">);</span> <span class="c1">//Frag den Benutzer nach</span>
                                              <span class="c1">// der Arraygröße</span>
    <span class="kt">int</span> <span class="n">array_size</span><span class="p">;</span>
    <span class="n">fcsanf</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">array_size</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">var_length_array</span><span class="p">[</span><span class="n">array_size</span><span class="p">];</span> <span class="c1">// deklariere Array mit variabler Länge</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"sizeof array =%zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">var_length_array</span><span class="p">);</span>

    <span class="c1">// Zum Beispiel:</span>
    <span class="c1">// &gt; Geben Sie die Arraygröße an: 10</span>
    <span class="c1">// &gt; sizeof array = 40</span>

    <span class="c1">// Strings sind lediglich Arrays von `chars`, welche mit einem Null-Byte</span>
    <span class="c1">// (0x00) beendet werden. In Strings wird das Nullbyte durch das Zeichen \0</span>
    <span class="c1">// repräsentiert. Wir müssen das Null-Byte nicht angeben in String-Literalen;</span>
    <span class="c1">// der Compiler fügt es am Ende des Array automatisch hinzu.</span>
    <span class="kt">char</span> <span class="n">a_string</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Das ist ein String"</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a_string</span><span class="p">);</span> <span class="c1">// %s formattiert einen String</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a_string</span><span class="p">[</span><span class="mi">18</span><span class="p">]);</span> <span class="c1">// =&gt; 0</span>
    <span class="c1">// Hier ist das Byte #19 0 (wie auch Byte #20)</span>

    <span class="c1">// Wenn wir Zeichen zwischen einfachen Anführungszeichen haben, ist es ein</span>
    <span class="c1">// Zeichenliteral vom Typ int und *nicht* char. (aus historischen Gründen)</span>
    <span class="kt">int</span> <span class="n">cha</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span> <span class="c1">// Ok</span>
    <span class="kt">char</span> <span class="n">chb</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span> <span class="c1">// auch ok (implizite Umwandlung von int zu char)</span>

    <span class="c1">// Mehrdimensionale Arrays:</span>
    <span class="kt">int</span> <span class="n">multi_array</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">0</span><span class="p">}</span>
    <span class="p">};</span>
    <span class="c1">// Auf Elemente zugreifen:</span>
    <span class="kt">int</span> <span class="n">array_int</span> <span class="o">=</span> <span class="n">multi_array</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// =&gt; 3</span>

    <span class="c1">////////////////////////////////////////////////</span>
    <span class="c1">// Kontrollstrukturen</span>
    <span class="c1">////////////////////////////////////////////////</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Ich werde nie ausgeführt."</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Ich werde auch nie ausgeführt."</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Ich gebe etwas aus."</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// While-Schleifen existieren auch</span>
    <span class="kt">int</span> <span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">ii</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// JEDER Wert unter zehn ist wahr</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d, "</span> <span class="n">ii</span><span class="o">++</span><span class="p">);</span> <span class="c1">//i++ inkrementiert ii NACHDEM der Wert gebraucht</span>
                             <span class="c1">// wurde.</span>
    <span class="p">}</span> <span class="c1">// =&gt; gibt folgendes aus: "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">kk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d, "</span><span class="p">,</span> <span class="n">kk</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="o">++</span><span class="n">kk</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">);</span> <span class="c1">//++kk inkrementiert kk BEVOR der Wert gebraucht wurde.</span>
    <span class="c1">// =&gt; gibt folgendes aus: "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="c1">// In C gibt es auch for-Schleifen</span>
    <span class="kt">int</span> <span class="n">jj</span><span class="p">;</span> 
    <span class="k">for</span> <span class="p">(</span><span class="n">jj</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">jj</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">jj</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d, "</span><span class="p">,</span> <span class="n">jj</span><span class="p">);</span>
    <span class="p">}</span> <span class="c1">// =&gt; gibt folgendes aus: "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="c1">// **Merke**</span>
    <span class="c1">// Schleifen und Funktionen müssen einen Rumpf haben. Wenn kein Rumpf gebraucht</span>
    <span class="c1">// wird, kann folgendes gemacht werden:</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span> 
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">;</span> <span class="c1">// Semikolon wird als Rumpf behandelt (Null-Anweisung)</span>
    <span class="p">}</span>
    <span class="c1">// Alternativ kann auch folgendes geschrieben werden:</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">);</span>

    <span class="c1">// Verzweigungen mit mehreren Möglichkeiten: `switch()`</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="mi">0</span><span class="p">:</span> <span class="c1">// Labels müssen integrale *konstante* Ausdrücke sein (z.B. Enums)</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"Hey, 'a' ist gleich 0!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span> <span class="c1">//Wenn du kein break einsetzt, so geht der Kontrollfluss</span>
                   <span class="c1">// durch die Labels</span>
        <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"Huh, 'a' ist gleich 1!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
            <span class="c1">// Sei vorsichtig - wenn man das `break` vergisst, werden alle </span>
            <span class="c1">// Anweisungen ausgeführt bis das nächste `break` erscheint.</span>
        <span class="k">case</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">case</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"Schau mal ... 'a' ist entweder 3 oder 4.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="nl">default:</span>
            <span class="c1">// wenn der Ausdruck `a` auf kein Label zutrifft.</span>
            <span class="n">fputs</span><span class="p">(</span><span class="s">"Fehler!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">////////////////////////////////////////////////</span>
    <span class="c1">// Typenumwandlung</span>
    <span class="c1">////////////////////////////////////////////////</span>

    <span class="c1">// Jeder Wert in C hat einen bestimmten Typen, aber es ist möglich, ein </span>
    <span class="c1">// Wert in einen anderen Typ umzuwandeln (mit einigen Einschränkungen).</span>

    <span class="kt">int</span> <span class="n">x_hex</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span> <span class="c1">// Es ist möglich, Variablen Hexadezimalwerten zuzuweisen.</span>

    <span class="c1">// Bei der Umwandlung zwischen Typen wird versucht, den numerischen Wert</span>
    <span class="c1">// beizubehalten.</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x_hex</span><span class="p">);</span> <span class="c1">// =&gt; 1</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">short</span><span class="p">)</span> <span class="n">x_hex</span><span class="p">);</span> <span class="c1">// =&gt; 1</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="n">x_hex</span><span class="p">);</span> <span class="c1">// =&gt; 1</span>

    <span class="c1">// Typen werden überlaufen (overflow) ohne jegliche Warnung</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="mi">257</span><span class="p">);</span> <span class="c1">// =&gt; 1 (Max char=255 wenn char 8 Bit ist)</span>

    <span class="c1">// Um den maximalen Wert eines `char`, `signed char` oder `unsigned char` </span>
    <span class="c1">// herauszufinden, können die Makros `CHAR_MAX`, `SCHAR_MAX` und `UCHAR_MAX`</span>
    <span class="c1">// aus der Header-Datei `&lt;limits.h&gt;` verwendet werden.</span>

    <span class="c1">// Integer-Typen können zu Gleitkommazahlen und umgekehrt umgewandelt werden.</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="mi">100</span><span class="p">);</span> <span class="c1">// %f formattiert immer zu einem `double`...</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="n">flaot</span><span class="p">)</span> <span class="mi">100</span><span class="p">);</span> <span class="c1">// ... auch mit einem `float`</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mi">100</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span> 

    <span class="c1">////////////////////////////////////////////////</span>
    <span class="c1">// Zeiger (aka Pointer)</span>
    <span class="c1">////////////////////////////////////////////////</span>

    <span class="c1">// In diesem Tutorial wird das deutsche Wort Zeiger nicht verwendet, da es</span>
    <span class="c1">// bei einer weiteren Recherche einfacher ist, wenn man von Pointern ausgeht.</span>
    <span class="c1">// Außerdem ist der Begriff Pointer auch im deutschen Sprachgebrauch zu finden.</span>

    <span class="c1">// Ein Pointer ist eine Variable, welche deklariert wurde, um eine Speicher-</span>
    <span class="c1">// adresse zu speichern. Die Deklaration eines Pointers wird auch zeigen,</span>
    <span class="c1">// auf welche Art von Daten der Pointer zeigt. Man kann die Speicheradresse</span>
    <span class="c1">// von Variablen abrufen und dann mit diesen herumspielen.</span>

    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
    <span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span> <span class="c1">// verwende &amp; um die Adresse der Variable</span>
    <span class="c1">// zu erhalten</span>
    <span class="c1">// %p  formattiert einen Objektpointer des Typen void*)</span>
    <span class="c1">// =&gt; Gibt eine Adresse im Speicher aus</span>

    <span class="c1">// Pointer starten mit einem * zu Beginn der Deklaration.</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">px</span><span class="p">,</span> <span class="n">not_a_pointer</span><span class="p">;</span> <span class="c1">// px ist ein Pointer zu einem int.</span>
    <span class="n">px</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span> <span class="c1">// Speichert die Adresse von x in px</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">px</span><span class="p">);</span> <span class="c1">// =&gt; Gibt eine Adresse im Speicher aus</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%zu, %zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">px</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">not_a_pointer</span><span class="p">));</span>
    <span class="c1">// Gibt auf einem typischen 64-Bit-System folgendes aus: "8, 4"</span>

    <span class="c1">// Um den Wert einer Adresse, auf welche ein Pointer zeigt, herauszufinden, </span>
    <span class="c1">// muss man vor die Variable ein * setzen, um sie zu dereferenzieren.</span>
    <span class="c1">// Notiz: Ja, es kann verwirrend sein, dass '*' sowohl für das Deklarieren</span>
    <span class="c1">// als auch das Derefenzieren verwendet werden kann.</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">px</span><span class="p">);</span> <span class="c1">// =&gt; 0, der Wert von x</span>

    <span class="c1">// Man kann den Wert, auf welchen ein Pointer zeigt, auch verändern.</span>
    <span class="c1">// Man muss die Dereferenzierung in Klammern setzen, weil ++ eine höhere </span>
    <span class="c1">// Priorität als * hat.</span>
    <span class="p">(</span><span class="o">*</span><span class="n">px</span><span class="p">)</span><span class="o">++</span><span class="p">;</span> <span class="c1">// Inkrementiere den Wert, auf welchen px zeigt, um 1</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">px</span><span class="p">);</span> <span class="c1">// =&gt; 1</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// =&gt; 1</span>

    <span class="c1">// Arrays sind eine gute Möglichekit, einen zusammenhängenden Block von</span>
    <span class="c1">// Speicher zu allozieren.</span>
    <span class="kt">int</span> <span class="n">x_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span> <span class="c1">// deklariert einen Array der Größe 20 (Größe kann</span>
    <span class="c1">// nicht geändert werden.)</span>
    <span class="kt">int</span> <span class="n">xx</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">xx</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">xx</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">xx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x_array</span><span class="p">[</span><span class="n">xx</span><span class="p">]</span>  <span class="mi">20</span> <span class="o">-</span><span class="n">xx</span><span class="p">;</span>
    <span class="p">}</span> <span class="c1">// Initialisiere x_array zu 20, 19, 18, ... 2, 1</span>

    <span class="c1">// Deklariere ein Pointer des Typs int und initalisiere ihn, um auf `x_array`</span>
    <span class="c1">// zu zeigen.</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">x_ptr</span> <span class="o">=</span> <span class="n">x_array</span><span class="p">;</span>
    <span class="c1">// x_ptr zeigt jetzt auf den ersten Wert innerhalb des Arrays (int 20)</span>
    <span class="c1">// Das funktioniert, weil Arrays oft zu Pointern reduziert werden, welche</span>
    <span class="c1">// auf das erste Element zeigen.</span>
    <span class="c1">// Zum Beispiel: Wenn ein Array einer Funktion mitgegeben wird oder einem</span>
    <span class="c1">// Pointer zugewiesen wird, wird es zu einem Pointer reduziert (implizites Casting)</span>
    <span class="c1">// Ausnahme: Wenn das Array das Argument des Operators `&amp;` ist.</span>
    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr_to_arr</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">;</span> <span class="c1">//`&amp;arr` ist nicht vom Typ `int *`!</span>
    <span class="c1">// Es ist vom Typem "Pointer auf Array" (aus zehn `int`s)</span>
    <span class="c1">// oder wenn das Array ein Stringliteral ist, welches gebraucht wird um ein</span>
    <span class="c1">// `char`-Array zu initialisieren.</span>
    <span class="kt">char</span> <span class="n">other_arr</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"foobarbazquirk"</span><span class="p">;</span>
    <span class="c1">// oder wenn es das Argument des `sizeof` oder `alignof` Operators ist.</span>
    <span class="kt">int</span> <span class="n">third_array</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">third_array</span><span class="p">;</span> <span class="c1">// gleich wie: `int *ptr = &amp;arr[0]`</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%zu, %zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">third_array</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ptr</span><span class="p">));</span>
    <span class="c1">// Gibt wahrscheinlich "40, 4" oder "40, 8" aus</span>

    <span class="c1">// Pointer werden basierend auf dem Typ in- und dekrementiert</span>
    <span class="c1">// Dies wird Pointer-Arithmetik genannt.</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">x_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span> <span class="c1">// =&gt; 19</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// =&gt; 19</span>

    <span class="c1">// Man kann zusammenhängende Speicherblöcke auch mit der Funktion `malloc`</span>
    <span class="c1">// aus der Standardbibliothek dynamisch allozieren. Der Funktion `malloc` </span>
    <span class="c1">// muss ein Argument des Typs `size_t` übergeben werden, welches bestimmt, </span>
    <span class="c1">// wie viele Bytes alloziert werden sollen. (Normalerweise geschieht dies</span>
    <span class="c1">// aus dem Heap - dies kann auf eingebetteten Systemen unterschiedlichen sein.</span>
    <span class="c1">// Der C Standard sagt nichts darüber.)</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">my_ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">my_ptr</span><span class="p">)</span> <span class="o">*</span> <span class="mi">20</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">xx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">xx</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">xx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="p">(</span><span class="n">my_ptr</span> <span class="o">+</span> <span class="n">xx</span><span class="p">)</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">-</span><span class="n">xx</span><span class="p">;</span> <span class="c1">//my_ptr[xx] = 20-xx</span>
    <span class="p">}</span> <span class="c1">// initialisiere Speicher zu 20, 19, 18, 17, ... 2, 1 (als `int`)</span>

    <span class="c1">// Sei vorsichtig beim Übergeben von Benutzerdefinierten Werten an `malloc`.</span>
    <span class="c1">// Wenn du sicher sein willst, kannst du die Funktion `calloc` nutzen, welche</span>
    <span class="c1">// (nicht wie `malloc`) auch den Speicher nullt.</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">my_other_ptr</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

    <span class="c1">// Merke, dass es in C keinen Standard-Weg gibt, um die Länge eines dynamisch</span>
    <span class="c1">// allozierten Arrays zu bestimmen. Auf Grund dessen sollte eine Variable </span>
    <span class="c1">// erstellt werden, welche sich die Anzahl der Elemente im Array merkt, wenn</span>
    <span class="c1">// die Arrays mehrmals im Programm gebraucht werden.</span>
    <span class="c1">// Weitere Informationen stehen im Abschnitt Funktionen.</span>
    <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">my_array</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="c1">// Füge dem Array ein Element hinzu </span>
    <span class="n">size</span><span class="o">++</span><span class="p">;</span>
    <span class="n">my_array</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">my_array</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">size</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">my_array</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Denke daran, realloc-Fehler zu prüfen</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="n">my_array</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="c1">// Das Dereferenzieren von nicht alloziertem Speicher führt zu einem </span>
    <span class="c1">// Undefinierten Verhalten.</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">my_ptr</span> <span class="o">+</span> <span class="mi">21</span><span class="p">));</span> <span class="c1">// Gibt irgendwas aus.</span>
    <span class="c1">// Das Programm kann auch abstürzen</span>

    <span class="c1">// Nachdem du fertig mit einem Block bist, welcher `malloc` verwendet hat, </span>
    <span class="c1">// muss der Speicher befreit werden. Ansonsten kann dieser Speicherbereich</span>
    <span class="c1">// niemand nutzen bis dein Programm beendet wird.</span>
    <span class="c1">// Dies wird auch als "Speicherleck" (engl: memory leak) bezeichnet.</span>
    <span class="n">free</span><span class="p">(</span><span class="n">my_ptr</span><span class="p">);</span>

    <span class="c1">// Obwohl Strings normalerweise als Pointer-to-Char (Pointer zum ersten</span>
    <span class="c1">// Zeichen des Arrays) repräsentiert werden, sind Strings Arrays aus `char`s.</span>
    <span class="c1">// Es ist eine gute Praxis, `const char *` zu verwenden, wenn man ein</span>
    <span class="c1">// String-Literal referenziert, da String-Literale nicht modifiziert werden</span>
    <span class="c1">// sollten (z.B. "foo"[0] = 'a' ist ILLEGAL)</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">my_str</span> <span class="o">=</span> <span class="s">"Das ist mein eigener String"</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%c</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">my_str</span><span class="p">);</span> <span class="c1">// =&gt; D</span>

    <span class="c1">// Dies ist nicht der Fall, wenn der String ein Array (möglicherweise mit</span>
    <span class="c1">// einem String-Literal initialisiert) ist, welcher im beschreibbaren Speicher</span>
    <span class="c1">// bleibt, wie zum Beispiel in:</span>
    <span class="kt">char</span> <span class="n">foo</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"foo"</span><span class="p">;</span>
    <span class="n">foo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span> <span class="c1">// Dies ist legal, foo enthält jetzt "aoo"</span>

    <span class="n">function_1</span><span class="p">();</span>
<span class="p">}</span> <span class="c1">// Ende der `main`-Funktion</span>

<span class="c1">////////////////////////////////////////////////</span>
<span class="c1">// Funktionen</span>
<span class="c1">////////////////////////////////////////////////</span>

<span class="c1">// Syntax einer Funktionsdeklaration</span>
<span class="c1">// &lt;rueckgabe_wert&gt; &lt;funktions_name&gt;(&lt;args&gt;)</span>

<span class="kt">int</span> <span class="nf">add_two_ints</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="p">;</span> <span class="c1">// verwendet return, um einen Wert zurückzugeben</span>
<span class="p">}</span>

<span class="cm">/* 
Funktionen werden auf Grund des Wertes aufgerufen (call-by-value). Wenn eine 
Funktion aufgerufen wird, sind die Argumente Kopien der ursprünglichen Werte
(ausgenommen Arrays). Alles, was man innerhalb einer Funktion mit den Werten 
macht, hat keinen Einfluss auf die Originalwerte als die Funktion aufgerufen
wurde.

Verwende Pointer, um den Originalinhalt zu bearbeiten.

Beispiel:
*/</span>

<span class="c1">// Eine `void`-Funktion gibt keinen Wert zurück</span>
<span class="kt">void</span> <span class="nf">str_reverse</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str_in</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
    <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str_in</span><span class="p">);</span>
    <span class="c1">// `strlen()` ist ein Teil der C Standard-Bibliothek.</span>
    <span class="c1">// Merke: Die Länge, welche von `strlen` zurückgegeben wird, ist ohne den </span>
    <span class="c1">// Null-Byte Terminator.</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">ii</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// in C99 kann man `ii` hier deklarieren.</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">str_in</span><span class="p">[</span><span class="n">ii</span><span class="p">];</span>
        <span class="n">str_in</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">str_in</span><span class="p">[</span><span class="n">size</span> <span class="o">-</span> <span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">//#ii'tes Zeichen vom Ende her</span>
        <span class="n">str_in</span><span class="p">[</span><span class="n">size</span> <span class="o">-</span> <span class="n">ii</span><span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// Merke: Die `string.h`-Headerdatei muss inkludiert werden, bevor `strlen()`</span>
<span class="c1">// verwendet werden kann.</span>

<span class="cm">/*
char c[] = "Das ist ein Test";
str_reverse(c);
printf("%s\n", c), =&gt; "tseT nie tsi saD"
*/</span>

<span class="c1">// Weil wir lediglich eine Variable zurückgeben können, kann zum Ändern mehrerer</span>
<span class="c1">// Variablen das Konzept call-by-reference verwendet werden.</span>
<span class="kt">void</span> <span class="nf">swap_two_numbers</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
    <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
    <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> 
<span class="kt">int</span> <span class="n">seconde</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Erste Zahl: %d</span><span class="se">\n</span><span class="s"> Zweite Zahl: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">);</span>
<span class="n">swap_two_numbers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">first</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">second</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Erste Zahl: %d</span><span class="se">\n</span><span class="s"> Zweite Zahl: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">);</span>
<span class="c1">// Werte sind vertauscht.</span>

<span class="cm">/*
Wenn man Arrays betrachtet, so werden diese immer als Pointer übergeben. Auch
wenn die Arrays statisch alloziert werden (wie zum Beispiel `arr[10]`), werden
diese als Pointer zum ersten Element des Arrays übergeben.
Auch hier soll noch einmal erwähnt werden, dass es keinen Standard gibt, wie die 
Größe eines dynamischen Arrays herausgefunden werden kann.
*/</span>
<span class="c1">// Die Größe des Arrays muss unbedingt mitgegeben werden.</span>
<span class="c1">// Sonst hat die Funktion keine Ahnung wie groß das Array ist.</span>
<span class="kt">void</span> <span class="nf">print_int_arrray</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"arr[%d] ist %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">my_array</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">print_int_array</span><span class="p">(</span><span class="n">my_array</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="c1">// Wird folgendes ausgeben: "arr[0] ist 1" usw.</span>

<span class="c1">// Wenn man auf externe Variable (außerhalb der Funktion) referenziert, sollte</span>
<span class="c1">// man das Schlüsselwort `extern` verwenden.</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">test_function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">extern</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// i braucht nun die externe Variable i</span>
<span class="p">}</span>

<span class="c1">// Das Schlüsselwort `static` macht, dass eine Variable außerhalb der Kompilier-</span>
<span class="c1">// einheit nicht zugreifbar ist.  (Auf den meisten Systemen ist eine Kompiliereinheit</span>
<span class="c1">// eine `.c`-Datei.) Das Schlüsselwort `static` kann sowohl bei globalen</span>
<span class="c1">// (zur Kompiliereinheit gehörende) Variablen, Funktionen und Funktionslokale</span>
<span class="c1">// Variablen angewendet werden.</span>
<span class="c1">// Wenn man `static` bei lokalen Variablen verwendet, so ist diese Variable global</span>
<span class="c1">// erreichbar und behält dessen Wert über Funktionsaufrufe hinweg, aber sie ist </span>
<span class="c1">// nur innerhalb der deklarierten Funktion verfügbar. Außerdem werden statische</span>
<span class="c1">// Variablen mit 0 initialisiert, wenn sie nicht mit einem anderen Startwert </span>
<span class="c1">// initialisiert werden.</span>
<span class="c1">// Es ist auch möglich, Funktionen als statisch zu deklarieren, damit diese</span>
<span class="c1">// `private` sind. Privat heißt, dass sie nur in diesem Kontekt sichtbar sind.</span>


<span class="c1">////////////////////////////////////////////////</span>
<span class="c1">// Benutzerdefinierte Typen und Strukturen (Structs)</span>
<span class="c1">////////////////////////////////////////////////</span>

<span class="c1">// `typedef`s können verwendet werden, um Typenaliase zu erstellen.</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">my_type</span><span class="p">;</span>
<span class="n">my_type</span> <span class="n">my_type_var</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// Structs sind lediglich Sammlungen von Daten, die Inhalte werden</span>
<span class="c1">// (in der Reihenfolge wie sie geschrieben wurden) sequentiell alloziert.</span>
<span class="k">struct</span> <span class="n">rectangle</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">width</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">height</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Allgemein ist es nicht so, dass folgender Ausdruck wahr ist.</span>
<span class="c1">// sizeof(struct rectangle) == sizeof(int) + sizeof(int)</span>
<span class="c1">// Dies ist so, weil potentiell ein Padding zwischen den Struktur-Inhalten</span>
<span class="c1">// möglich ist). (siehe [1, Englisch])</span>

<span class="kt">void</span> <span class="nf">function_1</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">rectangle</span> <span class="n">my_rectangle</span><span class="p">;</span>

    <span class="c1">// Greife auf Struct-Inhalte mit `.` zu.</span>
    <span class="n">my_rectangle</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">my_rectangle</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

    <span class="c1">// Du kannst Pointer zu Structs deklarieren.</span>
    <span class="k">struct</span> <span class="n">rectangle</span> <span class="o">*</span><span class="n">my_rectangle_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_rectangle</span><span class="p">;</span>

    <span class="c1">// Verwende Dereferenzierung, um Struct-Inhalte zu bearbeiten</span>
    <span class="p">(</span><span class="o">*</span><span class="n">my_rectangle_ptr</span><span class="p">).</span><span class="n">width</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span> 

    <span class="c1">//Noch besser: Verwende die Kurzschreibweise -&gt;, um die Lesbarkeit zu</span>
    <span class="c1">// verbessern.</span>
    <span class="n">my_rectangle_ptr</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// Gleich wie: (*my_rectangle_ptr).height = 10;</span>
<span class="p">}</span>

<span class="c1">// Aus Bequemlichkeitsgründen ist es möglich einem `struct` ein `typedef` hinzuzufügen.</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">rectangle</span> <span class="n">rect</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">area</span><span class="p">(</span><span class="n">rect</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">r</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Wenn du große Structs hast, kannst du diese mit dem Pointer kopieren, </span>
<span class="c1">// damit große Kopiervorgänge vermieden werden.</span>
<span class="kt">int</span> <span class="nf">area_ptr</span><span class="p">(</span><span class="k">const</span> <span class="n">rect</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">*</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////</span>
<span class="c1">// Funktionspointer</span>
<span class="c1">////////////////////////////////////////////////</span>

<span class="cm">/* 
Zur Laufzeit sind Funktionen in einer Speicheradresse gespeichert. 
Funktionspointer sind wie normale Pointer (es wird einfach eine Speicheradresse 
gespeichert). Funktionspointer können verwendet werden, um Funktionen und
Handler (oder Callback-Funktionen) direkt aufzurufen.
Wie auch immer, die Syntax kann zu Beginn verwirrend wirken.

Zum Beispiel: Verwende str_reverse von einem Pointer 
*/</span>
<span class="kt">void</span> <span class="nf">str_reverse_through_pointer</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str_in</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Definiere eine Funktionspointer-Variable, welche f genannt wird.</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span> <span class="c1">// Signatur sollte genau der Funktion entsprechen.</span>
    <span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">str_reverse</span><span class="p">;</span> <span class="c1">// weise die Adresse der wirklichen Funktion zu</span>
                      <span class="c1">// (zur Laufzeit bestimmt)</span>
    <span class="c1">// `f = str_reverse;` würde auch funktionieren, da Funktionen zu Pointern</span>
    <span class="c1">// reduziert werden (ähnlich wie Arrays)</span>
    <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="n">str_in</span><span class="p">);</span> <span class="c1">// Die Funktion einfach mit dem Pointer aufrufen</span>
    <span class="c1">// f(str_in); // Dies ist eine weitere gültige Alternative um eine Funktion</span>
                  <span class="c1">// auzurufen.</span>
<span class="p">}</span>

<span class="cm">/*
Solange die Signaturen der Funktionen übereinstimmen, kann man sämtliche Funktionen
demselben Pointer zuweisen. Funktionspointer sind auf Grund der Einfacheit und
Leserlichkeit normalerweise wie folgt `typedef`d 
*/</span>
<span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">my_fnp_type</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="c1">// Danach werden diese genutzt, um die wirkliche Pointervariable zu deklarieren.</span>
<span class="c1">// ..</span>
<span class="c1">// my_fnp_type f;</span>

<span class="c1">// Spezialzeichen</span>
<span class="c1">// Im folgenden sin die englischen Begriffe jeweils in Klammern geschrieben,</span>
<span class="c1">// da diese Begriffe auch im deutschten Sprachgebrauch verwendet werden.</span>
<span class="sc">'\a'</span><span class="p">;</span> <span class="c1">// Alarmzeichen (alert (bell) character)</span>
<span class="sc">'\n'</span><span class="p">;</span> <span class="c1">// Zeichen für neue Linie (newline character)</span>
<span class="sc">'\t'</span><span class="p">;</span> <span class="c1">// Tab (tab character (left justifies text))</span>
<span class="sc">'\v'</span><span class="p">;</span> <span class="c1">// Vertikaler Tab (vertical tab)</span>
<span class="sc">'\f'</span><span class="p">;</span> <span class="c1">// Neue Seite (new page (form feed))</span>
<span class="sc">'\r'</span><span class="p">;</span> <span class="c1">// Wagenrücklauf (carriage return)</span>
<span class="sc">'\b'</span><span class="p">;</span> <span class="c1">// Backspace-Zeichen (backspace character)</span>
<span class="sc">'\0'</span><span class="p">;</span> <span class="c1">// Null-Byte (NULL character). In C wird dieses Zeichen normalerweise am</span>
<span class="c1">// Ende eines Strings gesetzt.</span>
<span class="c1">// Beispiel: Hallo\n\0. "\0"  wird per Konvention verwendet, um das Ende</span>
<span class="c1">// eines Strings zu kennzeichnen.</span>
<span class="sc">'\\'</span><span class="p">;</span> <span class="c1">// Backslash (backslash)</span>
<span class="sc">'\?'</span><span class="p">;</span> <span class="c1">// Fragezeichen (question mark)</span>
<span class="sc">'\''</span><span class="p">;</span> <span class="c1">// einfaches Anführungszeichen (single quote)</span>
<span class="sc">'\"'</span><span class="p">;</span> <span class="c1">// doppeltes Anführungszeichen (double quote)</span>
<span class="err">'\</span><span class="n">xhh</span><span class="err">'</span><span class="p">;</span> <span class="c1">// Hexadezimale Zahl (hexadecimal number.) Beispiel:</span>
        <span class="c1">// '\xb' = Zeichen für vertikalen Tab </span>
<span class="err">'\</span><span class="mi">0</span><span class="n">oo</span><span class="err">'</span><span class="p">;</span> <span class="c1">// Oktalzahl (octal number). Beispiel \013 = Zeichen für vertikalen Tab</span>

<span class="c1">//Ausgabeformatierung</span>
<span class="s">"%d"</span><span class="p">;</span>    <span class="c1">// Integer</span>
<span class="s">"%3d"</span><span class="p">;</span>   <span class="c1">// Integer mit einer minimalen Länge von drei Zeichen.</span>
<span class="s">"%s"</span><span class="p">;</span>    <span class="c1">// String</span>
<span class="s">"%f"</span><span class="p">;</span>    <span class="c1">// Gleitkommazahl (float)</span>
<span class="s">"%ld"</span><span class="p">;</span>   <span class="c1">// genauere Gleitkommazahl (long)</span>
<span class="s">"%3.2f"</span><span class="p">;</span> <span class="c1">// Mindestens drei Zeichen vor und drei nach dem Komma.</span>
<span class="s">"%7.4s"</span><span class="p">;</span> <span class="c1">// (Kann auch mit Strings gemacht werden)</span>
<span class="s">"%c"</span><span class="p">;</span>    <span class="c1">// einzelnes Zeichen (char)</span>
<span class="s">"%p"</span><span class="p">;</span>    <span class="c1">// Pointer. Merke: man muss den Pointer zu void umwandeln,</span>
         <span class="c1">// bevor `printf` funktioniert.</span>
<span class="s">"%x"</span><span class="p">;</span>    <span class="c1">// Hexadezimal</span>
<span class="s">"%o"</span><span class="p">;</span>    <span class="c1">// Oktalzahl</span>
<span class="s">"%%"</span><span class="p">;</span>    <span class="c1">// Gibt % aus</span>

<span class="c1">////////////////////////////////////////////////</span>
<span class="c1">// Reihenfolge der Auswertung von Operatoren</span>
<span class="c1">////////////////////////////////////////////////</span>

<span class="c1">//-------------------------------------------------------//</span>
<span class="c1">//        Operatoren                 | Assoziativität    //</span>
<span class="c1">//-------------------------------------------------------//</span>
<span class="c1">// () [] -&gt; .                        | linksassoziativ   //</span>
<span class="c1">// ! ~ ++ -- + = *(type)sizeof       | rechtsassoziativ  //</span>
<span class="c1">// * / %                             | linksassoziativ   //</span>
<span class="c1">// + -                               | linksassoziativ   //</span>
<span class="c1">// &lt;&lt; &gt;&gt;                             | linksassoziativ   //</span>
<span class="c1">// &lt; &lt;= &gt; &gt;=                         | linksassoziativ   //</span>
<span class="c1">// == !=                             | linksassoziativ   //</span>
<span class="c1">// &amp;                                 | linksassoziativ   //</span>
<span class="c1">// ^                                 | linksassoziativ   //</span>
<span class="c1">// |                                 | linksassoziativ   //</span>
<span class="c1">// &amp;&amp;                                | linksassoziativ   //</span>
<span class="c1">// ||                                | linksassoziativ   //</span>
<span class="c1">// ?:                                | rechtsassoziativ  //</span>
<span class="c1">// = += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;= | rechtsassoziativ  //</span>
<span class="c1">// ,                                 | linksassoziativ   //</span>
<span class="c1">//-------------------------------------------------------//</span>


<span class="c1">////////////////////////////////////////////////</span>
<span class="c1">// Header-Dateien</span>
<span class="c1">////////////////////////////////////////////////</span>

<span class="cm">/*
Header-Dateien sind ein wichtiger Teil von C, da sie eine Verbindung zwischen 
unterschiedlichen C-Quelldateien herstellen. Außerdem vereinfachen Header-Dateien
den Code und Definitionen, da diese in separaten Dateien geschrieben werden können.

Header-Dateien sind von der Syntax her ähnlich zu C-Quelldateien, allerdings haben
die Header-Dateien die Dateiendung `.h`. Header-Dateien können im Quellcode mit
der `#include`-Anweisung eingebunden werden z.B. `#include "beispiel.h". Die
vorherige Anweisung geht davon aus, dass sich die Header-Datei im selben Ordner
befindet wie die C-Quelldatei.
*/</span>

<span class="c1">// Eine sichere Möglichkeit, einen Header mehrere Male zu definieren bietet, das</span>
<span class="c1">// folgende Statement. Die mehrfache Definition geschieht, wenn Kreisabhängigkeiten</span>
<span class="c1">// bestehen.</span>
<span class="cp">#ifndef EXAMPLE_H </span><span class="cm">/* Wenn EXAMPLE_H noch nicht definiert wurde */</span><span class="cp">
#define EXAMPLE_H </span><span class="cm">/* definiere das Makro EXAMPLE_H */</span><span class="cp">
</span>
<span class="c1">// Es könenn weitere Header innerhalb eines Headers eingebunden werden, was dazu</span>
<span class="c1">// führt, dass diese bereits in anderen Dateien eingebunden wurden. So kann eine</span>
<span class="c1">// Header-Datei in mehreren Dateien eingebunden werden. zum Beispiel:</span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="c1">// Wie in den Quelldateien können auch in den Header-Dateien Makros definiert</span>
<span class="c1">// werden und in anderen Dateien verwendet werden, welche diesen Header einbinden.</span>
<span class="cp">#define EXAMPLE_NAME "Dennis Ritchie"
</span>
<span class="c1">// Funktionsmakros können auch definiert werden.</span>
<span class="cp">#define ADD(a, b) ((a) + (b))
</span>
<span class="c1">// Beachte die Klammern, welche um die Argumente geschrieben wurden - diese sind</span>
<span class="c1">// wichtig, damit sichergestellt werden kann, dass a und b nicht unerwartet </span>
<span class="c1">// erweitert werden. Zum Beispiel: `MUL (x,y) (x * y)`; Bei der Verwendung von </span>
<span class="c1">// `MUL(1 + 2, 3)` würde dies wie folgt erweitert werden: `(1 + 2 * 3)`, was zu</span>
<span class="c1">// einem falschen Resultat führt.</span>

<span class="c1">// Strukturen und Typendefinitionen können verwendet werden, um die Konsistenz</span>
<span class="c1">// zwischen unterschiedlichen Dateien beizubehalten.</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="n">Node</span><span class="p">;</span>

<span class="c1">// Dies kann auch mit Aufzählungen gemacht werden.</span>
<span class="k">enum</span> <span class="n">traffic_light_state</span> <span class="p">{</span><span class="n">GREEN</span><span class="p">,</span> <span class="n">YELLOW</span><span class="p">,</span> <span class="n">RED</span><span class="p">};</span>

<span class="c1">// Funktionsprototypen könenn auch in Header-Dateien definiert werden, um die</span>
<span class="c1">// Funktion in unterschiedlichen Dateien zu verwenden, aber dies wird als schlechte</span>
<span class="c1">// Praxis angesehen. Definitionen sollten in einer C-Datei erstellt werden.</span>
<span class="n">Node</span> <span class="nf">create_linked_list</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">);</span>

<span class="c1">// Außer den oben genannten Elementen, sollten weitere Definitionen in einer</span>
<span class="c1">// C-Datei gemacht werden. Übermäßige Includes und Definitionen sollten auch </span>
<span class="c1">// nicht einer Header-Datei gemacht werden. Stattdessen wird es empfohlen, diese</span>
<span class="c1">// in eine separate Header-Datei oder in eine C-Quelldatei zu schreiben.</span>

<span class="cp">#endif </span><span class="cm">/* Ende der Präprozessordirektive */</span><span class="cp">
</span></code></pre></div>
<h2>Weiterführende Literatur</h2>

<p>Das Beste wird es sein, wenn man sich ein Exemplar des Buches
<a href="https://de.wikipedia.org/wiki/The_C_Programming_Language">&ldquo;The C Programming Language&rdquo;</a> besorgt.
Dieses Buch gilt als <strong>das</strong> Buch über die Programmiersprache C und wurde
von Dennis Ritchie, dem Erfinder der Programmiersprache C, und Brian Kernighan
geschrieben.
Sei vorsichtig, da dieses Buch mittlerweile schon etwas älter ist und gewisse
Unkorrektheiten (d.h. Ideen, welche nicht mehr als gut empfunden werden.) oder
mittlerweile geänderte Praktiken enthält. [Hinweis: Das Buch wurde auf Englisch
geschrieben, es gibt aber auch eine Übersetzung davon]</p>

<p>Eine weitere gute Ressource ist <a href="http://learncodethehardway.org/c/">Learn C The Hard Way</a>.
[Englisch]</p>

<p>Solltest du Fragen zu C haben, so lies die FAQ <a href="http://c-faq.com">compl.lang.c Frequently Asked Questions</a>.[Englisch]</p>

<p>Außerdem ist es wichtig, eine saubere Einrückung zu verwenden. Des weiteren ist
es wichtig, dass der Codestil möglichst konsistent ist. Es ist wichtiger, lesbaren
Code zu schreiben als Code, welcher clever und schnell ist. Es lohnt sich ein
Blick auf den <a href="https://www.kernel.org/doc/Documentation/process/coding-style.rst">Codestil des Linuxkernel</a> zu werfen. [Englisch]</p>

<p>[1] <a href="http://stackoverflow.com/questions/119123/why-isnt-sizeof-for-a-struct-equal-to-the-sum-of-sizeof-of-each-member">Why isn&rsquo;t sizeof for a struct equal to the sum of sizeof of each member?</a></p>

    <hr>
    <p>Du hast einen Verbesserungsvorschlag oder einen Fehler gefunden? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Erstelle ein Ticket</a> im offiziellen Github Repo, oder du erstellst einfach gleich einen <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/de-de/c-de.html.markdown">pull request</a>!
    </p>
    <p class="contributed">
    Originalversion von caminsha, mit Updates von <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/de-de/c-de.html.markdown">0 contributor(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="https://github.com/caminsha">caminsha</a>
    </p>

    <p>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>

        <script>
            var _gaq=[['_setAccount','UA-3525624-21'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>
</html>
