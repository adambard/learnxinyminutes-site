<!DOCTYPE html lang="es-es" xml:lang="es-es" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="es-es">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn X in Y Minutes: Scenic Programming Language Tours</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/es-es/awk-es/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fes-es%2Fawk-es%2F&text=Aprende+X+en+Y+minutos%2C+donde+X%3Dawk">
        Comparte esta página
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Seleccione el tema:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">ligero</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">oscuro</button>
  </div>
  <h1><a href="/">Aprende X en Y minutos</a></h1>
  <h2>Donde X=awk</h2>
    <p class="filelink">
    Descarga el código:
    <a href="/docs/files/learnawk-es.awk">learnawk-es.awk</a>
    </p>
  <div id="doc">
    <p>AWK es una herramienta estándar en cada sistema UNIX compatible con POSIX.
Es como un Perl restringido, perfecto para tareas de procesamiento de texto y
otras necesidades de scripting. Tiene una sintaxis similar a C, pero sin
puntos y comas, manejo manual de memoria y tipado estático. Puedes llamarlo
desde un script de shell o usarlo como un lenguaje stand-alone para scripting.</p>

<p>¿Por qué elegir AWK sobre Perl? Principalmente, porque AWK es parte de UNIX.
Siempre puedes contar con él, mientras que el futuro de Perl está en duda. AWK
es más fácil de leer que Perl. Para scripts sencillos de procesamiento de texto,
particularmente si es para leer archivos línea a línea y dividir por
delimitadores, probablemente AWK es la herramienta correcta para el trabajo.</p>
<div class="highlight"><pre class="highlight awk"><code><span class="c1">#!/usr/bin/awk -f</span>

<span class="c1"># Los comentarios tienen este aspecto.</span>

<span class="c1"># Los programas AWK son una colección de patrones y acciones. El patrón más</span>
<span class="c1"># importante es BEGIN. Las acciones van en bloques delimitados por llaves.</span>

<span class="kr">BEGIN</span> <span class="p">{</span>

    <span class="c1"># BEGIN correrá al inicio del programa. Es donde pones todo el código</span>
    <span class="c1"># preliminar antes de procesar los archivos de texto. Si no tienes archivos</span>
    <span class="c1"># de texto, piensa en BEGIN como el punto de entrada principal del script.</span>

    <span class="c1"># Las variables son globales. Asígnalas o úsalas sin declararlas.</span>
    <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Los operadores son justo como en C (y amigos).</span>
    <span class="nx">a</span> <span class="o">=</span> <span class="nx">count</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="nx">b</span> <span class="o">=</span> <span class="nx">count</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="nx">c</span> <span class="o">=</span> <span class="nx">count</span> <span class="o">*</span> <span class="mi">1</span>
    <span class="nx">d</span> <span class="o">=</span> <span class="nx">count</span> <span class="o">/</span> <span class="mi">1</span>
    <span class="nx">e</span> <span class="o">=</span> <span class="nx">count</span> <span class="o">%</span> <span class="mi">1</span> <span class="c1"># módulo</span>
    <span class="nx">f</span> <span class="o">=</span> <span class="nx">count</span> <span class="o">^</span> <span class="mi">1</span> <span class="c1"># exponenciación</span>

    <span class="nx">a</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="nx">b</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="nx">c</span> <span class="o">*=</span> <span class="mi">1</span>
    <span class="nx">d</span> <span class="o">/=</span> <span class="mi">1</span>
    <span class="nx">e</span> <span class="o">%=</span> <span class="mi">1</span>
    <span class="nx">f</span> <span class="o">^=</span> <span class="mi">1</span>

    <span class="c1"># Incremento y decremento en uno</span>
    <span class="nx">a</span><span class="o">++</span>
    <span class="nx">b</span><span class="o">--</span>

    <span class="c1"># Como un operador prefijo, regresa el valor modificado</span>
    <span class="o">++</span><span class="nx">a</span>
    <span class="o">--</span><span class="nx">b</span>

    <span class="c1"># Nota que no hay puntación para terminar las instrucciones</span>

    <span class="c1"># Instrucciones de control</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">print</span> <span class="s2">"Iniciando count en 0"</span>
    <span class="k">else</span>
        <span class="k">print</span> <span class="s2">"Eh?"</span>

    <span class="c1"># O puedes usar el operador ternario</span>
    <span class="k">print</span> <span class="p">(</span><span class="nx">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">?</span> <span class="s2">"Iniciando count en 0"</span> <span class="p">:</span> <span class="s2">"Eh?"</span>

    <span class="c1"># Bloques formados por múltiples líneas usan llaves</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">a</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">print</span> <span class="s2">"La concatenación de strings se hace "</span> <span class="s2">" con series "</span>
        <span class="k">print</span> <span class="s2">" de"</span> <span class="s2">" strings separados por espacios"</span>
        <span class="k">print</span> <span class="nx">a</span>

        <span class="nx">a</span><span class="o">++</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">print</span> <span class="s2">"El viejo confiable ciclo for"</span>

    <span class="c1"># Los operaciones de comparación son estándar...</span>
    <span class="nx">a</span> <span class="o">&lt;</span> <span class="nx">b</span>   <span class="c1"># Menor que</span>
    <span class="nx">a</span> <span class="o">&lt;=</span> <span class="nx">b</span>  <span class="c1"># Menor o igual que</span>
    <span class="nx">a</span> <span class="o">!=</span> <span class="nx">b</span>  <span class="c1"># No igual</span>
    <span class="nx">a</span> <span class="o">==</span> <span class="nx">b</span>  <span class="c1"># Igual</span>
    <span class="nx">a</span> <span class="o">&gt;</span> <span class="nx">b</span>   <span class="c1"># Mayor que</span>
    <span class="nx">a</span> <span class="o">&gt;=</span> <span class="nx">b</span>  <span class="c1"># Mayor o igual que</span>

    <span class="c1"># ...así como los operadores lógicos</span>
    <span class="nx">a</span> <span class="o">&amp;&amp;</span> <span class="nx">b</span>  <span class="c1"># AND</span>
    <span class="nx">a</span> <span class="o">||</span> <span class="nx">b</span>  <span class="c1"># OR</span>

    <span class="c1"># Además están las expresiones regulares</span>
    <span class="k">if</span> <span class="p">(</span><span class="s2">"foo"</span> <span class="o">~</span> <span class="s2">"^fo+$"</span><span class="p">)</span>
        <span class="k">print</span> <span class="s2">"Fooey!"</span>
    <span class="k">if</span> <span class="p">(</span><span class="s2">"boo"</span> <span class="o">!~</span> <span class="s2">"^fo+$"</span><span class="p">)</span>
        <span class="k">print</span> <span class="s2">"Boo!"</span>

    <span class="c1"># Arrays</span>
    <span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"foo"</span>
    <span class="nx">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"bar"</span>
    <span class="c1"># Desafortunadamente no hay otra manera de inicializar un array.</span>
    <span class="c1"># Tienes que inicializar cada posición del array.</span>

    <span class="c1"># También hay arrays asociativos</span>
    <span class="nx">assoc</span><span class="p">[</span><span class="s2">"foo"</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"bar"</span>
    <span class="nx">assoc</span><span class="p">[</span><span class="s2">"bar"</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"baz"</span>

    <span class="c1"># Y arrays multidimensionales con limitaciones que no mencionaré aquí</span>
    <span class="nx">multidim</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"foo"</span>
    <span class="nx">multidim</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"bar"</span>
    <span class="nx">multidim</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"baz"</span>
    <span class="nx">multidim</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"boo"</span>

    <span class="c1"># Puedes probar pertenencia a un array</span>
    <span class="k">if</span> <span class="p">(</span><span class="s2">"foo"</span> <span class="o">in</span> <span class="nx">assoc</span><span class="p">)</span>
        <span class="k">print</span> <span class="s2">"Fooey!"</span>

    <span class="c1"># También puedes usar el operador 'in' para iterar las claves de un array</span>
    <span class="k">for</span> <span class="p">(</span><span class="nx">key</span> <span class="o">in</span> <span class="nx">assoc</span><span class="p">)</span>
        <span class="k">print</span> <span class="nx">assoc</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>

    <span class="c1"># La terminal es un array especial llamado ARGV</span>
    <span class="k">for</span> <span class="p">(</span><span class="nx">argnum</span> <span class="o">in</span> <span class="kc">ARGV</span><span class="p">)</span>
        <span class="k">print</span> <span class="kc">ARGV</span><span class="p">[</span><span class="nx">argnum</span><span class="p">]</span>

    <span class="c1"># Puedes eliminar elementos de un array.</span>
    <span class="c1"># Esto es útil para prevenir que AWK suponga que algunos argumentos</span>
    <span class="c1"># son archivos por procesar.</span>
    <span class="k">delete</span> <span class="kc">ARGV</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># El número de argumentos de la terminal está en la variable ARGC</span>
    <span class="k">print</span> <span class="kc">ARGC</span>

    <span class="c1"># AWK tiene tres categorías de funciones incluidas.</span>
    <span class="c1"># Demostraré esas funciones posteriormente.</span>

    <span class="nx">return_value</span> <span class="o">=</span> <span class="nx">arithmetic_functions</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
    <span class="nx">string_functions</span><span class="p">()</span>
    <span class="nx">io_functions</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1"># Así se define una función</span>
<span class="kd">function</span> <span class="nx">arithmetic_functions</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span>     <span class="nx">localvar</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1"># Probablemente la parte más molesta de AWK es que no hay variables locales</span>
    <span class="c1"># Todo es global. No es problema en scripts pequeños, pero sí para</span>
    <span class="c1"># scripts más grandes.</span>

    <span class="c1"># Hay un work-around (mmm... hack). Los argumentos de las funciones son</span>
    <span class="c1"># locales para la función, y AWK permite definir más argumentos de función</span>
    <span class="c1"># de los que necesita, por lo que define las variables locales en la</span>
    <span class="c1"># declaración como en la función de arriba. Como convención, agrega</span>
    <span class="c1"># espacios en blanco para distinguir los parámetros de la función de las</span>
    <span class="c1"># variables locales. En este ejemplo, a, b y c son parámetros y localvar es</span>
    <span class="c1"># una variable local.</span>

    <span class="c1"># Ahora, a demostrar las funciones aritméticas</span>

    <span class="c1"># La mayoría de las implementaciones de AWK tienen funciones</span>
    <span class="c1"># trigonométricas estándar</span>
    <span class="nx">localvar</span> <span class="o">=</span> <span class="nb">sin</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
    <span class="nx">localvar</span> <span class="o">=</span> <span class="nb">cos</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
    <span class="nx">localvar</span> <span class="o">=</span> <span class="nb">atan2</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span> <span class="c1"># arcotangente de b / a</span>

    <span class="c1"># Y cosas logarítmicas</span>
    <span class="nx">localvar</span> <span class="o">=</span> <span class="nb">exp</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
    <span class="nx">localvar</span> <span class="o">=</span> <span class="nb">log</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>

    <span class="c1"># Raíz cuadrada</span>
    <span class="nx">localvar</span> <span class="o">=</span> <span class="nb">sqrt</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>

    <span class="c1"># Trucar un flotante a entero</span>
    <span class="nx">localvar</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">5.34</span><span class="p">)</span> <span class="c1"># localvar =&gt; 5</span>

    <span class="c1"># Números aleatorios</span>
    <span class="nb">srand</span><span class="p">()</span> <span class="c1"># La semilla es el argumento. Por defecto usa el tiempo del sistema</span>
    <span class="nx">localvar</span> <span class="o">=</span> <span class="nb">rand</span><span class="p">()</span> <span class="c1"># Número aleatorio entre 0 y 1.</span>

    <span class="c1"># Y aquí se regresa el valor</span>
    <span class="k">return</span> <span class="nx">localvar</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">string_functions</span><span class="p">(</span>    <span class="nx">localvar</span><span class="p">,</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1"># AWK tiene algunas funciones para procesamiento de strings,</span>
    <span class="c1"># y muchas dependen fuertemente en expresiones regulares.</span>

    <span class="c1"># Buscar y remplazar, primer instancia (sub) o todas las instancias (gsub)</span>
    <span class="c1"># Ambas regresan el número de matches remplazados.</span>
    <span class="nx">localvar</span> <span class="o">=</span> <span class="s2">"fooooobar"</span>
    <span class="nb">sub</span><span class="p">(</span><span class="s2">"fo+"</span><span class="p">,</span> <span class="s2">"Meet me at the "</span><span class="p">,</span> <span class="nx">localvar</span><span class="p">)</span> <span class="c1"># localvar =&gt; "Meet me at the bar"</span>
    <span class="nb">gsub</span><span class="p">(</span><span class="s2">"e"</span><span class="p">,</span> <span class="s2">"."</span><span class="p">,</span> <span class="nx">localvar</span><span class="p">)</span> <span class="c1"># localvar =&gt; "M..t m. at th. bar"</span>

    <span class="c1"># Buscar una cadena que haga match con una expresión regular</span>
    <span class="c1"># index() hace lo mismo, pero no permite expresiones regulares</span>
    <span class="nb">match</span><span class="p">(</span><span class="nx">localvar</span><span class="p">,</span> <span class="s2">"t"</span><span class="p">)</span> <span class="c1"># =&gt; 4, dado que 't' es el cuarto caracter</span>

    <span class="c1"># Separar con base en un delimitador</span>
    <span class="nb">split</span><span class="p">(</span><span class="s2">"foo-bar-baz"</span><span class="p">,</span> <span class="nx">arr</span><span class="p">,</span> <span class="s2">"-"</span><span class="p">)</span> <span class="c1"># a =&gt; ["foo", "bar", "baz"]</span>

    <span class="c1"># Otras funciones útiles</span>
    <span class="nb">sprintf</span><span class="p">(</span><span class="s2">"%s %d %d %d"</span><span class="p">,</span> <span class="s2">"Testing"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># =&gt; "Testing 1 2 3"</span>
    <span class="nb">substr</span><span class="p">(</span><span class="s2">"foobar"</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># =&gt; "oob"</span>
    <span class="nb">substr</span><span class="p">(</span><span class="s2">"foobar"</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="c1"># =&gt; "bar"</span>
    <span class="nb">length</span><span class="p">(</span><span class="s2">"foo"</span><span class="p">)</span> <span class="c1"># =&gt; 3</span>
    <span class="nb">tolower</span><span class="p">(</span><span class="s2">"FOO"</span><span class="p">)</span> <span class="c1"># =&gt; "foo"</span>
    <span class="nb">toupper</span><span class="p">(</span><span class="s2">"foo"</span><span class="p">)</span> <span class="c1"># =&gt; "FOO"</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">io_functions</span><span class="p">(</span>    <span class="nx">localvar</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1"># Ya has visto print</span>
    <span class="k">print</span> <span class="s2">"Hello world"</span>

    <span class="c1"># También hay printf</span>
    <span class="k">printf</span><span class="p">(</span><span class="s2">"%s %d %d %d\n"</span><span class="p">,</span> <span class="s2">"Testing"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="c1"># AWK no tiene handles de archivos en sí mismo. Automáticamente abrirá un</span>
    <span class="c1"># handle de archivo cuando use algo que necesite uno. El string que usaste</span>
    <span class="c1"># para esto puede ser tratada como un handle de archivo para propósitos</span>
    <span class="c1"># de I/O. Esto lo hace similar al scripting de shell:</span>

    <span class="k">print</span> <span class="s2">"foobar"</span> <span class="o">&gt;</span><span class="s2">"/tmp/foobar.txt"</span>

    <span class="c1"># Ahora el string "/tmp/foobar.txt" es un handle. Puedes cerrarlo:</span>
    <span class="nx">close</span><span class="p">(</span><span class="s2">"/tmp/foobar.txt"</span><span class="p">)</span>

    <span class="c1"># Aquí está como correr algo en el shell</span>
    <span class="nb">system</span><span class="p">(</span><span class="s2">"echo foobar"</span><span class="p">)</span> <span class="c1"># =&gt; muestra foobar</span>

    <span class="c1"># Lee una línea de la entrada estándar (stdin) y lo guarda en localvar</span>
    <span class="k">getline</span> <span class="nx">localvar</span>

    <span class="c1"># Lee una línea desde un pipe</span>
    <span class="s2">"echo foobar"</span> <span class="o">|</span> <span class="k">getline</span> <span class="nx">localvar</span> <span class="c1"># localvar =&gt; "foobar"</span>
    <span class="nx">close</span><span class="p">(</span><span class="s2">"echo foobar"</span><span class="p">)</span>

    <span class="c1"># Lee una línea desde un archivo y la guarda en localvar</span>
    <span class="k">getline</span> <span class="nx">localvar</span> <span class="o">&lt;</span><span class="s2">"/tmp/foobar.txt"</span>
    <span class="nx">close</span><span class="p">(</span><span class="s2">"/tmp/foobar.txt"</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1"># Como dije al inicio, los programas en AWK son una colección de patrones y</span>
<span class="c1"># acciones. Ya conociste el patrón BEGIN. otros patrones sólo se usan si estás</span>
<span class="c1"># procesando líneas desde archivos o stdin.</span>

<span class="c1"># Cuando pasas argumentos a AWK, son tratados como nombres de archivos a</span>
<span class="c1"># procesar. Los va a procesar todos, en orden. Imagínalos como un ciclo for</span>
<span class="c1"># implícito, iterando sobre las líneas de estos archivos. Estos patrones y</span>
<span class="c1"># acciones son como instrucciones switch dentro del ciclo.</span>

<span class="sr">/^fo+bar$/</span> <span class="p">{</span>

    <span class="c1"># Esta acción se ejecutará por cada línea que haga match con la expresión</span>
    <span class="c1"># regular /^fo+bar$/, y será saltada por cualquier línea que no haga match.</span>
    <span class="c1"># Vamos a sólo mostrar la línea:</span>

    <span class="k">print</span>

    <span class="c1"># ¡Wow, sin argumento! Eso es porque print tiene uno por defecto: $0.</span>
    <span class="c1"># $0 es el nombre de la línea actual que se está procesando.</span>
    <span class="c1"># Se crea automáticamente para ti.</span>

    <span class="c1"># Probablemente puedas adivinar que hay otras variables $. Cada línea es</span>
    <span class="c1"># separada implícitamente antes de que se llame cada acción, justo como lo</span>
    <span class="c1"># hace shell. Y, como shell, cada campo puede ser accesado con $.</span>

    <span class="c1"># Esto mostrará el segundo y cuarto campos de la línea</span>
    <span class="k">print</span> <span class="nv">$2</span><span class="p">,</span> <span class="nv">$4</span>

    <span class="c1"># AWK automáticamente define muchas otras variables que te ayudan a</span>
    <span class="c1"># inspeccionar y procesar cada línea. La más importante es NF</span>

    <span class="c1"># Imprime el número de campos de esta línea</span>
    <span class="k">print</span> <span class="kc">NF</span>

    <span class="c1"># Imprime el último campo de esta línea</span>
    <span class="k">print</span> <span class="nv">$NF</span>
<span class="p">}</span>

<span class="c1"># Cada patrón es realmente un prueba de verdadero/falso. La expresión regular</span>
<span class="c1"># en el último patrón también es una prueba verdadero/falso, pero parte de eso</span>
<span class="c1"># estaba oculto. Si no le das un string a la prueba, supondrá $0, la línea que</span>
<span class="c1"># se está procesando. La versión completa de esto es:</span>

<span class="nv">$0</span> <span class="o">~</span> <span class="sr">/^fo+bar$/</span> <span class="p">{</span>
    <span class="k">print</span> <span class="s2">"Equivalente al último patrón"</span>
<span class="p">}</span>

<span class="nx">a</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="c1"># Esto se ejecutará una vez por línea, mientras a sea positivo</span>
<span class="p">}</span>

<span class="c1"># Y ya te das una idea. Procesar archivos de texto, leyendo una línea a la vez,</span>
<span class="c1"># y haciendo algo con ella, particularmente separando en un deliminator, es tan</span>
<span class="c1"># común en UNIX que AWK es un lenguaje de scripting que hace todo eso por ti</span>
<span class="c1"># sin que tengas que pedirlo. Basta con escribir los patrones y acciones</span>
<span class="c1"># basados en lo que esperas de la entrada y lo quieras quieras hacer con ella.</span>

<span class="c1"># Aquí está un ejemplo de un script simple, para lo que AWK es perfecto.</span>
<span class="c1"># El script lee un nombre de stdin y muestra el promedio de edad para todos los</span>
<span class="c1"># que tengan ese nombre. Digamos que como argumento pasamos el nombre de un</span>
<span class="c1"># archivo con este contenido:</span>
<span class="c1">#</span>
<span class="c1"># Bob Jones 32</span>
<span class="c1"># Jane Doe 22</span>
<span class="c1"># Steve Stevens 83</span>
<span class="c1"># Bob Smith 29</span>
<span class="c1"># Bob Barker 72</span>
<span class="c1">#</span>
<span class="c1"># Éste es el script:</span>

<span class="kr">BEGIN</span> <span class="p">{</span>

    <span class="c1"># Primero, pedir al usuario el nombre</span>
    <span class="k">print</span> <span class="s2">"¿Para qué nombre quieres el promedio de edad?"</span>

    <span class="c1"># Recuperar una línea de stdin, no de archivos en la línea de comandos</span>
    <span class="k">getline</span> <span class="nx">name</span> <span class="o">&lt;</span><span class="s2">"/dev/stdin"</span>
<span class="p">}</span>

<span class="c1"># Ahora, hacer match con cada línea cuyo primer campo es el nombre dado</span>
<span class="nv">$1</span> <span class="o">==</span> <span class="nx">name</span> <span class="p">{</span>

    <span class="c1"># Aquí dentro tenemos acceso a variables útiles precargadas:</span>
    <span class="c1"># $0 es toda la línea</span>
    <span class="c1"># $3 es el tercer campo, la edad, que es lo que nos interesa</span>
    <span class="c1"># NF es el número de campos, que debe ser 3</span>
    <span class="c1"># NR es el número de registros (líneas) vistos hasta ahora</span>
    <span class="c1"># FILENAME es el nombre del archivo que está siendo procesado</span>
    <span class="c1"># FS es el campo separador, " " en este caso</span>
    <span class="c1"># Y muchas más que puedes conocer ejecutando 'man awk' en la terminal.</span>

    <span class="c1"># Llevar el registro de la suma y cuantas líneas han hecho match.</span>
    <span class="nx">sum</span> <span class="o">+=</span> <span class="nv">$3</span>
    <span class="nx">nlines</span><span class="o">++</span>
<span class="p">}</span>

<span class="c1"># Otro patrón especial es END. Va a ejecutarse después de procesar todos los</span>
<span class="c1"># archivos de texto. A diferencia de BEGIN, sólo se ejecuta si le das dado una</span>
<span class="c1"># entrada a procesar. Se ejecutará después de que todos los archivos hayan sido</span>
<span class="c1"># leídos y procesados según las reglas y acciones que programaste. El propósito</span>
<span class="c1"># es usualmente para mostrar un reporte final, o hacer algo con el agregado de</span>
<span class="c1"># los datos que has acumulado durante la ejecución del script.</span>

<span class="kr">END</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">nlines</span><span class="p">)</span>
        <span class="k">print</span> <span class="s2">"La edad promedio para "</span> <span class="nx">name</span> <span class="s2">" es "</span> <span class="nx">sum</span> <span class="o">/</span> <span class="nx">nlines</span>
<span class="p">}</span>

</code></pre></div>
<p>Más información:</p>

<ul>
<li><a href="http://www.grymoire.com/Unix/Awk.html">Tutorial de AWK</a></li>
<li><a href="https://linux.die.net/man/1/awk">Página man de AWK</a></li>
<li><a href="https://www.gnu.org/software/gawk/manual/gawk.html">La guía del usuario de GNU Awk</a>:
GNU Awk se encuentra en la mayoría de los sistemas Linux.</li>
</ul>

    <hr>
    <p>¿Tienes una sugerencia o rectificación? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Abre un issue</a> en el repositorio de Github, o haz un <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/es-es/awk-es.html.markdown">pull request</a> tu mismo
    </p>
    <p class="contributed">
    Originalmente contribuido por Marshall Mason, y actualizado por <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/es-es/awk-es.html.markdown">0 colaborador(es)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://github.com/marshallmason">Marshall Mason</a>
    </p>

    <p>
      Translated by:
        <a href="http://github.com/HugoGuillen">Hugo Guillén-Ramírez</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>

        <script>
            var _gaq=[['_setAccount','UA-3525624-21'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>
</html>
