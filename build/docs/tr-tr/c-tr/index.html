<!DOCTYPE html lang="tr-tr" xml:lang="tr-tr" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="tr-tr">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn C in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/tr-tr/c-tr/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Ftr-tr%2Fc-tr%2F&text=Y+dakikada+X+%C3%B6%C4%9Fren%2C+burada+X%3DC">
        Bu sayfayı paylaş
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Tema seçin:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">hafif</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">karanlık</button>
  </div>
  <h1><a href="/">Y dakikada X öğren</a></h1>
  <h2>Burada X=C</h2>
    <p class="filelink">
    Kodu al:
    <a href="/docs/files/learnc-tr.c">learnc-tr.c</a>
    </p>
  <div id="doc">
    <p>/*
C halen modern yüksek performans bilgisayarların dili.</p>

<p>C bir çok programcının kullandığı en düşük seviye dillerdendir, ama
salt hız ile daha fazlasını karşılar. C&#39;nin bellek yönetiminden iyi
anlarsanız sizi isteğiniz yere götürecektir.</p>
<div class="highlight"><pre class="highlight c"><code><span class="c1">// Tek satır yorum // karakterleri ile başlar</span>

<span class="cm">/*
Çoklu satırlı yorumlar bu şekilde görünür.
*/</span>

<span class="c1">// C Standart kütüphanelerini uygulamanıza #include&lt;ornek.h&gt; ile </span>
<span class="c1">// dahil edebilirsiniz.</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="c1">// Kendi başlık(header) dosyalarınız dahil etmek için "çift tırnak" </span>
<span class="c1">// kullanmalısınız.</span>
<span class="cp">#include</span> <span class="cpf">"my_header.h"</span><span class="cp">
</span>
<span class="c1">// Fonksiyonlarınızı bir .h dosyasında ya da c dosyanızın üst tarafta </span>
<span class="c1">// tanımlayın.</span>

<span class="kt">void</span> <span class="nf">function_1</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">function_2</span><span class="p">();</span>

<span class="c1">// Programınızın giriş noktası main isimli bir fonksiyondur ve </span>
<span class="c1">// integer değer döner</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="c1">// çıktıları yazdırmak için printf kullanılır, "print formatted"</span>
    <span class="c1">// %d bir sayı tipidir, \n yeni satır karakteridir</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// =&gt; 0 karakteri yazdırılır.</span>
    <span class="c1">// Tüm ifadeler noktalı virgül ile bitmelidir.</span>

    <span class="c1">///////////////////////////////////////</span>
    <span class="c1">// Tipler</span>
    <span class="c1">///////////////////////////////////////</span>

    <span class="c1">// Değişkenleri kullanmadan önce tanımlamalısınız. Bir değişken tanımlarken</span>
    <span class="c1">// tipini belirtmelisiniz; bu tip onun byte olarak boyutunu belirler.</span>

    <span class="c1">// int değişken tipi 4 byte boyutundadır.</span>
    <span class="kt">int</span> <span class="n">x_int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// short değişken tipi genellikle 2 byte boyutundadır.</span>
    <span class="kt">short</span> <span class="n">x_short</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// char tipi 1 byte boyutunu garanti eder. </span>
    <span class="kt">char</span> <span class="n">x_char</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">y_char</span> <span class="o">=</span> <span class="sc">'y'</span><span class="p">;</span> <span class="c1">// Karakterler '' işaretleri arasına yazılır.</span>

    <span class="c1">// long tipi 4-8 byte olur; long long tipi en azından 64 bit garantiler.</span>
    <span class="kt">long</span> <span class="n">x_long</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">x_long_long</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 

    <span class="c1">// float tipi 32-bit kayan noktalı sayı boyutundadır.</span>
    <span class="kt">float</span> <span class="n">x_float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

    <span class="c1">// double değişken tipi 64-bit kayan noktalı yazı tipindedir. </span>
    <span class="kt">double</span> <span class="n">x_double</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

    <span class="c1">// Integral türleri işaretsiz olabilir. Bunun anlamı, onlar eksi değer </span>
    <span class="c1">// olamaz demektir, ama aynı boyuttaki işaretsiz bir sayının maksimum </span>
    <span class="c1">// değeri işaretli bir sayının maksimum değeriden büyük olur.</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ux_char</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ux_short</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ux_int</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ux_long_long</span><span class="p">;</span>

    <span class="c1">// Diğer taraftan char, ki her zaman bir byte boyutundadır, bu tipler </span>
    <span class="c1">// makinenize göre boyut değiştirir. sizeof(T) size bir değişkenin byte </span>
    <span class="c1">// cinsinden boyutunu verir öyle ki bu tipin boyutunu taşınabilir bir </span>
    <span class="c1">// şekilde ifade edilebilir</span>
    <span class="c1">// Örneğin,</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span> <span class="c1">// =&gt; 4 (bir çok makinede 4-byte words)</span>

    <span class="c1">// Eger arguman düzenli ifae olan sizeof operatoru ise degerlendirilmez.</span>
    <span class="c1">// VLAs hariç asagiya bakiniz).</span>
    <span class="c1">// Bu durumda verimliligin degeri derleme-zamani sabitidir.</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// size_t bir objeyi temsil etmek için kullanılan 2 byte uzunluğundaki bir </span>
    <span class="c1">// işaretsiz tam sayı tipidir</span>

    <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="o">++</span><span class="p">);</span> <span class="c1">// a++ is not evaluated</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"sizeof(a++) = %zu where a = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="c1">// yazdirilan "sizeof(a++) = 4 where a = 1" (32-bit mimaride)</span>

    <span class="c1">// Diziler somut bir boyut ile oluşturulmalıdır.</span>
    <span class="kt">char</span> <span class="n">my_char_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span> <span class="c1">// Bu dizi 1 * 20 = 20 byte alan kaplar</span>
    <span class="kt">int</span> <span class="n">my_int_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span> <span class="c1">// Bu dizi 4 * 20 = 80 byte alan kaplar</span>
                          <span class="c1">// (4-byte bir word varsayılır)</span>

    <span class="c1">// Şu şekilde bir diziyi 0 ile oluşturabilirsiniz:</span>
    <span class="kt">char</span> <span class="n">my_array</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

    <span class="c1">// Dizinin elemanlarını indexlemek diğer diller gibidir, veya </span>
    <span class="c1">// diğer diller C gibi.</span>
    <span class="n">my_array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// =&gt; 0</span>

    <span class="c1">// Diziler değişebilirdir (mutable); O sadece memory!</span>
    <span class="n">my_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">my_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// =&gt; 2</span>

    <span class="c1">// C99'da (ve C11 istege bagli bir ozellik olarak), değidken-uzunluklu diziler (VLAs) bildirilebilirler.</span>
    <span class="c1">// Böyle bir dizinin boyuunu derlenmesi gerekmez</span>
    <span class="c1">// zaman sabiti:</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Enter the array size: "</span><span class="p">);</span> <span class="c1">// dizi boyutu kullaniciya soruluyor</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mh">0x100</span><span class="p">];</span>
    <span class="n">fgets</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">buf</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>

    <span class="c1">// strtoul isaretsiz integerlar icin string ayiricisidir.</span>
    <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">var_length_array</span><span class="p">[</span><span class="n">size</span><span class="p">];</span> <span class="c1">// declare the VLA</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"sizeof array = %zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">var_length_array</span><span class="p">);</span>

    <span class="c1">// Bu programın olası bir sonucu olabilir:</span>
    <span class="c1">// &gt; Enter the array size: 10</span>
    <span class="c1">// &gt; sizeof array = 40</span>

    <span class="c1">// String'ler bir NUL (0x00) byte ile sonlandırılmış karakter dizileridir,</span>
    <span class="c1">// bu string içerisinde özel bir karakter olan '\0' ile gösterilir.</span>
    <span class="c1">// (Biz Nul byte'i string karakterleri arasında bulundurmamıza gerek </span>
    <span class="c1">// yoktur; derleyici onu bizim için dizinin sonuna ekler.)</span>
    <span class="kt">char</span> <span class="n">a_string</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="s">"This is a string"</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a_string</span><span class="p">);</span> <span class="c1">// %s bir string formatıdır.</span>

    <span class="cm">/*
    a_string 16 karakter uzunluğundadır. 
    17. karakter NUL karakteridir.
    18., 19. ve 20. karakterler tanımsızdır.(undefined)
    */</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a_string</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span> <span class="c1">// =&gt; 0</span>
    <span class="c1">// i.e., byte #17 is 0 (as are 18, 19, and 20)</span>

    <span class="c1">// Tek tirnak arasinda karakterlere sahipsek, bu karakterler degismezdir.</span>
    <span class="c1">// Tip `int` ise, `char` *degildir* (tarihsel sebeplerle).</span>
    <span class="kt">int</span> <span class="n">cha</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span> <span class="c1">// fine</span>
    <span class="kt">char</span> <span class="n">chb</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span> <span class="c1">// fine too (implicit conversion from int to char)</span>

    <span class="c1">///////////////////////////////////////</span>
    <span class="c1">// Operatörler</span>
    <span class="c1">///////////////////////////////////////</span>

    <span class="kt">int</span> <span class="n">i1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// Çoklu tanımlama için kısayol.</span>
    <span class="kt">float</span> <span class="n">f1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">f2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

    <span class="c1">// Aritmatik basittir.</span>
    <span class="n">i1</span> <span class="o">+</span> <span class="n">i2</span><span class="p">;</span> <span class="c1">// =&gt; 3</span>
    <span class="n">i2</span> <span class="o">-</span> <span class="n">i1</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>
    <span class="n">i2</span> <span class="o">*</span> <span class="n">i1</span><span class="p">;</span> <span class="c1">// =&gt; 2</span>
    <span class="n">i1</span> <span class="o">/</span> <span class="n">i2</span><span class="p">;</span> <span class="c1">// =&gt; 0 (0.5'dir ama 0 a yuvarlanmıştır.)</span>

    <span class="n">f1</span> <span class="o">/</span> <span class="n">f2</span><span class="p">;</span> <span class="c1">// =&gt; 0.5, artı veya eksi epsilon</span>

    <span class="c1">// Modüler aritmetikte vardır.</span>
    <span class="mi">11</span> <span class="o">%</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// =&gt; 2</span>

    <span class="c1">// Karşılaştırma operatörleri muhtemelen tanıdıktır, ama</span>
    <span class="c1">// C'de boolean tipi yoktur. Bunun yerine sayı(int) kullanırız.</span>
    <span class="c1">// 0 false yerine ve diğer herşey true yerine geçmektedir. </span>
    <span class="c1">// (Karşılaştırma operatörleri her zaman 0 veya 1 dönmektedir.)</span>
    <span class="mi">3</span> <span class="o">==</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 0 (false)</span>
    <span class="mi">3</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 1 (true)</span>
    <span class="mi">3</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>
    <span class="mi">3</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 0</span>
    <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>
    <span class="mi">2</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>

    <span class="c1">// Sayılar üzerinde mantık işlemleri</span>
    <span class="o">!</span><span class="mi">3</span><span class="p">;</span> <span class="c1">// =&gt; 0 (Logical not)</span>
    <span class="o">!</span><span class="mi">0</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>
    <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 1 (Logical and)</span>
    <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 0</span>
    <span class="mi">0</span> <span class="o">||</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 1 (Logical or)</span>
    <span class="mi">0</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// =&gt; 0</span>

    <span class="c1">// Bit boyutunda işlem yapmak için operatörler</span>
    <span class="o">~</span><span class="mh">0x0F</span><span class="p">;</span> <span class="c1">// =&gt; 0xF0 (bitwise negation)</span>
    <span class="mh">0x0F</span> <span class="o">&amp;</span> <span class="mh">0xF0</span><span class="p">;</span> <span class="c1">// =&gt; 0x00 (bitwise AND)</span>
    <span class="mh">0x0F</span> <span class="o">|</span> <span class="mh">0xF0</span><span class="p">;</span> <span class="c1">// =&gt; 0xFF (bitwise OR)</span>
    <span class="mh">0x04</span> <span class="o">^</span> <span class="mh">0x0F</span><span class="p">;</span> <span class="c1">// =&gt; 0x0B (bitwise XOR)</span>
    <span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 0x02 (bitwise left shift (by 1))</span>
    <span class="mh">0x02</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 0x01 (bitwise right shift (by 1))</span>

    <span class="c1">// Isaretli sayilari kaydirirken dikkatli olun - tanimsizlar sunlardir:</span>
    <span class="c1">// - isaretli sayinin isaret bitinde yap?ilan kaydirma (int a = 1 &lt;&lt; 32)</span>
    <span class="c1">// - negatif sayilarda sol kaydirma (int a = -1 &lt;&lt; 2)</span>
    <span class="c1">// - LHS tipinde &gt;= ile olan ofset genisletmelerde yapilan kaydirma:</span>
    <span class="c1">//   int a = 1 &lt;&lt; 32; // UB if int is 32 bits wide</span>

    <span class="c1">///////////////////////////////////////</span>
    <span class="c1">// Kontrol Yapıları</span>
    <span class="c1">///////////////////////////////////////</span>

    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"I am never run</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"I am also never run</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"I print</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// While Döngüsü</span>
    <span class="kt">int</span> <span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">ii</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d, "</span><span class="p">,</span> <span class="n">ii</span><span class="o">++</span><span class="p">);</span> <span class="c1">// ii++, ii değişkenini değerini kullandıktan sonra artırır.</span>
    <span class="p">}</span> <span class="c1">// =&gt; prints "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">kk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d, "</span><span class="p">,</span> <span class="n">kk</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">kk</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">);</span> <span class="c1">// ++kk, kk değişkeninin değerini kullanmadan önce artırır.</span>
    <span class="c1">// =&gt; prints "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="c1">// For Döngüsü</span>
    <span class="kt">int</span> <span class="n">jj</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">jj</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">jj</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">jj</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d, "</span><span class="p">,</span> <span class="n">jj</span><span class="p">);</span>
    <span class="p">}</span> <span class="c1">// =&gt; prints "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="c1">///////////////////////////////////////</span>
    <span class="c1">// Tip Dönüşümleri</span>
    <span class="c1">///////////////////////////////////////</span>

    <span class="c1">// C'de her değer bir tipe sahiptir, ama siz bir değeri bir başka tipe </span>
    <span class="c1">// dönüştürebilirsiniz.</span>

    <span class="kt">int</span> <span class="n">x_hex</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span> <span class="c1">// Hex literatüründe değer atayabilirsiniz.</span>

    <span class="c1">// Türler arasındaki dönüşümde kendi değerini korumak için çalışacaktır.</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x_hex</span><span class="p">);</span> <span class="c1">// =&gt; Prints 1</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">short</span><span class="p">)</span> <span class="n">x_hex</span><span class="p">);</span> <span class="c1">// =&gt; Prints 1</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="n">x_hex</span><span class="p">);</span> <span class="c1">// =&gt; Prints 1</span>

    <span class="c1">// Tip hiçbir hata vermeden taşacaktır(overflow).</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="mi">257</span><span class="p">);</span> <span class="c1">// =&gt; 1 (Max char = 255 eğer karakter 8 bit uzunluğunda ise)</span>

    <span class="c1">// `char`, `signed char` ve `unsigned char` karakter tiplerinin maksimum uzunluğunu </span>
    <span class="c1">// belirlemek için &lt;limits.h&gt; kütüphanesindeki CHAR_MAX, SCHAR_MAX ve UCHAR_MAX </span>
    <span class="c1">// macrolarını kullanınız.</span>

    <span class="c1">// Integral tipi kayan noktalı yazı tipine dönüştürülecektir ve tam tersi. </span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="mi">100</span><span class="p">);</span> <span class="c1">// %f formats a float</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%lf</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="mi">100</span><span class="p">);</span> <span class="c1">// %lf formats a double</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mi">100</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>

    <span class="c1">///////////////////////////////////////</span>
    <span class="c1">// İşaretçiler (Pointers)</span>
    <span class="c1">///////////////////////////////////////</span>

    <span class="c1">// Bir işaretci bellek adresini barındıran bir değişkendir. Tanımlaması ile işaret </span>
    <span class="c1">// edeceği verinin tipi de belirtilecektir. Değişkenlerininzi bellek adreslerini </span>
    <span class="c1">// getirerek bellek ile ilgili karışıklığı ortadan kaldırabilirsiniz. </span>

    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span> <span class="c1">// &amp; işareti bir değişkenin bellek adresini getirmek için kullanılır. </span>
    <span class="c1">// (%p işaretçilerin formatıdır)</span>
    <span class="c1">// =&gt; Bazı bellek adresleri yazdırılacaktır.</span>


    <span class="c1">// İşaretçiler tanımlanırken * ile başlar</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">px</span><span class="p">,</span> <span class="n">not_a_pointer</span><span class="p">;</span> <span class="c1">// px sayı tipinde bir işaretçidir. </span>
    <span class="n">px</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span> <span class="c1">// X değişkeninin bellek adresi px değişkeninde tutulmaktadır.</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">px</span><span class="p">);</span> <span class="c1">// =&gt; x değişkeninin bellek adresi yazdırılacaktır. </span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d, %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">px</span><span class="p">),</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">not_a_pointer</span><span class="p">));</span>
    <span class="c1">// =&gt; 64-bit sistemde "8, 4" yazdırılacaktır.</span>

    <span class="c1">// İşaretçinin adres olarak gösterdiği yerdeki değeri almak için </span>
    <span class="c1">// değişkenin önüne * işareti ekleyiniz.</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">px</span><span class="p">);</span> <span class="c1">// =&gt; 0 bastıracaktır, x in değeridir, </span>
                         <span class="c1">// çünkü px değişkeni x in adresini göstermektedir.</span>

    <span class="c1">// Ayrıca siz işaretçinin gösterdiği yerin değerini </span>
    <span class="c1">// değiştirebilirsiniz. Burada referansı parantez içerisinde göstereceğiz </span>
    <span class="c1">// çünkü ++ işleminin önceliği * işleminden yüksektir.</span>
    <span class="p">(</span><span class="o">*</span><span class="n">px</span><span class="p">)</span><span class="o">++</span><span class="p">;</span> <span class="c1">// px'in işaret ettiği değeri 1 artır. </span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">px</span><span class="p">);</span> <span class="c1">// =&gt; 1 yazdırılır.</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// =&gt; 1 yazdırılır.</span>

    <span class="kt">int</span> <span class="n">x_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span> <span class="c1">// Diziler(arrays) bellekten yan yana bellek bloklarını </span>
                     <span class="c1">// tahsis etmek için iyi bir yöntemdir.</span>
    <span class="kt">int</span> <span class="n">xx</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">xx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">xx</span><span class="o">&lt;</span><span class="mi">20</span><span class="p">;</span> <span class="n">xx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x_array</span><span class="p">[</span><span class="n">xx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">-</span> <span class="n">xx</span><span class="p">;</span>
    <span class="p">}</span> <span class="c1">// x_array dizisi 20, 19, 18,... 2, 1 değerleri ile oluşturuluyor.</span>

    <span class="c1">// Bir sayı tipinde işaretçi tanımlanıyor ve x_array'i işaret ediyor.</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">x_ptr</span> <span class="o">=</span> <span class="n">x_array</span><span class="p">;</span>
    <span class="c1">// x_ptr artık dizinin ilk elemanını işaret etmektedir (the integer 20).</span>
    <span class="c1">// Bu çalışacaktır çünkü diziler(arrays) aslında sadece onların ilk </span>
    <span class="c1">// elemanlarını gösteren birer işaretçidir.</span>
    <span class="c1">// For example, when an array is passed to a function or is assigned to a pointer,</span>
    <span class="c1">// it decays into (implicitly converted to) a pointer.</span>
    <span class="c1">// Exceptions: when the array is the argument of the `&amp;` (address-od) operator:</span>
    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr_to_arr</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">;</span> <span class="c1">// &amp;arr is NOT of type `int *`!</span>
                                  <span class="c1">// It's of type "pointer to array" (of ten `int`s).</span>
    <span class="c1">// or when the array is a string literal used for initializing a char array:</span>
    <span class="kt">char</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"foobarbazquirk"</span><span class="p">;</span>
    <span class="c1">// or when it's the argument of the `sizeof` or `alignof` operator:</span>
    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span> <span class="c1">// equivalent with int *ptr = &amp;arr[0];</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%zu %zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">arr</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">ptr</span><span class="p">);</span> <span class="c1">// probably prints "40, 4" or "40, 8"</span>

    <span class="c1">// Diziler ilk elemanlarını gösteren birer işaretçidirler.</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">x_ptr</span><span class="p">));</span> <span class="c1">// =&gt; 20 yazılacaktır.</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// =&gt; 20 yazılacaktır.</span>

    <span class="c1">// İşaretçiler kendi tiplerinde artırılır ve azaltılır. </span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">x_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span> <span class="c1">// =&gt; 19 yazılacaktır.</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// =&gt; 19 yazılacaktır.</span>

    <span class="c1">// Ayrıca dinamik olarak bir bellek bloğunu standart kütüphanede bulunan </span>
    <span class="c1">// malloc fonksiyonu ile uygulamanız için ayırabilirsiniz. Bu fonksiyon </span>
    <span class="c1">// byte türünden ayırmak istediğiniz bloğun boyutunu parametre olarak alır. </span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">my_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">20</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">xx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">xx</span><span class="o">&lt;</span><span class="mi">20</span><span class="p">;</span> <span class="n">xx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="p">(</span><span class="n">my_ptr</span> <span class="o">+</span> <span class="n">xx</span><span class="p">)</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">-</span> <span class="n">xx</span><span class="p">;</span> <span class="c1">// my_ptr[xx] = 20-xx 'de aynı zamanda çalışabilir</span>
    <span class="p">}</span> <span class="c1">// Bellekte 20, 19, 18, 17... 2, 1 (as ints) şeklinde oluşturulmuş olacaktır.</span>

    <span class="c1">// Eğer ayrımadığınız bir bellek adresini çağırırsanız</span>
    <span class="c1">// öngörülmeyen bir değer dönecektir. </span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">my_ptr</span> <span class="o">+</span> <span class="mi">21</span><span class="p">));</span> <span class="c1">// =&gt; kim-bilir-ne-yazacak?</span>

    <span class="c1">// Malloc fonksiyonu ile ayrıdığınız bellek kısmı ile işiniz bittiğinde </span>
    <span class="c1">// onu free fonksiyonu ile boşaltmalısınız, aksi durumda uygulamanız </span>
    <span class="c1">// kapatılana kadar belleğin o kısmını kimse kullanamaz. </span>
    <span class="n">free</span><span class="p">(</span><span class="n">my_ptr</span><span class="p">);</span>

    <span class="c1">// Metin Dizileri(String) birer karakter dizisidir(char array), ama</span>
    <span class="c1">// genelde karakter işaretçisi olarak kullanılır.</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">my_str</span> <span class="o">=</span> <span class="s">"This is my very own string"</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"%c</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">my_str</span><span class="p">);</span> <span class="c1">// =&gt; 'T'</span>

    <span class="n">function_1</span><span class="p">();</span>
<span class="p">}</span> <span class="c1">// main fonksiyon sonu</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Fonksiyonlar</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// Fonksiyon tanımlama sözdizimi:</span>
<span class="c1">// &lt;return type&gt; &lt;fonksiyon adi&gt;(&lt;args&gt;)</span>

<span class="kt">int</span> <span class="nf">add_two_ints</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="p">;</span> <span class="c1">// bir değer geri döndürmek için return kullanılır.</span>
<span class="p">}</span>

<span class="cm">/*
Fonksiyonlar pass-by-value'dür, ama isterseniz işaretçi referanslarını 
kullanarak fonksiyona gönderilen parametrenin değerini değiştirebilirsiniz. 

Example: Bir metni tersine çevirme
*/</span>

<span class="c1">// Bir void konksiyonu hiç bir değer dönmez</span>
<span class="kt">void</span> <span class="nf">str_reverse</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">str_in</span><span class="p">){</span>
    <span class="kt">char</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ii</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str_in</span><span class="p">);</span> <span class="c1">// Strlen C'nin standart kütüphanesinin bir fonksiyonu</span>
    <span class="k">for</span><span class="p">(</span><span class="n">ii</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">ii</span><span class="o">&lt;</span><span class="n">len</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">ii</span><span class="o">++</span><span class="p">){</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">str_in</span><span class="p">[</span><span class="n">ii</span><span class="p">];</span>
        <span class="n">str_in</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">str_in</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">// sondan ii'inci elemanı</span>
        <span class="n">str_in</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*
char c[] = "This is a test.";
str_reverse(c);
printf("%s\n", c); // =&gt; ".tset a si sihT"
*/</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Kullanıcı Tanımlı Tipler ve Yapılar</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// Typedef'ler bir tip takma adı oluşturur.</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">my_type</span><span class="p">;</span>
<span class="n">my_type</span> <span class="n">my_type_var</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// Struct'lar bir veri koleksiyonudur. </span>
<span class="k">struct</span> <span class="n">rectangle</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">width</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">height</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// It's not generally true that</span>
<span class="c1">// sizeof(struct rectangle) == sizeof(int) + sizeof(int)</span>
<span class="c1">// due to potential padding between the structure members (this is for alignment</span>
<span class="c1">// reasons). [1]</span>

<span class="kt">void</span> <span class="nf">function_1</span><span class="p">(){</span>

    <span class="k">struct</span> <span class="n">rectangle</span> <span class="n">my_rec</span><span class="p">;</span>

    <span class="c1">// "." ile yapı üyelerine ulaşılabilir.</span>
    <span class="n">my_rec</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">my_rec</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

    <span class="c1">// Bir yapının adresini işaretçiye atayabilirsiniz.</span>
    <span class="k">struct</span> <span class="n">rectangle</span><span class="o">*</span> <span class="n">my_rec_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_rec</span><span class="p">;</span>

    <span class="c1">// İşaretçi üzerinden bir yapıya ulaşabilirsiniz. </span>
    <span class="p">(</span><span class="o">*</span><span class="n">my_rec_ptr</span><span class="p">).</span><span class="n">width</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>

    <span class="c1">// ya da -&gt; işareti ile yapının elemanlarına ulaşabilirsiniz. </span>
    <span class="n">my_rec_ptr</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// (*my_rec_ptr).height = 10; ile aynıdır.</span>
<span class="p">}</span>

<span class="c1">// Kolaylık sağlamak için bir yapıya typedef tanımlayabilirsiniz. </span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">rectangle</span> <span class="n">rect</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">area</span><span class="p">(</span><span class="n">rect</span> <span class="n">r</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">r</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Fonksiyon İşaretçiler</span>
<span class="c1">///////////////////////////////////////</span>

<span class="cm">/*
Çalışma zamanında, fonksiyonların bilinen bir bellek adresleri vardır. Fonksiyon
işaretçileri fonksiyonları direk olarak çağırmayı sağlayan veya geri bildirim(callback)
için parametre gönderirken kullanılan başka birer işaretçidirler. Ama, syntax tanımı 
başlangıçta biraz karışık gelebilir. 

Örnek: bir işaretçiden str_reverse kullanımı
*/</span>
<span class="kt">void</span> <span class="nf">str_reverse_through_pointer</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span> <span class="n">str_in</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// f adında bir fonksiyon işaretçisi tanımlanır.</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span> <span class="c1">// Signature should exactly match the target function.</span>
    <span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">str_reverse</span><span class="p">;</span> <span class="c1">// Assign the address for the actual function (determined at runtime)</span>
    <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="n">str_in</span><span class="p">);</span> <span class="c1">// Just calling the function through the pointer</span>
    <span class="c1">// f(str_in); // That's an alternative but equally valid syntax for calling it.</span>
<span class="p">}</span>

<span class="cm">/*
As long as function signatures match, you can assign any function to the same pointer.
Function pointers are usually typedef'd for simplicity and readability, as follows:
*/</span>

<span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">my_fnp_type</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span>

<span class="c1">// Gerçek bir işaretçi tanımlandığı zaman ki kullanımı:</span>
<span class="c1">// ...</span>
<span class="c1">// my_fnp_type f; </span>

</code></pre></div>
<h2>Daha Fazla Okuma Listesi</h2>

<p><a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">K&amp;R, aka &ldquo;The C Programming Language&rdquo;</a>&rsquo;in bir kopyasını bulundurmak mükemmel olabilir</p>

<p>Diğer bir iyi kaynak ise <a href="http://learncodethehardway.org/c/">Learn C the hard way</a></p>

<p>It&rsquo;s very important to use proper spacing, indentation and to be consistent with your coding style in general.
Readable code is better than clever code and fast code. For a good, sane coding style to adopt, see the
<a href="https://www.kernel.org/doc/Documentation/CodingStyle">Linux kernel coding style</a>.</p>

<p>Diğer taraftan google sizin için bir arkadaş olabilir.</p>

<p>[1] http://stackoverflow.com/questions/119123/why-isnt-sizeof-for-a-struct-equal-to-the-sum-of-sizeof-of-each-member</p>

    <hr>
    <p>Bir öneriniz mi var? Belki bir düzeltme? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Bir konu açın</a> Github deposundan, ya da kendi <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/tr-tr/c-tr.html.markdown">PR</a>'nizi hazırlayın!
    </p>
    <p class="contributed">
    Aslen katkıda bulunan Adam Bard, ve güncelleştiren <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/tr-tr/c-tr.html.markdown">0 geliştirici(ler)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://adambard.com/">Adam Bard</a>
    </p>

    <p>
      Translated by:
        <a href="http://scanf.info/">Haydar KULEKCI</a>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>

        <script>
            var _gaq=[['_setAccount','UA-3525624-21'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>
</html>
