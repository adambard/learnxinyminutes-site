<!DOCTYPE html lang="tr-tr" xml:lang="tr-tr" xmlns="http://www.w3.org/1999/xhtml">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="tr-tr">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn C++ in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="/css/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/tr-tr/c++-tr/">
        <script>
            var THEME_KEY = "lxiym_theme";
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];
                if (!el) {
                  return;
                }

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem(THEME_KEY, theme);
            }

            function load_theme() {
              var theme = localStorage.getItem(THEME_KEY);
              if (theme) {
                set_theme(theme);
              }
            }

            // Attempt immediate application of html style
            load_theme();

            // Backup: do it onload. Will flash, but better than nothing.
            window.addEventListener("load", function(){
              load_theme();
            });
        </script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Ftr-tr%2Fc%2B%2B-tr%2F&text=Y+dakikada+X+%C3%B6%C4%9Fren%2C+burada+X%3DC%2B%2B">
        Bu sayfayı paylaş
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Tema seçin:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">hafif</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">karanlık</button>
  </div>
  <h1><a href="/">Y dakikada X öğren</a></h1>
  <h2>Burada X=C++</h2>
    <p class="filelink">
    Kodu al:
    <a href="/docs/files/learncpp-tr.cpp">learncpp-tr.cpp</a>
    </p>
  <div id="doc">
    <p>C++ 
<a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">yaratıcısı Bjarne Stroustrup&#39;a göre</a>,</p>

<ul>
<li>&ldquo;daha iyi bir C&rdquo; yapmak</li>
<li>veri soyutlamayı desteklemek </li>
<li>nesneye yönelik programlamayı deskteklemek</li>
<li>tipten bağımsız programlamayı desteklemek </li>
</ul>

<p>için tasarlanmış bir sistem programlama dilir.</p>

<p>Sözdizimi daha yeni dillerden daha zor veya karmaşık olsa da işlemcinin doğrudan çalıştırabileceği
native komutlara derlenerek, donanım üzerinde (C gibi) sıkı bir kontrol sağlar, bunu yaparken
tipten bağımsızlık, exception&#39;lar ve sınıflar gibi yüksek-seviyeli özellikleri destekler.
Bu hız ve kullanışlılık C++&lsquo;ı en çok kullanılan dillerden biri yapar.</p>
<div class="highlight"><pre class="highlight cpp"><code><span class="c1">//////////////////////</span>
<span class="c1">// C ile karşılaştırma</span>
<span class="c1">//////////////////////</span>

<span class="c1">// C++ _neredeyse_ C'nin bir üstkümesidir, değişken tanımı, basit tipleri</span>
<span class="c1">// ve fonksiyonları için temelde aynı sözdizimini paylaşır.</span>

<span class="c1">// Aynı C gibi, programın başlangıç noktası bir integer döndüren </span>
<span class="c1">// main fonksiyonudur.</span>
<span class="c1">// Bu değer programın bitiş statüsünü belli eder.</span>
<span class="c1">// Daha fazla bilgi için bknz http://en.wikipedia.org/wiki/Exit_status .</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Komut satırı argümanları C'de olduğu gibi argv ve argc ile geçilir</span>
    <span class="c1">// argc, argüman sayısını belli eder,</span>
    <span class="c1">// argv, argümanları belli eden, C-stili string'lerin (char*) dizisidir.</span>
    <span class="c1">// İlk argüman çağrılan programın adıdır.</span>
    <span class="c1">// Eğer argümanları umursamıyorsan, argv ve argc kullanılmayabilir </span>
    <span class="c1">// int main() gibi</span>

    <span class="c1">// 0 çıkış durumu başarıyı belirtir.</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Bunlara rağmen C++ aşağıdaki noktalarda farklılaşır:</span>

<span class="c1">// C++'ta, karakterler char türündendir</span>
<span class="k">sizeof</span><span class="p">(</span><span class="sc">'c'</span><span class="p">)</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

<span class="c1">// C'de, karakterler int türündendir</span>
<span class="k">sizeof</span><span class="p">(</span><span class="sc">'c'</span><span class="p">)</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>


<span class="c1">// C++ katı bir prototip kuralına sahiptir</span>
<span class="kt">void</span> <span class="n">func</span><span class="p">();</span> <span class="c1">// fonksiyon argüman kabul etmez</span>

<span class="c1">// C'de</span>
<span class="kt">void</span> <span class="n">func</span><span class="p">();</span> <span class="c1">// fonksiyon herhangi bir sayıda argüman kabul edebilir</span>

<span class="c1">// C++'da NULL yerine nullptr kullanılır</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">ip</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

<span class="c1">// C standard başlıkları başına "c" eklenip, sondaki .h</span>
<span class="c1">// kullanılmadan C++'ta kullanılabilir</span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Hello, world!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//////////////////////////////////</span>
<span class="c1">// Fonksiyonun fazladan yüklenmesi</span>
<span class="c1">//////////////////////////////////</span>

<span class="c1">// C++ herbir fonksiyonun farklı parametereler</span>
<span class="c1">// aldığı fonksiyon fazladan yüklenmesini desktekler </span>

<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">myString</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"String %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">myString</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="kt">int</span> <span class="n">myInt</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"My int is %d"</span><span class="p">,</span> <span class="n">myInt</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">);</span> <span class="c1">// void print(const char*) fonksiyonunu çağırır.</span>
    <span class="n">print</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span> <span class="c1">// void print(int) fonksiyonunu çağırır.</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////</span>
<span class="c1">// Default fonksiyon argümanları</span>
<span class="c1">////////////////////////////////</span>

<span class="c1">// Eğer çağırıcı tarafından fonksiyona argüman sağlanmamışsa,</span>
<span class="c1">// fonksiyona default argüman verebilirsin</span>

<span class="kt">void</span> <span class="n">doSomethingWithInts</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Burada int'lerle birşeyler yap</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">doSomethingWithInts</span><span class="p">();</span>      <span class="c1">// a = 1,  b = 4</span>
    <span class="n">doSomethingWithInts</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>    <span class="c1">// a = 20, b = 4</span>
    <span class="n">doSomethingWithInts</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// a = 20, b = 5</span>
<span class="p">}</span>

<span class="c1">// Default argümanlar, argüman listesinin sonunda yer almalı.</span>

<span class="kt">void</span> <span class="n">invalidDeclaration</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="c1">// Hata!</span>
<span class="p">{</span>
<span class="p">}</span>


<span class="c1">/////////////////////////</span>
<span class="c1">// Namespace(İsim uzayı)</span>
<span class="c1">/////////////////////////</span>

<span class="c1">// Namespace'ler değişken, fonksiyon ve diğer bildirimlerin </span>
<span class="c1">// kapsama alanını ayırır. </span>
<span class="c1">// Namespace'ler içiçe geçebilir.</span>

<span class="k">namespace</span> <span class="n">First</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">Nested</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"This is First::Nested::foo</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="c1">// Nested namespace'inin sonu</span>
<span class="p">}</span> <span class="c1">// First namespace'inin sonu</span>

<span class="k">namespace</span> <span class="n">Second</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"This is Second::foo</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"This is global foo</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Second namespace'i içinideki tüm sembolleri mevcut kapsama alanına dahil eder.</span>
    <span class="c1">// Dikkat edersen artık yalnızca foo() çağrısı çalışmayacaktır çünkü hangi</span>
    <span class="c1">// namespace'ten çağrıldığı açık değildir.</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">Second</span><span class="p">;</span>

    <span class="n">Second</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span> <span class="c1">// "This is Second::foo" yazdırıır</span>
    <span class="n">First</span><span class="o">::</span><span class="n">Nested</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span> <span class="c1">// "This is First::Nested::foo" yazdırır</span>
    <span class="o">::</span><span class="n">foo</span><span class="p">();</span> <span class="c1">// "This is global foo" yazdırır.</span>
<span class="p">}</span>

<span class="c1">///////////////</span>
<span class="c1">// Input/Output</span>
<span class="c1">///////////////</span>

<span class="c1">// C++'ta input ve output stream'leri kullanır.</span>
<span class="c1">// cin, cout ve cerr,sırasıyla, stdin, stdout, ve stderr'i temsil eder.</span>
<span class="c1">// &lt;&lt; araya ekleme ve &gt;&gt; aradan çıkarma operatörüdür.</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="c1"> // I/O stream'lerini dahil etmek için</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span> <span class="c1">// Streamler std namespace'i içindedir(standard kütüphane)</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="kt">int</span> <span class="n">myInt</span><span class="p">;</span>

   <span class="c1">// stdout (veya terminal/screen)'ta çıktı verir</span>
   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Enter your favorite number:</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
   <span class="c1">// Girdiyi alır </span>
   <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">myInt</span><span class="p">;</span>

   <span class="c1">// cout ayrıca formatlanabilir</span>
   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Your favorite number is "</span> <span class="o">&lt;&lt;</span> <span class="n">myInt</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
   <span class="c1">// prints "Your favorite number is &lt;myInt&gt;"</span>

    <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Used for error messages"</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//////////////</span>
<span class="c1">// String'ler</span>
<span class="c1">/////////////</span>

<span class="c1">// String'ler C++'ta nesnedir ve pek çok üye fonksiyonu vardır</span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span> <span class="c1">// String'ler de std namespace'i içindedir. (standard kütüphane)</span>

<span class="n">string</span> <span class="n">myString</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="p">;</span>
<span class="n">string</span> <span class="n">myOtherString</span> <span class="o">=</span> <span class="s">" World"</span><span class="p">;</span>

<span class="c1">// + eklemek için kullanıldır </span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">myString</span> <span class="o">+</span> <span class="n">myOtherString</span><span class="p">;</span> <span class="c1">// "Hello World"</span>

<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">myString</span> <span class="o">+</span> <span class="s">" You"</span><span class="p">;</span> <span class="c1">// "Hello You"</span>

<span class="c1">// C++'ta  stringler are mutable'dır (değişebilir).</span>
<span class="n">myString</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">" Dog"</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">myString</span><span class="p">;</span> <span class="c1">// "Hello Dog"</span>


<span class="c1">///////////////////////</span>
<span class="c1">// Reference (Referans)</span>
<span class="c1">///////////////////////</span>

<span class="c1">// C'deki pointer'lara ek olarak </span>
<span class="c1">// C++ _reference_'lara sahiptir.</span>
<span class="c1">// Bunlar bir kere atandınğında tekrardan atanamayan pointer'dır</span>
<span class="c1">// ve null olamaz.</span>
<span class="c1">// Değişkenin kendisiyle aynı sözdizimine sahiptir:</span>
<span class="c1">// Değerine ulaşmak için * ihtiyaç yoktur ve</span>
<span class="c1">// atama için &amp; (address of) kullanılmaz.</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">string</span> <span class="n">foo</span> <span class="o">=</span> <span class="s">"I am foo"</span><span class="p">;</span>
<span class="n">string</span> <span class="n">bar</span> <span class="o">=</span> <span class="s">"I am bar"</span><span class="p">;</span>


<span class="n">string</span><span class="o">&amp;</span> <span class="n">fooRef</span> <span class="o">=</span> <span class="n">foo</span><span class="p">;</span> <span class="c1">// Bu foo'nun reference'ını oluşturur.</span>
<span class="n">fooRef</span> <span class="o">+=</span> <span class="s">". Hi!"</span><span class="p">;</span> <span class="c1">// foo'yu reference'ı üzerinden değiştirir.</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">fooRef</span><span class="p">;</span> <span class="c1">// "I am foo. Hi!" yazdırır.</span>

<span class="c1">// "fooRef"e yeniden atama yapmaz. Bu "foo = bar" denktir ve bu satırdan sonra</span>
<span class="c1">//  foo == "I am bar" olur</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">fooRef</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// foo'un adresini yazdırır</span>
<span class="n">fooRef</span> <span class="o">=</span> <span class="n">bar</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">fooRef</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//Hala foo'nun adresini yazdırır</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">fooRef</span><span class="p">;</span>  <span class="c1">//"I am bar" yazdırır</span>

<span class="c1">// fooRef'in adresi aynı kalır yani hala foo'nun adresidir.</span>

<span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">barRef</span> <span class="o">=</span> <span class="n">bar</span><span class="p">;</span> <span class="c1">// bar'a const reference oluşturur</span>
<span class="c1">// C'de olduğu gibi, const değerler (pointer'lar ve reference'ler) değiştirilemez.</span>
<span class="n">barRef</span> <span class="o">+=</span> <span class="s">". Hi!"</span><span class="p">;</span> <span class="c1">// Hata, const reference'ler değiştirilemez.</span>

<span class="c1">// Kısa bir ekleme: reference'lere devam etmeden önce, geçici nesne konseptinden</span>
<span class="c1">// bahsetmeliyiz. Mesela aşadaki gibi bir kod var:</span>
<span class="n">string</span> <span class="n">tempObjectFun</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="n">string</span> <span class="n">retVal</span> <span class="o">=</span> <span class="n">tempObjectFun</span><span class="p">();</span>

<span class="c1">// Bu iki satırda aslında ne oluyor:</span>
<span class="c1">//   - tempObjectFun fonksiyonundan bir string nesnesi dönüyor</span>
<span class="c1">//   - dönmüş olan nesneyle yeni bir string oluşturuyor</span>
<span class="c1">//   - dönmüş olan nesne yok ediliyor</span>
<span class="c1">// İşte bu dönen nesneye geçici nesne denir. Geçici nesneler fonksiyon nesne</span>
<span class="c1">// döndürdüğünde oluşturulur ve ifade işini bitirdiğinde yok edilir (Aslında,</span>
<span class="c1">// standard'ın söylediği şey bu ama derleyiciler bu davranışı değiştirmemize </span>
<span class="c1">// izin veriyor. Daha fazla detay için "return value optimization" diye</span>
<span class="c1">// aratabilirsin. Sonuç olarak aşağıdaki kodda:</span>
<span class="n">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">(</span><span class="n">tempObjectFun</span><span class="p">()))</span>

<span class="c1">// foo ve bar'ın varolduğunu kabul ediyoruz, tempObjectFun'dan dönen nesne</span>
<span class="c1">// bar'a geçti ve foo çağrılmadan önce yokedildir.</span>

<span class="c1">// Şimdi reference'lara dönelim. "ifadenin sonunda" kuralının bir istisnası</span>
<span class="c1">// eğer geçici nesne const reference'a geçildiyse oratya çıkar, bu durumda</span>
<span class="c1">// nesnenin ömrü mevcut kapsama alanına kadar uzar:</span>

<span class="kt">void</span> <span class="n">constReferenceTempObjectFun</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// constRef geçici nesneyi alır ve bu durum fonksiyonun sonuna kadar geçerlidir.</span>
  <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">constRef</span> <span class="o">=</span> <span class="n">tempObjectFun</span><span class="p">();</span>
  <span class="p">...</span>
<span class="p">}</span>

<span class="c1">// C++11 ile gelen diğer bir reference geçici nesnelere özeldir. Bu türden birden </span>
<span class="c1">// bir tip tanımlayamazsın ama aşırı yüklenme sırasında bu tipler öncelik alır:</span>
<span class="kt">void</span> <span class="n">someFun</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>  <span class="c1">// Regular reference</span>
<span class="kt">void</span> <span class="n">someFun</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>  <span class="c1">// Geçici nesneye reference </span>

<span class="n">string</span> <span class="n">foo</span><span class="p">;</span>
<span class="n">someFun</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>  <span class="c1">// regular reference'ı çağırır</span>
<span class="n">someFun</span><span class="p">(</span><span class="n">tempObjectFun</span><span class="p">());</span>  <span class="c1">// geçici reference'ı çağırır</span>

<span class="c1">/////////////////////</span>
<span class="c1">// Enum</span>
<span class="c1">/////////////////////</span>

<span class="c1">// Enum'lar sabit değerler yapmak için kullanılır ve çoğunlukla kodun daha okunaklı</span>
<span class="c1">// olması için kullanılır</span>

<span class="k">enum</span> <span class="n">ECarTypes</span>
<span class="p">{</span>
  <span class="n">Sedan</span><span class="p">,</span>
  <span class="n">Hatchback</span><span class="p">,</span>
  <span class="n">SUV</span><span class="p">,</span>
  <span class="n">Wagon</span>
<span class="p">};</span>

<span class="n">ECarTypes</span> <span class="n">GetPreferredCarType</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">ECarTypes</span><span class="o">::</span><span class="n">Hatchback</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// C++11 ile beraber bir tipi enum'a atamanın kolay bir yolu var, bu enum'un istenen</span>
<span class="c1">// tipe dönüştürmek için kullanışlı bir yöntem</span>
<span class="k">enum</span> <span class="n">ECarTypes</span> <span class="o">:</span> <span class="kt">uint8_t</span>
<span class="p">{</span>
  <span class="n">Sedan</span><span class="p">,</span> <span class="c1">// 0</span>
  <span class="n">Hatchback</span><span class="p">,</span> <span class="c1">// 1</span>
  <span class="n">SUV</span> <span class="o">=</span> <span class="mi">254</span><span class="p">,</span> <span class="c1">// 254</span>
  <span class="n">Hybrid</span> <span class="c1">// 255</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">WriteByteToFile</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">InputValue</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Serialize the InputValue to a file</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">WritePreferredCarTypeToFile</span><span class="p">(</span><span class="n">ECarTypes</span> <span class="n">InputCarType</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// enum uint8_t tipine dönüştürüldü</span>
    <span class="n">WriteByteToFile</span><span class="p">(</span><span class="n">InputCarType</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Diğer yandan enum'ların yanlışlıkla integer tipini veya diğer enumlara dönüşmesini</span>
<span class="c1">// istemiyorsan enum class olarak tanımlayabilirsin</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">ECarTypes</span> <span class="o">:</span> <span class="kt">uint8_t</span>
<span class="p">{</span>
  <span class="n">Sedan</span><span class="p">,</span> <span class="c1">// 0</span>
  <span class="n">Hatchback</span><span class="p">,</span> <span class="c1">// 1</span>
  <span class="n">SUV</span> <span class="o">=</span> <span class="mi">254</span><span class="p">,</span> <span class="c1">// 254</span>
  <span class="n">Hybrid</span> <span class="c1">// 255</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">WriteByteToFile</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">InputValue</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Serialize the InputValue to a file</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">WritePreferredCarTypeToFile</span><span class="p">(</span><span class="n">ECarTypes</span> <span class="n">InputCarType</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ECarTypes, uint8_t tipinde olmasına rağmen, "enum class" olarak </span>
    <span class="c1">// tanımlandığından derlenmeyecektir!</span>
    <span class="n">WriteByteToFile</span><span class="p">(</span><span class="n">InputCarType</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">///////////////////////////////////////////</span>
<span class="c1">// Sınıflar ve nesneye yönelik proglamalama</span>
<span class="c1">///////////////////////////////////////////</span>

<span class="c1">// Sınıflara(class) ilk örnek</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="c1">// Sınıfı tanımla.</span>
<span class="c1">// Sınıflar genelde header (.h veya .hpp) dosyalarında tanımlanır.</span>
<span class="k">class</span> <span class="nc">Dog</span> <span class="p">{</span>
    <span class="c1">// Üye değişkenler ve fonksiyonlar default olarak private'dir.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">weight</span><span class="p">;</span>

<span class="c1">// Aşağıda, "private:" veya "protected:" bulunana kadar</span>
<span class="c1">// bütün üyeler public'tir.</span>
<span class="nl">public:</span>

    <span class="c1">// Default constructor</span>
    <span class="n">Dog</span><span class="p">();</span>

    <span class="c1">// Üye fonksiyon bildirimi (gerçeklenimi aşağıda)</span>
    <span class="c1">// Dikkat ederseniz using namespace std; yerine</span>
    <span class="c1">// std::string kullandık.</span>
    <span class="c1">// Hiçbir zaman header dosyasında "using namespace std;" kullanma.</span>
    <span class="kt">void</span> <span class="n">setName</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">dogsName</span><span class="p">);</span>

    <span class="kt">void</span> <span class="n">setWeight</span><span class="p">(</span><span class="kt">int</span> <span class="n">dogsWeight</span><span class="p">);</span>

    <span class="c1">// Nesnenin durumunu değiştirmeyen fonksiyonlar const ile işaretlenmelidir</span>

    <span class="c1">// Türetilen sınıflarda fonksiyonu override edebilmek için başına </span>
    <span class="c1">// _virtual_ eklenmelidir.</span>
    <span class="c1">// Fonksiyonlar, performanslar ilgili nedenlerden ötürü default olarak virtual değildir</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// Fonksiyonlar class içinde de tanımlanabilir.</span>
    <span class="c1">// Bu şekille tanımlanan fonksiyonlar otomatik olarak inline olur.</span>
    <span class="kt">void</span> <span class="n">bark</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">" barks!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// C++ constructor'ların yanında destructor'da sağlar.</span>
    <span class="c1">// Bunlar nesne silindiğinde veya scope'un dışına çıktığında çağrılır.</span>
    <span class="c1">// Bu RAII gibi güçlü paradigmaları etkin kılar.</span>
    <span class="c1">// (aşağıda açıklandı)</span>
    <span class="c1">// Eğer sınıf kendisinden türetiliyorsa, destructor virtual olmalıdır,</span>
    <span class="c1">// eğer virtual değilse, türetilmiş sınıfın destructor'ı nesne, ana sınıf</span>
    <span class="c1">// referans'ı veya pointer'ı üzerinden yok edildiğinde, çağrılmayacaktır.</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Dog</span><span class="p">();</span>

<span class="p">};</span> <span class="c1">// class tanımının sonuda noktalı virgül(;) olmalıdır.</span>

<span class="c1">// Sınıfın üye fonksiyonları genelde .cpp dosyaları içinde gerçeklenir.</span>
<span class="n">Dog</span><span class="o">::</span><span class="n">Dog</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"A dog has been constructed</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Objects (such as strings) should be passed by reference</span>
<span class="c1">// Nesneler (string gibi) reference ile fonksiyonlara geçilmelidir</span>
<span class="c1">// Eğer nesneleri değiştirilecekse reference ile fonksiyonlara geçilmelidir,</span>
<span class="c1">// değiştirilmeyecekse const reference ile geçilmelidir.</span>
<span class="kt">void</span> <span class="n">Dog</span><span class="o">::</span><span class="n">setName</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">dogsName</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">dogsName</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Dog</span><span class="o">::</span><span class="n">setWeight</span><span class="p">(</span><span class="kt">int</span> <span class="n">dogsWeight</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">dogsWeight</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Dikkat edersen "virtual" yalnızca bildirimde gerekli, tanımlamada değil.</span>
<span class="kt">void</span> <span class="n">Dog</span><span class="o">::</span><span class="n">print</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Dog is "</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">" and weighs "</span> <span class="o">&lt;&lt;</span> <span class="n">weight</span> <span class="o">&lt;&lt;</span> <span class="s">"kg</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Dog</span><span class="o">::~</span><span class="n">Dog</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Goodbye "</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Dog</span> <span class="n">myDog</span><span class="p">;</span> <span class="c1">// "A dog has been constructed" yazdırır</span>
    <span class="n">myDog</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">"Barkley"</span><span class="p">);</span>
    <span class="n">myDog</span><span class="p">.</span><span class="n">setWeight</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">myDog</span><span class="p">.</span><span class="n">print</span><span class="p">();</span> <span class="c1">// "Dog is Barkley and weighs 10 kg" yazdırır.</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// "Goodbye Barkley" yazdırır.</span>

<span class="c1">// Inheritance(Miras)</span>

<span class="c1">// Bu sınıf, Dog sınıfında public ve protected olan herşeyi miras alır, </span>
<span class="c1">// private olanları da miras alır ama, public ve protected sınıflar aracılıyla</span>
<span class="c1">// yapılmıyorsa, doğrudan erişemez.</span>
<span class="k">class</span> <span class="nc">OwnedDog</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Dog</span> <span class="p">{</span>

<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">setOwner</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">dogsOwner</span><span class="p">);</span>

    <span class="c1">// print fonksiyonunun davranışını bütün OwnedDogs sınıfı için override eder</span>
    <span class="c1">// (üstünden geçer, kendine uyarlar).</span>
    <span class="c1">// bknz http://en.wikipedia.org/wiki/Polymorphism_(computer_science)</span>
    <span class="c1">// override anahtar sözcüpü kullanılma da olur ama kullanılması aslında bir temel</span>
    <span class="c1">// temel sınıf fonksiyonunun üzerinden geçtiğimizi gösterir.</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

<span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">owner</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Bu arada takip eden .cpp dosyasında:</span>

<span class="kt">void</span> <span class="n">OwnedDog</span><span class="o">::</span><span class="n">setOwner</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">dogsOwner</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">owner</span> <span class="o">=</span> <span class="n">dogsOwner</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">OwnedDog</span><span class="o">::</span><span class="n">print</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">Dog</span><span class="o">::</span><span class="n">print</span><span class="p">();</span> <span class="c1">// Ana dog sınıfındaki print fonksiyonunu çağırır </span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Dog is owned by "</span> <span class="o">&lt;&lt;</span> <span class="n">owner</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="c1">//        "Dog is &lt;name&gt; and weights &lt;weight&gt;"</span>
    <span class="c1">//        "Dog is owned by &lt;owner&gt;"</span>
    <span class="c1">//         yazdırır</span>
<span class="p">}</span>

<span class="c1">/////////////////////////////////////////////////////</span>
<span class="c1">// ilk değer atama ve Operatörün fazladan yüklenmesi</span>
<span class="c1">/////////////////////////////////////////////////////</span>

<span class="c1">// C++ dilinde +, -, *, /, gibi operatörlerin davranışını fazladan yükleyebilirsiniz.</span>
<span class="c1">// Bu, operator her kullandınıldığında çağrılan bir fonksiyon tanımlamasıyla yapılır.</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Üye değişkenkenlere default değer atanabilir.</span>
    <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// Default constructor</span>
    <span class="n">Point</span><span class="p">()</span> <span class="p">{</span> <span class="p">};</span>

    <span class="n">Point</span> <span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span> <span class="o">:</span>
        <span class="n">x</span><span class="p">(</span><span class="n">a</span><span class="p">),</span>
        <span class="n">y</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="p">{</span> <span class="cm">/* İlk değer atama dışında birşey yapma */</span> <span class="p">}</span>

    <span class="c1">// + operatorünün fazladan yükle.</span>
    <span class="n">Point</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// += operatorünü fazladan yükle</span>
    <span class="n">Point</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>

    <span class="c1">// - ve -= operatorleri fazladan yüklemek de mantıklı olurdu</span>
    <span class="c1">// ama kısa tutmak için burda değinmedik.</span>
<span class="p">};</span>

<span class="n">Point</span> <span class="n">Point</span><span class="o">::</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// yeni bir nokta oluştur ve bunu rhs ile topla</span>
    <span class="k">return</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Point</span><span class="o">&amp;</span> <span class="n">Point</span><span class="o">::</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">x</span> <span class="o">+=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="n">y</span> <span class="o">+=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">Point</span> <span class="n">up</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">Point</span> <span class="n">right</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="c1">// Bu Point + operatorünü çağırır</span>
    <span class="n">Point</span> <span class="n">result</span> <span class="o">=</span> <span class="n">up</span> <span class="o">+</span> <span class="n">right</span><span class="p">;</span>
    <span class="c1">// "Result is upright (1,1)" yazdırır.</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Result is upright ("</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="sc">','</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="s">")</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">////////////////////////</span>
<span class="c1">// Şablonlar (Templates)</span>
<span class="c1">////////////////////////</span>

<span class="c1">// Şablonlar C++ dilinde tipten bağımsız programlama için kullanılır.</span>

<span class="c1">// Zaten aşina olduğun tipten bağımsız programlamayla başladık. Bir tip parametresi</span>
<span class="c1">// alan fonksiyon veya sınıf tanımlamaık için:</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Box</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Bu sınıfta T, herhangi bir tip için kullanılabilir.</span>
    <span class="kt">void</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Derleme esnasında derleyici aslında, parametreleri yerine konmuş şekilde herbir şablonu üretir,</span>
<span class="c1">// bu yüzden sınıfın tam tanımı her çağrılma sırasında var olmak zorundadır. Bu nedenle şablon sınıflarını</span>
<span class="c1">// tamamen header dosyalarında görürsün.</span>

<span class="c1">// Stack'ta şablon sınıfın bir örneğini oluşturmak için:</span>
<span class="n">Box</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">intBox</span><span class="p">;</span>

<span class="c1">// ve, anladığın gibi, kullanabilirsin:</span>
<span class="n">intBox</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>

<span class="c1">// Tabi, şablonları içiçe geçirebilirsin:</span>
<span class="n">Box</span><span class="o">&lt;</span><span class="n">Box</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">boxOfBox</span><span class="p">;</span>
<span class="n">boxOfBox</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">intBox</span><span class="p">);</span>

<span class="c1">// C++11'den önce iki '&gt;' arasına boşluk koymak zorundaydık yoksa sağa kaydırma </span>
<span class="c1">// operatörü olarak algılanabilirdi.</span>

<span class="c1">// Bazen şunu da görebilirsin</span>
<span class="c1">//   template&lt;typename T&gt;</span>
<span class="c1">// 'class' ve 'typename' anahtar sözcükleri çoğunlukla </span>
<span class="c1">// birbirlerinin yerine kullanılabilir. Tam açıklama için, bknz.</span>
<span class="c1">//   http://en.wikipedia.org/wiki/Typename</span>
<span class="c1">// (evet, bu anahtar sözcüğün kendi Wikipedia sayfası var).</span>

<span class="c1">// Benzer şekilde, bir şablon fonksiyon:</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">barkThreeTimes</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">input</span><span class="p">.</span><span class="n">bark</span><span class="p">();</span>
    <span class="n">input</span><span class="p">.</span><span class="n">bark</span><span class="p">();</span>
    <span class="n">input</span><span class="p">.</span><span class="n">bark</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Dikkat edersen tip parametresi hakkında birşey belirtilmedi. Derleyici bunları üretecek</span>
<span class="c1">// ve her parametre geçişinde tip-kontrolü yapacaktır, bu nedenle de fonksiyon herhangi bir T</span>
<span class="c1">// tipi için çalışacaktır!</span>

<span class="n">Dog</span> <span class="n">fluffy</span><span class="p">;</span>
<span class="n">fluffy</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">"Fluffy"</span><span class="p">)</span>
<span class="n">barkThreeTimes</span><span class="p">(</span><span class="n">fluffy</span><span class="p">);</span> <span class="c1">// Üç kere "Fluffy barks" yazdırır.</span>

<span class="c1">// Şablonun parametresi sınıf olmak zorunda değildir:</span>
<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">Y</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">printMessage</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Learn C++ in "</span> <span class="o">&lt;&lt;</span> <span class="n">Y</span> <span class="o">&lt;&lt;</span> <span class="s">" minutes!"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Ve template'i daha etkili kod için dışarıdan özelleştirebilirsin. </span>
<span class="c1">// Tabiki gerçek-dünya kullanımlarında özelleştirme bunun kadar kolay değildir.</span>
<span class="c1">// Dikkat edersen, bütün parametreleri dıştan özelleştirmiş olsak bile</span>
<span class="c1">// hala fonksiyonu (veya sınıfı( template olarak tanımlamamız gerekli.</span>
<span class="k">template</span><span class="o">&lt;</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">printMessage</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Learn C++ faster in only 10 minutes!"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">printMessage</span><span class="o">&lt;</span><span class="mi">20</span><span class="o">&gt;</span><span class="p">();</span>  <span class="c1">// "Learn C++ in 20 minutes!" yazdırır</span>
<span class="n">printMessage</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span><span class="p">();</span>  <span class="c1">// "Learn C++ faster in only 10 minutes!" yazdırır</span>


<span class="c1">///////////////////////////////////////////////</span>
<span class="c1">// İstisnai Durum Yönetimi (Exception Handling)</span>
<span class="c1">///////////////////////////////////////////////</span>

<span class="c1">// Standard kütüphane bazı istisnai tipler sağlar</span>
<span class="c1">// (bknz http://en.cppreference.com/w/cpp/error/exception)</span>
<span class="c1">// ama herhangi bir tip de istisnai durum fırlatabilir </span>

<span class="cp">#include</span> <span class="cpf">&lt;exception&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdexcept&gt;</span><span class="cp">
</span>
<span class="c1">// _try_ bloğu içinde fırlatılan bütün istisnai durumlar, takip eden, _catch_ ile </span>
<span class="c1">// yakalanabilir.</span>
<span class="k">try</span> <span class="p">{</span>
    <span class="c1">// _new_ kullanarak heap'ten istisnai durumlar için yer ayırma</span>
    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"A problem occurred"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// istisnai durumlar nesne ise  const reference ile yakala</span>
<span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Bir önceki _catch_ bloğundan kaçan istisnai durum burda yakala</span>
<span class="k">catch</span> <span class="p">(...)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Unknown exception caught"</span><span class="p">;</span>
    <span class="k">throw</span><span class="p">;</span> <span class="c1">// Tekrardan istisnai durum fırlatır</span>
<span class="p">}</span>

<span class="c1">///////</span>
<span class="c1">// RAII</span>
<span class="c1">///////</span>

<span class="c1">// RAII, "Resource Acquisition Is Initialization" kelimelerinin kısaltmasıdır.</span>
<span class="c1">// Bu Türkçe, "Kaynak alımı aynı zamanda ilk değer atamasıdır." olarak çevrilebilir.</span>
<span class="c1">// Bunu basitçe constructor ile ayrılan hafızanın destructor ile iade edilmesi olarak </span>
<span class="c1">// düşünebiliriz.</span>

<span class="c1">// Bunun ne şekilde kullanışlı olduğunu görmek için</span>
<span class="c1">// bir C dosyasının, dosya işleme biçimine bakabiliriz:</span>
<span class="kt">void</span> <span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Başlangıçta herşeyin yolunda gittiğini düşünelim</span>

    <span class="kt">FILE</span><span class="o">*</span> <span class="n">fh</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span> <span class="c1">// Dosyayı okuma modunda aç</span>

    <span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
    <span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>

    <span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span> <span class="c1">// Dosyayı kapat</span>
<span class="p">}</span>

<span class="c1">// Malesef hatalarla başa çıkmaya çalışırken işler hızlıca karmaşıklaşır.</span>
<span class="c1">// Mesela fopen'ın başarısız olduğunu varsayalım, ve doSoomethingWithTheFile ve </span>
<span class="c1">// doSomethingWithIt hata kodları gönderdi.</span>
<span class="c1">//  (İstisnai durumlar yonetimi, hata koduna tercih ediler bir yöntemdir, ama bazı</span>
<span class="c1">//   programcılar, özellikle C arkaplanı olanlar, aynı fikirde değildir.</span>
<span class="c1">// Bu durumda her bir fonksiyon çağrısını kontrol etmeli ve bir problem oluştuysa</span>
<span class="c1">// dosyayı kapatmalıyız.</span>

<span class="kt">bool</span> <span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">FILE</span><span class="o">*</span> <span class="n">fh</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>  <span class="c1">// Dosyayı okuma modunda aç</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fh</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="c1">// Başarısız olma durumunda dönen değer null olur</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Başarısız olma durumunu çağırıcıya bildir</span>

    <span class="c1">// Başarısız olma durumunda her iki fonksiyonun da false döndürdüğünü kabul edelim</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span> <span class="c1">// Dosyayı kapatalım, akıntı olmasın.</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Hatayı bildir</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span> <span class="c1">// Dosyayı kapatalım, akıntı olmasın.</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Hatayı bildir</span>
    <span class="p">}</span>

    <span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span> <span class="c1">// Dosyayı kapat</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// Başarı durumunu ifade eder</span>
<span class="p">}</span>

<span class="c1">// C programcıları biraz goto kullanarak bu durumu temizler</span>
<span class="kt">bool</span> <span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">FILE</span><span class="o">*</span> <span class="n">fh</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fh</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>

    <span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span> <span class="c1">// Dosyayı kapat </span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// Başarı durumunu ifade eder</span>

<span class="nl">failure:</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Hatayı bildir</span>
<span class="p">}</span>

<span class="c1">// Eğer fonksiyon istisnai durum yönetimi araçlarını kullanırsa</span>
<span class="c1">// işler daha temiz olur ama hala en iyi durumun altında kalır.</span>
<span class="kt">void</span> <span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">FILE</span><span class="o">*</span> <span class="n">fh</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span> 
    <span class="k">if</span> <span class="p">(</span><span class="n">fh</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Could not open the file."</span><span class="p">);</span>

    <span class="k">try</span> <span class="p">{</span>
        <span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
        <span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
        <span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span> <span class="c1">// Hata durumunda dosyayı kapattığından emin ol</span>
        <span class="k">throw</span><span class="p">;</span> <span class="c1">// Sonra, tekrardan istisnai durum fırlat</span>
    <span class="p">}</span>

    <span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span> <span class="c1">// Dosyayı kapat</span>
    <span class="c1">// Herşey başarılı</span>
<span class="p">}</span>

<span class="c1">// Şimdi aynı şeyi C++'ın dosya stream sınıfıyla (fstream) karşılaştıralım</span>
<span class="c1">// fstream, dosyayı kapatmak için kendi destructor'ını kullanır.</span>
<span class="c1">// Destructor'ın, nesne scope dışına çıktığında otomatik olarak çağrıldığını </span>
<span class="c1">// hatırlayın.</span>
<span class="kt">void</span> <span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">fh</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span> <span class="c1">// Dosyayı aç</span>

    <span class="c1">// Dosyayla birşeyler yap</span>
    <span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
    <span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>

<span class="p">}</span> <span class="c1">// Dosya, destructor tarafından otomatik olarak kapatıldı</span>

<span class="c1">// Bunun _çok büyük_ avantajları var:</span>
<span class="c1">// 1. Ne olursa olursun,</span>
<span class="c1">//    kaynak (bu örnekte dosya tutucusu) temizlenecektir.</span>
<span class="c1">//    Destructor doğru yazıldığında,</span>
<span class="c1">//    Tutucuyu kapatmayı unutma ve kaynak akıntısı _imkansız_dır.</span>
<span class="c1">// 2. Kodun çok daha temiz olduğuna dikkat edin.</span>
<span class="c1">//    Destructor, dosyayı kapatma işini, endilenmemize gerek kalmadan</span>
<span class="c1">//    arka planda halleder.</span>
<span class="c1">// 3. Kod, istisnai durumlara karşı korunaklıdır.</span>
<span class="c1">//    İstisnai durum fonksiyonun herhangi bir yerinde fırlatılabilir ve</span>
<span class="c1">//    temizleme işi gene de yapılır.</span>

<span class="c1">// Bütün C++ kodu deyimleri RAII prensibini tüm kaynakları için kullanır.</span>
<span class="c1">// Ek örnekler şunlardır:</span>
<span class="c1">// - unique_ptr ve shared_ptr ile hafıza kullanımı</span>
<span class="c1">// - Tutucular - standard kütüphane linked list,</span>
<span class="c1">//   vector (yani kendiliğinden boyu ayarlanan dizi), hash map vs.</span>
<span class="c1">//   scope'un dışına çıktığında içerini otomatik olarak yok eden tüm yapılar.</span>
<span class="c1">// - lock_guard ve unique_lock kullanan mutex'ler</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Lambda İfadeleri (C++11 ve yukarısı)</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// lambda'lar, tam olarak çağrıldığı yerde bir anonim fonksiyon tanımlamak</span>
<span class="c1">// veya fonksiyona argüman geçmek için uygun bir yoldur.</span>

<span class="c1">// Mesela, pair'lardan oluşan bir vector'u, pair'ın ikinci değerine </span>
<span class="c1">// göre sıralamak isteyelim</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">tester</span><span class="p">;</span>
<span class="n">tester</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">));</span>
<span class="n">tester</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">));</span>
<span class="n">tester</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

<span class="c1">// sort fonksiyonuna üçüncü argüman olarak lambda ifadesini geç</span>
<span class="c1">// sort, &lt;algorithm&gt; başlığında tanımlı</span>

<span class="n">sort</span><span class="p">(</span><span class="n">tester</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">tester</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">const</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
    <span class="p">});</span>

<span class="c1">// Lambda ifadesinin söz dizimine dikkat edin, </span>
<span class="c1">// lambda'daki [], değişkenleri "tutmak" için kullanılır</span>
<span class="c1">// "Tutma listesi", fonksiyon gövdesinde nelerin, ne şekilde erişilebilir olduğunu tanımlar</span>
<span class="c1">// Şunlardan biri olabilir:</span>
<span class="c1">//  1. bir değer : [x]</span>
<span class="c1">//  2. bir referans : [&amp;x]</span>
<span class="c1">//  3. mevcut scope içindeki herhangi bir değişkene referans ile [&amp;]</span>
<span class="c1">//  4. 3 ile aynı, ama değer ile [=]</span>
<span class="c1">// Mesela:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dog_ids</span><span class="p">;</span>
<span class="c1">// number_of_dogs = 3;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dog_ids</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">weight</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">30</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">10</span><span class="p">};</span>

<span class="c1">// Mesela dog_ids vector'unu dog'ların ağırlıklarına göre sıralamak isteyelim</span>
<span class="c1">// Yani en sonunda şöyle olmalı: [2, 0, 1]</span>

<span class="c1">// Burada lambda ifadesi oldukça kullanışlıdır</span>

<span class="n">sort</span><span class="p">(</span><span class="n">dog_ids</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">dog_ids</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">weight</span><span class="p">](</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">weight</span><span class="p">[</span><span class="n">lhs</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">weight</span><span class="p">[</span><span class="n">rhs</span><span class="p">];</span>
    <span class="p">});</span>
<span class="c1">// Dikkat edersen "weight" dizisini referans ile aldık.</span>
<span class="c1">// C++'da lambdalar hakkında daha fazla bilgi için : http://stackoverflow.com/questions/7627098/what-is-a-lambda-expression-in-c11</span>

<span class="c1">//////////////////////////////////</span>
<span class="c1">// Akıllı For (C++11 ve yukarısı)</span>
<span class="c1">//////////////////////////////////</span>

<span class="c1">// Akıllı for döngüsünü bir tutucuyu dolaşmak için kullanabilirsin</span>
<span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>

<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">elem</span><span class="o">:</span> <span class="n">arr</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Tutucunun elemanlarının tipi için endişe etmeden "auto" kullanabilirsin</span>
<span class="c1">// Mesela:</span>

<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">elem</span><span class="o">:</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// arr dizisinin elemanlarıyla ilgili bir şeyler yap</span>
<span class="p">}</span>

<span class="c1">////////////////</span>
<span class="c1">// Güzel Şeyler</span>
<span class="c1">////////////////</span>

<span class="c1">// C++ dilinin bakış açısı yeni başlayanlar için (hatta dili iyi bilenler için bile)</span>
<span class="c1">// şaşırtıcı olabilir. </span>
<span class="c1">// Bu bölüm, ne yazık ki, büyük ölçüde tam değil; C++ kendi ayağına ateş edilebilecek kolay</span>
<span class="c1">// dillerden biridir.</span>

<span class="c1">// private metodları override edebilirsin!</span>
<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">bar</span><span class="p">();</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">FooSub</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">bar</span><span class="p">();</span>  <span class="c1">// Foo::bar fonksiyonu override edilir!</span>
<span class="p">};</span>


<span class="c1">// 0 == false == NULL (çoğu zaman)!</span>
<span class="kt">bool</span><span class="o">*</span> <span class="n">pt</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">bool</span><span class="p">;</span>
<span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 'pt'nin gösterdiği değere false atar.</span>
<span class="n">pt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 'pt'ye null pointer atar. Her iki satır uyarısız derlenir.</span>

<span class="c1">// nullptr'ın bu meselenin bazılarını çözmesi beklenmiştir:</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">pt2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>
<span class="o">*</span><span class="n">pt2</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="c1">// Derlenmez.</span>
<span class="n">pt2</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>  <span class="c1">// pt2'ye null atar.</span>

<span class="c1">// bool tipleri için bir istisna vardır.</span>
<span class="c1">// Bu null pointer'ları if(!ptr) ile test etmek içindir.</span>
<span class="c1">// ama sonuç olarak bir bool değerine nullptr atayabilirsin!</span>
<span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>  <span class="c1">// '*pt' değeri bir boll olmasına rağmen, hala derlenir!</span>


<span class="c1">// '=' != '=' != '='!</span>
<span class="c1">// Calls Foo::Foo(const Foo&amp;) or some variant (see move semantics) copy</span>
<span class="c1">// Foo::Foo(const Foo&amp;) çağrısını veya kopyalama constructor'ının bir çeşidinin çağrısınıyapar(taşıma semantiklerine bknz.)</span>
<span class="n">Foo</span> <span class="n">f2</span><span class="p">;</span>
<span class="n">Foo</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">f2</span><span class="p">;</span>

<span class="c1">// Foo::operator=(Foo&amp;) çağrısını yapar.</span>
<span class="n">Foo</span> <span class="n">f1</span><span class="p">;</span>
<span class="n">f1</span> <span class="o">=</span> <span class="n">f2</span><span class="p">;</span>


<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Tuple (C++11 ve yukarısı)</span>
<span class="c1">///////////////////////////////////////</span>

<span class="cp">#include</span><span class="cpf">&lt;tuple&gt;</span><span class="cp">
</span>
<span class="c1">// Ana fikir olarak, Tuple, eski veri yapılarına (C'deki struct'lar) benzer ama isimli veri üyeleri yerine </span>
<span class="c1">// elemanlarına tuple içindeki sırasına göre erişilir.</span>

<span class="c1">// Tuple'ı inşa ederek başlayalım</span>
<span class="c1">// değişkenleri tuple içinde paketliyoruz</span>
<span class="k">auto</span> <span class="n">first</span> <span class="o">=</span> <span class="n">make_tuple</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="sc">'A'</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">maxN</span> <span class="o">=</span> <span class="mf">1e9</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">maxL</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">second</span> <span class="o">=</span> <span class="n">make_tuple</span><span class="p">(</span><span class="n">maxN</span><span class="p">,</span> <span class="n">maxL</span><span class="p">);</span>

<span class="c1">// 'first' tuple'ının değerlerini yazdırma</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// 10 A yazdırır</span>

<span class="c1">// 'second' tuple'ının değerlerini yazdırma</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">second</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">second</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// 1000000000 15 yazdırır</span>

<span class="c1">// Değişkenleri tuple'dan çıkarma</span>

<span class="kt">int</span> <span class="n">first_int</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">first_char</span><span class="p">;</span>
<span class="n">tie</span><span class="p">(</span><span class="n">first_int</span><span class="p">,</span> <span class="n">first_char</span><span class="p">)</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">first_int</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">first_char</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>  <span class="c1">// 10 A yazdırır</span>

<span class="c1">// Ayrıca şu şekide de tuple oluşturabiliriz.</span>

<span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">third</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="sc">'A'</span><span class="p">,</span> <span class="mf">3.14141</span><span class="p">);</span>
<span class="c1">// tuple_size, tuple'daki eleman sayısını (constexpr olarak) döndürür</span>

<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tuple_size</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">third</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// 3 yazdırır</span>

<span class="c1">// tuple_cat, tuple'daki tüm elemanları aynı sırada birleştirir.</span>

<span class="k">auto</span> <span class="n">concatenated_tuple</span> <span class="o">=</span> <span class="n">tuple_cat</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="n">third</span><span class="p">);</span>
<span class="c1">// concatenated_tuple = (10, 'A', 1e9, 15, 11, 'A', 3.14141) olur</span>

<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">concatenated_tuple</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// 10 yazdırır</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">concatenated_tuple</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// 15 yazdırır</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">&gt;</span><span class="p">(</span><span class="n">concatenated_tuple</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// 'A' yazdırır</span>


<span class="c1">/////////////////////</span>
<span class="c1">// Tutucular</span>
<span class="c1">/////////////////////</span>

<span class="c1">// Tutucular veya Standard Şablon Kütüphanesi(STL) önceden tanımlanmış şablonlar sunar.</span>
<span class="c1">// Bunlar elemanları için ayrılan hafıza alanını yönetir</span>
<span class="c1">// ve onlara erişim ve değiştirmek için üye fonksiyonlar sağlar</span>

<span class="c1">// Bazı tutucular şunlardır:</span>

<span class="c1">// Vector (Dinamik Dizi)</span>
<span class="c1">// koşma anında nesne dizisi veya list oluşturmamızı sağlar</span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="n">string</span> <span class="n">val</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">my_vector</span><span class="p">;</span> <span class="c1">// vector'ü tanımla</span>
<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">val</span><span class="p">;</span>
<span class="n">my_vector</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">val</span><span class="p">);</span> <span class="c1">// val değerini my_vector vectörüne push edecektir</span>
<span class="n">my_vector</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">val</span><span class="p">);</span> <span class="c1">// val değerini yeniden push edecektir (şu an iki elemanı var)</span>

<span class="c1">// vector içinde dolaşmak için iki seçenek var:</span>
<span class="c1">// ya klasik döngüyle (0. index'ten son index'e kadar iterasyon yaparak)</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">my_vector</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">my_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// vector'ün elemanlarına uşamak için [] operatörünü kullanabiliriz</span>
<span class="p">}</span>

<span class="c1">// ya da iteratör kulllanarak:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="p">;</span> <span class="c1">// vector için iterator tanımla</span>
<span class="k">for</span> <span class="p">(</span><span class="n">it</span> <span class="o">=</span> <span class="n">my_vector</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">my_vector</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span>  <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Set(Küme)</span>
<span class="c1">// Set'ler benzersiz(unique) elemanları belirli bir sırada saklayan tutuculardır.</span>
<span class="c1">// Set, benzersiz değerleri, herhangi bir fonksiyon veya kod gerektirmeksizin, sıralı olarak</span>

<span class="cp">#include</span><span class="cpf">&lt;set&gt;</span><span class="cp">
</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ST</span><span class="p">;</span>    <span class="c1">// int tipi için set tanımlar</span>
<span class="n">ST</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>  <span class="c1">// ST kümesini 30 değerini dahil eder</span>
<span class="n">ST</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>  <span class="c1">// ST kümesini 10 değerini dahil eder</span>
<span class="n">ST</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>  <span class="c1">// ST kümesini 20 değerini dahil eder</span>
<span class="n">ST</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>  <span class="c1">// ST kümesini 30 değerini dahil eder</span>
<span class="c1">// Şimdi kümedeki elemanlar aşağıdaki gibidir</span>
<span class="c1">//  10 20 30</span>

<span class="c1">// Bir eleman silmek için:</span>
<span class="n">ST</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>  <span class="c1">// 20 değerine sahip elemanı siler</span>
<span class="c1">// Set ST: 10 30</span>
<span class="c1">// Iterator kullanarak Set içinde iterasyon yapmak için:</span>
<span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="n">it</span><span class="o">=</span><span class="n">ST</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="n">it</span><span class="o">&lt;</span><span class="n">ST</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// Output:</span>
<span class="c1">// 10</span>
<span class="c1">// 30</span>

<span class="c1">// Tutucuyu tamamen silmek için Tutucu_Adi.clear() kullanırız</span>
<span class="n">ST</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ST</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>  <span class="c1">// ST kümesinin eleman sayısı(size)nı yazdırır.</span>
<span class="c1">// Output: 0</span>

<span class="c1">// NOTE: Aynı elemanlari içerebilen kümle için multiset kullanırız</span>

<span class="c1">// Map(Harita)</span>
<span class="c1">// Map, elemanları anahtar değer, haritalanmış değer şeklinde özel bir sırada saklar.</span>
<span class="c1">// anahtar_değer -&gt; haritalanmış_değer</span>

<span class="cp">#include</span><span class="cpf">&lt;map&gt;</span><span class="cp">
</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">mymap</span><span class="p">;</span>  <span class="c1">// Anahtar char ve değer int olacak şekilde map tanımlar</span>

<span class="n">mymap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="sc">'A'</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
<span class="c1">// 1 değeri için A anahtar değerini ekler</span>
<span class="n">mymap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="sc">'Z'</span><span class="p">,</span><span class="mi">26</span><span class="p">));</span>
<span class="c1">// 26 değeri için Z anahtar değerini ekler</span>

<span class="c1">// Map'te dolaşma</span>
<span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">it</span><span class="o">=</span><span class="n">mymap</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span><span class="o">!=</span><span class="n">mymap</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">"-&gt;"</span> <span class="o">&lt;&lt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="c1">// Output:</span>
<span class="c1">// A-&gt;1</span>
<span class="c1">// Z-&gt;26</span>

<span class="c1">// Anahtar'a atanmış değeri bulmak için</span>
<span class="n">it</span> <span class="o">=</span> <span class="n">mymap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">'Z'</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>

<span class="c1">// Output: 26</span>


<span class="c1">/////////////////////////////////////////////</span>
<span class="c1">// Mantıksal ve Bit seviyesindeki operatörler</span>
<span class="c1">/////////////////////////////////////////////</span>

<span class="c1">// Pek çok C++ operatörleri diğer dillerdekiyle aynıdır</span>

<span class="c1">// Mantıksal operatörler</span>

<span class="c1">// C++, bool ifadelerinde Kısa-devre değerlendirmesini kullanır yani ikinci argüman yalnızca ilk argüman</span>
<span class="c1">// ifadenin değerine karar vermek için yeterli değilse çalıştırılır</span>

<span class="nb">true</span> <span class="o">&amp;&amp;</span> <span class="nb">false</span> <span class="c1">// **mantıksal ve** işlemi yapılır ve yanlış sonucu üretilir</span>
<span class="nb">true</span> <span class="o">||</span> <span class="nb">false</span> <span class="c1">// **mantıksal veya** işlemi yapılır ve true  sonucu üretilir </span>
<span class="o">!</span> <span class="nb">true</span>        <span class="c1">// **mantıksal değil** işlemi yapılır ve yalnış sonucu üretilir</span>

<span class="c1">// Sembolleri kullanmak yerine onlara karşılık gelen anahtar kelimeler kullanılabilir</span>
<span class="nb">true</span> <span class="n">and</span> <span class="nb">false</span> <span class="c1">// **mantıksal ve** işlemi yapılır ve yanlış sonucu üretilir</span>
<span class="nb">true</span> <span class="n">or</span> <span class="nb">false</span>  <span class="c1">// **mantıksal veya** işlemi yapılır ve true  sonucu üretilir </span>
<span class="n">not</span> <span class="nb">true</span>       <span class="c1">// **mantıksal değil** işlemi yapılır ve yalnış sonucu üretilir</span>

<span class="c1">// Bit seviyesindeki operatörler</span>

<span class="c1">// **&lt;&lt;** Sola kaydırma operatörü</span>
<span class="c1">// &lt;&lt; bitleri sola kaydırır</span>
<span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="c1">// 4'ün bitlerini 1 sola kaydırır ve 8 sonucunu verir</span>
<span class="c1">// x &lt;&lt; n, x * 2^n olarak düşünülebilir</span>


<span class="c1">// **&gt;&gt;** Sağa kaydırma operatörü</span>
<span class="c1">// &gt;&gt; bitleri sağa kaydırır</span>
<span class="mi">4</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span> <span class="c1">// 4'ün bitlerini 1 sağa kaydırır ve 2 sonucunu verir</span>
<span class="c1">// x &gt;&gt; n, x / 2^n olarak düşünülebilir</span>

<span class="o">~</span><span class="mi">4</span>    <span class="c1">// Bit seviyesinde değil işlemini gerçekleştirir</span>
<span class="mi">4</span> <span class="o">|</span> <span class="mi">3</span> <span class="c1">// Bit seviyesinde veya işlemini gerçekleştirir</span>
<span class="mi">4</span> <span class="o">&amp;</span> <span class="mi">3</span> <span class="c1">// Bit seviyesinde ve işlemini gerçekleştirir</span>
<span class="mi">4</span> <span class="o">^</span> <span class="mi">3</span> <span class="c1">// Bit seviyesinde xor işlemini gerçekleştirir</span>

<span class="c1">// Eşdeğer anahtar kelimeler</span>
<span class="n">compl</span> <span class="mi">4</span>    <span class="c1">// Bit seviyesinde değil işlemini gerçekleştirir</span>
<span class="mi">4</span> <span class="n">bitor</span> <span class="mi">3</span>  <span class="c1">// Bit seviyesinde veya işlemini gerçekleştiri</span>
<span class="mi">4</span> <span class="n">bitand</span> <span class="mi">3</span> <span class="c1">// Bit seviyesinde ve işlemini gerçekleştirir</span>
<span class="mi">4</span> <span class="n">xor</span> <span class="mi">3</span>    <span class="c1">// Bit seviyesinde xor işlemini gerçekleştirir</span>


</code></pre></div>
<p>İleri okuma:</p>

<ul>
<li>Güncel bir referans <a href="http://cppreference.com/w/cpp">CPP Reference</a> adresinde bulunabilir.</li>
<li>Ek kaynaklar <a href="http://cplusplus.com">CPlusPlus</a> adresinde bulunabilir.</li>
<li>Dilin temellerini ve kodlama ortamını belirleyen bir öğretici <a href="https://www.youtube.com/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb">TheChernoProject - C ++</a> adresinde bulunabilir.</li>
</ul>

    <hr>
    <p>Bir öneriniz mi var? Belki bir düzeltme? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Bir konu açın</a> Github deposundan, ya da kendi <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/tr-tr/c++-tr.html.markdown">PR</a>'nizi hazırlayın!
    </p>
    <p class="contributed">
    Aslen katkıda bulunan Steven Basart, ve güncelleştiren <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/tr-tr/c++-tr.html.markdown">6 geliştirici(ler)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2024
        <a href="http://github.com/xksteven">Steven Basart</a>,
        <a href="https://github.com/mrkline">Matt Kline</a>,
        <a href="http://geoffliu.me">Geoff Liu</a>,
        <a href="http://github.com/connorwaters">Connor Waters</a>,
        <a href="http://github.com/ankushg07">Ankush Goyal</a>,
        <a href="https://github.com/jatindhankhar">Jatin Dhankhar</a>,
        <a href="https://github.com/p1v0t">Adem Budak</a>
    </p>

    <p>

    </footer>
  </div>

        </div>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="/js/script.js"></script>

        <script>
            var _gaq=[['_setAccount','UA-3525624-21'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>
</html>
