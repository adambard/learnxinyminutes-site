<!DOCTYPE html>
<html lang="hi">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-WXC8R75DEN');
    </script>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="Content-Language" content="hi">
    <title>Learn C++ in Y Minutes</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto+Slab:wght@100..900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/screen.css">
    <link rel="stylesheet" href="/css/light.css">
    <link rel="stylesheet" href="/css/dark.css">

    <link rel="canonical" href="https://learnxinyminutes.com/hi/c++/">
    <script>
      localStorage.removeItem("lxiym_theme");
    </script>
  </head>
  <body>
    <div class="container">
      <div class="share">
        <span class="sharemsg">
          <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fhi%2Fc%2B%2B%2F&amp;text=Learn+X+in+Y+minutes%2C+where+X%3DC%2B%2B">
            Share this page
          </a>
        </span>
        <span class='st_facebook_large' displayText='Facebook'></span>
        <span class='st_twitter_large' displayText='Tweet'></span>
      </div>
      <h1><a href="/">Learn X in Y minutes</a></h1>
      <h2>Where X=C++</h2>
      <p class="filelink">
        Get the code:
        <a href="/hi/files/learncpp.cpp">learncpp.cpp</a>
      </p>
      <div id="doc">
<p>C++ एक सिस्टम प्रोग्रामिंग लैंग्वेज है जो,
<a href="https://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">इसके आविष्कारक बजेर्न स्ट्राउस्ट्रप के अनुसार</a>,
के लिए डिजाइन किया गया था</p>
<ul>
<li>एक &quot;बेहतर सी&quot; बनें</li>
<li>डेटा एब्स्ट्रैक्शन का समर्थन करें</li>
<li>ऑब्जेक्ट-ओरिएंटेड प्रोग्रामिंग का समर्थन करें</li>
<li>सामान्य प्रोग्रामिंग का समर्थन करें</li>
</ul>
<p>हालांकि इसका सिंटैक्स नई भाषाओं की तुलना में अधिक कठिन या जटिल हो सकता है, इसका व्यापक रूप से उपयोग किया जाता है क्योंकि यह मूल निर्देशों को संकलित करता है जो हो सकते हैं सीधे प्रोसेसर द्वारा चलाया जाता है और हार्डवेयर पर कड़ा नियंत्रण प्रदान करता है (जैसे सी) जेनेरिक, अपवाद और कक्षाओं जैसी उच्च-स्तरीय सुविधाओं की पेशकश करते हुए। गति और कार्यक्षमता का यह संयोजन C++ बनाता है | सबसे व्यापक रूप से उपयोग की जाने वाली प्रोग्रामिंग भाषाओं में से एक।</p>
<div class="highlight"><pre lang="c++"><span class="c1">//////////////////</span>
<span class="c1">// सी . से तुलना</span>
<span class="c1">//////////////////</span>

<span class="c1">// C++ _लगभग_C का सुपरसेट है और इसके लिए अपना मूल सिंटैक्स साझा करता है</span>
<span class="c1">// परिवर्तनीय घोषणाएं, आदिम प्रकार, और कार्य।</span>

<span class="c1">// सी की तरह ही, आपके प्रोग्राम का एंट्री पॉइंट एक फंक्शन है, जिसे कहा जाता है</span>
<span class="c1">// मुख्य एक पूर्णांक वापसी प्रकार के साथ।</span>
<span class="c1">// यह मान प्रोग्राम की निकास स्थिति के रूप में कार्य करता है।</span>
<span class="c1">// अधिक जानकारी के लिए https://en.wikipedia.org/wiki/Exit_status देखें।</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// कमांड लाइन तर्क उसी तरह argc और argv द्वारा पारित किए जाते हैं</span>
<span class="w">    </span><span class="c1">// वे सी में हैं।</span>
<span class="w">    </span><span class="c1">// argc तर्कों की संख्या को इंगित करता है,</span>
<span class="w">    </span><span class="c1">// और argv सी-स्टाइल स्ट्रिंग्स (चार *) की एक सरणी है</span>
<span class="w">    </span><span class="c1">// तर्कों का प्रतिनिधित्व करते हैं।</span>
<span class="w">    </span><span class="c1">// पहला तर्क वह नाम है जिसके द्वारा प्रोग्राम को बुलाया गया था।</span>
<span class="w">    </span><span class="c1">// यदि आप तर्कों की परवाह नहीं करते हैं तो argc और argv को छोड़ा जा सकता है,</span>
<span class="w">    </span><span class="c1">// int main का फंक्शन सिग्नेचर देना ()</span>

<span class="w">    </span><span class="c1">// 0 की निकास स्थिति सफलता को इंगित करती है।</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// हालाँकि, C++ निम्नलिखित में से कुछ तरीकों से भिन्न होता है:</span>

<span class="c1">// सी ++ में, वर्ण अक्षर वर्ण हैं</span>
<span class="k">sizeof</span><span class="p">(</span><span class="sc">&#39;c&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span>

<span class="c1">// सी में, चरित्र अक्षर ints . हैं</span>
<span class="k">sizeof</span><span class="p">(</span><span class="sc">&#39;c&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>


<span class="c1">// सी ++ में सख्त प्रोटोटाइप है</span>
<span class="kt">void</span><span class="w"> </span><span class="n">func</span><span class="p">();</span><span class="w"> </span><span class="c1">// फ़ंक्शन जो कोई तर्क स्वीकार नहीं करता है</span>

<span class="c1">// सी में</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">();</span><span class="w"> </span><span class="c1">// फ़ंक्शन जो किसी भी संख्या में तर्कों को स्वीकार कर सकता है</span>

<span class="c1">// C++ में NULL के बजाय nullptr का प्रयोग करें</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="c1">// सी मानक हेडर सी ++ में उपलब्ध हैं।</span>
<span class="c1">// सी हेडर .h में समाप्त होते हैं, जबकि</span>
<span class="c1">// सी ++ हेडर &quot;सी&quot; के साथ उपसर्ग कर रहे हैं और कोई &quot;.एच&quot; प्रत्यय नहीं है।</span>

<span class="c1">// सी ++ मानक संस्करण:</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdio&gt;</span>

<span class="c1">// सी मानक संस्करण:</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, world!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">///////////////////////</span>
<span class="c1">// फंक्शन ओवरलोडिंग</span>
<span class="c1">///////////////////////</span>

<span class="c1">// सी ++ फ़ंक्शन ओवरलोडिंग का समर्थन करता है</span>
<span class="c1">// बशर्ते प्रत्येक फ़ंक्शन अलग-अलग पैरामीटर लेता है।</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">myString</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;String %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">myString</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">myInt</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;My int is %d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">myInt</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Resolves to void print(const char*)</span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span><span class="w"> </span><span class="c1">// Resolves to void print(int)</span>
<span class="p">}</span>

<span class="c1">/////////////////////////////</span>
<span class="c1">// डिफ़ॉल्ट फ़ंक्शन तर्क</span>
<span class="c1">/////////////////////////////</span>

<span class="c1">// आप किसी फ़ंक्शन के लिए डिफ़ॉल्ट तर्क प्रदान कर सकते हैं</span>
<span class="c1">// अगर वे कॉलर द्वारा प्रदान नहीं किए जाते हैं।</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">doSomethingWithInts</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// यहां इनट्स के साथ कुछ करें</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">doSomethingWithInts</span><span class="p">();</span><span class="w">      </span><span class="c1">// a = 1,  b = 4</span>
<span class="w">    </span><span class="n">doSomethingWithInts</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w">    </span><span class="c1">// a = 20, b = 4</span>
<span class="w">    </span><span class="n">doSomethingWithInts</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// a = 20, b = 5</span>
<span class="p">}</span>

<span class="c1">// डिफ़ॉल्ट तर्क तर्क सूची के अंत में होना चाहिए।</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">invalidDeclaration</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="c1">// Error!</span>
<span class="p">{</span>
<span class="p">}</span>


<span class="c1">/////////////</span>
<span class="c1">// नेमस्पेस</span>
<span class="c1">/////////////</span>

<span class="c1">// नेमस्पेस वैरिएबल, फंक्शन के लिए अलग-अलग स्कोप प्रदान करते हैं,</span>
<span class="c1">// और अन्य घोषणाएं।</span>
<span class="c1">// नेमस्पेस को नेस्ट किया जा सकता है।</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">First</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Nested</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;This is First::Nested::foo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// अंत नामस्थान नेस्टेड</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// अंतिम नाम स्थान पहले</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">Second</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;This is Second::foo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;This is global foo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// नेमस्पेस सेकेंड से वर्तमान दायरे में सभी प्रतीकों को शामिल करता है। ध्यान दें</span>
<span class="w">    </span><span class="c1">// वह बस foo() अब काम नहीं करता है, क्योंकि यह अब अस्पष्ट है कि क्या</span>
<span class="w">    </span><span class="c1">// हम फू को नेमस्पेस सेकेंड या टॉप लेवल में कॉल कर रहे हैं।</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Second</span><span class="p">;</span>

<span class="w">    </span><span class="n">Second</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// प्रिंट &quot;यह दूसरा है :: फू&quot;</span>
<span class="w">    </span><span class="n">First</span><span class="o">::</span><span class="n">Nested</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// प्रिंट &quot;यह पहला है :: नेस्टेड :: फू&quot;</span>
<span class="w">    </span><span class="o">::</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// प्रिंट करता है &quot;यह वैश्विक फू है&quot;</span>
<span class="p">}</span>

<span class="c1">///////////////</span>
<span class="c1">// इनपुट आउटपुट</span>
<span class="c1">///////////////</span>

<span class="c1">// सी ++ इनपुट और आउटपुट स्ट्रीम का उपयोग करता है</span>
<span class="c1">// cin, cout, और cerr stdin, stdout और stderr का प्रतिनिधित्व करते हैं।</span>
<span class="c1">// &lt;&lt; इंसर्शन ऑपरेटर है और &gt;&gt; एक्सट्रैक्शन ऑपरेटर है।</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="c1"> // I/O स्ट्रीम के लिए शामिल करें</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"> </span><span class="c1">// स्ट्रीम एसटीडी नेमस्पेस (मानक पुस्तकालय) में हैं</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">myInt</span><span class="p">;</span>

<span class="w">   </span><span class="c1">// स्टडआउट (या टर्मिनल / स्क्रीन) पर प्रिंट करता है</span>
<span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Enter your favorite number:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">   </span><span class="c1">// इनपुट लेता है</span>
<span class="w">   </span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">myInt</span><span class="p">;</span>

<span class="w">   </span><span class="c1">// cout को भी स्वरूपित किया जा सकता है</span>
<span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Your favorite number is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myInt</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="w">   </span><span class="c1">// प्रिंट करता है &quot;आपका पसंदीदा नंबर &lt;myInt&gt;&quot; है</span>

<span class="w">   </span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Used for error messages&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//////////</span>
<span class="c1">// स्ट्रिंग्स</span>
<span class="c1">//////////</span>

<span class="c1">// सी ++ में स्ट्रिंग्स ऑब्जेक्ट हैं और इसमें कई सदस्य कार्य हैं</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"> </span><span class="c1">// स्ट्रिंग्स नेमस्पेस एसटीडी (मानक पुस्तकालय) में भी हैं</span>

<span class="n">string</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span><span class="p">;</span>
<span class="n">string</span><span class="w"> </span><span class="n">myOtherString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot; World&quot;</span><span class="p">;</span>

<span class="c1">// + का उपयोग संयोजन के लिए किया जाता है।</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">myOtherString</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;Hello World&quot;</span>

<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; You&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;Hello You&quot;</span>

<span class="c1">// सी ++ स्ट्रिंग्स म्यूटेबल हैं।</span>
<span class="n">myString</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot; Dog&quot;</span><span class="p">);</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myString</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;Hello Dog&quot;</span>


<span class="c1">/////////////</span>
<span class="c1">// संदर्भ</span>
<span class="c1">/////////////</span>

<span class="c1">// सी में वाले जैसे पॉइंटर्स के अलावा,</span>
<span class="c1">// सी ++ में _references_ हैं।</span>
<span class="c1">// ये पॉइंटर प्रकार हैं जिन्हें एक बार सेट करने के बाद पुन: असाइन नहीं किया जा सकता है</span>
<span class="c1">// और शून्य नहीं हो सकता।</span>
<span class="c1">// उनके पास वैरिएबल के समान सिंटैक्स भी है:</span>
<span class="c1">// नहीं * dereferencing के लिए आवश्यक है और</span>
<span class="c1">// और (का पता) असाइनमेंट के लिए उपयोग नहीं किया जाता है।</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="n">string</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;I am foo&quot;</span><span class="p">;</span>
<span class="n">string</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;I am bar&quot;</span><span class="p">;</span>


<span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">fooRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w"> </span><span class="c1">// यह foo का संदर्भ बनाता है।</span>
<span class="n">fooRef</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;. Hi!&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// संदर्भ के माध्यम से फू को संशोधित करें</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fooRef</span><span class="p">;</span><span class="w"> </span><span class="c1">// प्रिंट &quot;I am foo. Hi!&quot;</span>

<span class="c1">// &quot;fooRef&quot; को पुन: असाइन नहीं करता है। यह &quot;फू = बार&quot; जैसा ही है, और</span>
<span class="c1">// फू == &quot;मैं बार हूँ&quot;</span>
<span class="c1">// इस लाइन के बाद।</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fooRef</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w">  </span><span class="c1">// फू का पता प्रिंट करता है</span>
<span class="n">fooRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fooRef</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// अभी भी फू का पता प्रिंट करता है</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fooRef</span><span class="p">;</span><span class="w">  </span><span class="c1">// प्रिंट &quot;I am bar&quot;</span>

<span class="c1">// fooRef का पता वही रहता है, यानी यह अभी भी foo की बात कर रहा है।</span>


<span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">barRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span><span class="w"> </span><span class="c1">// बार के लिए एक कॉन्स्टेबल संदर्भ बनाएं।</span>
<span class="c1">// सी की तरह, कॉन्स्ट वैल्यू (और पॉइंटर्स और रेफरेंस) को संशोधित नहीं किया जा सकता है।</span>
<span class="n">barRef</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;. Hi!&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// त्रुटि, कॉन्स्ट संदर्भों को संशोधित नहीं किया जा सकता है।</span>

<span class="c1">// साइडट्रैक: इससे पहले कि हम संदर्भों के बारे में अधिक बात करें, हमें एक अवधारणा पेश करनी चाहिए</span>
<span class="c1">// एक अस्थायी वस्तु कहा जाता है। मान लीजिए हमारे पास निम्नलिखित कोड है:</span>
<span class="n">string</span><span class="w"> </span><span class="nf">tempObjectFun</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="n">string</span><span class="w"> </span><span class="n">retVal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tempObjectFun</span><span class="p">();</span>

<span class="c1">// दूसरी पंक्ति में वास्तव में क्या होता है:</span>
<span class="c1">// - एक स्ट्रिंग ऑब्जेक्ट tempObjectFun से लौटाया जाता है</span>
<span class="c1">// - तर्क के रूप में लौटाई गई वस्तु के साथ एक नई स्ट्रिंग का निर्माण किया जाता है</span>
<span class="c1">// कंस्ट्रक्टर</span>
<span class="c1">// - लौटाई गई वस्तु नष्ट हो जाती है</span>
<span class="c1">// लौटाई गई वस्तु को अस्थायी वस्तु कहा जाता है। अस्थायी वस्तुएं हैं</span>
<span class="c1">// जब भी कोई फ़ंक्शन किसी ऑब्जेक्ट को लौटाता है, तब बनाया जाता है, और वे नष्ट हो जाते हैं</span>
<span class="c1">// संलग्न अभिव्यक्ति के मूल्यांकन का अंत (ठीक है, यह वही है</span>
<span class="c1">// मानक कहता है, लेकिन संकलक को इस व्यवहार को बदलने की अनुमति है। ऊपर देखो</span>
<span class="c1">// &quot;वापसी मूल्य अनुकूलन&quot; यदि आप इस तरह के विवरण में हैं)। तो इसमें</span>
<span class="c1">// कोड:</span>
<span class="n">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">(</span><span class="n">tempObjectFun</span><span class="p">()))</span>

<span class="c1">// यह मानते हुए कि फू और बार मौजूद हैं, tempObjectFun से लौटाई गई वस्तु है</span>
<span class="c1">// बार को पास किया गया, और फू को कॉल करने से पहले इसे नष्ट कर दिया गया।</span>

<span class="c1">// अब वापस संदर्भों पर। &quot;संलग्नक के अंत में&quot; का अपवाद</span>
<span class="c1">// अभिव्यक्ति&quot; नियम यह है कि यदि एक अस्थायी वस्तु एक कॉन्स्ट संदर्भ के लिए बाध्य है, तो</span>
<span class="c1">// किस मामले में इसका जीवन वर्तमान दायरे तक बढ़ जाता है:</span>

<span class="kt">void</span><span class="w"> </span><span class="n">constReferenceTempObjectFun</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// constRef अस्थायी वस्तु प्राप्त करता है, और यह इस के अंत तक मान्य है</span>
<span class="w">    </span><span class="c1">// समारोह।</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">constRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tempObjectFun</span><span class="p">();</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>

<span class="c1">// सी ++ 11 में पेश किया गया एक अन्य प्रकार का संदर्भ विशेष रूप से अस्थायी के लिए है</span>
<span class="c1">// ऑब्जेक्ट्स। आपके पास इसके प्रकार का एक चर नहीं हो सकता है, लेकिन इसमें पूर्वता होती है</span>
<span class="c1">// अधिभार संकल्प:</span>

<span class="kt">void</span><span class="w"> </span><span class="n">someFun</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">  </span><span class="c1">// नियमित संदर्भ</span>
<span class="kt">void</span><span class="w"> </span><span class="n">someFun</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">  </span><span class="c1">// अस्थायी वस्तु का संदर्भ</span>

<span class="n">string</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>
<span class="n">someFun</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span><span class="w">  </span><span class="c1">// नियमित संदर्भ के साथ संस्करण को कॉल करें</span>
<span class="n">someFun</span><span class="p">(</span><span class="n">tempObjectFun</span><span class="p">());</span><span class="w">  </span><span class="c1">// अस्थायी संदर्भ के साथ संस्करण को कॉल करें</span>

<span class="c1">// उदाहरण के लिए, आप कंस्ट्रक्टर के इन दो संस्करणों को देखेंगे</span>
<span class="c1">// std::basic_string:</span>
<span class="n">basic_string</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">basic_string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
<span class="n">basic_string</span><span class="p">(</span><span class="n">basic_string</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>

<span class="c1">// विचार यह है कि अगर हम एक अस्थायी वस्तु से एक नई स्ट्रिंग का निर्माण कर रहे हैं (जो</span>
<span class="c1">// वैसे भी जल्द ही नष्ट होने जा रहा है), हम अधिक कुशल हो सकते हैं</span>
<span class="c1">// कंस्ट्रक्टर जो उस अस्थायी स्ट्रिंग के कुछ हिस्सों को &quot;बचाता&quot; है। आप इसे देखेंगे</span>
<span class="c1">// अवधारणा को &quot;मूव सेमेन्टिक्स&quot; के रूप में जाना जाता है।</span>

<span class="c1">/////////////////////</span>
<span class="c1">// Enums</span>
<span class="c1">/////////////////////</span>

<span class="c1">// Enums सबसे अधिक उपयोग किए जाने वाले स्थिरांक को मान निर्दिष्ट करने का एक तरीका है</span>
<span class="c1">// आसान विज़ुअलाइज़ेशन और कोड को पढ़ना</span>
<span class="k">enum</span><span class="w"> </span><span class="nc">ECarTypes</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Sedan</span><span class="p">,</span>
<span class="w">  </span><span class="n">Hatchback</span><span class="p">,</span>
<span class="w">  </span><span class="n">SUV</span><span class="p">,</span>
<span class="w">  </span><span class="n">Wagon</span>
<span class="p">};</span>

<span class="n">ECarTypes</span><span class="w"> </span><span class="nf">GetPreferredCarType</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ECarTypes</span><span class="o">::</span><span class="n">Hatchback</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// सी ++ 11 के रूप में एनम को एक प्रकार असाइन करने का एक आसान तरीका है जो हो सकता है</span>
<span class="c1">// डेटा के क्रमांकन में उपयोगी और एनम को आगे-पीछे परिवर्तित करना</span>
<span class="c1">// वांछित प्रकार और उनके संबंधित स्थिरांक</span>
<span class="k">enum</span><span class="w"> </span><span class="nc">ECarTypes</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">uint8_t</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Sedan</span><span class="p">,</span><span class="w"> </span><span class="c1">// 0</span>
<span class="w">    </span><span class="n">Hatchback</span><span class="p">,</span><span class="w"> </span><span class="c1">// 1</span>
<span class="w">    </span><span class="n">SUV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">254</span><span class="p">,</span><span class="w"> </span><span class="c1">// 254</span>
<span class="w">    </span><span class="n">Hybrid</span><span class="w"> </span><span class="c1">// 255</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">WriteByteToFile</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">InputValue</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// किसी फ़ाइल में इनपुटवैल्यू को क्रमबद्ध करें</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">WritePreferredCarTypeToFile</span><span class="p">(</span><span class="n">ECarTypes</span><span class="w"> </span><span class="n">InputCarType</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// एनम को इसके घोषित एनम प्रकार के कारण uint8_t में परिवर्तित कर दिया गया है</span>
<span class="w">    </span><span class="n">WriteByteToFile</span><span class="p">(</span><span class="n">InputCarType</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// दूसरी ओर, हो सकता है कि आप नहीं चाहते कि गलती से एनम को एक पूर्णांक में डाला जाए</span>
<span class="c1">// टाइप करें या अन्य एनम के लिए ताकि इसके बजाय एक एनम क्लास बनाना संभव हो जो</span>
<span class="c1">// परोक्ष रूप से परिवर्तित नहीं किया जाएगा</span>
<span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">ECarTypes</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">uint8_t</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Sedan</span><span class="p">,</span><span class="w"> </span><span class="c1">// 0</span>
<span class="w">    </span><span class="n">Hatchback</span><span class="p">,</span><span class="w"> </span><span class="c1">// 1</span>
<span class="w">    </span><span class="n">SUV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">254</span><span class="p">,</span><span class="w"> </span><span class="c1">// 254</span>
<span class="w">    </span><span class="n">Hybrid</span><span class="w"> </span><span class="c1">// 255</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">WriteByteToFile</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">InputValue</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// किसी फ़ाइल में इनपुटवैल्यू को क्रमबद्ध करें</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">WritePreferredCarTypeToFile</span><span class="p">(</span><span class="n">ECarTypes</span><span class="w"> </span><span class="n">InputCarType</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// संकलित नहीं होगा, भले ही ECarTypes एक uint8_t एनम के कारण है</span>
<span class="w">    </span><span class="c1">// &quot;एनम क्लास&quot; के रूप में घोषित किया जा रहा है!</span>
<span class="w">    </span><span class="n">WriteByteToFile</span><span class="p">(</span><span class="n">InputCarType</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//////////////////////////////////////////</span>
<span class="c1">// कक्षाएं और वस्तु-उन्मुख प्रोग्रामिंग</span>
<span class="c1">//////////////////////////////////////////</span>

<span class="c1">// कक्षाओं का पहला उदाहरण</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="c1">// एक वर्ग घोषित करें।</span>
<span class="c1">// कक्षाएं आमतौर पर हेडर (.h या .hpp) फाइलों में घोषित की जाती हैं।</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Dog</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// सदस्य चर और कार्य डिफ़ॉल्ट रूप से निजी हैं।</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">weight</span><span class="p">;</span>

<span class="c1">// इसका अनुसरण करने वाले सभी सदस्य सार्वजनिक हैं</span>
<span class="c1">// जब तक &quot;निजी:&quot; या &quot;संरक्षित:&quot; नहीं मिलता है।</span>
<span class="k">public</span><span class="o">:</span>

<span class="w">    </span><span class="c1">// Default constructor</span>
<span class="w">    </span><span class="n">Dog</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// सदस्य फ़ंक्शन घोषणाएं (कार्यान्वयन का पालन करें)</span>
<span class="w">    </span><span class="c1">// ध्यान दें कि हम यहां रखने के बजाय std::string का उपयोग करते हैं</span>
<span class="w">    </span><span class="c1">// नेमस्पेस एसटीडी का उपयोग करना;</span>
<span class="w">    </span><span class="c1">// ऊपर।</span>
<span class="w">    </span><span class="c1">// हेडर में कभी भी &quot;नेमस्पेस का उपयोग करके&quot; स्टेटमेंट न डालें।</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">setName</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dogsName</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">setWeight</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">dogsWeight</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// ऐसे कार्य जो वस्तु की स्थिति को संशोधित नहीं करते हैं</span>
<span class="w">    </span><span class="c1">// को कॉन्स्ट के रूप में चिह्नित किया जाना चाहिए।</span>
<span class="w">    </span><span class="c1">// यह आपको ऑब्जेक्ट के संदर्भ में दिए जाने पर उन्हें कॉल करने की अनुमति देता है।</span>
<span class="w">    </span><span class="c1">// यह भी ध्यान दें कि कार्यों को स्पष्ट रूप से _virtual_ के रूप में घोषित किया जाना चाहिए</span>
<span class="w">    </span><span class="c1">// व्युत्पन्न कक्षाओं में ओवरराइड करने के लिए।</span>
<span class="w">    </span><span class="c1">// कार्य प्रदर्शन कारणों से डिफ़ॉल्ट रूप से आभासी नहीं हैं।</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// फंक्शन को क्लास बॉडी के अंदर भी परिभाषित किया जा सकता है।</span>
<span class="w">    </span><span class="c1">// इस तरह परिभाषित कार्य स्वचालित रूप से रेखांकित होते हैं।</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">bark</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; barks!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// कंस्ट्रक्टर्स के साथ, C++ डिस्ट्रक्टर्स प्रदान करता है।</span>
<span class="w">    </span><span class="c1">// इन्हें तब कहा जाता है जब कोई वस्तु हटा दी जाती है या दायरे से बाहर हो जाती है।</span>
<span class="w">    </span><span class="c1">// यह RAII जैसे शक्तिशाली प्रतिमानों को सक्षम बनाता है</span>
<span class="w">    </span><span class="c1">// (निचे देखो)</span>
<span class="w">    </span><span class="c1">// विध्वंसक आभासी होना चाहिए यदि एक वर्ग से प्राप्त किया जाना है;</span>
<span class="w">    </span><span class="c1">// यदि यह आभासी नहीं है, तो व्युत्पन्न वर्ग &#39;विनाशक होगा&#39;</span>
<span class="w">    </span><span class="c1">// यदि ऑब्जेक्ट बेस-क्लास संदर्भ के माध्यम से नष्ट हो जाता है तो कॉल नहीं किया जाएगा</span>
<span class="w">    </span><span class="c1">// या सूचक।</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Dog</span><span class="p">();</span>

<span class="p">};</span><span class="w"> </span><span class="c1">// अर्धविराम को वर्ग परिभाषा का पालन करना चाहिए।</span>

<span class="c1">// क्लास सदस्य फ़ंक्शन आमतौर पर .cpp फ़ाइलों में कार्यान्वित किए जाते हैं।</span>
<span class="n">Dog</span><span class="o">::</span><span class="n">Dog</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;A dog has been constructed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// वस्तुओं (जैसे तार) को संदर्भ द्वारा पारित किया जाना चाहिए</span>
<span class="c1">// यदि आप उन्हें संशोधित कर रहे हैं या यदि आप नहीं हैं तो संदर्भ संदर्भ।</span>
<span class="kt">void</span><span class="w"> </span><span class="n">Dog</span><span class="o">::</span><span class="n">setName</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dogsName</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dogsName</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">Dog</span><span class="o">::</span><span class="n">setWeight</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">dogsWeight</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dogsWeight</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ध्यान दें कि &quot;आभासी&quot; केवल घोषणा में आवश्यक है, परिभाषा नहीं।</span>
<span class="kt">void</span><span class="w"> </span><span class="n">Dog</span><span class="o">::</span><span class="n">print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Dog is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; and weighs &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;kg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Dog</span><span class="o">::~</span><span class="n">Dog</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Goodbye &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Dog</span><span class="w"> </span><span class="n">myDog</span><span class="p">;</span><span class="w"> </span><span class="c1">// prints &quot;A dog has been constructed&quot;</span>
<span class="w">    </span><span class="n">myDog</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">&quot;Barkley&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">myDog</span><span class="p">.</span><span class="n">setWeight</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="n">myDog</span><span class="p">.</span><span class="n">print</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &quot;Dog is Barkley and weighs 10 kg&quot;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// prints &quot;Goodbye Barkley&quot;</span>

<span class="c1">// विरासत:</span>

<span class="c1">// इस वर्ग को सब कुछ विरासत में मिला है और डॉग क्लास से संरक्षित है</span>
<span class="c1">// साथ ही निजी लेकिन सीधे निजी सदस्यों / विधियों तक नहीं पहुंच सकता है</span>
<span class="c1">// ऐसा करने के लिए सार्वजनिक या संरक्षित विधि के बिना</span>
<span class="k">class</span><span class="w"> </span><span class="nc">OwnedDog</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Dog</span><span class="w"> </span><span class="p">{</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">setOwner</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dogsOwner</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// सभी स्वामित्व वाले कुत्तों के लिए प्रिंट फ़ंक्शन के व्यवहार को ओवरराइड करें। ले देख</span>
<span class="w">    </span><span class="c1">// https://en.wikipedia.org/wiki/Polymorphism_(computer_science)#Subtyping</span>
<span class="w">    </span><span class="c1">// अधिक सामान्य परिचय के लिए यदि आप अपरिचित हैं</span>
<span class="w">    </span><span class="c1">// उपप्रकार बहुरूपता।</span>
<span class="w">    </span><span class="c1">// ओवरराइड कीवर्ड वैकल्पिक है लेकिन सुनिश्चित करता है कि आप वास्तव में हैं</span>
<span class="w">    </span><span class="c1">// बेस क्लास में विधि को ओवरराइड करना।</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">owner</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// इस बीच, संबंधित .cpp फ़ाइल में:</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">OwnedDog::setOwner</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dogsOwner</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dogsOwner</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">OwnedDog::print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Dog</span><span class="o">::</span><span class="n">print</span><span class="p">();</span><span class="w"> </span><span class="c1">// बेस डॉग क्लास में प्रिंट फ़ंक्शन को कॉल करें class</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Dog is owned by &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">owner</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// प्रिंट करता है &quot;कुत्ता &lt;नाम&gt; है और वजन &lt;वजन&gt;&quot; है</span>
<span class="w">    </span><span class="c1">// &quot;कुत्ता &lt;मालिक&gt; के स्वामित्व में है&quot;</span>
<span class="p">}</span>

<span class="c1">//////////////////////////////////////////</span>
<span class="c1">// आरंभीकरण और ऑपरेटर ओवरलोडिंग</span>
<span class="c1">//////////////////////////////////////////</span>

<span class="c1">// सी ++ में आप ऑपरेटरों के व्यवहार को ओवरलोड कर सकते हैं जैसे +, -, *, /, आदि।</span>
<span class="c1">// यह एक फ़ंक्शन को परिभाषित करके किया जाता है जिसे कहा जाता है</span>
<span class="c1">// जब भी ऑपरेटर का उपयोग किया जाता है।</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Point</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="c1">// सदस्य चर को इस तरह से डिफ़ॉल्ट मान दिया जा सकता है।</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// एक डिफ़ॉल्ट कंस्ट्रक्टर को परिभाषित करें जो कुछ भी नहीं करता है</span>
<span class="w">    </span><span class="c1">// लेकिन बिंदु को डिफ़ॉल्ट मान (0, 0) पर प्रारंभ करें</span>
<span class="w">    </span><span class="n">Point</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// The following syntax is known as an initialization list</span>
<span class="w">    </span><span class="c1">// and is the proper way to initialize class member values</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">        </span><span class="n">x</span><span class="p">(</span><span class="n">a</span><span class="p">),</span>
<span class="w">        </span><span class="n">y</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="cm">/* मानों को इनिशियलाइज़ करने के अलावा कुछ न करें */</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// + ऑपरेटर को ओवरलोड करें।</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// + = ऑपरेटर को अधिभारित करें</span>
<span class="w">    </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// - और - = ऑपरेटरों को जोड़ना भी समझ में आता है,</span>
<span class="w">    </span><span class="c1">// लेकिन हम उन्हें संक्षिप्तता के लिए छोड़ देंगे।</span>
<span class="p">};</span>

<span class="n">Point</span><span class="w"> </span><span class="n">Point</span><span class="o">::</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// एक नया बिंदु बनाएं जो इस एक और rhs का योग हो।.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// के सबसे बाएं चर के संदर्भ को वापस करने के लिए यह अच्छा अभ्यास है</span>
<span class="c1">// सौंपा गया कार्य। `(a += b) == c` इस तरह से काम करेगा।</span>
<span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Point</span><span class="o">::</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// `this` उस वस्तु का सूचक है, जिस पर एक विधि कहलाती है।</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="nf">up</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="nf">right</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// यह प्वाइंट + ऑपरेटर को कॉल करता है</span>
<span class="w">    </span><span class="c1">// पॉइंट अप + (फ़ंक्शन) को इसके पैरामीटर के रूप में दाईं ओर कॉल करता है</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Prints &quot;Result is upright (1,1)&quot;</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Result is upright (&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;,&#39;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/////////////////////</span>
<span class="c1">// टेम्पलेट्स</span>
<span class="c1">/////////////////////</span>

<span class="c1">// C++ में टेम्प्लेट ज्यादातर सामान्य प्रोग्रामिंग के लिए उपयोग किए जाते हैं, हालांकि वे हैं</span>
<span class="c1">// अन्य भाषाओं में सामान्य निर्माणों की तुलना में बहुत अधिक शक्तिशाली। वे भी</span>
<span class="c1">// स्पष्ट और आंशिक विशेषज्ञता और कार्यात्मक-शैली प्रकार का समर्थन करें</span>
<span class="c1">// कक्षाएं; वास्तव में, वे एक ट्यूरिंग-पूर्ण कार्यात्मक भाषा एम्बेडेड हैं</span>
<span class="c1">// सी ++ में!</span>

<span class="c1">// हम उस तरह की सामान्य प्रोग्रामिंग से शुरू करते हैं जिससे आप परिचित हो सकते हैं। सेवा</span>
<span class="c1">// एक वर्ग या फ़ंक्शन को परिभाषित करें जो एक प्रकार का पैरामीटर लेता है:</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Box</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// इस वर्ग में, टी का उपयोग किसी अन्य प्रकार के रूप में किया जा सकता है।</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// संकलन के दौरान, कंपाइलर वास्तव में प्रत्येक टेम्पलेट की प्रतियां बनाता है</span>
<span class="c1">// प्रतिस्थापित मापदंडों के साथ, इसलिए वर्ग की पूरी परिभाषा होनी चाहिए</span>
<span class="c1">// प्रत्येक आह्वान पर उपस्थित। यही कारण है कि आप टेम्पलेट वर्ग परिभाषित देखेंगे</span>
<span class="c1">// पूरी तरह से हेडर फाइलों में।</span>

<span class="c1">// स्टैक पर टेम्प्लेट क्लास को इंस्टेंट करने के लिए:</span>
<span class="n">Box</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">intBox</span><span class="p">;</span>

<span class="c1">// और आप इसका उपयोग कर सकते हैं जैसा कि आप उम्मीद करेंगे:</span>
<span class="n">intBox</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>

<span class="c1">// आप निश्चित रूप से, नेस्ट टेम्प्लेट कर सकते हैं:</span>
<span class="n">Box</span><span class="o">&lt;</span><span class="n">Box</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">boxOfBox</span><span class="p">;</span>
<span class="n">boxOfBox</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">intBox</span><span class="p">);</span>

<span class="c1">// C++11 तक, आपको दो &#39;&gt;&#39; के बीच एक जगह रखनी थी, अन्यथा &#39;&gt;&gt;&#39;</span>
<span class="c1">// सही शिफ्ट ऑपरेटर के रूप में पार्स किया जाएगा।</span>

<span class="c1">// आप कभी-कभी देखेंगे</span>
<span class="c1">// टेम्पलेट&lt;टाइपनाम टी&gt;</span>
<span class="c1">// बजाय। &#39;वर्ग&#39; कीवर्ड और &#39;टाइपनाम&#39; कीवर्ड _अधिकतर_ हैं</span>
<span class="c1">// इस मामले में विनिमेय। पूरी व्याख्या के लिए देखें</span>
<span class="c1">// https://en.wikipedia.org/wiki/Typename</span>
<span class="c1">// (हाँ, उस कीवर्ड का अपना विकिपीडिया पेज है)।</span>

<span class="c1">// इसी तरह, एक टेम्पलेट फ़ंक्शन:</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">barkThreeTimes</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">input</span><span class="p">.</span><span class="n">bark</span><span class="p">();</span>
<span class="w">    </span><span class="n">input</span><span class="p">.</span><span class="n">bark</span><span class="p">();</span>
<span class="w">    </span><span class="n">input</span><span class="p">.</span><span class="n">bark</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// ध्यान दें कि यहां प्रकार के मापदंडों के बारे में कुछ भी निर्दिष्ट नहीं है। संकलक</span>
<span class="c1">// उत्पन्न करेगा और फिर टेम्पलेट के प्रत्येक आमंत्रण को टाइप-चेक करेगा, इसलिए</span>
<span class="c1">// उपरोक्त फ़ंक्शन किसी भी प्रकार &#39;T&#39; के साथ काम करता है जिसमें एक कॉन्स &#39;bark&#39; विधि होती है!</span>

<span class="n">Dog</span><span class="w"> </span><span class="n">fluffy</span><span class="p">;</span>
<span class="n">fluffy</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">&quot;Fluffy&quot;</span><span class="p">)</span>
<span class="n">barkThreeTimes</span><span class="p">(</span><span class="n">fluffy</span><span class="p">);</span><span class="w"> </span><span class="c1">// Prints &quot;Fluffy barks&quot; three times.</span>

<span class="c1">// टेम्प्लेट मापदंडों का वर्ग होना जरूरी नहीं है:</span>
<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">Y</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">printMessage</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Learn C++ in &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; minutes!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// और आप स्पष्ट रूप से अधिक कुशल कोड के लिए टेम्पलेट्स को विशेषज्ञ बना सकते हैं। का</span>
<span class="c1">// बेशक, विशेषज्ञता के अधिकांश वास्तविक दुनिया के उपयोग इस तरह के रूप में तुच्छ नहीं हैं।</span>
<span class="c1">// ध्यान दें कि आपको अभी भी फ़ंक्शन (या वर्ग) को टेम्पलेट के रूप में घोषित करने की आवश्यकता है</span>
<span class="c1">// भले ही आपने सभी मापदंडों को स्पष्ट रूप से निर्दिष्ट किया हो।</span>
<span class="k">template</span><span class="o">&lt;&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">printMessage</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Learn C++ faster in only 10 minutes!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">printMessage</span><span class="o">&lt;</span><span class="mi">20</span><span class="o">&gt;</span><span class="p">();</span><span class="w">  </span><span class="c1">// Prints &quot;Learn C++ in 20 minutes!&quot;</span>
<span class="n">printMessage</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span><span class="p">();</span><span class="w">  </span><span class="c1">// Prints &quot;Learn C++ faster in only 10 minutes!&quot;</span>


<span class="c1">/////////////////////</span>
<span class="c1">// संचालन अपवाद</span>
<span class="c1">/////////////////////</span>

<span class="c1">// मानक पुस्तकालय कुछ अपवाद प्रकार प्रदान करता है</span>
<span class="c1">// (देखें https://en.cppreference.com/w/cpp/error/exception)</span>
<span class="c1">// लेकिन किसी भी प्रकार को अपवाद के रूप में फेंका जा सकता है</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exception&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdexcept&gt;</span>

<span class="c1">// _try_ ब्लॉक के अंदर फेंके गए सभी अपवादों को बाद में पकड़ा जा सकता है</span>
<span class="c1">// _कैच_ हैंडलर।</span>
<span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// _new_ का उपयोग करके ढेर पर अपवाद आवंटित न करें।</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;A problem occurred&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// कॉन्स्ट संदर्भ द्वारा अपवादों को पकड़ें यदि वे ऑब्जेक्ट हैं</span>
<span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// पिछले _catch_ ब्लॉक द्वारा नहीं पकड़े गए किसी भी अपवाद को पकड़ता है</span>
<span class="k">catch</span><span class="w"> </span><span class="p">(...)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Unknown exception caught&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">throw</span><span class="p">;</span><span class="w"> </span><span class="c1">// Re-throws the exception</span>
<span class="p">}</span>

<span class="c1">///////</span>
<span class="c1">// आरएआईआई</span>
<span class="c1">///////</span>

<span class="c1">// RAII का अर्थ  &quot;संसाधन अधिग्रहण आरंभीकरण है&quot;।</span>
<span class="c1">// इसे अक्सर C++ में सबसे शक्तिशाली प्रतिमान माना जाता है</span>
<span class="c1">// और सरल अवधारणा है कि एक वस्तु के लिए एक निर्माता</span>
<span class="c1">// उस वस्तु के संसाधनों को प्राप्त करता है और विनाशक उन्हें जारी करता है।</span>

<span class="c1">// यह समझने के लिए कि यह कैसे उपयोगी है,</span>
<span class="c1">// एक फ़ंक्शन पर विचार करें जो C फ़ाइल हैंडल का उपयोग करता है:</span>
<span class="kt">void</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// शुरू करने के लिए, मान लें कि कुछ भी विफल नहीं हो सकता है।</span>

<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Open the file in read mode.</span>

<span class="w">    </span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Close the file handle.</span>
<span class="p">}</span>

<span class="c1">// दुर्भाग्य से, त्रुटि प्रबंधन से चीजें जल्दी जटिल हो जाती हैं।</span>
<span class="c1">// मान लीजिए कि fopen विफल हो सकता है, और वह doSomethingWithTheFile और</span>
<span class="c1">// doSomethingElseWithIt विफल होने पर त्रुटि कोड लौटाता है।</span>
<span class="c1">// (अपवाद विफलता से निपटने का पसंदीदा तरीका है,</span>
<span class="c1">// लेकिन कुछ प्रोग्रामर, विशेष रूप से C बैकग्राउंड वाले,</span>
<span class="c1">// अपवादों की उपयोगिता पर असहमत)।</span>
<span class="c1">// अब हमें विफलता के लिए प्रत्येक कॉल की जांच करनी होगी और फ़ाइल हैंडल को बंद करना होगा</span>
<span class="c1">// यदि कोई समस्या हुई।</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// फ़ाइल को रीड मोड में खोलें</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fh</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="c1">// लौटाया गया सूचक विफलता पर शून्य है।</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Report that failure to the caller.</span>

<span class="w">    </span><span class="c1">// मान लें कि प्रत्येक फ़ंक्शन विफल होने पर गलत लौटाता है</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// फ़ाइल हैंडल को बंद करें ताकि यह लीक न हो।</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// त्रुटि का प्रचार करें।</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// फ़ाइल हैंडल को बंद करें ताकि यह लीक न हो।</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// त्रुटि का प्रचार करें।</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// फ़ाइल हैंडल को बंद करें ताकि यह लीक न हो।</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// सफलता का संकेत दें</span>
<span class="p">}</span>

<span class="c1">// सी प्रोग्रामर अक्सर गोटो का उपयोग करके इसे थोड़ा साफ करते हैं:</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fh</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">failure</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">failure</span><span class="p">;</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Close the file</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// Indicate success</span>

<span class="nl">failure</span><span class="p">:</span>
<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Propagate the error</span>
<span class="p">}</span>

<span class="c1">// यदि फ़ंक्शन अपवादों का उपयोग करके त्रुटियों को इंगित करता है,</span>
<span class="c1">// चीजें थोड़ी साफ हैं, लेकिन फिर भी उप-इष्टतम हैं।</span>
<span class="kt">void</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Open the file in shared_ptrread mode</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fh</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Could not open the file.&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">        </span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">catch</span><span class="w"> </span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Be sure to close the file if an error occurs.</span>
<span class="w">        </span><span class="k">throw</span><span class="p">;</span><span class="w"> </span><span class="c1">// Then re-throw the exception.</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Close the file</span>
<span class="w">    </span><span class="c1">// Everything succeeded</span>
<span class="p">}</span>

<span class="c1">// इसकी तुलना C++ के फाइल स्ट्रीम क्लास (fstream) के उपयोग से करें</span>
<span class="c1">// fstream फ़ाइल को बंद करने के लिए अपने विनाशक का उपयोग करता है।</span>
<span class="c1">// ऊपर से याद करें कि विध्वंसक स्वचालित रूप से कहलाते हैं</span>
<span class="c1">// जब भी कोई वस्तु दायरे से बाहर हो जाती है।</span>
<span class="kt">void</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// ifstream इनपुट फ़ाइल स्ट्रीम के लिए छोटा है</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span><span class="w"> </span><span class="nf">fh</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span><span class="w"> </span><span class="c1">// Open the file</span>

<span class="w">    </span><span class="c1">// Do things with the file</span>
<span class="w">    </span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>

<span class="p">}</span><span class="w"> </span><span class="c1">//फ़ाइल स्वचालित रूप से यहाँ विध्वंसक द्वारा बंद कर दी गई है</span>

<span class="c1">// इसके _massive_ फायदे हैं:</span>
<span class="c1">// 1. चाहे कुछ भी हो जाए,</span>
<span class="c1">// संसाधन (इस मामले में फ़ाइल हैंडल) को साफ किया जाएगा।</span>
<span class="c1">// एक बार जब आप विध्वंसक को सही ढंग से लिख लेते हैं,</span>
<span class="c1">// हैंडल को बंद करना और रिसोर्स को लीक करना भूल जाना _असंभव_ है।</span>
<span class="c1">// 2. ध्यान दें कि कोड ज्यादा साफ है।</span>
<span class="c1">// विनाशक पर्दे के पीछे फ़ाइल को बंद करने का प्रबंधन करता है</span>
<span class="c1">// आपको इसके बारे में चिंता किए बिना।</span>
<span class="c1">// 3. कोड अपवाद सुरक्षित है।</span>
<span class="c1">// फंक्शन और क्लीनअप में कहीं भी एक अपवाद फेंका जा सकता है</span>
<span class="c1">// अभी भी होगा।</span>

<span class="c1">// सभी मुहावरेदार सी ++ कोड सभी संसाधनों के लिए बड़े पैमाने पर आरएआईआई का उपयोग करता है।</span>
<span class="c1">// अतिरिक्त उदाहरणों में शामिल हैं</span>
<span class="c1">// - unique_ptr और shared_ptr . का उपयोग करके मेमोरी</span>
<span class="c1">// - कंटेनर - मानक पुस्तकालय लिंक्ड सूची,</span>
<span class="c1">// वेक्टर (यानी स्व-आकार देने वाला सरणी), हैश मैप, और इसी तरह</span>
<span class="c1">// जब वे दायरे से बाहर हो जाते हैं तो सभी स्वचालित रूप से अपनी सामग्री को नष्ट कर देते हैं।</span>
<span class="c1">// - लॉक_गार्ड और यूनिक_लॉक का उपयोग करने वाले म्यूटेक्स</span>


<span class="c1">/////////////////////</span>
<span class="c1">// स्मार्ट पॉइंटर</span>
<span class="c1">/////////////////////</span>

<span class="c1">// आम तौर पर एक स्मार्ट पॉइंटर एक ऐसा वर्ग होता है जो &quot;रॉ पॉइंटर&quot; (&quot;नया&quot; का उपयोग) को लपेटता है</span>
<span class="c1">// क्रमशः सी में मॉलोक / कॉलोक)। लक्ष्य सक्षम होना है</span>
<span class="c1">// स्पष्ट रूप से हटाने की आवश्यकता के बिना इंगित की जा रही वस्तु के जीवनकाल का प्रबंधन करें</span>
<span class="c1">// वस्तु। यह शब्द केवल पॉइंटर्स के एक सेट का वर्णन करता है जिसमें</span>
<span class="c1">// अमूर्त का उल्लेख किया।</span>
<span class="c1">// स्मार्ट पॉइंटर्स को रोकने के लिए कच्चे पॉइंटर्स पर प्राथमिकता दी जानी चाहिए</span>
<span class="c1">// जोखिम भरा मेमोरी लीक, जो तब होता है जब आप किसी ऑब्जेक्ट को हटाना भूल जाते हैं।</span>

<span class="c1">// कच्चे सूचक का उपयोग:</span>
<span class="n">Dog</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Dog</span><span class="p">();</span>
<span class="n">ptr</span><span class="o">-&gt;</span><span class="n">bark</span><span class="p">();</span>
<span class="k">delete</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span>

<span class="c1">// स्मार्ट पॉइंटर का उपयोग करके, आपको हटाने के बारे में चिंता करने की ज़रूरत नहीं है</span>
<span class="c1">// अब वस्तु का।</span>
<span class="c1">// एक स्मार्ट पॉइंटर एक नीति का वर्णन करता है, जिसमें संदर्भों की गणना की जाती है</span>
<span class="c1">// सूचक। वस्तु नष्ट हो जाती है जब अंतिम</span>
<span class="c1">// वस्तु का संदर्भ नष्ट हो जाता है।</span>

<span class="c1">// &quot;std::shared_ptr&quot; का उपयोग:</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// It&#39;s no longer necessary to delete the Dog.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;</span><span class="w"> </span><span class="n">doggo</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Dog</span><span class="p">());</span>
<span class="w">    </span><span class="n">doggo</span><span class="o">-&gt;</span><span class="n">bark</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// संभावित परिपत्र संदर्भों से सावधान रहें !!!</span>
<span class="c1">// हमेशा एक संदर्भ होगा, इसलिए इसे कभी नष्ट नहीं किया जाएगा!</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;</span><span class="w"> </span><span class="n">doggo_one</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Dog</span><span class="p">());</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;</span><span class="w"> </span><span class="n">doggo_two</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Dog</span><span class="p">());</span>
<span class="n">doggo_one</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">doggo_two</span><span class="p">;</span><span class="w"> </span><span class="c1">// p1 references p2</span>
<span class="n">doggo_two</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">doggo_one</span><span class="p">;</span><span class="w"> </span><span class="c1">// p2 references p1</span>

<span class="c1">// कई प्रकार के स्मार्ट पॉइंटर्स हैं।</span>
<span class="c1">// उनका उपयोग करने का तरीका हमेशा एक जैसा होता है।</span>
<span class="c1">// यह हमें इस प्रश्न की ओर ले जाता है: हमें प्रत्येक प्रकार के स्मार्ट पॉइंटर का उपयोग कब करना चाहिए?</span>
<span class="c1">// std::unique_ptr - इसका उपयोग तब करें जब आप केवल एक संदर्भ रखना चाहते हैं</span>
<span class="c1">// वस्तु।</span>
<span class="c1">// std::shared_ptr - इसका उपयोग तब करें जब आप इसके लिए कई संदर्भ रखना चाहते हैं</span>
<span class="c1">// एक ही वस्तु और यह सुनिश्चित करना चाहते हैं कि इसे हटा दिया गया है</span>
<span class="c1">// जब सभी संदर्भ चले गए हैं।</span>
<span class="c1">// std::weak_ptr - जब आप एक्सेस करना चाहते हैं तो इसका इस्तेमाल करें</span>
<span class="c1">// एक std::shared_ptr की अंतर्निहित वस्तु उस वस्तु को आवंटित किए बिना।</span>
<span class="c1">// कमजोर पॉइंटर्स का उपयोग सर्कुलर रेफरेंसिंग को रोकने के लिए किया जाता है।</span>


<span class="c1">/////////////////////</span>
<span class="c1">// कंटेनर</span>
<span class="c1">/////////////////////</span>

<span class="c1">// कंटेनर या मानक टेम्पलेट लाइब्रेरी कुछ पूर्वनिर्धारित टेम्पलेट हैं।</span>
<span class="c1">// वे इसके तत्वों के लिए भंडारण स्थान का प्रबंधन करते हैं और प्रदान करते हैं</span>
<span class="c1">// सदस्य उन्हें एक्सेस और हेरफेर करने के लिए कार्य करता है।</span>

<span class="c1">// कुछ कंटेनर इस प्रकार हैं:</span>

<span class="c1">// वेक्टर (गतिशील सरणी)</span>
<span class="c1">// हमें रन टाइम पर ऐरे या ऑब्जेक्ट्स की सूची को परिभाषित करने की अनुमति दें</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<span class="n">string</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">my_vector</span><span class="p">;</span><span class="w"> </span><span class="c1">// initialize the vector</span>
<span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="n">my_vector</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">val</span><span class="p">);</span><span class="w"> </span><span class="c1">// will push the value of &#39;val&#39; into vector (&quot;array&quot;) my_vector</span>
<span class="n">my_vector</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">val</span><span class="p">);</span><span class="w"> </span><span class="c1">// will push the value into the vector again (now having two elements)</span>

<span class="c1">// एक वेक्टर के माध्यम से पुनरावृति करने के लिए हमारे पास 2 विकल्प हैं:</span>
<span class="c1">// या तो क्लासिक लूपिंग (वेक्टर के माध्यम से इंडेक्स 0 से उसके अंतिम इंडेक्स तक पुनरावृति):</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">my_vector</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">my_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// वेक्टर के तत्व तक पहुँचने के लिए हम ऑपरेटर का उपयोग कर सकते हैं []</span>
<span class="p">}</span>

<span class="c1">// या एक पुनरावर्तक का उपयोग करना:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="p">;</span><span class="w"> </span><span class="c1">// initialize the iterator for vector</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_vector</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">my_vector</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="w">  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// सेट</span>
<span class="c1">// सेट कंटेनर हैं जो एक विशिष्ट क्रम के बाद अद्वितीय तत्वों को संग्रहीत करते हैं।</span>
<span class="c1">// सेट अद्वितीय मूल्यों को क्रमबद्ध क्रम में संग्रहीत करने के लिए एक बहुत ही उपयोगी कंटेनर है</span>
<span class="c1">// बिना किसी अन्य फ़ंक्शन या कोड के।</span>

<span class="cp">#include</span><span class="cpf">&lt;set&gt;</span>
<span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ST</span><span class="p">;</span><span class="w">    </span><span class="c1">// Will initialize the set of int data type</span>
<span class="n">ST</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span><span class="w">  </span><span class="c1">// Will insert the value 30 in set ST</span>
<span class="n">ST</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w">  </span><span class="c1">// Will insert the value 10 in set ST</span>
<span class="n">ST</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w">  </span><span class="c1">// Will insert the value 20 in set ST</span>
<span class="n">ST</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span><span class="w">  </span><span class="c1">// Will insert the value 30 in set ST</span>
<span class="c1">// अब सेट के तत्व इस प्रकार हैं</span>
<span class="c1">// 10 20 30</span>

<span class="c1">// किसी तत्व को मिटाने के लिए</span>
<span class="n">ST</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w"> </span><span class="c1">// मान 20 . के साथ तत्व मिटा देगा</span>
<span class="c1">// एसटी सेट करें: 10 30</span>
<span class="c1">// सेट के माध्यम से पुनरावृति करने के लिए हम पुनरावृत्तियों का उपयोग करते हैं</span>
<span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="n">it</span><span class="o">=</span><span class="n">ST</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="n">it</span><span class="o">!=</span><span class="n">ST</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="n">it</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// Output:</span>
<span class="c1">// 10</span>
<span class="c1">// 30</span>

<span class="c1">// पूरे कंटेनर को साफ करने के लिए हम कंटेनर_नाम.क्लियर () का उपयोग करते हैं</span>
<span class="n">ST</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ST</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w">  </span><span class="c1">// will print the size of set ST</span>
<span class="c1">// आउटपुट: 0</span>

<span class="c1">// नोट: डुप्लिकेट तत्वों के लिए हम मल्टीसेट का उपयोग कर सकते हैं</span>
<span class="c1">// नोट: हैश सेट के लिए, unordered_set का उपयोग करें। वे अधिक कुशल हैं लेकिन</span>
<span class="c1">// आदेश को संरक्षित न करें। unordered_set C++11 के बाद से उपलब्ध है</span>

<span class="c1">// नक्शा</span>
<span class="c1">// मैप्स एक प्रमुख मूल्य के संयोजन द्वारा गठित तत्वों को संग्रहीत करता है</span>
<span class="c1">// और एक विशिष्ट क्रम के बाद एक मैप किया गया मान।</span>

<span class="cp">#include</span><span class="cpf">&lt;map&gt;</span>
<span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mymap</span><span class="p">;</span><span class="w">  </span><span class="c1">// Will initialize the map with key as char and value as int</span>

<span class="n">mymap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="sc">&#39;A&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
<span class="c1">// Will insert value 1 for key A</span>
<span class="n">mymap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="sc">&#39;Z&#39;</span><span class="p">,</span><span class="mi">26</span><span class="p">));</span>
<span class="c1">// Will insert value 26 for key Z</span>

<span class="c1">// To iterate</span>
<span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">it</span><span class="o">=</span><span class="n">mymap</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="o">!=</span><span class="n">mymap</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;-&gt;&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
<span class="c1">// आउटपुट:</span>
<span class="c1">// ए-&gt; 1</span>
<span class="c1">// जेड-&gt; 26</span>

<span class="c1">// कुंजी के अनुरूप मान ज्ञात करने के लिए</span>
<span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mymap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39;Z&#39;</span><span class="p">);</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>

<span class="c1">// आउटपुट: 26</span>

<span class="c1">// नोट: हैश मैप के लिए, unordered_map का उपयोग करें। वे अधिक कुशल हैं लेकिन करते हैं</span>
<span class="c1">// आदेश को संरक्षित नहीं करें। unordered_map C++11 के बाद से उपलब्ध है।</span>

<span class="c1">// गैर-आदिम मूल्यों (कस्टम वर्ग) की ऑब्जेक्ट कुंजियों वाले कंटेनरों की आवश्यकता होती है</span>
<span class="c1">// ऑब्जेक्ट में या फ़ंक्शन पॉइंटर के रूप में फ़ंक्शन की तुलना करें। पुरातन</span>
<span class="c1">// डिफ़ॉल्ट तुलनित्र हैं, लेकिन आप इसे ओवरराइड कर सकते हैं।</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">    </span><span class="n">Foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">j</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">compareFunction</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">Foo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Foo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">j</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="c1">// इसकी अनुमति नहीं है (हालांकि यह कंपाइलर के आधार पर भिन्न हो सकता है)</span>
<span class="c1">// एसटीडी :: नक्शा &lt;फू, इंट&gt; फूमैप;</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">compareFunction</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fooMap</span><span class="p">;</span>
<span class="n">fooMap</span><span class="p">[</span><span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">fooMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w"> </span><span class="c1">//true</span>


<span class="c1">////////////////////////////////////</span>
<span class="c1">// लैम्ब्डा एक्सप्रेशन (सी ++ 11 और ऊपर)</span>
<span class="c1">////////////////////////////////////</span>

<span class="c1">// लैम्ब्डा एक अनाम फ़ंक्शन को परिभाषित करने का एक सुविधाजनक तरीका है</span>
<span class="c1">// वस्तु उस स्थान पर ठीक है जहां इसे लागू किया गया है या पारित किया गया है</span>
<span class="c1">// किसी फ़ंक्शन के लिए एक तर्क।</span>

<span class="c1">// उदाहरण के लिए, दूसरे का उपयोग करके जोड़े के वेक्टर को सॉर्ट करने पर विचार करें</span>
<span class="c1">// जोड़ी का मूल्य</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">tester</span><span class="p">;</span>
<span class="n">tester</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">));</span>
<span class="n">tester</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">));</span>
<span class="n">tester</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span>

<span class="c1">// लैम्ब्डा एक्सप्रेशन को सॉर्ट फ़ंक्शन के तीसरे तर्क के रूप में पास करें</span>
<span class="c1">// सॉर्ट &lt;एल्गोरिदम&gt; हेडर से है</span>

<span class="n">sort</span><span class="p">(</span><span class="n">tester</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">tester</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">lhs</span><span class="p">.</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<span class="w">    </span><span class="p">});</span>

<span class="c1">// लैम्ब्डा एक्सप्रेशन के सिंटैक्स पर ध्यान दें,</span>
<span class="c1">// [] लैम्ब्डा में चर को &quot;कैप्चर&quot; करने के लिए प्रयोग किया जाता है</span>
<span class="c1">// &quot;कैप्चर लिस्ट&quot; परिभाषित करती है कि लैम्ब्डा के बाहर से फंक्शन बॉडी के अंदर क्या उपलब्ध होना चाहिए और कैसे।</span>
<span class="c1">// यह या तो हो सकता है:</span>
<span class="c1">// 1. एक मान: [x]</span>
<span class="c1">// 2. एक संदर्भ: [&amp;x]</span>
<span class="c1">// 3. संदर्भ के अनुसार वर्तमान में कोई भी चर [&amp;]</span>
<span class="c1">// 4. ३ के समान, लेकिन मूल्य से [=]</span>
<span class="c1">// उदाहरण:</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dog_ids</span><span class="p">;</span>
<span class="c1">// number_of_dogs = 3;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">dog_ids</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">weight</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">30</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">};</span>

<span class="c1">// मान लें कि आप कुत्तों के वजन के अनुसार dog_ids को सॉर्ट करना चाहते हैं</span>
<span class="c1">// तो dog_ids अंत में बन जाना चाहिए: [२, ०, १]</span>

<span class="c1">// यहाँ वह जगह है जहाँ लैम्ब्डा के भाव काम आते हैं</span>

<span class="n">sort</span><span class="p">(</span><span class="n">dog_ids</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">dog_ids</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">weight</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">weight</span><span class="p">[</span><span class="n">lhs</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">weight</span><span class="p">[</span><span class="n">rhs</span><span class="p">];</span>
<span class="w">    </span><span class="p">});</span>
<span class="c1">// ध्यान दें कि हमने उपरोक्त उदाहरण में संदर्भ द्वारा &quot;वजन&quot; पर कब्जा कर लिया है।</span>
<span class="c1">// सी ++ में लैम्ब्डा पर अधिक: https://stackoverflow.com/questions/7627098/what-is-a-lambda-expression-in-c11</span>

<span class="c1">/////////////////////////////</span>
<span class="c1">// रेंज के लिए (सी ++ 11 और ऊपर)</span>
<span class="c1">/////////////////////////////</span>

<span class="c1">// आप एक कंटेनर पर लूप को पुनरावृत्त करने के लिए एक श्रेणी का उपयोग कर सकते हैं</span>
<span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span>

<span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">elem</span><span class="o">:</span><span class="w"> </span><span class="n">arr</span><span class="p">){</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// आप &quot;ऑटो&quot; का उपयोग कर सकते हैं और कंटेनर के तत्वों के प्रकार के बारे में चिंता न करें</span>
<span class="c1">// उदाहरण के लिए:</span>

<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">elem</span><span class="o">:</span><span class="w"> </span><span class="n">arr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Do something</span>
<span class="p">}</span>

<span class="c1">/////////////////////</span>
<span class="c1">// मजेदार चीजें</span>
<span class="c1">/////////////////////</span>

<span class="c1">// सी ++ के पहलू जो नवागंतुकों (और यहां तक कि कुछ दिग्गजों) के लिए आश्चर्यजनक हो सकते हैं।</span>
<span class="c1">// यह खंड, दुर्भाग्य से, बेतहाशा अधूरा है; सी ++ सबसे आसान में से एक है</span>
<span class="c1">// भाषाएं जिनके साथ अपने आप को पैर में गोली मारनी है।</span>

<span class="c1">// आप निजी तरीकों को ओवरराइड कर सकते हैं!</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">();</span>
<span class="p">};</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FooSub</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">();</span><span class="w">  </span><span class="c1">// Overrides Foo::bar!</span>
<span class="p">};</span>


<span class="c1">// 0 == false == NULL (most of the time)!</span>
<span class="kt">bool</span><span class="o">*</span><span class="w"> </span><span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">bool</span><span class="p">;</span>
<span class="o">*</span><span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// मान बिंदुओं को &#39;पीटी&#39; द्वारा गलत पर सेट करता है।</span>
<span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// &#39;पीटी&#39; को अशक्त सूचक पर सेट करता है। दोनों पंक्तियाँ बिना किसी चेतावनी के संकलित हैं।</span>

<span class="c1">// nullptr उस समस्या में से कुछ को ठीक करने वाला है:</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">pt2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>
<span class="o">*</span><span class="n">pt2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"> </span><span class="c1">// Doesn&#39;t compile</span>
<span class="n">pt2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w">  </span><span class="c1">// Sets pt2 to null.</span>

<span class="c1">// बूल के लिए एक अपवाद बनाया गया है।</span>
<span class="c1">// यह आपको if(!ptr) के साथ नल पॉइंटर्स के लिए परीक्षण करने की अनुमति देता है,</span>
<span class="c1">// लेकिन परिणामस्वरूप आप सीधे बूल को नलप्टर असाइन कर सकते हैं!</span>
<span class="o">*</span><span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w">  </span><span class="c1">// This still compiles, even though &#39;*pt&#39; is a bool!</span>


<span class="c1">// &#39;=&#39; != &#39;=&#39; != &#39;=&#39;!</span>
<span class="c1">// कॉल फू :: फू (कॉन्स्ट फू एंड) या कुछ प्रकार (मूव शब्दार्थ देखें) कॉपी</span>
<span class="c1">// कंस्ट्रक्टर।</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span>

<span class="c1">// कॉल फू :: फू (कॉन्स्ट फू एंड) या संस्करण, लेकिन केवल &#39;फू&#39; भाग की प्रतिलिपि बनाता है</span>
<span class="c1">// &#39;फूसब&#39;। &#39;fooSub&#39; के किसी भी अतिरिक्त सदस्य को छोड़ दिया जाता है। यह कभी कभी</span>
<span class="c1">// भयानक व्यवहार को &quot;ऑब्जेक्ट स्लाइसिंग&quot; कहा जाता है।</span>
<span class="n">FooSub</span><span class="w"> </span><span class="n">fooSub</span><span class="p">;</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fooSub</span><span class="p">;</span>

<span class="c1">// Calls Foo::operator=(Foo&amp;) or variant.</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f1</span><span class="p">;</span>
<span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span>


<span class="c1">////////////////////////////////////</span>
<span class="c1">// टुपल्स (सी ++ 11 और ऊपर)</span>
<span class="c1">////////////////////////////////////</span>

<span class="cp">#include</span><span class="cpf">&lt;tuple&gt;</span>

<span class="c1">// वैचारिक रूप से, टुपल्स पुराने डेटा संरचनाओं (सी-जैसी संरचना) के समान हैं</span>
<span class="c1">// लेकिन डेटा सदस्यों को नामित करने के बजाय,</span>
<span class="c1">// इसके तत्वों को टपल में उनके क्रम द्वारा एक्सेस किया जाता है।</span>

<span class="c1">// हम एक टपल के निर्माण के साथ शुरू करते हैं।</span>
<span class="c1">// मूल्यों को टपल में पैक करें</span>
<span class="k">auto</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;A&#39;</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maxN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1e9</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maxL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">15</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_tuple</span><span class="p">(</span><span class="n">maxN</span><span class="p">,</span><span class="w"> </span><span class="n">maxL</span><span class="p">);</span>

<span class="c1">// Printing elements of &#39;first&#39; tuple</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">first</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">first</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">//prints : 10 A</span>

<span class="c1">// Printing elements of &#39;second&#39; tuple</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">second</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">second</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// prints: 1000000000 15</span>

<span class="c1">// टपल को वेरिएबल में अनपैक करना</span>

<span class="kt">int</span><span class="w"> </span><span class="n">first_int</span><span class="p">;</span>
<span class="kt">char</span><span class="w"> </span><span class="n">first_char</span><span class="p">;</span>
<span class="n">tie</span><span class="p">(</span><span class="n">first_int</span><span class="p">,</span><span class="w"> </span><span class="n">first_char</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first</span><span class="p">;</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">first_int</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">first_char</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span><span class="w">  </span><span class="c1">// prints : 10 A</span>

<span class="c1">// हम इस तरह टपल भी बना सकते हैं।</span>

<span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">third</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;A&#39;</span><span class="p">,</span><span class="w"> </span><span class="mf">3.14141</span><span class="p">);</span>
<span class="c1">// tuple_size टपल में तत्वों की संख्या लौटाता है (एक कॉन्स्टेक्स के रूप में)</span>

<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">tuple_size</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">third</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// prints: 3</span>

<span class="c1">// tuple_cat सभी टुपल्स के तत्वों को एक ही क्रम में संयोजित करता है।</span>

<span class="k">auto</span><span class="w"> </span><span class="n">concatenated_tuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tuple_cat</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">second</span><span class="p">,</span><span class="w"> </span><span class="n">third</span><span class="p">);</span>
<span class="c1">// concatenated_tuple बन जाता है = (10, &#39;ए&#39;, 1e9, 15, 11, &#39;ए&#39;, 3.14141)</span>

<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">concatenated_tuple</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// prints: 10</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">concatenated_tuple</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// prints: 15</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">&gt;</span><span class="p">(</span><span class="n">concatenated_tuple</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// prints: &#39;A&#39;</span>


<span class="c1">/////////////////////////////////</span>
<span class="c1">// लॉजिकल और बिटवाइज ऑपरेटर्स</span>
<span class="c1">////////////////////////////////</span>

<span class="c1">// सी ++ में अधिकांश ऑपरेटर अन्य भाषाओं की तरह ही हैं</span>

<span class="c1">// लॉजिकल ऑपरेटर्स</span>

<span class="c1">// सी ++ बूलियन अभिव्यक्तियों के लिए शॉर्ट-सर्किट मूल्यांकन का उपयोग करता है, यानी, दूसरा तर्क निष्पादित किया जाता है या</span>
<span class="c1">// केवल तभी मूल्यांकन किया जाता है जब पहला तर्क अभिव्यक्ति के मूल्य को निर्धारित करने के लिए पर्याप्त नहीं है</span>

<span class="nb">true</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="c1">// निष्पादित करता है **तार्किक और** असत्य उत्पन्न करने के लिए</span>
<span class="nb">true</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="c1">// सत्य उत्पन्न करने के लिए **तार्किक या** करता है</span>
<span class="o">!</span><span class="w"> </span><span class="nb">true</span><span class="w">        </span><span class="c1">// प्रदर्शन करता है **तार्किक नहीं** झूठा उत्पन्न करने के लिए</span>

<span class="c1">// प्रतीकों का उपयोग करने के बजाय समकक्ष कीवर्ड का उपयोग किया जा सकता है</span>
<span class="nb">true</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="c1">// प्रदर्शन करता है **तार्किक और ** गलत उत्पन्न करने के लिए</span>
<span class="nb">true</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="nb">false</span><span class="w">  </span><span class="c1">// सत्य उत्पन्न करने के लिए **तार्किक या ** करता है</span>
<span class="k">not</span><span class="w"> </span><span class="nb">true</span><span class="w">       </span><span class="c1">// निष्पादित करता है **तार्किक नहीं ** असत्य उत्पन्न करने के लिए</span>

<span class="c1">// बिटवाइज ऑपरेटर्स</span>

<span class="c1">// **&lt;&lt;** लेफ्ट शिफ्ट ऑपरेटर</span>
<span class="c1">// &lt;&lt; बिट्स को बाईं ओर शिफ्ट करता है</span>
<span class="mi">4</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// 8 देने के लिए 4 के बिट्स को 1 से बायीं ओर शिफ्ट करता है</span>
<span class="c1">// x &lt;&lt; n को x * 2^n . के रूप में माना जा सकता है</span>


<span class="c1">// **&gt;&gt;** राइट शिफ्ट ऑपरेटर</span>
<span class="c1">// &gt;&gt; बिट्स को दाईं ओर शिफ्ट करता है</span>
<span class="mi">4</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// २ देने के लिए ४ के बिट्स को १ से दायीं ओर शिफ्ट करता है</span>
<span class="c1">// x &gt;&gt; n को x / 2^n . के रूप में माना जा सकता है</span>

<span class="o">~</span><span class="mi">4</span><span class="w">    </span><span class="c1">// Performs a bitwise not</span>
<span class="mi">4</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">// Performs bitwise or</span>
<span class="mi">4</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">// Performs bitwise and</span>
<span class="mi">4</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">// Performs bitwise xor</span>

<span class="c1">// समतुल्य कीवर्ड हैं</span>
<span class="k">compl</span><span class="w"> </span><span class="mi">4</span><span class="w">    </span><span class="c1">// Performs a bitwise not</span>
<span class="mi">4</span><span class="w"> </span><span class="k">bitor</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="c1">// Performs bitwise or</span>
<span class="mi">4</span><span class="w"> </span><span class="k">bitand</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">// Performs bitwise and</span>
<span class="mi">4</span><span class="w"> </span><span class="k">xor</span><span class="w"> </span><span class="mi">3</span><span class="w">    </span><span class="c1">// Performs bitwise xor</span>
</pre></div>
<p>अग्रिम पठन:</p>
<ul>
<li>एक अप-टू-डेट भाषा संदर्भ <a href="http://cppreference.com/w/cpp">सीपीपी संदर्भ</a> पर पाया जा सकता है।</li>
<li>अतिरिक्त संसाधन <a href="http://cplusplus.com">CPlusPlus</a> पर मिल सकते हैं।</li>
<li><a href="https://www.youtube.com/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb">TheChernoProject - C++</a> पर भाषा की बुनियादी बातों और कोडिंग परिवेश को सेट करने वाला एक ट्यूटोरियल उपलब्ध है।</li>
</ul>

        <hr>
        <p>
          Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the GitHub Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/hi/c++.md">pull request</a> yourself!
        </p>
        <p class="contributed">
          Originally contributed by Steven Basart, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/hi/c++.md">2 contributors</a>.
        </p>

        <footer>
          <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width: 0; width: 80px; height: 28px; padding-bottom: 5px;" src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-sa.svg" /></a>
          <p>
            &copy; 2025
            <a href="https://github.com/xksteven">Steven Basart</a>,
            <a href="https://github.com/mrkline">Matt Kline</a>,
            <a href="http://geoffliu.me">Geoff Liu</a>,
            <a href="https://github.com/connorwaters">Connor Waters</a>,
            <a href="https://github.com/ankushg07">Ankush Goyal</a>,
            <a href="https://github.com/jatindhankhar">Jatin Dhankhar</a>
          </p>
        </footer>
      </div>
    </div>
  </body>
</html>