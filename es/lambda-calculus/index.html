<!DOCTYPE html>
<html lang="es">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-WXC8R75DEN');
    </script>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="Content-Language" content="es">
    <title>Learn Lambda Calculus in Y Minutes</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto+Slab:wght@100..900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/screen.css">
    <link rel="stylesheet" href="/css/light.css">
    <link rel="stylesheet" href="/css/dark.css">

    <link rel="canonical" href="https://learnxinyminutes.com/es/lambda-calculus/">
    <script>
      localStorage.removeItem("lxiym_theme");
    </script>
  </head>
  <body>
    <div class="container">
      <h1><a href="/">Aprende X en Y minutos</a></h1>
      <h2>Donde X=Lambda Calculus</h2>

      <div class="lang-choice">
        <label for="lang-select">Idioma:</label>
        <select id="lang-select" name="lang-select">
          <option value="es">español</option>
          <option value="en" data-url="/lambda-calculus/">English</option>
          <option value="fr" data-url="/fr/lambda-calculus/">français</option>
          <option value="pt-br" data-url="/pt-br/lambda-calculus/">português (Brasil)</option>
          <option value="zh-cn" data-url="/zh-cn/lambda-calculus/">中文 (简体)</option>
        </select>
      </div>
      <div id="doc">
<h1>Cálculo Lambda</h1>
<p>Cálculo Lambda (Cálculo-λ), originalmente creado por
<a href="https://es.wikipedia.org/wiki/Alonzo_Church">Alonzo Church</a>,
es el lenguaje de programación más pequeño del mundo.
A pesar de no tener números, cadenas, valores booleanos o cualquier
tipo de datos no funcional, el cálculo lambda se puede utilizar para
representar cualquier máquina de Turing.</p>
<p>El cálculo lambda se compone de 3 elementos: <strong>variables</strong>, <strong>funciones</strong> y
<strong>aplicaciones</strong>.</p>
<table>
<thead>
<tr>
<th>Nombre</th>
<th>Sintaxis</th>
<th>Ejemplo</th>
<th>Explicación</th>
</tr>
</thead>
<tbody>
<tr>
<td>Variable</td>
<td><code>&lt;nombre&gt;</code></td>
<td><code>x</code></td>
<td>una variable llamada &quot;x&quot;</td>
</tr>
<tr>
<td>Función</td>
<td><code>λ&lt;parámetro&gt;.&lt;cuerpo&gt;</code></td>
<td><code>λx.x</code></td>
<td>una función con parámetro &quot;x&quot; y cuerpo &quot;x&quot;</td>
</tr>
<tr>
<td>Aplicación</td>
<td><code>&lt;función&gt;&lt;variable o función&gt;</code></td>
<td><code>(λx.x)a</code></td>
<td>llamando a la función &quot;λx.x&quot; con el argumento &quot;a&quot;</td>
</tr>
</tbody>
</table>
<p>La función más básica es la función de identidad: <code>λx.x</code> que es equivalente a
<code>f(x) = x</code>. La primera &quot;x&quot; es el argumento de la función y la segunda es el
cuerpo de la función.</p>
<h2>Variables Libres vs. Enlazadas:</h2>
<ul>
<li>En la función <code>λx.x</code>, &quot;x&quot; se llama una variable enlazada porque está tanto en
el cuerpo de la función como en el parámetro.</li>
<li>En <code>λx.y</code>, &quot;y&quot; se llama variable libre porque nunca se declara de antemano.</li>
</ul>
<h2>Evaluación:</h2>
<p>Evaluación se realiza a través de
<a href="https://es.wikipedia.org/wiki/C%C3%A1lculo_lambda#%CE%B2-reducci%C3%B3n">β-Reduction</a>,
que es, esencialmente, sustitución de ámbito léxico.</p>
<p>Al evaluar la expresión <code>(λx.x)a</code>, reemplazamos todas las ocurrencias de &quot;x&quot;
en el cuerpo de la función con &quot;a&quot;.</p>
<ul>
<li><code>(λx.x)a</code> evalúa a: <code>a</code></li>
<li><code>(λx.y)a</code> evalúa a: <code>y</code></li>
</ul>
<p>Incluso puedes crear funciones de orden superior:</p>
<ul>
<li><code>(λx.(λy.x))a</code> evalúa a: <code>λy.a</code></li>
</ul>
<p>Aunque el cálculo lambda tradicionalmente solo admite funciones
de un solo parámetro, podemos crear funciones multiparamétricas usando
una técnica llamada <a href="https://es.wikipedia.org/wiki/Currificaci%C3%B3n">Currificación</a>.</p>
<ul>
<li><code>(λx.λy.λz.xyz)</code> es equivalente a <code>f(x, y, z) = ((x y) z)</code></li>
</ul>
<p>Algunas veces <code>λxy.&lt;cuerpo&gt;</code> es usado indistintamente con: <code>λx.λy.&lt;cuerpo&gt;</code></p>
<hr />
<p>Es importante reconocer que el cálculo lambda tradicional <strong>no tiene números,
caracteres ni ningún tipo de datos que no sea de función.</strong></p>
<h2>Lógica Booleana:</h2>
<p>No hay &quot;Verdadero&quot; o &quot;Falso&quot; en el cálculo lambda. Ni siquiera hay un 1 o un 0.</p>
<p>En vez:</p>
<p><code>T</code> es representado por: <code>λx.λy.x</code></p>
<p><code>F</code> es representado por: <code>λx.λy.y</code></p>
<p>Primero, podemos definir una función &quot;if&quot; <code>λbtf</code> que devuelve
<code>t</code> si <code>b</code> es Verdadero y <code>f</code> si <code>b</code> es Falso</p>
<p><code>IF</code> es equivalente a: <code>λb.λt.λf.b t f</code></p>
<p>Usando <code>IF</code> podemos definir los operadores lógicos booleanos básicos:</p>
<p><code>a AND b</code> es equivalente a: <code>λab.IF a b F</code></p>
<p><code>a OR b</code> es equivalente a: <code>λab.IF a T b</code></p>
<p><code>a NOT b</code> es equivalente a: <code>λa.IF a F T</code></p>
<p><em>Note: <code>IF a b c</code> es esencialmente diciendo: <code>IF((a b) c)</code></em></p>
<h2>Números:</h2>
<p>Aunque no hay números en el cálculo lambda, podemos codificar números usando
<a href="https://en.wikipedia.org/wiki/Church_encoding">Númeral de Church</a>.</p>
<p>Para cualquier número n: <code>n = λf.f <sup> n </sup></code> así:</p>
<p><code>0 = λf.λx.x</code></p>
<p><code>1 = λf.λx.f x</code></p>
<p><code>2 = λf.λx.f(f x)</code></p>
<p><code>3 = λf.λx.f(f(f x))</code></p>
<p>Para incrementar un númeral de Church, usamos la función sucesora
<code>S(n) = n + 1</code> que es:</p>
<p><code>S = λn.λf.λx.f((n f) x)</code></p>
<p>Usando el sucesor, podemos definir AGREGAR:</p>
<p><code>AGREGAR = λab.(a S)n</code></p>
<p><strong>Desafío:</strong> intenta definir tu propia función de multiplicación!</p>
<h2>Vamos más pequeño: SKI, SK y Iota</h2>
<h3>Combinador de SKI</h3>
<p>Sean S, K, I las siguientes funciones:</p>
<p><code>I x = x</code></p>
<p><code>K x y =  x</code></p>
<p><code>S x y z = x z (y z)</code></p>
<p>Podemos convertir una expresión en el cálculo lambda en una expresión
en el cálculo del combinador de SKI:</p>
<ol>
<li><code>λx.x = I</code></li>
<li><code>λx.c = Kc</code></li>
<li><code>λx.(y z) = S (λx.y) (λx.z)</code></li>
</ol>
<p>Tome el número 2 de Church por ejemplo:</p>
<p><code>2 = λf.λx.f(f x)</code></p>
<p>Para la parte interior <code>λx.f(f x)</code>:</p>
<div class="highlight"><pre>  λx.f(f x)
= S (λx.f) (λx.(f x))          (case 3)
= S (K f)  (S (λx.f) (λx.x))   (case 2, 3)
= S (K f)  (S (K f) I)         (case 2, 1)
</pre></div>
<p>Así que:</p>
<div class="highlight"><pre>  2
= λf.λx.f(f x)
= λf.(S (K f) (S (K f) I))
= λf.((S (K f)) (S (K f) I))
= S (λf.(S (K f))) (λf.(S (K f) I)) (case 3)
</pre></div>
<p>Para el primer argumento <code>λf.(S (K f))</code>:</p>
<div class="highlight"><pre>  λf.(S (K f))
= S (λf.S) (λf.(K f))       (case 3)
= S (K S) (S (λf.K) (λf.f)) (case 2, 3)
= S (K S) (S (K K) I)       (case 2, 3)
</pre></div>
<p>Para el segundo argumento <code>λf.(S (K f) I)</code>:</p>
<div class="highlight"><pre>  λf.(S (K f) I)
= λf.((S (K f)) I)
= S (λf.(S (K f))) (λf.I)             (case 3)
= S (S (λf.S) (λf.(K f))) (K I)       (case 2, 3)
= S (S (K S) (S (λf.K) (λf.f))) (K I) (case 1, 3)
= S (S (K S) (S (K K) I)) (K I)       (case 1, 2)
</pre></div>
<p>Uniéndolos:</p>
<div class="highlight"><pre>  2
= S (λf.(S (K f))) (λf.(S (K f) I))
= S (S (K S) (S (K K) I)) (S (S (K S) (S (K K) I)) (K I))
</pre></div>
<p>Al expandir esto, terminaríamos con la misma expresión para el número 2 de Church nuevamente.</p>
<h3>Cálculo del combinador SKI</h3>
<p>El cálculo del combinador SKI puede reducirse aún más. Podemos eliminar
el combinador I observando que <code>I = SKK</code>. Podemos sustituir
todos los 'I' con <code>SKK</code>.</p>
<h3>Combinador Iota</h3>
<p>El cálculo del combinador SK todavía no se encuentra en su expresión mínima.
Definiendo:</p>
<div class="highlight"><pre>ι = λf.((f S) K)
</pre></div>
<p>Tenemos que:</p>
<div class="highlight"><pre>I = ιι
K = ι(ιI) = ι(ι(ιι))
S = ι(K) = ι(ι(ι(ιι)))
</pre></div>
<h2>Para una lectura más avanzada:</h2>
<ol>
<li><a href="http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf">A Tutorial Introduction to the Lambda Calculus</a></li>
<li><a href="http://www.cs.cornell.edu/courses/cs3110/2008fa/recitations/rec26.html">Cornell CS 312 Recitation 26: The Lambda Calculus</a></li>
<li><a href="https://es.wikipedia.org/wiki/C%C3%A1lculo_lambda">Wikipedia - Lambda Calculus</a></li>
<li><a href="https://en.wikipedia.org/wiki/SKI_combinator_calculus">Wikipedia - SKI combinator calculus</a></li>
<li><a href="https://en.wikipedia.org/wiki/Iota_and_Jot">Wikipedia - Iota and Jot</a></li>
</ol>

        <hr>
        <p>
          ¿Tienes una sugerencia o rectificación? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Abre un issue</a> en el repositorio de GitHub, o haz un <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/es/lambda-calculus.md">pull request</a> tu mismo
        </p>
        <p class="contributed">
          Originalmente contribuido por Max Sun, y actualizado por <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/es/lambda-calculus.md">2 colaboradores</a>.
        </p>

        <footer>
          <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width: 0; width: 80px; height: 28px; padding-bottom: 5px;" src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-sa.svg" /></a>
          <p>
            &copy; 2025
            <a href="http://github.com/maxsun">Max Sun</a>,
            <a href="http://github.com/yanhh0">Yan Hui Hang</a>
          </p>
        </footer>
      </div>

      <script>
        document.addEventListener('DOMContentLoaded', () => {
          const langSelect = document.getElementById('lang-select');
          langSelect?.addEventListener('change', () => {
            const selectedOption = langSelect.options[langSelect.selectedIndex];
            const url = selectedOption?.getAttribute('data-url');
            if (url) {
              window.location.href = url;
            }
          });
        });
      </script>
    </div>
  </body>
</html>