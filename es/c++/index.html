<!DOCTYPE html>
<html lang="es">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-WXC8R75DEN');
    </script>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="Content-Language" content="es">
    <title>Learn C++ in Y Minutes</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto+Slab:wght@100..900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/screen.css">
    <link rel="stylesheet" href="/css/light.css">
    <link rel="stylesheet" href="/css/dark.css">

    <link rel="canonical" href="https://learnxinyminutes.com/es/c++/">
    <script>
      localStorage.removeItem("lxiym_theme");
    </script>
  </head>
  <body>
    <div class="container">
      <div class="share">
        <span class="sharemsg">
          <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fes%2Fc%2B%2B%2F&amp;text=Aprende+X+en+Y+minutos%2C+donde+X%3DC%2B%2B">
            Comparte esta página
          </a>
        </span>
        <span class='st_facebook_large' displayText='Facebook'></span>
        <span class='st_twitter_large' displayText='Tweet'></span>
      </div>
      <h1><a href="/">Aprende X en Y minutos</a></h1>
      <h2>Donde X=C++</h2>
      <p class="filelink">
        Descarga el código:
        <a href="/es/files/learncpp.cpp">learncpp.cpp</a>
      </p>
      <div id="doc">
<p>C++ es un lenguaje de programación de sistemas que,
<a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">de acuerdo a su inventor Bjarne Stroustrup</a>,
fue diseñado para</p>
<ul>
<li>ser un &quot;mejor C&quot;</li>
<li>soportar abstracción de datos</li>
<li>soportar programación orientada a objetos</li>
<li>soportar programación genérica</li>
</ul>
<p>Aunque su sintaxis puede ser más difícil o compleja que los nuevos lenguajes,
es ampliamente utilizado, ya que compila instrucciones nativas que pueden ser
directamente ejecutadas por el procesador y ofrece un estricto control sobre
el hardware (como C), mientras ofrece características de alto nivel como
genericidad, excepciones, y clases. Esta combinación de velocidad y
funcionalidad hace de C ++ uno de los lenguajes de programación más utilizados.</p>
<div class="highlight"><pre lang="c++"><span class="c1">////////////////////</span>
<span class="c1">// Comparación con C</span>
<span class="c1">////////////////////</span>

<span class="c1">// C ++ es _casi_ un superconjunto de C y comparte su sintaxis básica para las</span>
<span class="c1">// declaraciones de variables, tipos primitivos y funciones.</span>

<span class="c1">// Al igual que en C, el punto de entrada de tu programa es una función llamada</span>
<span class="c1">// main con un retorno de tipo entero.</span>
<span class="c1">// Este valor sirve como código de salida del programa.</span>
<span class="c1">// Mira http://en.wikipedia.org/wiki/Exit_status para mayor información.</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">	</span><span class="c1">// Los argumentos de la línea de comandos se pasan por argc y argv de la</span>
<span class="w">	</span><span class="c1">// misma manera que en C.</span>
<span class="w">	</span><span class="c1">// argc indica el número de argumentos,</span>
<span class="w">	</span><span class="c1">// y argv es un arreglo de strings de estilo C (char*)</span>
<span class="w">	</span><span class="c1">// representando los argumentos.</span>
<span class="w">	</span><span class="c1">// El primer argumento es el nombre con el que el programa es llamado.</span>
<span class="w">	</span><span class="c1">// argc y argv pueden omitirse si no te preocupan los argumentos,</span>
<span class="w">	</span><span class="c1">// dejando la definición de la función como int main ()</span>

<span class="w">	</span><span class="c1">// Un estado de salida 0 indica éxito.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Sin embargo, C ++ varía en algunas de las siguientes maneras:</span>

<span class="c1">// En C++, los caracteres literales son caracteres</span>
<span class="k">sizeof</span><span class="p">(</span><span class="sc">&#39;c&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span>

<span class="c1">// En C, los caracteres literales son enteros</span>
<span class="k">sizeof</span><span class="p">(</span><span class="sc">&#39;c&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>


<span class="c1">// C++ tiene prototipado estricto</span>
<span class="kt">void</span><span class="w"> </span><span class="n">func</span><span class="p">();</span><span class="w"> </span><span class="c1">// función que no acepta argumentos</span>

<span class="c1">// En C</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">();</span><span class="w"> </span><span class="c1">// función que puede aceptar cualquier número de argumentos</span>

<span class="c1">// Use nullptr en lugar de NULL en C++</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="c1">// Las cabeceras (headers) estándar de C están disponibles en C ++,</span>
<span class="c1">// pero tienen el prefijo &quot;c&quot; y no tienen sufijo .h.</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdio&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hola mundo!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//////////////////////////</span>
<span class="c1">// Sobrecarga de funciones</span>
<span class="c1">//////////////////////////</span>

<span class="c1">// C++ soporta sobrecarga de funciones</span>
<span class="c1">// siempre que cada función tenga diferentes parámetros.</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">myString</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;String %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">myString</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">myInt</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Mi entero es %d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">myInt</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Corresponde a void print(const char*)</span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span><span class="w"> </span><span class="c1">// Corresponde a void print(int)</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////</span>
<span class="c1">// Argumentos de función por defecto</span>
<span class="c1">////////////////////////////////////</span>

<span class="c1">// Puedes proporcionar argumentos por defecto para una función si no son</span>
<span class="c1">// proporcionados por quien la llama.</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">doSomethingWithInts</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Hacer algo con los enteros aquí</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">doSomethingWithInts</span><span class="p">();</span><span class="w">      </span><span class="c1">// a = 1,  b = 4</span>
<span class="w">    </span><span class="n">doSomethingWithInts</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w">    </span><span class="c1">// a = 20, b = 4</span>
<span class="w">    </span><span class="n">doSomethingWithInts</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// a = 20, b = 5</span>
<span class="p">}</span>

<span class="c1">// Los argumentos predeterminados deben estar al final de la lista de argumentos.</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">invalidDeclaration</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="c1">// Error!</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="c1">/////////////////////</span>
<span class="c1">// Espacios de nombre</span>
<span class="c1">/////////////////////</span>

<span class="c1">// Los espacios de nombres proporcionan ámbitos separados para variable, función y</span>
<span class="c1">// otras declaraciones.</span>
<span class="c1">// Los espacios de nombres se pueden anidar.</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">First</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Nested</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Esto es First::Nested::foo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// fin del nombre de espacio Nested</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// fin del nombre de espacio First</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">Second</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Esto es Second::foo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Este es global: foo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>

<span class="w">	</span><span class="c1">// Incluye todos los símbolos del espacio de nombre Second en el ámbito</span>
<span class="w">	</span><span class="c1">// actual. Tenga en cuenta que simplemente foo() no funciona, ya que ahora</span>
<span class="w">	</span><span class="c1">// es ambigua si estamos llamando a foo en espacio de nombres Second o en</span>
<span class="w">	</span><span class="c1">// el nivel superior.</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Second</span><span class="p">;</span>

<span class="w">    </span><span class="n">Second</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// imprime &quot;Esto es Second::foo&quot;</span>
<span class="w">    </span><span class="n">First</span><span class="o">::</span><span class="n">Nested</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// imprime &quot;Esto es First::Nested::foo&quot;</span>
<span class="w">    </span><span class="o">::</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// imprime &quot;Este es global: foo&quot;</span>
<span class="p">}</span>

<span class="c1">/////////////////</span>
<span class="c1">// Entrada/Salida</span>
<span class="c1">/////////////////</span>

<span class="c1">// La entrada y salida de C++ utiliza flujos (streams)</span>
<span class="c1">// cin, cout, y cerr representan a stdin, stdout, y stderr.</span>
<span class="c1">// &lt;&lt; es el operador de inserción &gt;&gt; es el operador de extracción.</span>


<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="c1"> // Incluir para el flujo de entrada/salida</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"> </span><span class="c1">// Los streams estan en el espacio de nombre std (libreria estandar)</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">myInt</span><span class="p">;</span>

<span class="w">   </span><span class="c1">// Imprime a la stdout (o terminal/pantalla)</span>
<span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Ingresa tu número favorito:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">   </span><span class="c1">// Toma una entrada</span>
<span class="w">   </span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">myInt</span><span class="p">;</span>

<span class="w">   </span><span class="c1">// cout puede también ser formateado</span>
<span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Tu número favorito es &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myInt</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">   </span><span class="c1">// imprime &quot;Tu número favorito es &lt;myInt&gt;&quot;</span>

<span class="w">    </span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Usado para mensajes de error&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">////////////////////</span>
<span class="c1">// Cadenas (Strings)</span>
<span class="c1">////////////////////</span>

<span class="c1">// Las cadenas en C++ son objetos y tienen muchas funciones</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"> </span><span class="c1">// Las cadenas también estan en el nombre de espacio std</span>

<span class="n">string</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hola&quot;</span><span class="p">;</span>
<span class="n">string</span><span class="w"> </span><span class="n">myOtherString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot; Mundo&quot;</span><span class="p">;</span>

<span class="c1">// + es usado para concatenar.</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">myOtherString</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;Hola Mundo&quot;</span>

<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; Tu&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;Hola Tu&quot;</span>

<span class="c1">// Las cadenas en C++ son mutables y tienen valor semántico.</span>
<span class="n">myString</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot; Perro&quot;</span><span class="p">);</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myString</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;Hola Perro&quot;</span>


<span class="c1">//////////////</span>
<span class="c1">// Referencias</span>
<span class="c1">//////////////</span>

<span class="c1">// Además de punteros como los de C,</span>
<span class="c1">// C++ tiene _references_.</span>
<span class="c1">// Estos tipos de puntero no pueden ser reasignados una vez establecidos</span>
<span class="c1">// Y no pueden ser nulos.</span>
<span class="c1">// También tienen la misma sintaxis que la propia variable:</span>
<span class="c1">// No es necesaria * para eliminar la referencia y</span>
<span class="c1">// &amp; (dirección) no se utiliza para la asignación.</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="n">string</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Yo soy foo&quot;</span><span class="p">;</span>
<span class="n">string</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Yo soy bar&quot;</span><span class="p">;</span>

<span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">fooRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w"> </span><span class="c1">// Crea una referencia a foo.</span>
<span class="n">fooRef</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;. Hola!&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Modifica foo través de la referencia</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fooRef</span><span class="p">;</span><span class="w"> </span><span class="c1">// Imprime &quot;Yo soy foo. Hola!&quot;</span>

<span class="c1">// No trate de reasignar &quot;fooRef&quot;. Esto es lo mismo que &quot;foo = bar&quot;, y</span>
<span class="c1">//   foo == &quot;Yo soy bar&quot;</span>
<span class="c1">// después de esta linea.</span>
<span class="n">fooRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span>

<span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">barRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span><span class="w"> </span><span class="c1">// Crea una referencia constante a bar.</span>
<span class="c1">// Como en C, los valores constantes (y punteros y referencias) no pueden ser</span>
<span class="c1">// modificados.</span>
<span class="n">barRef</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;. Hola!&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Error, una referencia constante no puede ser modificada.</span>

<span class="c1">// Sidetrack: Antes de hablar más sobre referencias, hay que introducir un</span>
<span class="c1">// concepto llamado objeto temporal. Supongamos que tenemos el siguiente código:</span>
<span class="n">string</span><span class="w"> </span><span class="nf">tempObjectFun</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="n">string</span><span class="w"> </span><span class="n">retVal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tempObjectFun</span><span class="p">();</span>

<span class="c1">// Lo que pasa en la segunda línea es en realidad:</span>
<span class="c1">// - Un objeto de cadena es retornado desde tempObjectFun</span>
<span class="c1">// - Una nueva cadena se construye con el objeto devuelto como argumento al</span>
<span class="c1">// constructor</span>
<span class="c1">// - El objeto devuelto es destruido</span>
<span class="c1">// El objeto devuelto se llama objeto temporal. Los objetos temporales son</span>
<span class="c1">// creados cada vez que una función devuelve un objeto, y es destruido en el</span>
<span class="c1">// fin de la evaluación de la expresión que encierra (Bueno, esto es lo que la</span>
<span class="c1">// norma dice, pero los compiladores están autorizados a cambiar este</span>
<span class="c1">// comportamiento. Busca &quot;return value optimization&quot; para ver mas detalles).</span>
<span class="c1">// Así que en este código:</span>
<span class="n">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">(</span><span class="n">tempObjectFun</span><span class="p">()))</span>

<span class="c1">// Suponiendo que foo y bar existen, el objeto retornado de tempObjectFun es</span>
<span class="c1">// pasado al bar, y se destruye antes de llamar foo.</span>

<span class="c1">// Ahora, de vuelta a las referencias. La excepción a la regla &quot;en el extremo</span>
<span class="c1">// de la expresión encerrada&quot; es si un objeto temporal se une a una</span>
<span class="c1">// referencia constante, en cuyo caso su vida se extiende al ámbito actual:</span>

<span class="kt">void</span><span class="w"> </span><span class="n">constReferenceTempObjectFun</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// ConstRef obtiene el objeto temporal, y es válido hasta el final de esta</span>
<span class="w">  </span><span class="c1">// función.</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">constRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tempObjectFun</span><span class="p">();</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>

<span class="c1">// Otro tipo de referencia introducida en C ++ 11 es específicamente para</span>
<span class="c1">// objetos temporales. No se puede tener una variable de este tipo, pero tiene</span>
<span class="c1">// prioridad en resolución de sobrecarga:</span>

<span class="kt">void</span><span class="w"> </span><span class="n">someFun</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">  </span><span class="c1">// Referencia regular</span>
<span class="kt">void</span><span class="w"> </span><span class="n">someFun</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">  </span><span class="c1">// Referencia a objeto temporal</span>

<span class="n">string</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>
<span class="n">someFun</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span><span class="w">  </span><span class="c1">// Llama la función con referencia regular</span>
<span class="n">someFun</span><span class="p">(</span><span class="n">tempObjectFun</span><span class="p">());</span><span class="w">  </span><span class="c1">// Llama la función con referencia temporal</span>

<span class="c1">// Por ejemplo, puedes ver estas dos versiones de constructores para</span>
<span class="c1">// std::basic_string:</span>
<span class="n">basic_string</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">basic_string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
<span class="n">basic_string</span><span class="p">(</span><span class="n">basic_string</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>

<span class="c1">// La idea es que si estamos construyendo una nueva cadena de un objeto temporal</span>
<span class="c1">// (que va a ser destruido pronto de todos modos), podemos tener un constructor</span>
<span class="c1">// mas eficiente que &quot;rescata&quot; partes de esa cadena temporal. Usted verá este</span>
<span class="c1">// concepto denominado &quot;movimiento semántico&quot;.</span>

<span class="c1">////////////////////////////////////////////</span>
<span class="c1">// Clases y programación orientada a objetos</span>
<span class="c1">////////////////////////////////////////////</span>

<span class="c1">// Primer ejemplo de clases</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="c1">// Declara una clase.</span>
<span class="c1">// Las clases son usualmente declaradas en archivos de cabeceras (.h o .hpp)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Dog</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Variables y funciones de la clase son privados por defecto.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">weight</span><span class="p">;</span>

<span class="c1">// Todos los miembros siguientes de este son públicos</span>
<span class="c1">// hasta que se encuentre &quot;private&quot; o &quot;protected&quot;.</span>
<span class="k">public</span><span class="o">:</span>

<span class="w">    </span><span class="c1">// Constructor por defecto</span>
<span class="w">    </span><span class="n">Dog</span><span class="p">();</span>

<span class="w">	</span><span class="c1">// Declaraciones de funciones de la clase (implementaciones a seguir)</span>
<span class="w">    </span><span class="c1">// Nota que usamos std::string aquí en lugar de colocar</span>
<span class="w">    </span><span class="c1">// using namespace std;</span>
<span class="w">    </span><span class="c1">// arriba.</span>
<span class="w">    </span><span class="c1">// Nunca ponga una declaración &quot;using namespace&quot; en un encabezado.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">setName</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dogsName</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">setWeight</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">dogsWeight</span><span class="p">);</span>
<span class="w">	</span><span class="c1">// Funciones que no modifican el estado del objeto</span>
<span class="w">	</span><span class="c1">// deben marcarse como const.</span>
<span class="w">	</span><span class="c1">// Esto le permite llamarlas si se envía una referencia constante al objeto.</span>
<span class="w">	</span><span class="c1">// También tenga en cuenta que las funciones deben ser declaradas</span>
<span class="w">	</span><span class="c1">// explícitamente como _virtual_ para que sea reemplazada en las clases</span>
<span class="w">	</span><span class="c1">// derivadas.</span>
<span class="w">	</span><span class="c1">// Las funciones no son virtuales por defecto por razones de rendimiento.</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Las funciones también se pueden definir en el interior</span>
<span class="w">    </span><span class="c1">// del cuerpo de la clase.</span>
<span class="w">	</span><span class="c1">// Funciones definidas como tales están entre líneas automáticamente.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">bark</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; barks!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Junto a los constructores, C++ proporciona destructores.</span>
<span class="w">	</span><span class="c1">// Estos son llamados cuando un objeto se elimina o está fuera del ámbito.</span>
<span class="w">	</span><span class="c1">// Esto permite paradigmas potentes como RAII</span>
<span class="w">	</span><span class="c1">// (mira abajo)</span>
<span class="w">	</span><span class="c1">// El destructor debe ser virtual si una clase es dervada desde el;</span>
<span class="w">	</span><span class="c1">// Si no es virtual, entonces la clase destructora derivada</span>
<span class="w">	</span><span class="c1">// no será llamada si el objeto se destruye a través de una referencia de</span>
<span class="w">	</span><span class="c1">// la clase base o puntero.</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Dog</span><span class="p">();</span>



<span class="p">};</span><span class="w"> </span><span class="c1">// Un punto y coma debe seguir la definición de clase.</span>

<span class="c1">// Las funciones de una clase son normalmente implementados en archivos .cpp.</span>
<span class="n">Dog</span><span class="o">::</span><span class="n">Dog</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Un perro ha sido construido</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Objetos (tales como cadenas) deben ser pasados por referencia</span>
<span class="c1">// si los estás modificando, o referencia constante en caso contrario.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">Dog</span><span class="o">::</span><span class="n">setName</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dogsName</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dogsName</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">Dog</span><span class="o">::</span><span class="n">setWeight</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">dogsWeight</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dogsWeight</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Nota que &quot;virtual&quot; sólo se necesita en la declaración, no en la definición.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">Dog</span><span class="o">::</span><span class="n">print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;El perro es &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; y pesa &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;kg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Dog</span><span class="o">::~</span><span class="n">Dog</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Adiós &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Dog</span><span class="w"> </span><span class="n">myDog</span><span class="p">;</span><span class="w"> </span><span class="c1">// imprime &quot;Un perro ha sido construido&quot;</span>
<span class="w">    </span><span class="n">myDog</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">&quot;Barkley&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">myDog</span><span class="p">.</span><span class="n">setWeight</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="n">myDog</span><span class="p">.</span><span class="n">print</span><span class="p">();</span><span class="w"> </span><span class="c1">// imprime &quot;El perro es Barkley y pesa 10 kg&quot;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// imprime &quot;Adiós Barkley&quot;</span>

<span class="c1">// Herencia:</span>

<span class="c1">// Esta clase hereda todo lo público y protegido de la clase Dog</span>
<span class="k">class</span><span class="w"> </span><span class="nc">OwnedDog</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Dog</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">setOwner</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dogsOwner</span><span class="p">);</span>

<span class="w">	</span><span class="c1">// Reemplaza el comportamiento de la función de impresión</span>
<span class="w">	</span><span class="c1">// de todos los OwnedDogs. Mira</span>
<span class="w">	</span><span class="c1">// http://en.wikipedia.org/wiki/Polymorphism_(computer_science)#Subtyping</span>
<span class="w">	</span><span class="c1">// para una introducción más general si no está familiarizado con el</span>
<span class="w">	</span><span class="c1">// polimorfismo de subtipo.</span>
<span class="w">	</span><span class="c1">// La palabra clave override es opcional, pero asegúrate de que estás</span>
<span class="w">	</span><span class="c1">// reemplazando el método de una clase base.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">owner</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Mientras tanto, en el archivo .cpp correspondiente:</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">OwnedDog::setOwner</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dogsOwner</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dogsOwner</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">OwnedDog::print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Dog</span><span class="o">::</span><span class="n">print</span><span class="p">();</span><span class="w"> </span><span class="c1">// Llama a la función de impresión en la clase base Dog</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;El perro es de &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">owner</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Imprime &quot;El perro es &lt;name&gt; y pesa &lt;weight&gt;&quot;</span>
<span class="w">    </span><span class="c1">//         &quot;El perro es de &lt;owner&gt;&quot;</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////</span>
<span class="c1">// Inicialización y sobrecarga de operadores</span>
<span class="c1">////////////////////////////////////////////</span>

<span class="c1">// En C ++ se puede sobrecargar el comportamiento</span>
<span class="c1">// de los operadores como +, -, *, /, etc.</span>
<span class="c1">// Esto se hace mediante la definición de una función que es llamada</span>
<span class="c1">// cada vez que se utiliza el operador.</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Point</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// Las variables de la clase pueden dar valores por defecto de esta manera.</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">	</span><span class="c1">// Define un constructor por defecto que no hace nada</span>
<span class="w">    </span><span class="c1">// pero inicializa el punto al valor por defecto (0, 0)</span>
<span class="w">    </span><span class="n">Point</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// La siguiente sintaxis se conoce como lista de inicialización</span>
<span class="w">    </span><span class="c1">// y es la forma correcta de inicializar los valores de los miembros de la clase</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">        </span><span class="n">x</span><span class="p">(</span><span class="n">a</span><span class="p">),</span>
<span class="w">        </span><span class="n">y</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="cm">/* No hace nada excepto inicializar los valores */</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Sobrecarga el operador +</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Sobrecarga el operador +=</span>
<span class="w">    </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// También tendría sentido añadir los operadores - y -=,</span>
<span class="w">   	</span><span class="c1">// pero vamos a omitirlos por razones de brevedad.</span>
<span class="p">};</span>

<span class="n">Point</span><span class="w"> </span><span class="n">Point</span><span class="o">::</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Crea un nuevo punto que es la suma de este y rhs.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Point</span><span class="o">::</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="nf">up</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="nf">right</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Llama al operador + de Point</span>
<span class="w">    </span><span class="c1">// Point llama la función + con right como parámetro</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Imprime &quot;Result is upright (1,1)&quot;</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Result is upright (&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;,&#39;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/////////////////////////</span>
<span class="c1">// Plantillas (Templates)</span>
<span class="c1">/////////////////////////</span>

<span class="c1">// Las plantillas en C++ se utilizan sobre todo en la programación genérica,</span>
<span class="c1">// a pesar de que son mucho más poderoso que los constructores genéricos</span>
<span class="c1">// en otros lenguajes. Ellos también soportan especialización explícita y</span>
<span class="c1">// parcial y clases de tipo estilo funcional; de hecho, son un lenguaje</span>
<span class="c1">// funcional Turing-completo incrustado en C ++!</span>

<span class="c1">// Empezamos con el tipo de programación genérica que podría estar</span>
<span class="c1">// familiarizado.</span>
<span class="c1">// Para definir una clase o función que toma un parámetro de tipo:</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Box</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// En este caso, T puede ser usado como cualquier otro tipo.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Durante la compilación, el compilador realmente genera copias de cada</span>
<span class="c1">// plantilla con parámetros sustituidos, por lo que la definición completa</span>
<span class="c1">// de la clase debe estar presente en cada invocación.</span>
<span class="c1">// Es por esto que usted verá clases de plantilla definidas</span>
<span class="c1">// enteramente en archivos de cabecera.</span>

<span class="c1">//Para crear una instancia de una clase de plantilla en la pila:</span>
<span class="n">Box</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">intBox</span><span class="p">;</span>

<span class="n">y</span><span class="w"> </span><span class="n">puedes</span><span class="w"> </span><span class="n">utilizarlo</span><span class="w"> </span><span class="n">como</span><span class="w"> </span><span class="n">era</span><span class="w"> </span><span class="n">de</span><span class="w"> </span><span class="n">esperar</span><span class="o">:</span>
<span class="n">intBox</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>

<span class="c1">// Puedes, por supuesto, anidar plantillas:</span>
<span class="n">Box</span><span class="o">&lt;</span><span class="n">Box</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">boxOfBox</span><span class="p">;</span>
<span class="n">boxOfBox</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">intBox</span><span class="p">);</span>

<span class="c1">// Hasta C++11, había que colocar un espacio entre los dos &#39;&gt;&#39;s,</span>
<span class="c1">// de lo contrario &#39;&gt;&gt;&#39; serían analizados como el operador de desplazamiento</span>
<span class="c1">// a la derecha.</span>


<span class="c1">// A veces verás</span>
<span class="c1">//   template&lt;typename T&gt;</span>
<span class="c1">// en su lugar. La palabra clave &quot;class&quot; y la palabra clave &quot;typename&quot; son</span>
<span class="c1">// mayormente intercambiables en este caso. Para la explicación completa, mira</span>
<span class="c1">//   http://en.wikipedia.org/wiki/Typename</span>
<span class="c1">// (sí, esa palabra clave tiene su propia página de Wikipedia).</span>

<span class="c1">// Del mismo modo, una plantilla de función:</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">barkThreeTimes</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">input</span><span class="p">.</span><span class="n">bark</span><span class="p">();</span>
<span class="w">    </span><span class="n">input</span><span class="p">.</span><span class="n">bark</span><span class="p">();</span>
<span class="w">    </span><span class="n">input</span><span class="p">.</span><span class="n">bark</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Observe que no se especifica nada acerca de los tipos de parámetros aquí.</span>
<span class="c1">// El compilador generará y comprobará cada invocación de la plantilla,</span>
<span class="c1">// por lo que la función anterior funciona con cualquier tipo &quot;T&quot;</span>
<span class="c1">// que tenga un método &#39;bark&#39; constante!</span>


<span class="n">Dog</span><span class="w"> </span><span class="n">fluffy</span><span class="p">;</span>
<span class="n">fluffy</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">&quot;Fluffy&quot;</span><span class="p">)</span>
<span class="n">barkThreeTimes</span><span class="p">(</span><span class="n">fluffy</span><span class="p">);</span><span class="w"> </span><span class="c1">// Imprime &quot;Fluffy barks&quot; 3 veces.</span>

<span class="c1">// Los parámetros de la plantilla no tienen que ser las clases:</span>
<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">Y</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">printMessage</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Aprende C++ en &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; minutos!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Y usted puede especializar explícitamente plantillas</span>
<span class="c1">// para código más eficiente.</span>
<span class="c1">// Por supuesto, la mayor parte del mundo real que utiliza una especialización</span>
<span class="c1">// no son tan triviales como esta.</span>
<span class="c1">// Tenga en cuenta que usted todavía tiene que declarar la función (o clase)</span>
<span class="c1">// como plantilla incluso si ha especificado de forma explícita todos</span>
<span class="c1">// los parámetros.</span>

<span class="k">template</span><span class="o">&lt;&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">printMessage</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Aprende C++ rapido en solo 10 minutos!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">printMessage</span><span class="o">&lt;</span><span class="mi">20</span><span class="o">&gt;</span><span class="p">();</span><span class="w">  </span><span class="c1">// Prints &quot;Aprende C++ en 20 minutos!&quot;</span>
<span class="n">printMessage</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span><span class="p">();</span><span class="w">  </span><span class="c1">// Prints &quot;Aprende C++ rapido en solo 10 minutos!&quot;</span>


<span class="c1">/////////////////////</span>
<span class="c1">// Manejador de excepciones</span>
<span class="c1">/////////////////////</span>

<span class="c1">// La biblioteca estándar proporciona algunos tipos de excepción</span>
<span class="c1">// (mira http://en.cppreference.com/w/cpp/error/exception)</span>
<span class="c1">// pero cualquier tipo puede ser lanzado como una excepción</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exception&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdexcept&gt;</span>

<span class="c1">//Todas las excepciones lanzadas dentro del bloque _try_ pueden ser</span>
<span class="c1">// capturados por los siguientes manejadores _catch_.</span>
<span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// No asigne excepciones en el heap usando _new_.</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Ocurrió un problema&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Captura excepciones por referencia const si son objetos</span>
<span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
<span class="p">}</span>
<span class="o">********************************************************************************</span>
<span class="c1">// Captura cualquier excepción no capturada por bloques _catch_ anteriores</span>
<span class="k">catch</span><span class="w"> </span><span class="p">(...)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Excepción desconocida capturada&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">throw</span><span class="p">;</span><span class="w"> </span><span class="c1">// Re-lanza la excepción</span>
<span class="p">}</span>

<span class="c1">///////</span>
<span class="c1">// RAII</span>
<span class="c1">///////</span>

<span class="c1">// RAII significa &quot;Resource Acquisition Is Initialization&quot;</span>
<span class="c1">// (Adquisición de recursos es inicialización).</span>
<span class="c1">// A menudo se considera el paradigma más poderoso en C++</span>
<span class="c1">// Y el concepto es simple: un constructor de un objeto</span>
<span class="c1">// adquiere recursos de ese objeto y el destructor les libera.</span>

<span class="c1">// Para entender cómo esto es útil,</span>
<span class="c1">// considere una función que utiliza un identificador de archivo C:</span>
<span class="kt">void</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Para empezar, asuma que nada puede fallar.</span>

<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Abre el archivo en modo lectura</span>

<span class="w">    </span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Cierra el manejador de archivos</span>
<span class="p">}</span>

<span class="c1">// Por desgracia, las cosas se complican rápidamente por el control de errores.</span>
<span class="c1">// Supongamos que fopen puede fallar, y que doSomethingWithTheFile y</span>
<span class="c1">// DoSomethingElseWithIt retornan códigos de error si fallan.</span>
<span class="c1">// 	(Excepciones son la mejor forma de manejar los fallos,</span>
<span class="c1">// 	 pero algunos programadores, especialmente los que tienen un fondo C,</span>
<span class="c1">// 	 estan en desacuerdo sobre la utilidad de las excepciones).</span>
<span class="c1">// Ahora tenemos que comprobar cada llamado por fallos y cerrar el manejador</span>
<span class="c1">// del archivo si se ha producido un problema.</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Abre el archivo en modo lectura</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fh</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="c1">// El puntero retornado es nulo o falla.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Reporta el fallo a quien hizo el llamado.</span>

<span class="w">    </span><span class="c1">// Asume que cada función retorna falso si falla</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Cierre el manejador de archivo para que no se filtre.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Propaga el error.</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Cierre el manejador de archivo para que no se filtre.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Propaga el error.</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Cierre el archivo.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// Indica que todo funcionó correctamente.</span>
<span class="p">}</span>

<span class="c1">// Programadores C suelen limpiar esto un poco usando goto:</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fh</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">failure</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">failure</span><span class="p">;</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Cierre el archivo.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// Indica que todo funcionó correctamente.</span>

<span class="nl">failure</span><span class="p">:</span>
<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Propaga el error</span>
<span class="p">}</span>

<span class="c1">// Si las funciones indican errores mediante excepciones,</span>
<span class="c1">// las cosas son un poco más claras, pero pueden optimizarse más.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Abrir el archivo en modo lectura</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fh</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;No puede abrirse el archivo.&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">        </span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">catch</span><span class="w"> </span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Asegúrese de cerrar el archivo si se produce un error.</span>
<span class="w">        </span><span class="k">throw</span><span class="p">;</span><span class="w"> </span><span class="c1">// Luego vuelve a lanzar la excepción.</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Cierra el archivo</span>
<span class="p">}</span>

<span class="c1">// Compare esto con el uso de la clase de flujo de archivos de C++ (fstream)</span>
<span class="c1">// fstream utiliza su destructor para cerrar el archivo.</span>
<span class="c1">// Los destructores son llamados automáticamente</span>
<span class="c1">// cuando un objeto queda fuera del ámbito.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// ifstream es la abreviatura de el input file stream</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span><span class="w"> </span><span class="nf">fh</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span><span class="w"> </span><span class="c1">// Abre el archivo</span>

<span class="w">    </span><span class="c1">// Hacer algo con el archivo</span>
<span class="w">    </span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// El archivo se cierra automáticamente aquí por el destructor</span>


<span class="c1">// Esto tiene ventajas _enormes_:</span>
<span class="c1">// 1. No importa lo que pase,</span>
<span class="c1">//    el recurso (en este caso el manejador de archivo) será limpiado.</span>
<span class="c1">//    Una vez que escribes el destructor correctamente,</span>
<span class="c1">//    es _imposible_ olvidar cerrar el identificador y permitir</span>
<span class="c1">//    fugas del recurso.</span>
<span class="c1">// 2. Tenga en cuenta que el código es mucho más limpio.</span>
<span class="c1">//    El destructor se encarga de cerrar el archivo detrás de cámaras</span>
<span class="c1">//    Sin que tenga que preocuparse por ello.</span>
<span class="c1">// 3. El código es seguro.</span>
<span class="c1">//    Una excepción puede ser lanzado en cualquier lugar de la función</span>
<span class="c1">//    y la limpieza ocurrirá.</span>

<span class="c1">// Todo el código idiomático C++ utiliza RAII ampliamente para todos los</span>
<span class="c1">// recursos.</span>
<span class="c1">// Otros ejemplos incluyen</span>
<span class="c1">// - Memoria usando unique_ptr y shared_ptr</span>
<span class="c1">// - Contenedores (Containers) - la biblioteca estándar linked list,</span>
<span class="c1">//   vector (es decir, array con auto-cambio de tamaño), hash maps, etc.</span>
<span class="c1">//   Destruimos todos sus contenidos de forma automática</span>
<span class="c1">//   cuando quedan fuera del ámbito.</span>
<span class="c1">// - Mutex utilizando lock_guard y unique_lock</span>


<span class="c1">/////////////////////</span>
<span class="c1">// Cosas divertidas</span>
<span class="c1">/////////////////////</span>

<span class="c1">// Aspectos de C ++ que pueden sorprender a los recién llegados</span>
<span class="c1">// (e incluso algunos veteranos).</span>
<span class="c1">// Esta sección es, por desgracia, salvajemente incompleta;</span>
<span class="c1">// C++ es uno de los lenguajes con los que mas facil te disparas en el pie.</span>

<span class="c1">// Tu puedes sobreescribir métodos privados!</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">();</span>
<span class="p">};</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FooSub</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">();</span><span class="w">  </span><span class="c1">// Sobreescribe Foo::bar!</span>
<span class="p">};</span>


<span class="c1">// 0 == false == NULL (La mayoria de las veces)!</span>
<span class="kt">bool</span><span class="o">*</span><span class="w"> </span><span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">bool</span><span class="p">;</span>
<span class="o">*</span><span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// Establece los puntos de valor de &#39;pt&#39; en falso.</span>
<span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// Establece &#39;pt&#39; al apuntador nulo. Ambas lineas compilan sin error.</span>

<span class="c1">// nullptr se supone que arregla un poco de ese tema:</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">pt2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>
<span class="o">*</span><span class="n">pt2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"> </span><span class="c1">// No compila</span>
<span class="n">pt2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w">  </span><span class="c1">// Establece pt2 como null.</span>

<span class="c1">// Hay una excepción para los valores bool.</span>
<span class="c1">// Esto es para permitir poner a prueba punteros nulos con if (!ptr),</span>
<span class="c1">// pero como consecuencia se puede asignar nullptr a un bool directamente!</span>
<span class="o">*</span><span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w">  </span><span class="c1">// Esto todavía compila, a pesar de que &#39;*pt&#39; es un bool!</span>

<span class="c1">// &#39;=&#39; != &#39;=&#39; != &#39;=&#39;!</span>
<span class="c1">// Llama Foo::Foo(const Foo&amp;) o alguna variante (mira movimientos semanticos)</span>
<span class="c1">// copia del constructor.</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span>

<span class="c1">// Llama Foo::Foo(const Foo&amp;) o variante, pero solo copia el &#39;Foo&#39; parte de</span>
<span class="c1">// &#39;fooSub&#39;. Cualquier miembro extra de &#39;fooSub&#39; se descarta. Este</span>
<span class="c1">// comportamiento horrible se llama &quot;Corte de objetos.&quot;</span>
<span class="n">FooSub</span><span class="w"> </span><span class="n">fooSub</span><span class="p">;</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fooSub</span><span class="p">;</span>

<span class="c1">// Llama a Foo::operator=(Foo&amp;) o variantes.</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f1</span><span class="p">;</span>
<span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span>


<span class="c1">// Cómo borrar realmente un contenedor:</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">  </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Foo</span><span class="p">());</span>
<span class="c1">// La siguiente línea establece el tamaño de v en 0,</span>
<span class="c1">// pero los destructores no son llamados y los recursos no se liberan!</span>

<span class="n">v</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
<span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Foo</span><span class="p">());</span><span class="w">  </span><span class="c1">// Nuevo valor se copia en el primer Foo que insertamos</span>

<span class="c1">// En verdad destruye todos los valores en v.</span>
<span class="c1">// Consulta la sección acerca de los objetos temporales para la</span>
<span class="c1">// explicación de por qué esto funciona.</span>
<span class="n">v</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">());</span>
</pre></div>
<p>Otras lecturas:</p>
<ul>
<li>Una referencia del lenguaje hasta a la fecha se puede encontrar en <a href="http://cppreference.com/w/cpp">CPP Reference</a>.</li>
<li>Recursos adicionales se pueden encontrar en <a href="http://cplusplus.com">[CPlusPlus]</a>.</li>
<li>Un tutorial que cubre los conceptos básicos del lenguaje y la configuración del entorno de codificación está disponible en <a href="https://www.youtube.com/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FF">TheChernoProject - C ++</a>.</li>
</ul>

        <hr>
        <p>
          ¿Tienes una sugerencia o rectificación? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Abre un issue</a> en el repositorio de GitHub, o haz un <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/es/c++.md">pull request</a> tu mismo
        </p>
        <p class="contributed">
          Originalmente contribuido por Steven Basart, y actualizado por <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/es/c++.md">5 colaboradores</a>.
        </p>

        <footer>
          <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width: 0; width: 80px; height: 28px; padding-bottom: 5px;" src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-sa.svg" /></a>
          <p>
            &copy; 2025
            <a href="http://github.com/xksteven">Steven Basart</a>,
            <a href="https://github.com/mrkline">Matt Kline</a>,
            <a href="http://geoffliu.me">Geoff Liu</a>,
            <a href="http://github.com/connorwaters">Connor Waters</a>
          </p>
        </footer>
      </div>
    </div>
  </body>
</html>