<!DOCTYPE html>
<html lang="en">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-WXC8R75DEN');
    </script>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="Content-Language" content="en">
    <title>Learn WebAssembly in Y Minutes</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto+Slab:wght@100..900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/screen.css">
    <link rel="stylesheet" href="/css/light.css">
    <link rel="stylesheet" href="/css/dark.css">

    <link rel="canonical" href="https://learnxinyminutes.com/wasm/">
    <script>
      localStorage.removeItem("lxiym_theme");
    </script>
  </head>
  <body>
    <div class="container">
      <div class="share">
        <span class="sharemsg">
          <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fwasm%2F&amp;text=Learn+X+in+Y+minutes%2C+where+X%3DWebAssembly">
            Share this page
          </a>
        </span>
        <span class='st_facebook_large' displayText='Facebook'></span>
        <span class='st_twitter_large' displayText='Tweet'></span>
      </div>
      <h1><a href="/">Learn X in Y minutes</a></h1>
      <h2>Where X=WebAssembly</h2>
      <p class="filelink">
        Get the code:
        <a href="/files/learn-wasm.wast">learn-wasm.wast</a>
      </p>
      <div id="doc">
<div class="highlight"><pre lang="wast"><span class="c1">;; learn-wasm.wast</span>

<span class="p">(</span><span class="k">module</span>
  <span class="c1">;; In WebAssembly, everything is included in a module. Moreover, everything</span>
  <span class="c1">;; can be expressed as an s-expression. Alternatively, there is the</span>
  <span class="c1">;; &quot;stack machine&quot; syntax, but that is not compatible with Binaryen</span>
  <span class="c1">;; intermediate representation (IR) syntax.</span>

  <span class="c1">;; The Binaryen IR format is *mostly* compatible with WebAssembly text format.</span>
  <span class="c1">;; There are some small differences:</span>
  <span class="c1">;; local_set -&gt; local.set</span>
  <span class="c1">;; local_get -&gt; local.get</span>

  <span class="c1">;; We have to enclose code in functions</span>

  <span class="c1">;; Data Types</span>
  <span class="p">(</span><span class="k">func</span> <span class="nv">$data_types</span>
    <span class="c1">;; WebAssembly has only four types:</span>
    <span class="c1">;; i32 - 32 bit integer</span>
    <span class="c1">;; i64 - 64 bit integer (not supported in JavaScript)</span>
    <span class="c1">;; f32 - 32 bit floating point</span>
    <span class="c1">;; f64 - 64 bit floating point</span>

    <span class="c1">;; We can declare local variables with the &quot;local&quot; keyword</span>
    <span class="c1">;; We have to declare all variables before we start doing anything</span>
    <span class="c1">;; inside the function</span>

    <span class="p">(</span><span class="k">local</span> <span class="nv">$int_32</span> <span class="kt">i32</span><span class="p">)</span>
    <span class="p">(</span><span class="k">local</span> <span class="nv">$int_64</span> <span class="kt">i64</span><span class="p">)</span>
    <span class="p">(</span><span class="k">local</span> <span class="nv">$float_32</span> <span class="kt">f32</span><span class="p">)</span>
    <span class="p">(</span><span class="k">local</span> <span class="nv">$float_64</span> <span class="kt">f64</span><span class="p">)</span>

    <span class="c1">;; These values remain uninitialized.</span>
    <span class="c1">;; To set them to a value, we can use &lt;type&gt;.const:</span>

    <span class="p">(</span><span class="nb">local.set</span> <span class="nv">$int_32</span> <span class="p">(</span><span class="nb">i32.const</span> <span class="mi">16</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">local.set</span> <span class="nv">$int_64</span> <span class="p">(</span><span class="nb">i64.const</span> <span class="mf">128</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">local.set</span> <span class="nv">$float_32</span> <span class="p">(</span><span class="nb">f32.const</span> <span class="mf">3.14</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">local.set</span> <span class="nv">$float_64</span> <span class="p">(</span><span class="nb">f64.const</span> <span class="mf">1.28</span><span class="p">))</span>
  <span class="p">)</span>

  <span class="c1">;; Basic operations</span>
  <span class="p">(</span><span class="k">func</span> <span class="nv">$basic_operations</span>

    <span class="c1">;; In WebAssembly, everything is an s-expression, including</span>
    <span class="c1">;; doing math, or getting the value of some variable</span>

    <span class="p">(</span><span class="k">local</span> <span class="nv">$add_result</span> <span class="kt">i32</span><span class="p">)</span>
    <span class="p">(</span><span class="k">local</span> <span class="nv">$mult_result</span> <span class="kt">f64</span><span class="p">)</span>

    <span class="p">(</span><span class="nb">local.set</span> <span class="nv">$add_result</span> <span class="p">(</span><span class="nb">i32.add</span> <span class="p">(</span><span class="nb">i32.const</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">i32.const</span> <span class="mi">4</span><span class="p">)))</span>
    <span class="c1">;; the value of add_result is now 6!</span>

    <span class="c1">;; We have to use the right data type for each operation:</span>
    <span class="c1">;; (local.set $mult_result (f32.mul (f32.const 2.0) (f32.const 4.0))) ;; WRONG! mult_result is f64!</span>
    <span class="p">(</span><span class="nb">local.set</span> <span class="nv">$mult_result</span> <span class="p">(</span><span class="nb">f64.mul</span> <span class="p">(</span><span class="nb">f64.const</span> <span class="mf">2.0</span><span class="p">)</span> <span class="p">(</span><span class="nb">f64.const</span> <span class="mf">4.0</span><span class="p">)))</span>

    <span class="c1">;; WebAssembly has some builtin operations, like basic math and bitshifting.</span>
    <span class="c1">;; Notably, it does not have built in trigonometric functions.</span>
    <span class="c1">;; In order to get access to these functions, we have to either</span>
    <span class="c1">;; - implement them ourselves (not recommended)</span>
    <span class="c1">;; - import them from elsewhere (later on)</span>
  <span class="p">)</span>

  <span class="c1">;; Functions</span>
  <span class="c1">;; We specify arguments with the `param` keyword, and specify return values</span>
  <span class="c1">;; with the `result` keyword</span>
  <span class="c1">;; The current value on the stack is the return value of a function</span>

  <span class="c1">;; We can call other functions we&#39;ve defined with the `call` keyword</span>

  <span class="p">(</span><span class="k">func</span> <span class="nv">$get_16</span> <span class="p">(</span><span class="k">result</span> <span class="kt">i32</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">i32.const</span> <span class="mi">16</span><span class="p">)</span>
  <span class="p">)</span>

  <span class="p">(</span><span class="k">func</span> <span class="nv">$add</span> <span class="p">(</span><span class="k">param</span> <span class="nv">$param0</span> <span class="kt">i32</span><span class="p">)</span> <span class="p">(</span><span class="k">param</span> <span class="nv">$param1</span> <span class="kt">i32</span><span class="p">)</span> <span class="p">(</span><span class="k">result</span> <span class="kt">i32</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">i32.add</span>
      <span class="p">(</span><span class="nb">local.get</span> <span class="nv">$param0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">local.get</span> <span class="nv">$param1</span><span class="p">)</span>
    <span class="p">)</span>
  <span class="p">)</span>

  <span class="p">(</span><span class="k">func</span> <span class="nv">$double_16</span> <span class="p">(</span><span class="k">result</span> <span class="kt">i32</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">i32.mul</span>
      <span class="p">(</span><span class="nb">i32.const</span> <span class="mi">2</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">call</span> <span class="nv">$get_16</span><span class="p">))</span>
  <span class="p">)</span>

  <span class="c1">;; Up until now, we haven&#39;t be able to print anything out, nor do we have</span>
  <span class="c1">;; access to higher level math functions (pow, exp, or trig functions).</span>
  <span class="c1">;; Moreover, we haven&#39;t been able to use any of the WASM functions in JavaScript!</span>
  <span class="c1">;; The way we get those functions into WebAssembly</span>
  <span class="c1">;; looks different whether we&#39;re in a Node.js or browser environment.</span>

  <span class="c1">;; If we&#39;re in Node.js we have to do two steps. First we have to convert the</span>
  <span class="c1">;; WASM text representation into actual webassembly. If we&#39;re using Binyaren,</span>
  <span class="c1">;; we can do that with a command like the following:</span>

  <span class="c1">;; wasm-as learn-wasm.wast -o learn-wasm.wasm</span>

  <span class="c1">;; We can apply Binaryen optimizations to that file with a command like the</span>
  <span class="c1">;; following:</span>

  <span class="c1">;; wasm-opt learn-wasm.wasm -o learn-wasm.opt.wasm -O3 --rse</span>

  <span class="c1">;; With our compiled WebAssembly, we can now load it into Node.js:</span>
  <span class="c1">;; const fs = require(&#39;fs&#39;)</span>
  <span class="c1">;; const instantiate = async function (inFilePath, _importObject) {</span>
  <span class="c1">;;  var importObject = {</span>
  <span class="c1">;;     console: {</span>
  <span class="c1">;;       log: (x) =&gt; console.log(x),</span>
  <span class="c1">;;     },</span>
  <span class="c1">;;     math: {</span>
  <span class="c1">;;       cos: (x) =&gt; Math.cos(x),</span>
  <span class="c1">;;     }</span>
  <span class="c1">;;   }</span>
  <span class="c1">;;  importObject = Object.assign(importObject, _importObject)</span>
  <span class="c1">;;</span>
  <span class="c1">;;  var buffer = fs.readFileSync(inFilePath)</span>
  <span class="c1">;;  var module = await WebAssembly.compile(buffer)</span>
  <span class="c1">;;  var instance = await WebAssembly.instantiate(module, importObject)</span>
  <span class="c1">;;  return instance.exports</span>
  <span class="c1">;; }</span>
  <span class="c1">;;</span>
  <span class="c1">;; const main = function () {</span>
  <span class="c1">;;   var wasmExports = await instantiate(&#39;learn-wasm.wasm&#39;)</span>
  <span class="c1">;;   wasmExports.print_args(1, 0)</span>
  <span class="c1">;; }</span>

  <span class="c1">;; The following snippet gets the functions from the importObject we defined</span>
  <span class="c1">;; in the JavaScript instantiate async function, and then exports a function</span>
  <span class="c1">;; &quot;print_args&quot; that we can call from Node.js</span>

  <span class="p">(</span><span class="k">import</span> <span class="s2">&quot;console&quot;</span> <span class="s2">&quot;log&quot;</span> <span class="p">(</span><span class="k">func</span> <span class="nv">$print_i32</span> <span class="p">(</span><span class="k">param</span> <span class="kt">i32</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">import</span> <span class="s2">&quot;math&quot;</span> <span class="s2">&quot;cos&quot;</span> <span class="p">(</span><span class="k">func</span> <span class="nv">$cos</span> <span class="p">(</span><span class="k">param</span> <span class="kt">f64</span><span class="p">)</span> <span class="p">(</span><span class="k">result</span> <span class="kt">f64</span><span class="p">)))</span>

  <span class="p">(</span><span class="k">func</span> <span class="nv">$print_args</span> <span class="p">(</span><span class="k">param</span> <span class="nv">$arg0</span> <span class="kt">i32</span><span class="p">)</span> <span class="p">(</span><span class="k">param</span> <span class="nv">$arg1</span> <span class="kt">i32</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">call</span> <span class="nv">$print_i32</span> <span class="p">(</span><span class="nb">local.get</span> <span class="nv">$arg0</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">call</span> <span class="nv">$print_i32</span> <span class="p">(</span><span class="nb">local.get</span> <span class="nv">$arg1</span><span class="p">))</span>
  <span class="p">)</span>
  <span class="p">(</span><span class="k">export</span> <span class="s2">&quot;print_args&quot;</span> <span class="p">(</span><span class="k">func</span> <span class="nv">$print_args</span><span class="p">))</span>

  <span class="c1">;; Loading in data from WebAssembly memory.</span>
  <span class="c1">;; Say that we want to apply the cosine function to a JavaScript array.</span>
  <span class="c1">;; We need to be able to access the allocated array, and iterate through it.</span>
  <span class="c1">;; This example will modify the input array inplace.</span>
  <span class="c1">;; f64.load and f64.store expect the location of a number in memory *in bytes*.</span>
  <span class="c1">;; If we want to access the 3rd element of an array, we have to pass something</span>
  <span class="c1">;; like (i32.mul (i32.const 8) (i32.const 2)) to the f64.store function.</span>

  <span class="c1">;; In JavaScript, we would call `apply_cos64` as follows</span>
  <span class="c1">;; (using the instantiate function from earlier):</span>
  <span class="c1">;;</span>
  <span class="c1">;; const main = function () {</span>
  <span class="c1">;;   var wasm = await instantiate(&#39;learn-wasm.wasm&#39;)</span>
  <span class="c1">;;   var n = 100</span>
  <span class="c1">;;   const memory = new Float64Array(wasm.memory.buffer, 0, n)</span>
  <span class="c1">;;   for (var i=0; i&lt;n; i++) {</span>
  <span class="c1">;;     memory[i] = i;</span>
  <span class="c1">;;   }</span>
  <span class="c1">;;   wasm.apply_cos64(n)</span>
  <span class="c1">;; }</span>
  <span class="c1">;;</span>
  <span class="c1">;; This function will not work if we allocate a Float32Array on the JavaScript</span>
  <span class="c1">;; side.</span>

  <span class="p">(</span><span class="k">memory</span> <span class="p">(</span><span class="k">export</span> <span class="s2">&quot;memory&quot;</span><span class="p">)</span> <span class="mf">100</span><span class="p">)</span>

  <span class="p">(</span><span class="k">func</span> <span class="nv">$apply_cos64</span> <span class="p">(</span><span class="k">param</span> <span class="nv">$array_length</span> <span class="kt">i32</span><span class="p">)</span>
    <span class="c1">;; declare the loop counter</span>
    <span class="p">(</span><span class="k">local</span> <span class="nv">$idx</span> <span class="kt">i32</span><span class="p">)</span>
    <span class="c1">;; declare the counter that will allow us to access memory</span>
    <span class="p">(</span><span class="k">local</span> <span class="nv">$idx_bytes</span> <span class="kt">i32</span><span class="p">)</span>
    <span class="c1">;; constant expressing the number of bytes in a f64 number.</span>
    <span class="p">(</span><span class="k">local</span> <span class="nv">$bytes_per_double</span> <span class="kt">i32</span><span class="p">)</span>

    <span class="c1">;; declare a variable for storing the value loaded from memory</span>
    <span class="p">(</span><span class="k">local</span> <span class="nv">$temp_f64</span> <span class="kt">f64</span><span class="p">)</span>

    <span class="p">(</span><span class="nb">local.set</span> <span class="nv">$idx</span> <span class="p">(</span><span class="nb">i32.const</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">local.set</span> <span class="nv">$idx_bytes</span> <span class="p">(</span><span class="nb">i32.const</span> <span class="mi">0</span><span class="p">))</span> <span class="c1">;; not entirely necessary</span>
    <span class="p">(</span><span class="nb">local.set</span> <span class="nv">$bytes_per_double</span> <span class="p">(</span><span class="nb">i32.const</span> <span class="mi">8</span><span class="p">))</span>

    <span class="p">(</span><span class="k">block</span>
      <span class="p">(</span><span class="k">loop</span>
        <span class="c1">;; this sets idx_bytes to bytes offset of the value we&#39;re interested in.</span>
        <span class="p">(</span><span class="nb">local.set</span> <span class="nv">$idx_bytes</span> <span class="p">(</span><span class="nb">i32.mul</span> <span class="p">(</span><span class="nb">local.get</span> <span class="nv">$idx</span><span class="p">)</span> <span class="p">(</span><span class="nb">local.get</span> <span class="nv">$bytes_per_double</span><span class="p">)))</span>

        <span class="c1">;; get the value of the array from memory:</span>
        <span class="p">(</span><span class="nb">local.set</span> <span class="nv">$temp_f64</span> <span class="p">(</span><span class="nb">f64.load</span> <span class="p">(</span><span class="nb">local.get</span> <span class="nv">$idx_bytes</span><span class="p">)))</span>

        <span class="c1">;; now apply the cosine function:</span>
        <span class="p">(</span><span class="nb">local.set</span> <span class="nv">$temp_64</span> <span class="p">(</span><span class="nb">call</span> <span class="nv">$cos</span> <span class="p">(</span><span class="nb">local.get</span> <span class="nv">$temp_64</span><span class="p">)))</span>

        <span class="c1">;; now store the result at the same location in memory:</span>
        <span class="p">(</span><span class="nb">f64.store</span>
          <span class="p">(</span><span class="nb">local.get</span> <span class="nv">$idx_bytes</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">local.get</span> <span class="nv">$temp_64</span><span class="p">))</span>

        <span class="c1">;; do it all in one step instead</span>
        <span class="p">(</span><span class="nb">f64.store</span>
          <span class="p">(</span><span class="nb">local.get</span> <span class="nv">$idx_bytes</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">call</span> <span class="nv">$cos</span>
            <span class="p">(</span><span class="nb">f64.load</span>
              <span class="p">(</span><span class="nb">local.get</span> <span class="nv">$idx_bytes</span><span class="p">))))</span>

        <span class="c1">;; increment the loop counter</span>
        <span class="p">(</span><span class="nb">local.set</span> <span class="nv">$idx</span> <span class="p">(</span><span class="nb">i32.add</span> <span class="p">(</span><span class="nb">local.get</span> <span class="nv">$idx</span><span class="p">)</span> <span class="p">(</span><span class="nb">i32.const</span> <span class="mi">1</span><span class="p">)))</span>

        <span class="c1">;; stop the loop if the loop counter is equal the array length</span>
        <span class="p">(</span><span class="nb">br_if</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">i32.eq</span> <span class="p">(</span><span class="nb">local.get</span> <span class="nv">$idx</span><span class="p">)</span> <span class="p">(</span><span class="nb">local.get</span> <span class="nv">$array_length</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">br</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">)</span>
    <span class="p">)</span>
  <span class="p">)</span>
  <span class="p">(</span><span class="k">export</span> <span class="s2">&quot;apply_cos64&quot;</span> <span class="p">(</span><span class="k">func</span> <span class="nv">$apply_cos64</span><span class="p">))</span>

  <span class="c1">;; Wasm is a stack-based language, but for returning values more complicated</span>
  <span class="c1">;; than an int/float, a separate memory stack has to be manually managed. One</span>
  <span class="c1">;; approach is to use a mutable global to store the stack_ptr. We give</span>
  <span class="c1">;; ourselves 1MiB of memstack and grow it downwards.</span>
  <span class="c1">;;</span>
  <span class="c1">;; Below is a demonstration of how this C code **might** be written by hand</span>
  <span class="c1">;;</span>
  <span class="c1">;;   typedef struct {</span>
  <span class="c1">;;       int a;</span>
  <span class="c1">;;       int b;</span>
  <span class="c1">;;   } sum_struct_t;</span>
  <span class="c1">;;</span>
  <span class="c1">;;   sum_struct_t sum_struct_create(int a, int b) {</span>
  <span class="c1">;;     return (sum_struct_t){a, b};</span>
  <span class="c1">;;   }</span>
  <span class="c1">;;</span>
  <span class="c1">;;   int sum_local() {</span>
  <span class="c1">;;     sum_struct_t s = sum_struct_create(40, 2);</span>
  <span class="c1">;;     return s.a + s.b;</span>
  <span class="c1">;;   }</span>

  <span class="c1">;; Unlike C, we must manage our own memory stack. We reserve 1MiB</span>
  <span class="p">(</span><span class="k">global</span> <span class="nv">$memstack_ptr</span> <span class="p">(</span><span class="k">mut</span> <span class="kt">i32</span><span class="p">)</span> <span class="p">(</span><span class="nb">i32.const</span> <span class="mf">65536</span><span class="p">))</span>

  <span class="c1">;; Structs can only be returned by reference</span>
  <span class="p">(</span><span class="k">func</span> <span class="nv">$sum_struct_create</span> 
        <span class="p">(</span><span class="k">param</span> <span class="nv">$sum_struct_ptr</span> <span class="kt">i32</span><span class="p">)</span> 
        <span class="p">(</span><span class="k">param</span> <span class="nv">$var$a</span> <span class="kt">i32</span><span class="p">)</span> 
        <span class="p">(</span><span class="k">param</span> <span class="nv">$var$b</span> <span class="kt">i32</span><span class="p">)</span>
    <span class="c1">;; c// sum_struct_ptr-&gt;a = a;</span>
    <span class="p">(</span><span class="nb">i32.store</span>
      <span class="p">(</span><span class="err">get_</span><span class="k">local</span> <span class="nv">$sum_struct_ptr</span><span class="p">)</span>
      <span class="p">(</span><span class="err">get_</span><span class="k">local</span> <span class="nv">$var$a</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1">;; c// sum_struct_ptr-&gt;b = b;</span>
    <span class="p">(</span><span class="nb">i32.store</span> <span class="k">offset</span><span class="o">=</span><span class="mi">4</span>
      <span class="p">(</span><span class="err">get_</span><span class="k">local</span> <span class="nv">$sum_struct_ptr</span><span class="p">)</span>
      <span class="p">(</span><span class="err">get_</span><span class="k">local</span> <span class="nv">$var$b</span><span class="p">)</span>
    <span class="p">)</span>
  <span class="p">)</span>

  <span class="p">(</span><span class="k">func</span> <span class="nv">$sum_local</span> <span class="p">(</span><span class="k">result</span> <span class="kt">i32</span><span class="p">)</span>
    <span class="p">(</span><span class="k">local</span> <span class="nv">$var$sum_struct$a</span> <span class="kt">i32</span><span class="p">)</span>
    <span class="p">(</span><span class="k">local</span> <span class="nv">$var$sum_struct$b</span> <span class="kt">i32</span><span class="p">)</span>
    <span class="p">(</span><span class="k">local</span> <span class="nv">$local_memstack_ptr</span> <span class="kt">i32</span><span class="p">)</span>

    <span class="c1">;; reserve memstack space</span>
    <span class="p">(</span><span class="nb">i32.sub</span>
      <span class="p">(</span><span class="err">get_</span><span class="k">global</span> <span class="nv">$memstack_ptr</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">i32.const</span> <span class="mi">8</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="err">tee_</span><span class="k">local</span> <span class="nv">$local_memstack_ptr</span> <span class="c1">;; tee both stores and returns given value</span>
    <span class="err">set_</span><span class="k">global</span> <span class="nv">$memstack_ptr</span>

    <span class="c1">;; call the function, storing the result in the memstack</span>
    <span class="p">(</span><span class="nb">call</span> <span class="nv">$sum_struct_create</span>
      <span class="p">(</span><span class="cm">(;$sum_struct_ptr=;)</span> <span class="err">get_</span><span class="k">local</span> <span class="nv">$local_memstack_ptr</span><span class="p">)</span>
      <span class="p">(</span><span class="cm">(;$var$a=;)</span> <span class="nb">i32.const</span> <span class="mi">40</span><span class="p">)</span>
      <span class="p">(</span><span class="cm">(;$var$b=;)</span> <span class="nb">i32.const</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1">;; retrieve values from struct</span>
    <span class="p">(</span><span class="err">set_</span><span class="k">local</span> <span class="nv">$var$sum_struct$a</span>
      <span class="p">(</span><span class="nb">i32.load</span> <span class="k">offset</span><span class="o">=</span><span class="mi">0</span> <span class="p">(</span><span class="err">get_</span><span class="k">local</span> <span class="nv">$local_memstack_ptr</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="p">(</span><span class="err">set_</span><span class="k">local</span> <span class="nv">$var$sum_struct$b</span>
      <span class="p">(</span><span class="nb">i32.load</span> <span class="k">offset</span><span class="o">=</span><span class="mi">4</span> <span class="p">(</span><span class="err">get_</span><span class="k">local</span> <span class="nv">$local_memstack_ptr</span><span class="p">))</span>
    <span class="p">)</span>

    <span class="c1">;; unreserve memstack space</span>
    <span class="p">(</span><span class="err">set_</span><span class="k">global</span> <span class="nv">$memstack_ptr</span>
        <span class="p">(</span><span class="nb">i32.add</span>
          <span class="p">(</span><span class="err">get_</span><span class="k">local</span> <span class="nv">$local_memstack_ptr</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">i32.const</span> <span class="mi">8</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="p">(</span><span class="nb">i32.add</span>
      <span class="p">(</span><span class="err">get_</span><span class="k">local</span> <span class="nv">$var$sum_struct$a</span><span class="p">)</span>
      <span class="p">(</span><span class="err">get_</span><span class="k">local</span> <span class="nv">$var$sum_struct$b</span><span class="p">)</span>
    <span class="p">)</span>
  <span class="p">)</span>
  <span class="p">(</span><span class="k">export</span> <span class="s2">&quot;sum_local&quot;</span> <span class="p">(</span><span class="k">func</span> <span class="nv">$sum_local</span><span class="p">))</span>
<span class="p">)</span>
</pre></div>

        <hr>
        <p>
          Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the GitHub Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/wasm.md">pull request</a> yourself!
        </p>
        <p class="contributed">
          Originally contributed by Dean Shaff, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/wasm.md">5 contributors</a>.
        </p>

        <footer>
          <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width: 0; width: 88px; height: 31px;" src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-sa.svg" /></a>
          <p>
            &copy; 2025
            <a href="http://dean-shaff.github.io">Dean Shaff</a>
          </p>
        </footer>
      </div>
    </div>
  </body>
</html>