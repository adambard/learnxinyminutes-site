<!DOCTYPE html>
<html lang="el">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-WXC8R75DEN');
    </script>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="Content-Language" content="el">
    <title>Learn Scala in Y Minutes</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto+Slab:wght@100..900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/screen.css">
    <link rel="stylesheet" href="/css/light.css">
    <link rel="stylesheet" href="/css/dark.css">

    <link rel="canonical" href="https://learnxinyminutes.com/el/scala/">
    <script>
      localStorage.removeItem("lxiym_theme");
    </script>
  </head>
  <body>
    <div class="container">
      <div class="share">
        <span class="sharemsg">
          <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fel%2Fscala%2F&amp;text=%CE%9C%CE%AC%CE%B8%CE%B5%CF%84%CE%B5+%CE%A7+%CF%83%CE%B5+%CE%A5+%CE%BB%CE%B5%CF%80%CF%84%CE%AC%2C+%CF%8C%CF%80%CE%BF%CF%85+X%3DScala">
            Μοιραστείτε αυτή τη σελίδα
          </a>
        </span>
        <span class='st_facebook_large' displayText='Facebook'></span>
        <span class='st_twitter_large' displayText='Tweet'></span>
      </div>
      <h1><a href="/">Μάθετε Χ σε Υ λεπτά</a></h1>
      <h2>Όπου X=Scala</h2>
      <p class="filelink">
        Αποκτήστε τον κώδικα:
        <a href="/el/files/learnscala.scala">learnscala.scala</a>
      </p>
      <div id="doc">
<p>Scala - Η επεκτάσιμη γλώσσα</p>
<div class="highlight"><pre lang="scala"><span class="cm">/*</span>
<span class="cm">  Προετοιμαστείτε:</span>

<span class="cm">  1) Κατεβάστε την Scala - http://www.scala-lang.org/downloads</span>
<span class="cm">  2) Κάνετε εξαγωγή στην επιθυμητή σας τοποθεσία και βάλτε τον υποφάκελο bin</span>
<span class="cm">      στο path του συστήματος</span>
<span class="cm">  3) Ξεκινήστε ένα scala REPL γράφοντας scala. Θα πρέπει να βλέπετε το prompt:</span>

<span class="cm">  scala&gt;</span>

<span class="cm">  Αυτό είναι το αποκαλούμενο REPL (Read-Eval-Print Loop) *.</span>
<span class="cm">  Μπορείτε να πληκτρολογήσετε οποιαδήποτε έγκυρη έκφραση σε Scala μέσα του ,</span>
<span class="cm">  και το αποτέλεσμα θα τυπωθεί. Θα εξηγήσουμε πως μοιάζουν τα αρχεία της Scala</span>
<span class="cm">  αργότερα μέσα στο tutorial , αλλά για τώρα ας αρχίσουμε με κάποια βασικά.</span>
<span class="cm">  *[Βρόχος του Διάβασε - Αξιολόγησε - Τύπωσε]</span>
<span class="cm">*/</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 1. Βασικές έννοιες</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Τα σχόλια μίας γραμμής ξεκινούν με δύο &quot;/&quot; (:forward slashes) .</span>

<span class="cm">/*</span>
<span class="cm">  Τα σχόλια που επεκτείνονται σε πολλές γραμμές , όπως μπορείτε</span>
<span class="cm">  να δείτε , φαίνονται κάπως έτσι.</span>
<span class="cm">*/</span>

<span class="c1">// Εκτύπωση με νέα γραμμή στην επόμενη εκτύπωση</span>
<span class="n">println</span><span class="p">(</span><span class="s">&quot;Hello world!&quot;</span><span class="p">)</span>
<span class="n">println</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="c1">// Εκτύπωση χωρίς νέα γραμμή στην επόμενη εκτύπωση</span>
<span class="n">print</span><span class="p">(</span><span class="s">&quot;Hello world&quot;</span><span class="p">)</span>

<span class="c1">// Η δήλωση μεταβλητών γίνεται χρησιμοποιώντας var ή val.</span>
<span class="c1">// Οι δηλώσεις val είναι αμετάβλητες, ενώ οι var είναι μεταβλητές.</span>
<span class="c1">// Η αμεταβλητότητα είναι συμφέρουσα και προσπαθούμε να την χρησιμοποιούμε.</span>
<span class="kd">val</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="c1">// το x είναι τώρα 10</span>
<span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="c1">// σφάλμα: αλλαγή σε val</span>
<span class="kd">var</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span>
<span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="w">  </span><span class="c1">// το y είναι τώρα 20</span>

<span class="cm">/*</span>
<span class="cm">  Η Scala είναι στατικού τύπου γλώσσα, εν τούτοις προσέξτε ότι στις παραπάνω</span>
<span class="cm">  δηλώσεις , δεν προσδιορίσαμε κάποιον τύπο. Αυτό συμβαίνει λόγω ενός</span>
<span class="cm">  χαρακτηριστικού της Scala που λέγεται συμπερασματολογία τύπων. Στις </span>
<span class="cm">  περισσότερες των περιπτώσεων, ο μεταγλωττιστής της Scala μπορεί να</span>
<span class="cm">  μαντέψει ποιος είναι ο τύπος μιας μεταβλητής. Μπορούμε να δηλώσουμε</span>
<span class="cm">  αναλυτικά τον τύπο μιας μεταβλητής ως εξής:</span>
<span class="cm">*/</span>
<span class="kd">val</span><span class="w"> </span><span class="n">z</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span>
<span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="nc">Double</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span>

<span class="cm">/*</span>
<span class="cm">  Προσέξτε ότι υπάρχει αυτόματη μετατροπή από ακέραιο (Int) σε διπλής </span>
<span class="cm">  ακρίβειας (Double), και συνεπώς το αποτέλεσμα είναι 10.0 και όχι 10. </span>
<span class="cm">*/</span><span class="w"> </span>
<span class="kd">val</span><span class="w"> </span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="nc">Double</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span>

<span class="c1">// Λογικές τιμές</span>
<span class="kc">true</span>
<span class="kc">false</span>

<span class="c1">// Λογικές Πράξεις</span>
<span class="o">!</span><span class="kc">true</span><span class="w"> </span><span class="c1">// false</span>
<span class="o">!</span><span class="kc">false</span><span class="w"> </span><span class="c1">// true</span>
<span class="kc">true</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="c1">// false</span>
<span class="mi">10</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="c1">// true</span>

<span class="c1">// Η αριθμητική είναι όπως τα συνηθισμένα</span>
<span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// 2</span>
<span class="mi">2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// 1</span>
<span class="mi">5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">// 15</span>
<span class="mi">6</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="c1">// 3</span>
<span class="mi">6</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="c1">// 1</span>
<span class="mf">6.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="c1">// 1.5</span>


<span class="cm">/*</span>
<span class="cm">  Αξιολογώντας μια έκφραση στο REPL, σας δίνεται ο τύπος και </span>
<span class="cm">  η τιμή του αποτελέσματος </span>
<span class="cm">*/</span>

<span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">7</span>

<span class="cm">/* Η παραπάνω γραμμή έχει το εξής αποτέλεσμα:</span>

<span class="cm">  scala&gt; 1 + 7</span>
<span class="cm">  res29: Int = 8</span>

<span class="cm">  Αυτό σημαίνει ότι το αποτέλεσμα της αξιολόγησης του 1 + 7 είναι ένα αντικείμενο</span>
<span class="cm">  τύπου Int με τιμή 8</span>

<span class="cm">  Σημειώστε ότι το &quot;res29&quot; είναι ένα σειριακά δημιουργούμενο όνομα μεταβλητής</span>
<span class="cm">  για να αποθηκεύονται τα αποτελέσματα των εκφράσεων που έχετε πληκτρολογήσει </span>
<span class="cm">  και συνεπώς η έξοδός σας μπορεί να διαφέρει.</span>
<span class="cm">*/</span>

<span class="s">&quot;Τα αλφαριθμητικά στην Scala περικλείονται από διπλά εισαγωγικά&quot;</span>
<span class="sc">&#39;a&#39;</span><span class="w"> </span><span class="c1">// Ένας χαρακτήρας στην Scala</span>
<span class="c1">// res30: Char = a</span>
<span class="c1">// Αλφαριθημτικά με μονά εισαγωγικά δεν υφίστανται &lt;= Αυτό θα προκαλέσει σφάλμα.</span>

<span class="c1">// Τα αλφαριθμητικά έχουν τις συνηθισμένες μεθόδους της Java ορισμένες πάνω τους.</span>
<span class="s">&quot;hello world&quot;</span><span class="p">.</span><span class="n">length</span>
<span class="s">&quot;hello world&quot;</span><span class="p">.</span><span class="n">substring</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span>
<span class="s">&quot;hello world&quot;</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;C&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;3&quot;</span><span class="p">)</span>

<span class="c1">// Έχουν επίσης μερικές επιπλέον μεθόδους Scala. </span>
<span class="c1">// Δείτε επίσης : scala.collection.immutable.StringOps</span>
<span class="s">&quot;hello world&quot;</span><span class="p">.</span><span class="n">take</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="s">&quot;hello world&quot;</span><span class="p">.</span><span class="n">drop</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="c1">// Παρεμβολή αλφαριθμητικών : παρατηρήστε το πρόθεμα &quot;s&quot;</span>
<span class="kd">val</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">45</span>
<span class="s">s&quot;We have </span><span class="si">$</span><span class="n">n</span><span class="s"> apples&quot;</span><span class="w"> </span><span class="c1">// =&gt; &quot;We have 45 apples&quot;</span>

<span class="c1">// Παρατηρήστε την χρήση των &#39;{&#39;, &#39;}&#39;</span>
<span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Array</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span>
<span class="s">s&quot;My second daughter is </span><span class="si">${</span><span class="n">a</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s"> years old.&quot;</span><span class="w"> </span><span class="c1">// =&gt; &quot;My second daughter is 5 years old.&quot;</span>
<span class="s">s&quot;We have double the amount of </span><span class="si">${</span><span class="n">n</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0</span><span class="si">}</span><span class="s"> in apples.&quot;</span><span class="w"> </span><span class="c1">// =&gt; &quot;We have double the amount of 22.5 in apples.&quot;</span>
<span class="s">s&quot;Power of 2: </span><span class="si">${</span><span class="n">math</span><span class="p">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s">&quot;</span><span class="w"> </span><span class="c1">// =&gt; &quot;Power of 2: 4&quot;</span>

<span class="c1">// Μορφοποίηση με παρεμβεβλημένα αλφαριθμητικά με το πρόθεμα &quot;f&quot;</span>
<span class="s">f&quot;Power of 5: </span><span class="si">${</span><span class="n">math</span><span class="p">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s">%1.0f&quot;</span><span class="w"> </span><span class="c1">// &quot;Power of 5: 25&quot;</span>
<span class="s">f&quot;Square root of 122: </span><span class="si">${</span><span class="n">math</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">122</span><span class="p">)</span><span class="si">}</span><span class="s">%1.4f&quot;</span><span class="w"> </span><span class="c1">// &quot;Square root of 122: 11.0454&quot;</span>

<span class="c1">// Raw αλφαριθμητικά, που αγνοούν τους ειδικούς χαρακτήρες.</span>
<span class="s">raw&quot;New line feed: \n. Carriage return: \r.&quot;</span><span class="w"> </span><span class="c1">// =&gt; &quot;New line feed: \n. Carriage return: \r.&quot;</span>

<span class="c1">// Μερικούς χαρακτήρες πρέπει να τους κάνουμε &quot;escape&quot;,</span>
<span class="c1">// λ.χ ένα διπλό εισαγωγικό μέσα σε ένα αλφαριθμητικό :</span>
<span class="s">&quot;They stood outside the \&quot;Rose and Crown\&quot;&quot;</span><span class="w"> </span><span class="c1">// =&gt; &quot;They stood outside the &quot;Rose and Crown&quot;&quot;</span>

<span class="cm">/* </span>
<span class="cm">  Τα τριπλά διπλά-εισαγωγικά επιτρέπουν στα αλφαριθμητικά να εκτείνονται σε</span>
<span class="cm">  πολλαπλές γραμμές και να περιέχουν διπλά εισαγωγικά</span>
<span class="cm">*/</span>
<span class="kd">val</span><span class="w"> </span><span class="n">html</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;&quot;&lt;form id=&quot;daform&quot;&gt;</span>
<span class="s">                &lt;p&gt;Press belo&#39;, Joe&lt;/p&gt;</span>
<span class="s">                &lt;input type=&quot;submit&quot;&gt;</span>
<span class="s">              &lt;/form&gt;&quot;&quot;&quot;</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 2. Συναρτήσεις</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Οι συναρτήσεις ορίζονται ως εξής:</span>
<span class="c1">//</span>
<span class="c1">//   def functionName(args...): ReturnType = { body... }</span>
<span class="c1">//</span>
<span class="c1">// Αν προέρχεστε απο πιο παραδοσιακές γλώσσες (C/C++ , Java) παρατηρήστε</span>
<span class="c1">// την παράλειψη του return. Στην Scala , η τελευταία έκφραση στο μπλόκ</span>
<span class="c1">// της συνάρτησης είναι η τιμή που επιστρέφει η συνάρτηση.</span>
<span class="k">def</span><span class="w"> </span><span class="nf">sumOfSquares</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">):</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span>
<span class="w">  </span><span class="n">x2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y2</span>
<span class="p">}</span>

<span class="c1">// Τα { } μπορούν να παραλειφθούν αν η συνάρτηση αποτελείται απο μια απλή έκφραση:</span>
<span class="k">def</span><span class="w"> </span><span class="nf">sumOfSquaresShort</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">):</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span>

<span class="c1">// Η σύνταξη για την κλήση συναρτήσεων είναι γνώριμη:</span>
<span class="n">sumOfSquares</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">  </span><span class="c1">// =&gt; 25</span>

<span class="c1">// Στις περισσότερες των περιπτώσεων (με τις αναδρομικές συναρτήσεις να αποτελούν</span>
<span class="c1">// την πιο αξιοπρόσεκτη εξαίρεση) , ο τύπος επιστροφής της συνάρτησης μπορεί να</span>
<span class="c1">// παραλειφθεί, και η ίδια συμπερασματολογία τύπων που είδαμε με τις μεταβλητές</span>
<span class="c1">// θα δουλεύει και με τους τύπους επιστροφής της συνάρτησης:</span>
<span class="k">def</span><span class="w"> </span><span class="nf">sq</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w">  </span><span class="c1">// Ο μεταγλωττιστής μπορεί να μαντέψει ότι</span>
<span class="w">                        </span><span class="c1">// ο τύπος επιστροφής της συνάρτησης είναι Int</span>

<span class="c1">// Οι συναρτήσεις μπορούν να έχουν προκαθορισμένες τιμές:</span>
<span class="k">def</span><span class="w"> </span><span class="nf">addWithDefault</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>
<span class="n">addWithDefault</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">  </span><span class="c1">// =&gt; 3</span>
<span class="n">addWithDefault</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">  </span><span class="c1">// =&gt; 6</span>


<span class="c1">// Οι ανώνυμες συναρτήσεις είναι ως εξής:</span>
<span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span>

<span class="c1">// Σε αντίθεση με τα defs , ακόμα και ο τύπος εισόδου απο τις ανώνυμες</span>
<span class="c1">// συναρτήσεις μπορεί να παραληφθεί αν τα συμφραζόμενα το κάνουν ξεκάθαρο.</span>
<span class="c1">// Προσέξτε τον τύπο &quot;Int =&gt; Int&quot; που σημαίνει ότι μια συνάρτηση παίρνει</span>
<span class="c1">// ένα Int και επιστρέφει ένα Int.</span>
<span class="kd">val</span><span class="w"> </span><span class="n">sq</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span>

<span class="c1">// Οι ανώνυμες συναρτήσεις μπορούν να κληθούν όπως συνήθως:</span>
<span class="n">sq</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w">   </span><span class="c1">// =&gt; 100</span>

<span class="c1">// Αν κάθε όρισμα στην ανώνυμη συνάρτηση χρησιμοποιείται μόνο μία φορά,</span>
<span class="c1">// η Scala επιτρέπει έναν ακόμα πιο σύντομο τρόπο να οριστεί. Αυτές</span>
<span class="c1">// οι ανώνυμες συναρτήσεις αποδεικνύεται ότι είναι πολύ κοινές ,</span>
<span class="c1">// όπως θα γίνει προφανές στο μέρος των δομών δεδομένων.</span>
<span class="kd">val</span><span class="w"> </span><span class="n">addOne</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="kd">val</span><span class="w"> </span><span class="n">weirdSum</span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>

<span class="n">addOne</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="w">  </span><span class="c1">// =&gt; 6</span>
<span class="n">weirdSum</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">  </span><span class="c1">// =&gt; 16</span>

<span class="c1">// Η δεσμευμένη λέξη return υπάρχει στην Scala , αλλά επιστρέφει μόνο </span>
<span class="c1">// από το πιο εσωτερικό def που την περικλείει.</span>
<span class="c1">// ΠΡΟΣΟΧΗ: Η χρήση του return στην Scala είναι επιρρεπής σε λάθη</span>
<span class="c1">// και θα πρέπει να αποφεύγεται.</span>
<span class="c1">// Δεν έχει καμία επίδραση στις ανώνυμες συναρτήσεις. Για παράδειγμα: </span>
<span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">):</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">anonFunc</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=&gt;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">z</span><span class="w">  </span><span class="c1">// Αυτή η σειρά κάνει το z την τιμή που επιστρέφει η foo!</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">      </span><span class="n">z</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="c1">// Αυτή η γραμμή είναι η τιμή που επιστρέφει η anonFunc</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">anonFunc</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w">  </span><span class="c1">// Αυτή η γραμμή είναι η τιμή που επιστρέφει η foo</span>
<span class="p">}</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 3. Έλεγχος ροής</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="mi">1</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mi">5</span>
<span class="kd">val</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mi">5</span>
<span class="n">r</span><span class="p">.</span><span class="n">foreach</span><span class="p">(</span><span class="w"> </span><span class="n">println</span><span class="w"> </span><span class="p">)</span>

<span class="n">r</span><span class="w"> </span><span class="n">foreach</span><span class="w"> </span><span class="n">println</span>
<span class="c1">// ΠΡΟΣΟΧΗ: Η Scala είναι σχετικά επιεικής ως αναφορά τις τελείες και </span>
<span class="c1">// τις παρενθέσεις. Διαβάστε τους κανόνες ξεχωριστά. </span>
<span class="c1">// Αυτό βοηθάει στο να γράφεις DSLs και APIs που διαβάζονται σαν τα Αγγλικά.</span>

<span class="p">(</span><span class="mi">5</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">println</span><span class="w"> </span><span class="p">)</span>

<span class="c1">// Ένας βρόχος while :</span>
<span class="kd">var</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="n">println</span><span class="p">(</span><span class="s">&quot;i &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">+=</span><span class="mi">1</span><span class="w">  </span><span class="p">}</span>

<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="n">println</span><span class="p">(</span><span class="s">&quot;i &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">+=</span><span class="mi">1</span><span class="w">  </span><span class="p">}</span><span class="w">   </span><span class="c1">// Ναι ξανά! Τι συνέβη; Γιατί;</span>

<span class="n">i</span><span class="w">    </span><span class="c1">// Εμφάνισε την τιμή του i. Σημειώστε ότι ένας βρόχος while είναι βρόχος</span>
<span class="w">     </span><span class="c1">// με την κλασική έννοια - εκτελείται σειριακά καθώς αλλάζει η μεταβλητή</span>
<span class="w">     </span><span class="c1">// του βρόχου. Το while είναι πολύ γρήγορο , γρηγορότερο απο τους βρόχους</span>
<span class="w">     </span><span class="c1">// της Java , αλλά η χρήση combinators και comprehensions όπως πιο πάνω ,</span>
<span class="w">     </span><span class="c1">// είναι πιο εύκολη στην κατανόηση και στην παραλληλοποίηση.</span>

<span class="c1">// Ένας βρόχος do while :</span>
<span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">println</span><span class="p">(</span><span class="s">&quot;x is still less than 10&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span>
<span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span>

<span class="c1">// Η αναδρομή ουράς είναι ένας ιδιωματικός τρόπος να κάνεις επαναλαμβανόμενα</span>
<span class="c1">// πράγματα στην Scala. Οι αναδρομικές συναρτήσεις απαιτούν να γραφτεί </span>
<span class="c1">// ρητά ο τύπος που θα επιστρέψουν, αλλιώς ο μεταγλωττιστής δεν μπορεί </span>
<span class="c1">// αλλιώς να τον συνάγει. Παρακάτω είναι μια συνάρτηση που επιστρέφει Unit.</span>
<span class="k">def</span><span class="w"> </span><span class="nf">showNumbersInRange</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">:</span><span class="nc">Int</span><span class="p">):</span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="w">    </span><span class="n">showNumbersInRange</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">showNumbersInRange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">14</span><span class="p">)</span>


<span class="c1">// Έλεγχος Ροής</span>

<span class="kd">val</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">println</span><span class="p">(</span><span class="s">&quot;yeah&quot;</span><span class="p">)</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="n">println</span><span class="p">(</span><span class="s">&quot;yeah&quot;</span><span class="p">)</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">11</span><span class="p">)</span><span class="w"> </span><span class="n">println</span><span class="p">(</span><span class="s">&quot;yeah&quot;</span><span class="p">)</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">11</span><span class="p">)</span><span class="w"> </span><span class="n">println</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;yeah&quot;</span><span class="p">)</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="n">println</span><span class="p">(</span><span class="s">&quot;nay&quot;</span><span class="p">)</span>

<span class="n">println</span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="s">&quot;yeah&quot;</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s">&quot;nope&quot;</span><span class="p">)</span>
<span class="kd">val</span><span class="w"> </span><span class="n">text</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="s">&quot;yeah&quot;</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s">&quot;nope&quot;</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 4. Δομές Δεδομένων</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">)</span>
<span class="n">a</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">a</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">a</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span><span class="w">    </span><span class="c1">// &quot;Πετάει&quot; exception</span>

<span class="kd">val</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Map</span><span class="p">(</span><span class="s">&quot;fork&quot;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;tenedor&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;spoon&quot;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;cuchara&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;knife&quot;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;cuchillo&quot;</span><span class="p">)</span>
<span class="n">m</span><span class="p">(</span><span class="s">&quot;fork&quot;</span><span class="p">)</span>
<span class="n">m</span><span class="p">(</span><span class="s">&quot;spoon&quot;</span><span class="p">)</span>
<span class="n">m</span><span class="p">(</span><span class="s">&quot;bottle&quot;</span><span class="p">)</span><span class="w">       </span><span class="c1">// &quot;Πετάει&quot; exception</span>

<span class="kd">val</span><span class="w"> </span><span class="n">safeM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">withDefaultValue</span><span class="p">(</span><span class="s">&quot;no lo se&quot;</span><span class="p">)</span>
<span class="n">safeM</span><span class="p">(</span><span class="s">&quot;bottle&quot;</span><span class="p">)</span>

<span class="kd">val</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Set</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span>
<span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="cm">/* Δείτε το documentation του map εδώ -</span>
<span class="cm"> * http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Map</span>
<span class="cm"> */</span>


<span class="c1">// Πλειάδες</span>

<span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>

<span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>

<span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;three&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;three&quot;</span><span class="p">)</span>

<span class="c1">// Γιατί να το έχουμε αυτό;</span>
<span class="kd">val</span><span class="w"> </span><span class="n">divideInts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>

<span class="n">divideInts</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">// Η συνάρτηση divideInts επιστρέφει το αποτέλεσμα </span>
<span class="w">                 </span><span class="c1">// της ακέραιας διαίρεσης και το υπόλοιπο.</span>

<span class="c1">// Για να έχουμε πρόσβαση στα στοιχεία μιας πλειάδας, χρησιμοποιούμε το _._n</span>
<span class="c1">// όπου το n είναι ο δείκτης με βάση το 1 του στοιχείου.</span>
<span class="kd">val</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">divideInts</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

<span class="n">d</span><span class="p">.</span><span class="n">_1</span>

<span class="n">d</span><span class="p">.</span><span class="n">_2</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 5. Αντικειμενοστραφής Προγραμματισμός</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="cm">/*</span>
<span class="cm">  Ότι έχουμε κάνει ως τώρα σε αυτό το tutorial ήταν απλές εκφράσεις</span>
<span class="cm">  (τιμές, συναρτήσεις, κτλ.). Αυτές οι εκφράσεις βολεύουν όταν τις</span>
<span class="cm">  γράφουμε στο REPL για γρήγορες δοκιμές, αλλά δεν μπορούν να υπάρχουν</span>
<span class="cm">  από μόνες τους σε ένα αρχείο Scala. Για παράδειγμα , δεν μπορούμε να</span>
<span class="cm">  έχουμε μόνο ένα &quot;val x = 5&quot; στο αρχείο Scala. Αντί αυτού , τα μόνα</span>
<span class="cm">  στοιχεία του πάνω επιπέδου που επιτρέπονται στην Scala είναι:</span>

<span class="cm">  - αντικείμενα (objects)</span>
<span class="cm">  - κλάσεις (classes)</span>
<span class="cm">  - κλάσεις περίπτωσης (case classes στην Scala)</span>
<span class="cm">  - Χαρακτηριστικά (traits , όπως ονομάζονται στην Scala)</span>

<span class="cm">  Και τώρα θα εξηγήσουμε τι είναι αυτά.</span>
<span class="cm">*/</span>
<span class="c1">// Οι κλάσεις είναι παρόμοιες με τις κλάσεις σε άλλες γλώσσες. Τα ορίσματα του</span>
<span class="c1">// &quot;κατασκευαστή&quot; (constructor) δηλώνονται μετά από το όνομα της κλάσης , </span>
<span class="c1">// και η αρχικοποιήση γίνεται μέσα στο σώμα της κλάσης.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Dog</span><span class="p">(</span><span class="n">br</span><span class="p">:</span><span class="w"> </span><span class="nc">String</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Κώδικας για τον &quot;κατασκευαστή&quot;</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="n">breed</span><span class="p">:</span><span class="w"> </span><span class="nc">String</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">br</span>

<span class="w">  </span><span class="c1">// Ορίζεται μια μέθοδος bark , που επιστρέφει ένα αλφαριθμητικό</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">bark</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Woof, woof!&quot;</span>

<span class="w">  </span><span class="c1">// Οι τιμές και οι μέθοδοι είναι public εκτός αν χρησιμοποιήσουμε κάποια</span>
<span class="w">  </span><span class="c1">// απο τις λέξεις κλειδιά &quot;protected&quot; και &quot;private&quot; . </span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">sleep</span><span class="p">(</span><span class="n">hours</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">println</span><span class="p">(</span><span class="s">s&quot;I&#39;m sleeping for </span><span class="si">$</span><span class="n">hours</span><span class="s"> hours&quot;</span><span class="p">)</span>

<span class="w">  </span><span class="c1">// Οι abstract μέθοδοι είναι απλά μέθοδοι χωρίς σώμα. Αν βγάζαμε</span>
<span class="w">  </span><span class="c1">// το σχόλιο απο την επόμενη γραμμή η κλάση Dog θα έπρεπε να </span>
<span class="w">  </span><span class="c1">// δηλωθεί ως abstract class Dog(...) { ... } :</span>
<span class="w">  </span><span class="c1">// def chaseAfter(what: String): String</span>
<span class="p">}</span>

<span class="kd">val</span><span class="w"> </span><span class="n">mydog</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Dog</span><span class="p">(</span><span class="s">&quot;greyhound&quot;</span><span class="p">)</span>
<span class="n">println</span><span class="p">(</span><span class="n">mydog</span><span class="p">.</span><span class="n">breed</span><span class="p">)</span><span class="w"> </span><span class="c1">// =&gt; &quot;greyhound&quot;</span>
<span class="n">println</span><span class="p">(</span><span class="n">mydog</span><span class="p">.</span><span class="n">bark</span><span class="p">)</span><span class="w"> </span><span class="c1">// =&gt; &quot;Woof, woof!&quot;</span>


<span class="c1">// Η λέξη &quot;object&quot; δημιουργεί ένα type ΚΑΙ ένα singleton instance αυτού.</span>
<span class="c1">// Είναι κοινό για τις κλάσεις στην Scala να έχουν ένα &quot;συντροφικό object&quot;,</span>
<span class="c1">// όπου η συμπεριφορά για κάθε instance αιχμαλωτίζεται μέσα στις κλάσεις</span>
<span class="c1">// αυτές καθ&#39; αυτές, αλλά η συμπρεριφορά που σχετίζεται με όλα τα instances </span>
<span class="c1">// της κλάσης πάνε μέσα στο object. Η διαφορά είναι παρόμοια με τις</span>
<span class="c1">// μεθόδους κλάσεων σε σχέση με στατικές μεθόδους σε άλλες γλώσσες.</span>
<span class="c1">// Προσέξτε ότι τα objects και οι κλάσεις μπορούν να έχουν το ίδιο όνομα.</span>
<span class="k">object</span><span class="w"> </span><span class="nc">Dog</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">allKnownBreeds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">List</span><span class="p">(</span><span class="s">&quot;pitbull&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;shepherd&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;retriever&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">createDog</span><span class="p">(</span><span class="n">breed</span><span class="p">:</span><span class="w"> </span><span class="nc">String</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Dog</span><span class="p">(</span><span class="n">breed</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Οι κλάσεις περίπτωσης (case classes) είναι που έχουν την επιπλέον </span>
<span class="c1">// λειτουργικότητα ενσωματωμένη. Μιά συνήθης ερώτηση για αρχάριους στην</span>
<span class="c1">// Scala είναι πότε να χρησιμοποιούνται κλάσεις και πότε case κλάσεις.</span>
<span class="c1">// Γενικά οι κλάσεις τείνουν να εστιάζουν στην ενθυλάκωση, τον</span>
<span class="c1">// πολυμορφισμό και τη συμπεριφορά. Οι τιμές μέσα σε αυτές τις κλάσεις </span>
<span class="c1">// τείνουν να είναι private , και μόνο οι μέθοδοι είναι εκτεθειμένες.</span>
<span class="c1">// Ο κύριος σκοπός των case classes είναι να κρατούν δεδομένα που είναι</span>
<span class="c1">// σταθερές(immutable). Συνήθως έχουν λίγες μεθόδους και οι μέθοδοι σπάνια</span>
<span class="c1">// έχουν παρενέργειες.</span>
<span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Person</span><span class="p">(</span><span class="n">name</span><span class="p">:</span><span class="w"> </span><span class="nc">String</span><span class="p">,</span><span class="w"> </span><span class="n">phoneNumber</span><span class="p">:</span><span class="w"> </span><span class="nc">String</span><span class="p">)</span>

<span class="c1">// Δημιουργία ενός instance. Παρατηρήστε ότι τα case classes </span>
<span class="c1">// δεν χρειάζονται την λέξη &quot;new&quot; .</span>
<span class="kd">val</span><span class="w"> </span><span class="n">george</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Person</span><span class="p">(</span><span class="s">&quot;George&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;1234&quot;</span><span class="p">)</span>
<span class="kd">val</span><span class="w"> </span><span class="n">kate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Person</span><span class="p">(</span><span class="s">&quot;Kate&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;4567&quot;</span><span class="p">)</span>

<span class="c1">// Με τα case classes, παίρνεις μερικά προνόμια δωρεάν , όπως:</span>
<span class="n">george</span><span class="p">.</span><span class="n">phoneNumber</span><span class="w">  </span><span class="c1">// =&gt; &quot;1234&quot;</span>

<span class="c1">// Ελέγχεται η ισότητα για κάθε πεδίο (δεν χρειάζεται να</span>
<span class="c1">// κάνουμε override στο .equals)</span>
<span class="nc">Person</span><span class="p">(</span><span class="s">&quot;George&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;1234&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nc">Person</span><span class="p">(</span><span class="s">&quot;Kate&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;1236&quot;</span><span class="p">)</span><span class="w">  </span><span class="c1">// =&gt; false</span>

<span class="c1">// Έυκολος τρόπος να κάνουμε αντιγραφή. Δημιουργούμε έναν νέο geroge:</span>
<span class="c1">// otherGeorge == Person(&quot;george&quot;, &quot;9876&quot;)</span>
<span class="kd">val</span><span class="w"> </span><span class="n">otherGeorge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">george</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">phoneNumber</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;9876&quot;</span><span class="p">)</span>

<span class="c1">// Και πολλά άλλα. Τα case classes έχουν και αντιστοίχιση προτύπων </span>
<span class="c1">// (pattern matching) δωρεάν, δείτε παρακάτω.</span>

<span class="c1">// Τα χαρακτηριστικά (traits) έρχονται σε λίγο καιρό !</span>

<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 6. Αντιστοίχιση Προτύπων </span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Η αντιστοίχιση προτύπων (pattern matching) είναι ένα πολύ δυνατό και</span>
<span class="c1">// ευρέως χρησιμοποιούμενο χαρακτηριστικό στην Scala. Παρακάτω βλέπουμε</span>
<span class="c1">// πως γίνεται το pattern matching σε ένα case class. Σημείωση: Σε </span>
<span class="c1">// αντίθεση με άλλες γλώσσες η Scala δεν χρειάζεται breaks, γιατί γίνεται </span>
<span class="c1">// αυτόματα όταν γίνει κάποιο match.</span>

<span class="k">def</span><span class="w"> </span><span class="nf">matchPerson</span><span class="p">(</span><span class="n">person</span><span class="p">:</span><span class="w"> </span><span class="nc">Person</span><span class="p">):</span><span class="w"> </span><span class="nc">String</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">person</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Μετά προσδιορίζουμε το πρότυπο (pattern):</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="nc">Person</span><span class="p">(</span><span class="s">&quot;George&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">number</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&quot;We found George! His number is &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">number</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="nc">Person</span><span class="p">(</span><span class="s">&quot;Kate&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">number</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&quot;We found Kate! Her number is &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">number</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="nc">Person</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">number</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&quot;We matched someone : &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;, phone : &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">number</span>
<span class="p">}</span>

<span class="kd">val</span><span class="w"> </span><span class="n">email</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;(.*)@(.*)&quot;</span><span class="p">.</span><span class="n">r</span><span class="w">  </span><span class="c1">// Ορίζουμε ένα regex για το επόμενο παράδειγμα.</span>
<span class="w">                           </span><span class="c1">// (regex &lt;- REGular EXpression)  </span>

<span class="c1">// Το pattern matching μπορεί να μοιάζει γνώριμο απο τα switch statements σε</span>
<span class="c1">// γλώσσες που ανήκουν στην οικογένεια της C αλλά είναι πολύ πιο ισχυρό.</span>
<span class="c1">// Στην Scala , μπορούμε να κάνουμε match πολύ περισσότερα:</span>
<span class="k">def</span><span class="w"> </span><span class="nf">matchEverything</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span><span class="w"> </span><span class="nc">Any</span><span class="p">):</span><span class="w"> </span><span class="nc">String</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Μπορούμε να ταιριάξουμε τιμές:</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="s">&quot;Hello world&quot;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&quot;Got the string Hello world&quot;</span>

<span class="w">  </span><span class="c1">// Μπορούμε να ταιριάξουμε τύπους:</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">Double</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&quot;Got a Double: &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span>

<span class="w">  </span><span class="c1">// Μπορούμε να βάλουμε συνθήκες:</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">10000</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&quot;Got a pretty big number!&quot;</span>

<span class="w">  </span><span class="c1">// Μπορούμε να ταιριάξουμε case classes όπως πρίν:</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="nc">Person</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">number</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">s&quot;Got contact info for </span><span class="si">$</span><span class="n">name</span><span class="s">!&quot;</span>

<span class="w">  </span><span class="c1">// Μπορούμε να ταιριάξουμε regex:</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">email</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">domain</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">s&quot;Got email address </span><span class="si">$</span><span class="n">name</span><span class="s">@</span><span class="si">$</span><span class="n">domain</span><span class="s">&quot;</span>

<span class="w">  </span><span class="c1">// Μπορούμε να ταιριάξουμε πλειάδες:</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="nc">Double</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">:</span><span class="w"> </span><span class="nc">String</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">s&quot;Got a tuple: </span><span class="si">$</span><span class="n">a</span><span class="s">, </span><span class="si">$</span><span class="n">b</span><span class="s">, </span><span class="si">$</span><span class="n">c</span><span class="s">&quot;</span>

<span class="w">  </span><span class="c1">// Μπορούμε να ταιριάξουμε δομές δεδομένων:</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="nc">List</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">s&quot;Got a list with three elements and starts with 1: 1, </span><span class="si">$</span><span class="n">b</span><span class="s">, </span><span class="si">$</span><span class="n">c</span><span class="s">&quot;</span>

<span class="w">  </span><span class="c1">// Μπορούμε να ταιριάξουμε πρότυπα που το ένα είναι μέσα στο άλλο:</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="nc">List</span><span class="p">(</span><span class="nc">List</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="s">&quot;YAY&quot;</span><span class="p">)))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&quot;Got a list of list of tuple&quot;</span>
<span class="p">}</span>

<span class="c1">// Στην πραγματικότητα , μπορούμε να κάνουμε pattern matching σε όποιο αντικείμενο</span>
<span class="c1">// έχει την μέθοδο &quot;unapply&quot;. Αυτό το χαρακτηριστικό είναι τόσο ισχυρό ώστε</span>
<span class="c1">// η Scala επιτρέπει να ορίστούν ολόκληρες συναρτήσεις σαν patterns.</span>
<span class="kd">val</span><span class="w"> </span><span class="n">patternFunc</span><span class="p">:</span><span class="w"> </span><span class="nc">Person</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">String</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="nc">Person</span><span class="p">(</span><span class="s">&quot;George&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">number</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">s&quot;George&#39;s number: </span><span class="si">$</span><span class="n">number</span><span class="s">&quot;</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="nc">Person</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">number</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">s&quot;Random person&#39;s number: </span><span class="si">$</span><span class="n">number</span><span class="s">&quot;</span>
<span class="p">}</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 7. Συναρτησιακός Προγραμματισμός</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Η Scala επιτρέπει στις μεθόδους και τις συναρτήσεις να επιστρέφουν ή να</span>
<span class="c1">// δέχονται ως παραμέτρους άλλες μεθόδους ή συναρτήσεις.</span>

<span class="kd">val</span><span class="w"> </span><span class="n">add10</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="c1">// Μια συνάρτηση που δέχεται Int και επιστρέφει Int</span>
<span class="nc">List</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="n">add10</span><span class="w"> </span><span class="c1">// List(11, 12, 13) - το add10 εφαρμόζεται σε κάθε στοιχείο</span>
<span class="w">                        </span><span class="c1">// μέσω του map</span>

<span class="c1">// Οι ανώνυμες συναρτήσεις μπορούν να χρησιμοποιηθούν αντί </span>
<span class="c1">// ονοματισμένων (όπως απο πάνω) :</span>
<span class="nc">List</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span>

<span class="c1">// Και το σύμβολο της κάτω παύλας , μπορεί να χρησιμοποιηθεί αν υπάρχει μόνο</span>
<span class="c1">// ένα όρισμα στην ανώνυμη συνάρτηση. Έτσι δεσμεύεται ως η μεταβλητή.</span>
<span class="nc">List</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span>

<span class="c1">// Αν το μπλοκ της ανώνυμης  συνάρτησης ΚΑΙ η συνάρτηση που εφαρμόζεται</span>
<span class="c1">// (στην περίπτωσή μας το foreach και το println) παίρνουν ένα όρισμα</span>
<span class="c1">// μπορείτε να παραλείψετε την κάτω παύλα.</span>
<span class="nc">List</span><span class="p">(</span><span class="s">&quot;Dom&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Bob&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Natalia&quot;</span><span class="p">)</span><span class="w"> </span><span class="n">foreach</span><span class="w"> </span><span class="n">println</span>


<span class="c1">// Συνδυαστές</span>

<span class="n">s</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">sq</span><span class="p">)</span>

<span class="kd">val</span><span class="w"> </span><span class="n">sSquared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">sq</span><span class="p">)</span>

<span class="n">sSquared</span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span>

<span class="n">sSquared</span><span class="p">.</span><span class="n">reduce</span><span class="w"> </span><span class="p">(</span><span class="n">_+_</span><span class="p">)</span>

<span class="c1">// Η συνάρτηση filter παίρνει ένα κατηγορούμενο (predicate)</span>
<span class="c1">// που είναι μια συνάρτηση απο το A -&gt; Boolean και διαλέγει </span>
<span class="c1">// όλα τα στοιχεία που ικανοποιούν αυτό το κατηγορούμενο.</span>
<span class="nc">List</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">// List(3)</span>
<span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Person</span><span class="p">(</span><span class="n">name</span><span class="p">:</span><span class="nc">String</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="p">:</span><span class="nc">Int</span><span class="p">)</span>
<span class="nc">List</span><span class="p">(</span>
<span class="w">  </span><span class="nc">Person</span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Dom&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">23</span><span class="p">),</span>
<span class="w">  </span><span class="nc">Person</span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Bob&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">)</span>
<span class="p">).</span><span class="n">filter</span><span class="p">(</span><span class="n">_</span><span class="p">.</span><span class="n">age</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">25</span><span class="p">)</span><span class="w"> </span><span class="c1">// List(Person(&quot;Bob&quot;, 30))</span>


<span class="c1">// Το foreach είναι μια μέθοδος της Scala , που ορίζεται για ορισμένες</span>
<span class="c1">// συλλογές (collections). Παίρνει έναν τύπο και επιστρέφει Unit</span>
<span class="c1">// (μια μέθοδο void)</span>
<span class="kd">val</span><span class="w"> </span><span class="n">aListOfNumbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">List</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span>
<span class="n">aListOfNumbers</span><span class="w"> </span><span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="n">aListOfNumbers</span><span class="w"> </span><span class="n">foreach</span><span class="w"> </span><span class="n">println</span>

<span class="c1">// For comprehensions</span>

<span class="k">for</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="n">sq</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<span class="kd">val</span><span class="w"> </span><span class="n">nSquared2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="n">sq</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<span class="k">for</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">nSquared2</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="n">n</span>

<span class="k">for</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"> </span><span class="n">nSquared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">nSquared</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">}</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="n">nSquared</span>

<span class="cm">/*</span>
<span class="cm">  Προσοχή : Αυτά δεν ήταν βρόχοι for. Η σημασιολογία ενός βρόχου for είναι</span>
<span class="cm">  η επανάληψη, ενώ ένα for-comprehension ορίζει μια σχέση μεταξύ δύο</span>
<span class="cm">  συνόλων δεδομένων.</span>
<span class="cm">*/</span>

<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 8. Implicits</span>
<span class="c1">/////////////////////////////////////////////////</span>
<span class="cm">/*</span>
<span class="cm">  ΠΡΟΣΟΧΗ! Τα implicits είναι ένα σύνολο απο ισχυρά χαρακτηριστικά της Scala</span>
<span class="cm">  και επομένως είναι εύκολο να γίνει κατάχρηση. Οι αρχάριοι στην Scala θα </span>
<span class="cm">  πρέπει να αντισταθούν στον πειρασμό να τα χρησιμοποιήσουν έως ότου, όχι </span>
<span class="cm">  μόνο καταλάβουν πως λειτουργούν, αλλά ακόμα εξασκηθούν πάνω τους.</span>
<span class="cm">  Ο μόνος λόγος που συμπεριλάβαμε αυτό το κομμάτι στο tutorial είναι</span>
<span class="cm">  γιατί είναι τόσο κοινό στις βιβλιοθήκες της Scala , που αδύνατο να κάνεις </span>
<span class="cm">  οτιδήποτε σημαντικό χωρίς να χρησιμοποιήσεις μια που να έχει implicits.</span>

<span class="cm">*/</span>

<span class="c1">// Κάθε τιμή (vals , συναρτήσεις , αντικείμενα , κτλ) μπορεί να δηλωθεί ως</span>
<span class="c1">// implicit χρησιμοποιώντας , ναι το μαντέψατε , την λέξη &quot;implicit&quot;.</span>
<span class="c1">// Σημειώστε ότι χρησιμοποιούμε την κλάση Dog που δημιουργήσαμε στο</span>
<span class="c1">// 5ο μέρος των παραδειγμάτων.</span>
<span class="k">implicit</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="n">myImplicitInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span>
<span class="k">implicit</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">myImplicitFunction</span><span class="p">(</span><span class="n">breed</span><span class="p">:</span><span class="w"> </span><span class="nc">String</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Dog</span><span class="p">(</span><span class="s">&quot;Golden &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">breed</span><span class="p">)</span>


<span class="c1">// Απο μόνη της, η λέξη implicit, δεν αλλάζει την συμπεριφορά μιάς τιμής</span>
<span class="c1">// οπότε οι παραπάνω μπορούν να χρησιμοποιοηθούν όπως συνήθως.</span>
<span class="n">myImplicitInt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="c1">// =&gt; 102</span>
<span class="n">myImplicitFunction</span><span class="p">(</span><span class="s">&quot;Pitbull&quot;</span><span class="p">).</span><span class="n">breed</span><span class="w">  </span><span class="c1">// =&gt; &quot;Golden Pitbull&quot;</span>

<span class="c1">// Η διαφορά είναι ότι τώρα αυτές οι τιμές έχουν την δυνατότητα να </span>
<span class="c1">// χρησιμοποιηθούν όταν ένα άλλο κομμάτι κώδικα &quot;χρειάζεται&quot; μια </span>
<span class="c1">// implicit τιμή. Μια τέτοια περίπτωση είναι τα ορίσματα μιας implicit </span>
<span class="c1">// συνάρτησης:</span>
<span class="k">def</span><span class="w"> </span><span class="nf">sendGreetings</span><span class="p">(</span><span class="n">toWhom</span><span class="p">:</span><span class="w"> </span><span class="nc">String</span><span class="p">)(</span><span class="k">implicit</span><span class="w"> </span><span class="n">howMany</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="s">s&quot;Hello </span><span class="si">$</span><span class="n">toWhom</span><span class="s">, </span><span class="si">$</span><span class="n">howMany</span><span class="s"> blessings to you and yours!&quot;</span>

<span class="c1">// Άν τροφοδοτήσουμε μια τιμή για το &quot;homMany&quot;, η συνάρτηση συμπεριφέρεται</span>
<span class="c1">// ως συνήθως </span>
<span class="n">sendGreetings</span><span class="p">(</span><span class="s">&quot;John&quot;</span><span class="p">)(</span><span class="mi">1000</span><span class="p">)</span><span class="w">  </span><span class="c1">// =&gt; &quot;Hello John, 1000 blessings to you and yours!&quot;</span>

<span class="c1">// Αλλά αν παραλείψουμε την παράμετρο implicit , μια implicit τιμή του ιδίου τύπου</span>
<span class="c1">// χρησιμοποιείται, στην περίπτωσή μας, το &quot;myImplicitInt&quot;</span>
<span class="n">sendGreetings</span><span class="p">(</span><span class="s">&quot;Jane&quot;</span><span class="p">)</span><span class="w">  </span><span class="c1">// =&gt; &quot;Hello Jane, 100 blessings to you and yours!&quot;</span>

<span class="c1">// Οι παράμετροι implicit συναρτήσεων μας επιτρέπουν να προσομοιάζουμε</span>
<span class="c1">// κλάσεις τύπων (type classes) σε άλλες συναρτησιακές γλώσσες.</span>
<span class="c1">// Χρησιμοποιείται τόσο συχνά που έχει την δικιά του συντομογραφία.</span>
<span class="c1">// Οι επόμενες δύο γραμμές κώδικα σημαίνουν το ίδιο πράγμα.</span>
<span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">[</span><span class="nc">T</span><span class="p">](</span><span class="k">implicit</span><span class="w"> </span><span class="n">c</span><span class="p">:</span><span class="w"> </span><span class="nc">C</span><span class="p">[</span><span class="nc">T</span><span class="p">])</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span>
<span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">[</span><span class="nc">T</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">C</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span>



<span class="c1">// Μια άλλη περίπτωση στην οποία ο μεταγλωττιστής αναζητά μια implicit τιμή </span>
<span class="c1">// είναι αν έχετε obj.method (...)</span>
<span class="c1">// αλλά το &quot;obj&quot; δεν έχει την &quot;method&quot; ως μέθοδο. Σε αυτή την περίπτωση, </span>
<span class="c1">// αν υπάρχει μια implicit μετατροπή του τύπου Α =&gt; Β, όπου Α είναι ο τύπος </span>
<span class="c1">// του obj, ενώ το Β έχει μία μέθοδο που ονομάζεται «method», εφαρμόζεται η </span>
<span class="c1">// εν λόγω μετατροπή. Έτσι, έχοντας την MyImplicitFunction μέσα στο πεδίο </span>
<span class="c1">// εφαρμογής(scope), μπορούμε να πούμε:</span>
<span class="s">&quot;Retriever&quot;</span><span class="p">.</span><span class="n">breed</span><span class="w">  </span><span class="c1">// =&gt; &quot;Golden Retriever&quot;</span>
<span class="s">&quot;Sheperd&quot;</span><span class="p">.</span><span class="n">bark</span><span class="w">  </span><span class="c1">// =&gt; &quot;Woof, woof!&quot;</span>

<span class="c1">// Εδώ το String αρχικά μετατρέπεται σε Dog χρησιμοποιώντας την συνάρτησή μας</span>
<span class="c1">// παραπάνω, και μετά καλείται η κατάλληλη μέθοδος. Αυτό είναι ένα εξερετικά</span>
<span class="c1">// ισχυρό χαρακτηριστικό, αλλά δεν πρέπει να χρησιμοποιείται με ελαφριά την </span>
<span class="c1">// καρδιά. Μάλιστα, όταν ορίσατε την συνάρτηση implicit παραπάνω, ο μεταγλωττιστής</span>
<span class="c1">// θα πρέπει να σας έδωσε μια προειδοποιήση, ότι δεν πρέπει να το κάνετε αυτό </span>
<span class="c1">// εκτός αν πραγματικά γνωρίζετε τι κάνετε.</span>


<span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// 9. Διάφορα</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Εισαγωγή βιβλιοθηκών κτλ</span>
<span class="k">import</span><span class="w"> </span><span class="nn">scala</span><span class="p">.</span><span class="nn">collection</span><span class="p">.</span><span class="nn">immutable</span><span class="p">.</span><span class="nc">List</span>

<span class="c1">// Εισαγωγή των πάντων απο το scala.collection.immutable</span>
<span class="k">import</span><span class="w"> </span><span class="nn">scala</span><span class="p">.</span><span class="nn">collection</span><span class="p">.</span><span class="nn">immutable</span><span class="p">.</span><span class="n">_</span>

<span class="c1">// Εισαγωγή πολλών κλάσεων σε μία έκφραση</span>
<span class="k">import</span><span class="w"> </span><span class="nn">scala</span><span class="p">.</span><span class="nn">collection</span><span class="p">.</span><span class="nn">immutable</span><span class="p">.{</span><span class="nc">List</span><span class="p">,</span><span class="w"> </span><span class="nc">Map</span><span class="p">}</span>

<span class="c1">// Δώστε ένα νέο όνομα στην εισαγωγή σας χρησιμοποιώντας το &#39;=&gt;&#39;</span>
<span class="k">import</span><span class="w"> </span><span class="nn">scala</span><span class="p">.</span><span class="nn">collection</span><span class="p">.</span><span class="nn">immutable</span><span class="p">.{</span><span class="w"> </span><span class="nc">List</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">ImmutableList</span><span class="w"> </span><span class="p">}</span>

<span class="c1">// Εισαγωγή όλων των κλάσεων εκτός απο μερικές.</span>
<span class="c1">// Το επόμενο δεν εισάγει το Map και το Set:</span>
<span class="k">import</span><span class="w"> </span><span class="nn">scala</span><span class="p">.</span><span class="nn">collection</span><span class="p">.</span><span class="nn">immutable</span><span class="p">.{</span><span class="nc">Map</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="nc">Set</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">}</span>

<span class="c1">// Το σημείο εισαγωγής του προγράμματος σας ορίζεται σε ένα αρχείο scala ,</span>
<span class="c1">// χρησιμοποιώντας ένα αντικείμενο (object), με μία μέθοδο , την main.</span>
<span class="k">object</span><span class="w"> </span><span class="nc">Application</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">]):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Εδω γράφουμε ...</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Files can contain multiple classes and objects. Compile with scalac</span>
<span class="c1">// Τα files μπορούν να περιέχουν περισσότερες απο μία κλάσεις και </span>
<span class="c1">// αντικείμενα. Το compile γίνεται με την εντολή scalac</span>

<span class="c1">// Εισαγωγή και εξαγωγή.</span>

<span class="c1">// Για να διβάσετε ένα αρχείο γραμμή προς γραμμή</span>
<span class="k">import</span><span class="w"> </span><span class="nn">scala</span><span class="p">.</span><span class="nn">io</span><span class="p">.</span><span class="nc">Source</span>
<span class="k">for</span><span class="p">(</span><span class="n">line</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nc">Source</span><span class="p">.</span><span class="n">fromFile</span><span class="p">(</span><span class="s">&quot;myfile.txt&quot;</span><span class="p">).</span><span class="n">getLines</span><span class="p">())</span>
<span class="w">  </span><span class="n">println</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

<span class="c1">// Για να γράψετε σε ένα αρχείο </span>
<span class="kd">val</span><span class="w"> </span><span class="n">writer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">PrintWriter</span><span class="p">(</span><span class="s">&quot;myfile.txt&quot;</span><span class="p">)</span>
<span class="n">writer</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Writing line for line&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">util</span><span class="p">.</span><span class="nc">Properties</span><span class="p">.</span><span class="n">lineSeparator</span><span class="p">)</span>
<span class="n">writer</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Another line here&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">util</span><span class="p">.</span><span class="nc">Properties</span><span class="p">.</span><span class="n">lineSeparator</span><span class="p">)</span>
<span class="n">writer</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
<h2>Further resources</h2>
<p><a href="http://horstmann.com/scala/">Scala for the impatient</a></p>
<p><a href="http://twitter.github.io/scala_school/">Twitter Scala school</a></p>
<p><a href="http://docs.scala-lang.org/">The scala documentation</a></p>
<p><a href="http://scalatutorials.com/tour/">Try Scala in your browser</a></p>
<p>Join the <a href="https://groups.google.com/forum/#!forum/scala-user">Scala user group</a></p>

        <hr>
        <p>
          Έχετε κάποια πρόταση; Κάποια διόρθωση, ίσως; <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Δημιουργήστε ένα Issue</a> στο GitHub Repo μας, ή ανοίξτε ένα <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/el/scala.md">pull request</a>!
        </p>
        <p class="contributed">
          Αρχική συμβολή: George Petrov, ενημερώσεις/επεξεργασία: <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/el/scala.md">2 contributor(s)</a>.
        </p>

        <footer>
          <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width: 0; width: 88px; height: 31px;" src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-sa.svg" /></a>
          <p>
            &copy; 2025
            <a href="http://github.com/petrovg">George Petrov</a>,
            <a href="http://dbousamra.github.com">Dominic Bou-Samra</a>,
            <a href="http://geoffliu.me">Geoff Liu</a>
          </p>
        </footer>
      </div>
    </div>
  </body>
</html>