<!DOCTYPE html>
<html lang="el">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-WXC8R75DEN');
    </script>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="Content-Language" content="el">
    <title>Learn Haskell in Y Minutes</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto+Slab:wght@100..900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/screen.css">
    <link rel="stylesheet" href="/css/light.css">
    <link rel="stylesheet" href="/css/dark.css">

    <link rel="canonical" href="https://learnxinyminutes.com/el/haskell/">
    <script>
      localStorage.removeItem("lxiym_theme");
    </script>
  </head>
  <body>
    <div class="container">
      <div class="share">
        <span class="sharemsg">
          <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fel%2Fhaskell%2F&amp;text=%CE%9C%CE%AC%CE%B8%CE%B5%CF%84%CE%B5+%CE%A7+%CF%83%CE%B5+%CE%A5+%CE%BB%CE%B5%CF%80%CF%84%CE%AC%2C+%CF%8C%CF%80%CE%BF%CF%85+X%3DHaskell">
            Μοιραστείτε αυτή τη σελίδα
          </a>
        </span>
        <span class='st_facebook_large' displayText='Facebook'></span>
        <span class='st_twitter_large' displayText='Tweet'></span>
      </div>
      <h1><a href="/">Μάθετε Χ σε Υ λεπτά</a></h1>
      <h2>Όπου X=Haskell</h2>
      <p class="filelink">
        Αποκτήστε τον κώδικα:
        <a href="/el/files/learnhaskell.hs">learnhaskell.hs</a>
      </p>
      <div id="doc">
<p>Η Haskell σχεδιάστηκε για να είναι μια πρακτική, αγνή συναρτησιακή γλώσσα προγραμματισμού.
Είναι διάσημη για τα monads και το σύστημα τύπων της, αλλά χρησιμοποιείται από πολλούς
κυρίως για την κομψότητά της. Προσωπικά θεωρώ ότι είναι από τις πιο όμορφες, αν όχι
η πιο όμορφη, γλώσσα προγραμματισμού.</p>
<div class="highlight"><pre lang="haskell"><span class="c1">-- Τα σχόλια μιας γραμμής ξεκινούν με 2 παύλες.</span>
<span class="cm">{- Ενώ τα σχόλια πολλών γραμμών βρίσκονται</span>
<span class="cm">μέσα σε blocks σαν αυτό</span>
<span class="cm">-}</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 1. Πρωτόγονοι Τύποι Δεδομένων (Primitive datatype) και Τελεστές</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Οι αριθμοί είναι ένα primitive datatype</span>
<span class="mi">3</span><span class="w"> </span><span class="c1">-- 3</span>

<span class="c1">-- Και οι τελεστές κάνουν αυτό που θα περιμέναμε</span>
<span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">-- 2</span>
<span class="mi">8</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">-- 7</span>
<span class="mi">10</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="c1">-- 20</span>
<span class="mi">35</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="c1">-- 7.0</span>

<span class="c1">-- Η καθιερωμένη διαίρεση δεν είναι ακέραια</span>
<span class="mi">35</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="c1">-- 8.75</span>

<span class="c1">-- Η ακέραια διαίρεση γίνεται με την συνάρτηση div</span>
<span class="mi">35</span><span class="w"> </span><span class="p">`</span><span class="n">div</span><span class="p">`</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="c1">-- 8</span>

<span class="c1">-- Και οι boolean μεταβλητές ειναι primitives</span>
<span class="kt">True</span>
<span class="kt">False</span>

<span class="c1">-- Πράξεις με booleans</span>
<span class="nf">not</span><span class="w"> </span><span class="kt">True</span><span class="w"> </span><span class="c1">-- False</span>
<span class="nf">not</span><span class="w"> </span><span class="kt">False</span><span class="w"> </span><span class="c1">-- True</span>
<span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">-- True</span>
<span class="mi">1</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">-- False</span>
<span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="c1">-- True</span>

<span class="c1">-- Στα παραπάνω παραδείγματα, το `not` είναι μια συνάρτηση που παίρνει ένα όρισμα</span>
<span class="c1">-- Στην Haskell δεν χρειάζονται παρενθέσεις για τις κλήσεις συναρτήσεων, όλες οι παράμετροι</span>
<span class="c1">-- γράφονται με κενά αμέσως μετά την συνάρτηση. Στην γενική περίπτωση,</span>
<span class="c1">-- η κλήση συνάρτησης μοιάζει κάπως έτσι: func arg1 arg2 arg3...</span>
<span class="c1">-- Για το πως να ορίσετε τις δικές σας συναρτήσεις διαβάστε το κεφάλαιο των συναρτήσεων παρακάτω</span>

<span class="c1">-- Συμβολοσειρές και χαρακτήρες</span>
<span class="s">&quot;This is a string.&quot;</span><span class="w"> </span><span class="c1">-- συμβολοσειρά</span>
<span class="sc">&#39;a&#39;</span><span class="w"> </span><span class="c1">-- χαρακτήρας</span>
<span class="kt">&#39;You</span><span class="w"> </span><span class="n">cant</span><span class="w"> </span><span class="n">use</span><span class="w"> </span><span class="n">single</span><span class="w"> </span><span class="n">quotes</span><span class="w"> </span><span class="n">for</span><span class="w"> </span><span class="n">strings</span><span class="o">.</span><span class="sc">&#39;</span><span class="err"> -- error!</span>
<span class="c1">-- δεν μπορούμε να γράψουμε συμβολοσειρές ανάμεσα από &#39;&#39;</span>

<span class="c1">-- Οι συμβολοσειρές μπορούν να συννενωθούν με την χρήση του τελεστή ++</span>
<span class="s">&quot;Hello &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s">&quot;world!&quot;</span><span class="w"> </span><span class="c1">-- &quot;Hello world!&quot;</span>

<span class="c1">-- Η συμβολοσειρά είναι ουσιαστικά μια λίστα χαρακτήρων</span>
<span class="p">[</span><span class="sc">&#39;H&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;e&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;l&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;l&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;o&#39;</span><span class="p">]</span><span class="w"> </span><span class="c1">-- &quot;Hello&quot;</span>
<span class="s">&quot;This is a string&quot;</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="c1">-- &#39;T&#39;</span>


<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 2. Λίστες και διατεταγμένα σύνολα (tuples)</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Όλα τα στοιχεία μιας λίστας πρέπει να είναι του ίδιου τύπου</span>
<span class="c1">-- Οι δύο παρακάτω λίστες είναι οι ίδιες:</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- διάστημα ή range</span>

<span class="c1">-- Τα διαστήματα μπορούν να χρησιμοποιηθούν και για άλλους τύπους εκτός από αριθμούς</span>
<span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;F&#39;</span><span class="p">]</span><span class="w"> </span><span class="c1">-- &quot;ABCDEF&quot;</span>

<span class="c1">-- Μπορούμε ακόμη να ορίσουμε και ένα βήμα</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [0, 2, 4, 6, 8, 10]</span>
<span class="p">[</span><span class="mi">5</span><span class="o">..</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [] (Το default βήμα της Haskell είναι το 1, επομένως η διπλανή λίστα είναι κενή)</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="o">..</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [5, 4, 3, 2, 1]</span>

<span class="c1">-- Προσπέλαση στοιχείου σε τυχαία θέση</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">-- 4 (οι δείκτες των θέσεων ξεκινούν από το 0)</span>

<span class="c1">-- Στην Haskell υπάρχουν και άπειρες λίστες!</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span><span class="w"> </span><span class="c1">-- η λίστα των φυσικών αριθμών</span>

<span class="c1">-- Οι άπειρες λίστες μπορούν να λειτουργούν επειδή η Haksell έχει &quot;lazy evaluation&quot;.</span>
<span class="c1">-- Αυτό σημαίνει ότι η Haskell κάνει υπολογισμούς μόνο όταν πραγματικά χρειάζεται!</span>
<span class="c1">-- οπότε αν ζητήσουμε το 1000στό στοιχείο μιας άπειρης λίστας θα μας το δώσει,</span>
<span class="c1">-- ξέρει ότι δεν χρειάζεται να υπολογίσει όλη την άπειρη λίστα πρώτα!</span>

<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="mi">999</span><span class="w"> </span><span class="c1">-- 1000</span>

<span class="c1">-- Στο παραπάνω παράδειγμα η Haskell υπολόγισε τα στοιχεία 1 μέχρι 1000...τα υπόλοιπα</span>
<span class="c1">-- στοιχεία της άπειρης λίστας δεν υπάρχουν ακόμα! Η Haskell θα τα υπολογίσει</span>
<span class="c1">-- μόνο αν κάποια στιγμή τα χρειαστεί.</span>

<span class="c1">-- συνένωση δύο λιστών με τον τελεστή ++ (σε γραμμικό χρόνο)</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="mi">6</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>

<span class="c1">-- προσθήκη στοιχείου στην αρχή της λίστας (σε σταθερό χρόνο)</span>
<span class="mi">0</span><span class="kt">:</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [0, 1, 2, 3, 4, 5]</span>

<span class="c1">-- περισσότερες συναρτήσεις για τις λίστες</span>
<span class="nf">head</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- 1</span>
<span class="nf">tail</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [2, 3, 4, 5]</span>
<span class="nf">init</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [1, 2, 3, 4]</span>
<span class="nf">last</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- 5</span>

<span class="c1">-- list comprehensions</span>
<span class="c1">-- ένας άλλος τρόπος να ορίζουμε τις λίστες που θυμίζει πολύ τον ορισμό συνόλων στα μαθηματικά!</span>
<span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]]</span><span class="w"> </span><span class="c1">-- [2, 4, 6, 8, 10]</span>

<span class="c1">-- list comprehension με συνθήκη</span>
<span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [6, 8, 10]</span>

<span class="c1">-- Κάθε στοιχείο ενός tuple μπορεί να έχει διαφορετικό τύπο, όμως το tuple έχει σταθερό μέγεθος.</span>
<span class="c1">-- Ένα tuple:</span>
<span class="p">(</span><span class="s">&quot;haskell&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="c1">-- προσπέλαση στοιχείων ενός ζεύγους στοιχείων (δηλαδή ενός tuple μεγέθους 2)</span>
<span class="nf">fst</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;haskell&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">-- &quot;haskell&quot;</span>
<span class="nf">snd</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;haskell&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">-- 1</span>

<span class="c1">-- οι παραπάνω συναρτήσεις δεν λειτουργούν σε tuples μεγαλύτερου μεγέθους</span>
<span class="nf">snd</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;snd&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;can&#39;t touch this&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;da na na na&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">-- error!</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 3. Συναρτήσεις</span>
<span class="c1">----------------------------------------------------</span>
<span class="c1">-- Μια απλή συνάρτηση που παίρνει 2 μεταβλητές a, b και επιστρέφει το άθροισμά τους</span>
<span class="nf">add</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span>

<span class="c1">-- Προσέξτε ότι αν χρησιμοποιείτε το διαδραστικό περιβάλλον της Haskell (ghci), δηλαδή</span>
<span class="c1">-- τον interpreter, θα πρέπει να προσθέσετε ενα `let` πριν τον ορισμό της συνάρτησης:</span>
<span class="c1">-- let add a b = a + b</span>

<span class="c1">-- Κλήση της συνάρτησης</span>
<span class="nf">add</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="c1">-- 3</span>

<span class="c1">-- Μπορούμε να καλέσουμε την συνάρτηση και σαν τελεστή ανάμεσα στα 2 ορίσματα</span>
<span class="c1">-- γράφοντας το όνομα της συνάρτησης μέσα σε backticks:</span>
<span class="mi">1</span><span class="w"> </span><span class="p">`</span><span class="n">add</span><span class="p">`</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="c1">-- 3</span>

<span class="c1">-- Μπορούμε να ορίσουμε και συναρτήσεις που δεν έχουν γράμματα στο όνομά τους!</span>
<span class="c1">-- Αυτό μας επιτρέπει να ορίσουμε δικούς μας τελεστές, όπως για παράδειγμα την ακέραια διάιρεση:</span>

<span class="p">(</span><span class="o">//</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">`</span><span class="n">div</span><span class="p">`</span><span class="w"> </span><span class="n">b</span>
<span class="mi">35</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="c1">-- 8</span>

<span class="c1">-- Guards: ένας εύκολος τρόπος να υλοποιήσουμε διακλαδώσεις σε μια συνάρτηση</span>
<span class="nf">fib</span><span class="w"> </span><span class="n">x</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>

<span class="c1">-- Το ταίριασμα προτύπων (Pattern matching) είναι παρόμοιο.</span>
<span class="c1">-- Εδώ δίνουμε 3 διαφορετικούς ορισμούς για την συνάρτηση fib</span>
<span class="c1">-- H Haskell θα χρησιμοποιήσει αυτόματα τον πρώτο ορισμό το οποίου οι παράμετροι</span>
<span class="c1">-- ταιριάζουν με τις παραμέτρους της κλήσης</span>

<span class="nf">fib</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>
<span class="nf">fib</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span>
<span class="nf">fib</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>

<span class="c1">-- Pattern matching σε tuples</span>
<span class="nf">sndOfTriple</span><span class="w"> </span><span class="p">(</span><span class="kr">_</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">y</span>
<span class="c1">-- η κάτω παύλα χρησιμοποιείται για να μην δίνουμε ονόματα</span>
<span class="c1">-- σε μεταβλητές που δεν θα χρησιμοποιήσουμε και</span>
<span class="c1">-- ταιριάζει με όλους τους τύπους</span>

<span class="c1">-- Pattern matching σε λίστες.</span>
<span class="c1">-- Στο παρακάτω παράδειγμα, το `x` είναι το πρώτο στοιχείο της λίστας</span>
<span class="c1">-- και τo `xs` είναι η λίστα με τα υπόλοιπα στοιχεία</span>

<span class="nf">myMap</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span>
<span class="nf">myMap</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">(</span><span class="n">myMap</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span>

<span class="c1">-- Μπορούμε να ορίσουμε και ανώνυμες συναρτήσεις (lambdas) χρησιμοποιώντας το</span>
<span class="c1">-- backslash (που μοιάζει με λ) ακολουθούμενο από τις παραμέτρους:</span>
<span class="nf">myMap</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [3, 4, 5, 6, 7]</span>

<span class="c1">-- χρήση της συνάρτησης fold με μία ανώνυμη συνάρτηση</span>
<span class="c1">-- Το foldl1 είναι σαν fold από αριστερά, αλλά χρησιμοποιεί σαν αρχική τιμή του</span>
<span class="c1">-- accumulator το πρώτο στοιχείο της λίστας.</span>
<span class="nf">foldl1</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">acc</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- 15</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 4. Περισσότερες συναρτήσεις</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Μερική κλήση: αν δεν περάσουμε όλες τις μεταβλητές σε μια συνάρτηση,</span>
<span class="c1">-- τότε αυτή &quot;καλείται μερικώς&quot;. Αυτό σημαίνει ότι μας επιστρέφει μια συνάρτηση</span>
<span class="c1">-- η οποία παίρνει ως ορίσματα τις εναπομείνασες μεταβλητές</span>

<span class="nf">add</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="c1">-- η foo είναι μια συνάρτηση που περιμένει 1 αριθμό και του προσθέτει 10</span>
<span class="nf">foo</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="c1">-- 15</span>

<span class="c1">-- Ένας άλλος τρόπος να γράψουμε το ίδιο πράγμα:</span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="mi">10</span><span class="o">+</span><span class="p">)</span>
<span class="nf">foo</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="c1">-- 15</span>

<span class="c1">-- Σύνθεση συναρτήσεων</span>
<span class="c1">-- Ο τελεστής `.` χρησιμοποιείται για την σύνθεση (&quot;αλυσίδωση&quot;) συναρτήσεων.</span>
<span class="c1">-- Για παράδειγμα, η foo παρακάτω είναι μια συνάρτηση που παίρνει ως όρισμα 1 αριθμό.</span>
<span class="c1">-- Πρώτα προσθέτει 10 στον αριθμό που δώσαμε και μετά πολλαπλασιάζει το αποτέλεσμα με 4</span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="mi">10</span><span class="o">+</span><span class="p">)</span>

<span class="c1">-- 4*(10+5) = 60</span>
<span class="nf">foo</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="c1">-- 60</span>

<span class="c1">-- διόρθωση προτεραιότητας</span>
<span class="c1">-- Στην Haskell υπάρχει ο τελεστής `$`. Ο τελεστής αυτός εφαρμόζει μια συνάρτηση</span>
<span class="c1">-- σε μία παράμετρο. Σε αντίθεση με την απλή εφαρμογή συνάρτησης, η οποία έχει</span>
<span class="c1">-- την μεγαλύτερη πιθανή προτεραιότητα και είναι αριστερά προσεταιριστική,</span>
<span class="c1">-- ο τελεστής `$` έχει την ελάχιστη προτεραιότητας και είναι δεξιά προσεταιριστικός.</span>
<span class="c1">-- Λόγω της χαμηλής του προτεραιότητας, η έκφραση που βρίσκεται στα δεξιά του</span>
<span class="c1">-- θα υπολογιστεί και θα περαστεί σαν παράμετρος στην συνάρτηση που βρίσκεται στα αριστερά του</span>


<span class="c1">-- πριν</span>
<span class="nf">even</span><span class="w"> </span><span class="p">(</span><span class="n">fib</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="c1">-- false</span>

<span class="c1">-- ισοδύναμα</span>
<span class="nf">even</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="c1">-- false</span>

<span class="c1">-- χρησιμοποιόντας σύνθεση συναρτήσεων</span>
<span class="nf">even</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="c1">-- false</span>


<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 5. Τύποι</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Η Haskell έχει ένα πολύ ισχυρό σύστημα τύπων, στο οποίο κάθε έκφραση έχει έναν τύπο</span>

<span class="c1">-- Κάποιο βασικοί τύποι:</span>
<span class="mi">5</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span>
<span class="s">&quot;hello&quot;</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">String</span>
<span class="kt">True</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Bool</span>

<span class="c1">-- Και οι συναρτήσεις έχουν κάποιο τύπο</span>
<span class="c1">-- Η συνάρτηση`not` παίρνει ένα boolean και επιστρέφει ένα boolean:</span>
<span class="c1">-- not :: Bool -&gt; Bool</span>

<span class="c1">-- Παρακάτω βλέπετε μια συνάρτηση που παίρνει 2 ορίσματα:</span>
<span class="c1">-- add :: Integer -&gt; Integer -&gt; Integer</span>

<span class="c1">-- Όταν ορίζουμε μια συνάρτηση ή μεταβλητή, είναι καλή πρακτική να γράφουμε</span>
<span class="c1">-- και τον τύπο της:</span>
<span class="nf">double</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span>
<span class="nf">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 6. Έλεγχος ροής και συνθήκες</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- if-expressions</span>
<span class="nf">haskell</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="s">&quot;awesome&quot;</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="s">&quot;awful&quot;</span><span class="w"> </span><span class="c1">-- haskell = &quot;awesome&quot;</span>

<span class="c1">-- τα if-expressions μπορούν να πιάνουν και πολλές γραμμές</span>
<span class="c1">-- αλλά η στοίχιση είναι σημαντική!</span>
<span class="nf">haskell</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span>
<span class="w">            </span><span class="kr">then</span><span class="w"> </span><span class="s">&quot;awesome&quot;</span>
<span class="w">            </span><span class="kr">else</span><span class="w"> </span><span class="s">&quot;awful&quot;</span>

<span class="c1">-- case expressions: Με τον παρακάτω τρόπο θα μπορούσαμε να κάνουμε parse</span>
<span class="c1">-- command line arguments</span>
<span class="kr">case</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="kr">of</span>
<span class="w">  </span><span class="s">&quot;help&quot;</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">printHelp</span>
<span class="w">  </span><span class="s">&quot;start&quot;</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">startProgram</span>
<span class="w">  </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;bad args&quot;</span>

<span class="c1">-- Η Haskell δεν έχει βρόχους επανάληψης; αντιθέτως, χρησιμοποιούμε αναδρομή.</span>
<span class="c1">-- Η συνάρτηση map εφαρμόζει μια συνάρτηση σε κάθε στοιχείο μιας λίστας</span>

<span class="nf">map</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- [2, 4, 6, 8, 10]</span>

<span class="c1">-- μπορούμε να κατασκευάσουμε τον βρόχο for χρησιμοποιώντας την map</span>
<span class="nf">for</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="n">array</span>

<span class="c1">-- και να τον χρησιμοποιήσουμε</span>
<span class="nf">for</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="nf">\</span><span class="n">i</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="n">i</span>

<span class="c1">-- το παραπάνω θα μπορούσε να γραφτεί και έτσι:</span>
<span class="nf">for</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="n">show</span>

<span class="c1">-- Μπορούμε να χρησιμοποιήσουμε τις συναρτήσεις foldl και foldr</span>
<span class="c1">-- για να υπολογίζουμε μια τιμή από μια λίστα (πχ άθροισμα ή γινόμενο)</span>
<span class="c1">-- foldl &lt;fn&gt; &lt;initial value&gt; &lt;list&gt;</span>
<span class="nf">foldl</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="c1">-- 43</span>

<span class="c1">-- Η παραπάνω κλήση είναι η ίδια με:</span>
<span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>

<span class="c1">-- Η foldl γίνεται από τα αριστερά ενώ η foldr από τα δεξιά</span>
<span class="nf">foldr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="c1">-- 16</span>

<span class="c1">-- Η παραπάνω κλήση είναι τώρ:</span>
<span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">)))</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 7. Τύποι δεδομένων</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Με τον παρακάτω τρόπο μπορούμε να ορίζουμε δικούς μας τύπους</span>
<span class="c1">-- δεδομένων στην Haskell</span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Color</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Red</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Blue</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Green</span>

<span class="c1">-- Τώρα μπορούμε να χρησιμοποιήσουμε τον τύπο μας και σε συναρτήσεις:</span>

<span class="nf">say</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Color</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span>
<span class="nf">say</span><span class="w"> </span><span class="kt">Red</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;You are Red!&quot;</span>
<span class="nf">say</span><span class="w"> </span><span class="kt">Blue</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;You are Blue!&quot;</span>
<span class="nf">say</span><span class="w"> </span><span class="kt">Green</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;You are Green!&quot;</span>

<span class="c1">-- Οι τύποι δεδομένων μας μπορεί να είναι και παραμετρικοί, να δέχονται δηλαδή</span>
<span class="c1">-- κάποιον τύπο ως παράμετρο</span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Nothing</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="n">a</span>

<span class="c1">-- Όλες οι παρακάτω τιμές έχουν τύπο Maybe</span>
<span class="kt">Just</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="w">    </span><span class="c1">-- of type `Maybe String`</span>
<span class="kt">Just</span><span class="w"> </span><span class="mi">1</span><span class="w">          </span><span class="c1">-- of type `Maybe Int`</span>
<span class="kt">Nothing</span><span class="w">         </span><span class="c1">-- of type `Maybe a` for any `a`</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 8. Haskell IO</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Αν και το IO δεν μπορεί να εξηγηθεί σε βάθος χωρίς να εξηγήσουμε</span>
<span class="c1">-- πρώτα τα monads, δεν είναι δύσκολο να το εξηγήσουμε αρκετά ώστε να μπορεί</span>
<span class="c1">-- κάποιος να το χρησιμοποιήσει</span>

<span class="c1">-- Όταν ένα πρόγραμμα Haskell εκτελείται, καλείται η συνάρτηση `main`</span>
<span class="c1">-- Η συνάρτηση αυτή πρέπει να επιστρέφει τύπο `IO a` για κάποιο τύπο `a`.</span>
<span class="c1">-- Για παράδειγμα:</span>

<span class="nf">main</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span>
<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">putStrLn</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="s">&quot;Hello, sky! &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">(</span><span class="n">say</span><span class="w"> </span><span class="kt">Blue</span><span class="p">)</span>
<span class="c1">-- η συνάρτηση putStrLn έχει τύπο: String -&gt; IO ()</span>

<span class="c1">-- Είναι πιο εύκολο να χρησιμοποιήσουμε IO αν μπορούμε να γράψουμε το πρόγραμμά μας</span>
<span class="c1">-- ως μια συνάρτηση από String σε String. Η συνάρτηση</span>
<span class="c1">--    interact :: (String -&gt; String) -&gt; IO ()</span>
<span class="c1">-- παίρνει ως είσοδο ένα string, τρέχει μια συνάρτηση πάνω στην είσοδο</span>
<span class="c1">-- και τυπώνει την έξοδο</span>

<span class="nf">countLines</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span>
<span class="nf">countLines</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">lines</span>

<span class="nf">main&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">interact</span><span class="w"> </span><span class="n">countLines</span>

<span class="c1">-- Μπορείτε να σκεφτείτε μια συνάρτηση που επιστρέφει τιμή με τύπο `IO ()`</span>
<span class="c1">-- ως μια ακολουθία πράξεων, περίπου όπως και σε μια imperative γλώσσα</span>
<span class="c1">-- Μπορούμε να χρησιμοποιήσουμε το `do` και να ενώσουμε αυτές τις κλήσεις</span>
<span class="c1">-- Για παράδειγμα:</span>

<span class="nf">sayHello</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span>
<span class="nf">sayHello</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span>
<span class="w">   </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;What is your name?&quot;</span>
<span class="w">   </span><span class="n">name</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getLine</span><span class="w"> </span><span class="c1">-- η συνάρτηση αυτή διαβάζει μια γραμμή και την αναθέτει στην μετβαλήτη name</span>
<span class="w">   </span><span class="n">putStrLn</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="s">&quot;Hello, &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">name</span>

<span class="c1">-- Δοκιμάστε να γράψετε την συνάρτηση `interact` που θα διαβάζει μια γραμμή</span>

<span class="c1">-- Ωστόσο ο κώδικας της συνάρτησης `sayHello` δεν θα εκτελεστεί ποτέ. Η μόνη συνάρτηση</span>
<span class="c1">-- που εκτελείται όταν κάνουμε compile ένα αρχείο haskell είναι η `main`.</span>
<span class="c1">-- Αν θέλετε να τρέξετε την sayHello (εκτός από το να φορτώσετε τον κώδικα στο</span>
<span class="c1">-- ghci) μπορείτε να βάλετε σε σχόλια τον προηγούμενο ορισμό της main</span>
<span class="c1">-- και να την ορίσετε ως:</span>
<span class="c1">--    main = sayHello</span>

<span class="c1">-- Ας προσπαθήσουμε να καταλάβουμε πως λειτουργεί η συνάρτηση `getLine`</span>
<span class="c1">-- Ο τύπος της είναι:</span>
<span class="c1">--    getLine :: IO String</span>
<span class="c1">-- Μπορείτε να φανταστείτε ότι μια τιμή με τύπο `IO a` θα παραχθεί</span>
<span class="c1">-- από ένα πρόγραμμα που παράγει μια τιμή με τύπο `a` (ενώ παράλληλα κάνει και κάτι άλλο)</span>
<span class="c1">-- Μπορούμε να πάρουμε και να επαναχρησιμοποιήσουμε αυτήν την τιμή χρησιμοποιώντας</span>
<span class="c1">-- το `&lt;-`. Μπορούμε ακόμα και να φτιάξουμε την δική μας συνάρτηση με τύπο</span>
<span class="c1">-- `IO String`:</span>

<span class="nf">action</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">String</span>
<span class="nf">action</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span>
<span class="w">   </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;This is a line. Duh&quot;</span>
<span class="w">   </span><span class="n">input1</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getLine</span>
<span class="w">   </span><span class="n">input2</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getLine</span>
<span class="w">   </span><span class="c1">-- Ο τύπος του `do` μπλοκ είναι εκείνος της τελευταίας γραμμής.</span>
<span class="w">   </span><span class="c1">-- Το `return` δεν είναι κάποια ειδική λέξη, αλλά απλώς μια συνάρτηση</span>
<span class="w">   </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">input1</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">input2</span><span class="p">)</span><span class="w"> </span><span class="c1">-- return :: String -&gt; IO String</span>

<span class="c1">-- Μπορούμε να χρησιμοποιήσουμε την παραπάνω συνάρτηση ακριβώς όπως την  `getLine`:</span>

<span class="nf">main&#39;&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span>
<span class="w">    </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;I will echo two lines!&quot;</span>
<span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">action</span>
<span class="w">    </span><span class="n">putStrLn</span><span class="w"> </span><span class="n">result</span>
<span class="w">    </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;This was all, folks!&quot;</span>

<span class="c1">-- Ο τύπος `IO` είναι παράδειγμα ενός &quot;monad&quot;. Χρησιμοποιώντας τα monads για το</span>
<span class="c1">-- ΙΟ, η Haskell καταφέρνει να είναι αγνή συναρτησιακή γλώσσα. Κάθε συνάρτηση που</span>
<span class="c1">-- αλληλεπιδρά με τον έξω κόσμο (δηλαδή κάνει IO), έχει το IO (ή κάποιο άλλο monad)</span>
<span class="c1">-- στον τύπο της. Αυτό μας διευκολύνει να γνωρίζουμε ποιές συναρτήσεις είναι αγνές</span>
<span class="c1">-- (μαθηματικές -- δεν αλληλεπιδρούν με τον έξω κόσμο ούτε αλλάζουν κάποιο state)</span>
<span class="c1">-- και ποιες δεν είναι.</span>

<span class="c1">-- Αυτό είναι ένα πολύ ισχυρό χαρακτηριστικό γιατί είναι πολύ εύκολο να</span>
<span class="c1">-- εκτελούμε παράλληλα αγνές συναρτήσεις! Οπότε η παραλληλοποίηση στην Haskell</span>
<span class="c1">-- είναι αρκετά πιο εύκολη</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 9. Haskell REPL</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Μπορείτε να ξεκινήσετε το διαδραστικό περιβάλλον της Haskell με την εντολή `ghci`.</span>
<span class="c1">-- Εδώ μπορείτε να γράψετε και να εκτελέσετε κώδικα haskell.</span>
<span class="c1">-- Κάθε νέα τιμή πρέπει να ορίζεται με το `let`</span>

<span class="kr">let</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">5</span>

<span class="c1">-- Μπορείτε να βρείτε τον τύπο μιας συνάρτησης με το `:t`:</span>

<span class="o">&gt;</span><span class="w"> </span><span class="kt">:</span><span class="n">t</span><span class="w"> </span><span class="n">foo</span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span>

<span class="c1">-- Οι τελεστές, όπως οι `+`, `:` και `$`, είναι επίσης συναρτήσεις.</span>
<span class="c1">-- Μπορούμε να δούμε τον τύπο τους βάζοντας τους μέσα σε παρενθέσεις:</span>

<span class="o">&gt;</span><span class="w"> </span><span class="kt">:</span><span class="n">t</span><span class="w"> </span><span class="p">(</span><span class="kt">:</span><span class="p">)</span>
<span class="p">(</span><span class="kt">:</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span>

<span class="c1">-- Για περισσότερες πληροφορίες για οποιαδήποτε συνάρτηση ή τύπο,</span>
<span class="c1">-- μπορείτε να χρησιμοποιήσετε το `:i`:</span>

<span class="o">&gt;</span><span class="w"> </span><span class="kt">:</span><span class="n">i</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span>
<span class="kr">class</span><span class="w"> </span><span class="kt">Num</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span>
<span class="w">  </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span>
<span class="w">  </span><span class="o">...</span>
<span class="w">    </span><span class="c1">-- Defined in ‘GHC.Num’</span>
<span class="kr">infixl</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="o">+</span>

<span class="c1">-- Μπορείτε επίσης να τρέξετε κάθε συνάρτηση με τύπο `IO ()`</span>

<span class="o">&gt;</span><span class="w"> </span><span class="n">sayHello</span>
<span class="kt">What</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">your</span><span class="w"> </span><span class="n">name</span><span class="o">?</span>
<span class="kt">Friend</span><span class="o">!</span>
<span class="kt">Hello</span><span class="p">,</span><span class="w"> </span><span class="kt">Friend</span><span class="o">!</span>
</pre></div>
<p>Υπάρχουν πολλά ακόμα πράγματα να εξερευνήσετε στην Haskell, όπως τα typeclasses
και διάφορα monads! Αυτές οι μαθηματικά ορισμένες έννοιες είναι που κάνουν την
Haskell αυστηρή, αγνή και κομψή! Θα τελειώσουμε αυτήν την σύντομη περιήγηση με
ένα τελευταίο παράδειγμα, η υλοποίηση της QuickSort σε Haskell:</p>
<div class="highlight"><pre lang="haskell"><span class="nf">qsort</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span>
<span class="nf">qsort</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">qsort</span><span class="w"> </span><span class="n">lesser</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">qsort</span><span class="w"> </span><span class="n">greater</span>
<span class="w">    </span><span class="kr">where</span><span class="w"> </span><span class="n">lesser</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span>
<span class="w">          </span><span class="n">greater</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="o">&gt;=</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span>
</pre></div>
<p>Υπάρχουν 2 παραδοσιακοί τρόποι να εγκαταστήσετε την Haskell:</p>
<ul>
<li><a href="http://www.haskell.org/platform/">Cabal-based installation</a>,</li>
<li><a href="https://www.stackage.org/install">Stack-based process</a>.</li>
</ul>
<p>Στις παρακάτω πηγές μπορείτε να βρείτε αρκετά κομψές εισαγωγές στην Haskell</p>
<ul>
<li><a href="http://learnyouahaskell.com/">Learn you a Haskell</a>,</li>
<li><a href="http://www.happylearnhaskelltutorial.com/">Happy Learn Haskell Tutorial</a>,</li>
<li><a href="http://book.realworldhaskell.org/">Real World Haskell</a></li>
</ul>

        <hr>
        <p>
          Έχετε κάποια πρόταση; Κάποια διόρθωση, ίσως; <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Δημιουργήστε ένα Issue</a> στο GitHub Repo μας, ή ανοίξτε ένα <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/el/haskell.md">pull request</a>!
        </p>
        <p class="contributed">
          Αρχική συμβολή: Miltiadis Stouras, ενημερώσεις/επεξεργασία: <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/el/haskell.md">2 contributor(s)</a>.
        </p>

        <footer>
          <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width: 0; width: 80px; height: 28px; padding-bottom: 5px;" src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-sa.svg" /></a>
          <p>
            &copy; 2025
            <a href="https://github.com/mstou">Miltiadis Stouras</a>
          </p>
        </footer>
      </div>
    </div>
  </body>
</html>