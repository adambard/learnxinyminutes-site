<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-WXC8R75DEN');
    </script>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="Content-Language" content="zh-CN">
    <title>Learn C in Y Minutes</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto+Slab:wght@100..900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/screen.css">
    <link rel="stylesheet" href="/css/light.css">
    <link rel="stylesheet" href="/css/dark.css">

    <link rel="canonical" href="https://learnxinyminutes.com/zh-cn/c/">
    <script>
      localStorage.removeItem("lxiym_theme");
    </script>
  </head>
  <body>
    <div class="container">
      <div class="share">
        <span class="sharemsg">
          <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fzh-cn%2Fc%2F&amp;text=Y%E5%88%86%E9%92%9F%E9%80%9F%E6%88%90X%2C+%E5%85%B6%E4%B8%AD+X%3DC">
            分享此页
          </a>
        </span>
        <span class='st_facebook_large' displayText='Facebook'></span>
        <span class='st_twitter_large' displayText='Tweet'></span>
      </div>
      <h1><a href="/">Y分钟速成X</a></h1>
      <h2>其中 X=C</h2>
      <p class="filelink">
        源代码下载：
        <a href="/zh-cn/files/learnc.c">learnc.c</a>
      </p>
      <div id="doc">
<p>C语言在今天仍然是高性能计算的主要选择。</p>
<p>C大概是大多数程序员用到的最接近底层的语言了，C语言原生的速度就很高了，但是别忘了C的手动内存管理，它会让你将性能发挥到极致。</p>
<div class="highlight"><pre lang="c"><span class="c1">// 单行注释以//开始。（仅适用于C99或更新的版本。）</span>

<span class="cm">/*</span>
<span class="cm">多行注释是这个样子的。（C89也适用。）</span>
<span class="cm">*/</span>

<span class="c1">// 常数： #define 关键词</span>
<span class="cp">#define DAYS_IN_YEAR 365</span>

<span class="c1">// 以枚举的方式定义常数</span>
<span class="k">enum</span><span class="w"> </span><span class="n">days</span><span class="w"> </span><span class="p">{</span><span class="n">SUN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">MON</span><span class="p">,</span><span class="w"> </span><span class="n">TUE</span><span class="p">,</span><span class="w"> </span><span class="n">WED</span><span class="p">,</span><span class="w"> </span><span class="n">THU</span><span class="p">,</span><span class="w"> </span><span class="n">FRI</span><span class="p">,</span><span class="w"> </span><span class="n">SAT</span><span class="p">};</span>
<span class="c1">// MON自动被定义为2，TUE被定义为3，以此类推。</span>

<span class="c1">// 用#include来导入头文件</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>

<span class="c1">// &lt;尖括号&gt;间的文件名是C标准库的头文件。</span>
<span class="c1">// 标准库以外的头文件，使用双引号代替尖括号。</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;my_header.h&quot;</span>

<span class="c1">// 函数的签名可以事先在.h文件中定义，</span>
<span class="c1">// 也可以直接在.c文件的头部定义。</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">function_1</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">function_2</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="c1">// 如果函数调用在main()之后，那么必须声明在main()之前</span>
<span class="c1">// 先声明一个函数原型</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">add_two_ints</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x2</span><span class="p">);</span><span class="w"> </span><span class="c1">// 函数原型</span>

<span class="c1">// 你的程序的入口是一个返回值为整型的main函数</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="c1">// 用printf打印到标准输出，可以设定格式，</span>
<span class="c1">// %d 代表整数, \n 代表换行</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; 打印 0</span>
<span class="c1">// 所有的语句都要以分号结束</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// 类型</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// 在使用变量之前我们必须先声明它们。</span>
<span class="c1">// 变量在声明时需要指明其类型，而类型能够告诉系统这个变量所占用的空间</span>

<span class="c1">// int型（整型）变量一般占用4个字节</span>
<span class="kt">int</span><span class="w"> </span><span class="n">x_int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// short型（短整型）变量一般占用2个字节</span>
<span class="kt">short</span><span class="w"> </span><span class="n">x_short</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// char型（字符型）变量会占用1个字节</span>
<span class="kt">char</span><span class="w"> </span><span class="n">x_char</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kt">char</span><span class="w"> </span><span class="n">y_char</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;y&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 字符变量的字面值需要用单引号包住</span>

<span class="c1">// long型（长整型）一般需要4个字节到8个字节; 而long long型则至少需要8个字节（64位）</span>

<span class="kt">long</span><span class="w"> </span><span class="n">x_long</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x_long_long</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// float一般是用32位表示的浮点数字</span>
<span class="kt">float</span><span class="w"> </span><span class="n">x_float</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>

<span class="c1">// double一般是用64位表示的浮点数字</span>
<span class="kt">double</span><span class="w"> </span><span class="n">x_double</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>

<span class="c1">// 整数类型也可以有无符号的类型表示。这样这些变量就无法表示负数</span>
<span class="c1">// 但是无符号整数所能表示的范围就可以比原来的整数大一些</span>

<span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">ux_short</span><span class="p">;</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ux_int</span><span class="p">;</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">ux_long_long</span><span class="p">;</span>

<span class="c1">// 单引号内的字符是机器的字符集中的整数。</span>
<span class="sc">&#39;0&#39;</span><span class="w"> </span><span class="c1">// =&gt; 在ASCII字符集中是48</span>
<span class="sc">&#39;A&#39;</span><span class="w"> </span><span class="c1">// =&gt; 在ASCII字符集中是65</span>

<span class="c1">// char类型一定会占用1个字节，但是其他的类型却会因具体机器的不同而各异</span>
<span class="c1">// sizeof(T) 可以返回T类型在运行的机器上占用多少个字节</span>
<span class="c1">// 这样你的代码就可以在各处正确运行了</span>
<span class="c1">// sizeof(obj)返回表达式（变量、字面量等）的尺寸</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"> </span><span class="c1">// =&gt; 4 (大多数的机器字长为4)</span>

<span class="c1">// 如果`sizeof`的参数是一个表达式，那么这个参数不会被演算（VLA例外，见下）</span>
<span class="c1">// 它产生的值是编译期的常数</span>
<span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="c1">// size_t是一个无符号整型，表示对象的尺寸，至少2个字节</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="o">++</span><span class="p">);</span><span class="w"> </span><span class="c1">// a++ 不会被演算</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(a++) = %zu where a = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
<span class="c1">// 打印 &quot;sizeof(a++) = 4 where a = 1&quot; （在32位架构上）</span>

<span class="c1">// 数组必须要被初始化为具体的长度</span>
<span class="kt">char</span><span class="w"> </span><span class="n">my_char_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span><span class="w"> </span><span class="c1">// 这个数组占据 1 * 20 = 20 个字节</span>
<span class="kt">int</span><span class="w"> </span><span class="n">my_int_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span><span class="w"> </span><span class="c1">// 这个数组占据 4 * 20 = 80 个字节</span>
<span class="w">                      </span><span class="c1">// (这里我们假设字长为4)</span>


<span class="c1">// 可以用下面的方法把数组初始化为0:</span>
<span class="kt">char</span><span class="w"> </span><span class="n">my_array</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>

<span class="c1">// 索引数组和其他语言类似 -- 好吧，其实是其他的语言像C</span>
<span class="n">my_array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="c1">// =&gt; 0</span>

<span class="c1">// 数组是可变的，其实就是内存的映射！</span>
<span class="n">my_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">my_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"> </span><span class="c1">// =&gt; 2</span>

<span class="c1">// 在C99 （C11中是可选特性），变长数组（VLA）也可以声明长度。</span>
<span class="c1">// 其长度不用是编译期常量。</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Enter the array size: &quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// 询问用户数组长度</span>
<span class="kt">char</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="mh">0x100</span><span class="p">];</span>
<span class="n">fgets</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">stdin</span><span class="p">);</span>

<span class="c1">// strtoul 将字符串解析为无符号整数</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="n">var_length_array</span><span class="p">[</span><span class="n">size</span><span class="p">];</span><span class="w"> </span><span class="c1">// 声明VLA</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof array = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="n">var_length_array</span><span class="p">);</span>

<span class="c1">// 上述程序可能的输出为：</span>
<span class="c1">// &gt; Enter the array size: 10</span>
<span class="c1">// &gt; sizeof array = 40</span>

<span class="c1">// 字符串就是以 NUL (0x00) 这个字符结尾的字符数组,</span>
<span class="c1">// NUL可以用&#39;\0&#39;来表示.</span>
<span class="c1">// (在字符串字面量中我们不必输入这个字符，编译器会自动添加的)</span>
<span class="kt">char</span><span class="w"> </span><span class="n">a_string</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;This is a string&quot;</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a_string</span><span class="p">);</span><span class="w"> </span><span class="c1">// %s 可以对字符串进行格式化</span>
<span class="cm">/*</span>
<span class="cm">也许你会注意到 a_string 实际上只有16个字节长.</span>
<span class="cm">第17个字节是一个空字符(NUL)</span>
<span class="cm">而第18, 19 和 20 个字符的值是未定义。</span>
<span class="cm">*/</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a_string</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span><span class="w"> </span><span class="c1">// =&gt; 0</span>
<span class="c1">//  byte #17值为0（18，19，20同样为0）</span>

<span class="c1">// 单引号间的字符是字符字面量</span>
<span class="c1">// 它的类型是`int`，而 *不是* `char`</span>
<span class="c1">// （由于历史原因）</span>
<span class="kt">int</span><span class="w"> </span><span class="n">cha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 合法</span>
<span class="kt">char</span><span class="w"> </span><span class="n">chb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 同样合法 (隐式类型转换</span>

<span class="c1">// 多维数组</span>
<span class="kt">int</span><span class="w"> </span><span class="n">multi_array</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">},</span>
<span class="w">        </span><span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span>
<span class="w">    </span><span class="p">};</span>
<span class="c1">// 获取元素</span>
<span class="kt">int</span><span class="w"> </span><span class="n">array_int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">multi_array</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="c1">// =&gt; 3</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// 操作符</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// 多个变量声明的简写</span>
<span class="kt">int</span><span class="w"> </span><span class="n">i1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">i2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="n">f2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span>

<span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// 算数运算直截了当</span>
<span class="n">i1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 3</span>
<span class="n">i2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">i1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>
<span class="n">i2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 2</span>
<span class="n">i1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">i2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0 (0.5，但会被化整为 0)</span>

<span class="n">f1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0.5, 也许会有很小的误差</span>
<span class="c1">// 浮点数和浮点数运算都是近似值</span>

<span class="c1">// 取余运算</span>
<span class="mi">11</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 2</span>

<span class="c1">// 你多半会觉得比较操作符很熟悉, 不过C中没有布尔类型</span>
<span class="c1">// 而是用整形替代</span>
<span class="c1">// (C99中有_Bool或bool。)</span>
<span class="c1">// 0为假, 其他均为真. (比较操作符的返回值总是返回0或1)</span>
<span class="mi">3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0 (false)</span>
<span class="mi">3</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1 (true)</span>
<span class="mi">3</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>
<span class="mi">3</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0</span>
<span class="mi">2</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>
<span class="mi">2</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>

<span class="c1">// C不是Python —— 连续比较不合法</span>
<span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="c1">// 错误</span>
<span class="kt">int</span><span class="w"> </span><span class="n">between_0_and_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="c1">// 正确</span>
<span class="kt">int</span><span class="w"> </span><span class="n">between_0_and_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>

<span class="c1">// 逻辑运算符适用于整数</span>
<span class="o">!</span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0 (非)</span>
<span class="o">!</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1</span>
<span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1 (且)</span>
<span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0</span>
<span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 1 (或)</span>
<span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0</span>

<span class="c1">// 条件表达式 （ ? : ）</span>
<span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="c1">//  10 “若a &gt; b返回a，否则返回b。”</span>

<span class="c1">// 增、减</span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;iLoveC&quot;</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span><span class="w"> </span><span class="c1">// &quot;i&quot; 返回s的第j项，然后增加j的值。</span>
<span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">s</span><span class="p">[</span><span class="o">++</span><span class="n">j</span><span class="p">];</span><span class="w"> </span><span class="c1">// =&gt; &quot;L&quot;  增加j的值，然后返回s的第j项。</span>
<span class="c1">// j-- 和 --j 同理</span>

<span class="c1">// 位运算</span>
<span class="o">~</span><span class="mh">0x0F</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0xF0 (取反)</span>
<span class="mh">0x0F</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xF0</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0x00 (和)</span>
<span class="mh">0x0F</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0xF0</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0xFF (或)</span>
<span class="mh">0x04</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="mh">0x0F</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0x0B (异或)</span>
<span class="mh">0x01</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0x02 (左移1位)</span>
<span class="mh">0x02</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// =&gt; 0x01 (右移1位)</span>

<span class="c1">// 对有符号整数进行移位操作要小心 —— 以下未定义：</span>
<span class="c1">// 有符号整数位移至符号位 int a = 1 &lt;&lt; 32</span>
<span class="c1">// 左移位一个负数 int a = -1 &lt;&lt; 2</span>
<span class="c1">// 移位超过或等于该类型数值的长度</span>
<span class="c1">// int a = 1 &lt;&lt; 32; // 假定int32位</span>


<span class="c1">///////////////////////////////////////</span>
<span class="c1">// 控制结构</span>
<span class="c1">///////////////////////////////////////</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;I am never run</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;I am also never run</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;I print</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// While循环</span>
<span class="kt">int</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">ii</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 任何非0的值均为真</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ii</span><span class="o">++</span><span class="p">);</span><span class="w"> </span><span class="c1">// ii++ 在取值过后自增</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// =&gt;  打印 &quot;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="kt">int</span><span class="w"> </span><span class="n">kk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">kk</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">++</span><span class="n">kk</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="c1">// ++kk 先自增，再被取值</span>
<span class="c1">// =&gt; 打印 &quot;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="c1">// For 循环</span>
<span class="kt">int</span><span class="w"> </span><span class="n">jj</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">jj</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">jj</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">jj</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">jj</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// =&gt; 打印 &quot;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="c1">// *****注意*****:</span>
<span class="c1">// 循环和函数必须有主体部分，如果不需要主体部分：</span>
<span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">;</span><span class="w"> </span><span class="c1">// 使用分号表达主体（null语句）</span>
<span class="p">}</span>

<span class="c1">// 多重分支：switch()</span>
<span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">some_integral_expression</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="k">case</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span><span class="w"> </span><span class="c1">// 标签必须是整数常量表达式</span>
<span class="w">    </span><span class="n">do_stuff</span><span class="p">();</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"> </span><span class="c1">// 如果不使用break，控制结构会继续执行下面的标签</span>
<span class="k">case</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span>
<span class="w">    </span><span class="n">do_something_else</span><span class="p">();</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="k">default</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// 假设 `some_integral_expression` 不匹配任何标签</span>
<span class="w">    </span><span class="n">fputs</span><span class="p">(</span><span class="s">&quot;error!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">stderr</span><span class="p">);</span>
<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="mi">-1</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// 类型转换</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// 在C中每个变量都有类型，你可以将变量的类型进行转换</span>
<span class="c1">// (有一定限制)</span>

<span class="kt">int</span><span class="w"> </span><span class="n">x_hex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x01</span><span class="p">;</span><span class="w"> </span><span class="c1">// 可以用16进制字面量赋值</span>

<span class="c1">// 在类型转换时，数字本身的值会被保留下来</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x_hex</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; 打印 1</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">short</span><span class="p">)</span><span class="w"> </span><span class="n">x_hex</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; 打印 1</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="n">x_hex</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; 打印 1</span>

<span class="c1">// 类型转换时可能会造成溢出，而且不会抛出警告</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="mi">257</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; 1 (char的最大值为255，假定char为8位长)</span>

<span class="c1">// 使用&lt;limits.h&gt;提供的CHAR_MAX、SCHAR_MAX和UCHAR_MAX宏可以确定`char`、`signed_char`和`unisigned char`的最大值。</span>


<span class="c1">// 整数型和浮点型可以互相转换</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="mi">100</span><span class="p">);</span><span class="w"> </span><span class="c1">// %f 格式化单精度浮点</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="mi">100</span><span class="p">);</span><span class="w"> </span><span class="c1">// %lf 格式化双精度浮点</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mf">100.0</span><span class="p">);</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// 指针</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// 指针变量是用来储存内存地址的变量</span>
<span class="c1">// 指针变量的声明也会告诉它所指向的数据的类型</span>
<span class="c1">// 你可以使用得到你的变量的地址，并把它们搞乱，;-)</span>

<span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// 用 &amp; 来获取变量的地址</span>
<span class="c1">// (%p 格式化一个类型为 void *的指针)</span>
<span class="c1">// =&gt; 打印某个内存地址</span>

<span class="c1">// 指针类型在声明中以*开头</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">px</span><span class="p">,</span><span class="w"> </span><span class="n">not_a_pointer</span><span class="p">;</span><span class="w"> </span><span class="c1">// px是一个指向int型的指针</span>
<span class="n">px</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// 把x的地址保存到px中</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">px</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; 输出内存中的某个地址</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%zu, %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">px</span><span class="p">),</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">not_a_pointer</span><span class="p">));</span>
<span class="c1">// =&gt; 在64位系统上打印“8， 4”。</span>

<span class="c1">// 要得到某个指针指向的内容的值，可以在指针前加一个*来取得（取消引用）</span>
<span class="c1">// 注意： 是的，这可能让人困惑，&#39;*&#39;在用来声明一个指针的同时取消引用它。</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">px</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; 输出 0, 即x的值</span>

<span class="c1">// 你也可以改变指针所指向的值</span>
<span class="c1">// 此时你需要取消引用上添加括号，因为++比*的优先级更高</span>
<span class="p">(</span><span class="o">*</span><span class="n">px</span><span class="p">)</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">// 把px所指向的值增加1</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">px</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; 输出 1</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; 输出 1</span>

<span class="c1">// 数组是分配一系列连续空间的常用方式</span>
<span class="kt">int</span><span class="w"> </span><span class="n">x_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
<span class="kt">int</span><span class="w"> </span><span class="n">xx</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">xx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">xx</span><span class="o">&lt;</span><span class="mi">20</span><span class="p">;</span><span class="w"> </span><span class="n">xx</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x_array</span><span class="p">[</span><span class="n">xx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">xx</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// 初始化 x_array 为 20, 19, 18,... 2, 1</span>

<span class="c1">// 声明一个整型的指针，并初始化为指向x_array</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">x_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x_array</span><span class="p">;</span>
<span class="c1">// x_ptr现在指向了数组的第一个元素(即整数20).</span>
<span class="c1">// 这是因为数组通常衰减为指向它们的第一个元素的指针。</span>
<span class="c1">// 例如，当一个数组被传递给一个函数或者绑定到一个指针时，</span>
<span class="c1">//它衰减为(隐式转化为）一个指针。</span>
<span class="c1">// 例外： 当数组是`&amp;`操作符的参数：</span>
<span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">ptr_to_arr</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arr</span><span class="p">;</span><span class="w"> </span><span class="c1">// &amp;arr的类型不是`int *`！</span>
<span class="w">                              </span><span class="c1">// 它的类型是指向数组的指针（数组由10个int组成）</span>
<span class="c1">// 或者当数组是字符串字面量（初始化字符数组）</span>
<span class="kt">char</span><span class="w"> </span><span class="n">arr</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foobarbazquirk&quot;</span><span class="p">;</span>
<span class="c1">// 或者当它是`sizeof`或`alignof`操作符的参数时：</span>
<span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">;</span><span class="w"> </span><span class="c1">// 等价于 int *ptr = &amp;arr[0];</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%zu, %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="n">ptr</span><span class="p">);</span><span class="w"> </span><span class="c1">// 应该会输出&quot;40, 4&quot;或&quot;40, 8&quot;</span>

<span class="c1">// 指针的增减多少是依据它本身的类型而定的</span>
<span class="c1">// （这被称为指针算术）</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">x_ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w"> </span><span class="c1">// =&gt; 打印 19</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"> </span><span class="c1">// =&gt; 打印 19</span>

<span class="c1">// 你也可以通过标准库函数malloc来实现动态分配</span>
<span class="c1">// 这个函数接受一个代表容量的参数，参数类型为`size_t`</span>
<span class="c1">// 系统一般会从堆区分配指定容量字节大小的空间</span>
<span class="c1">// （在一些系统，例如嵌入式系统中这点不一定成立</span>
<span class="c1">// C标准对此未置一词。）</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">my_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">my_ptr</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">20</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">xx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">xx</span><span class="o">&lt;</span><span class="mi">20</span><span class="p">;</span><span class="w"> </span><span class="n">xx</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">*</span><span class="p">(</span><span class="n">my_ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">xx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">xx</span><span class="p">;</span><span class="w"> </span><span class="c1">// my_ptr[xx] = 20-xx</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// 初始化内存为 20, 19, 18, 17... 2, 1 (类型为int）</span>

<span class="c1">// 对未分配的内存进行取消引用会产生未定义的结果</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">my_ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">21</span><span class="p">));</span><span class="w"> </span><span class="c1">// =&gt; 谁知道会输出什么</span>

<span class="c1">// malloc分配的区域需要手动释放</span>
<span class="c1">// 否则没人能够再次使用这块内存，直到程序结束为止</span>
<span class="n">free</span><span class="p">(</span><span class="n">my_ptr</span><span class="p">);</span>

<span class="c1">// 字符串通常是字符数组，但是经常用字符指针表示</span>
<span class="c1">// (它是指向数组的第一个元素的指针)</span>
<span class="c1">// 一个优良的实践是使用`const char *`来引用一个字符串字面量，</span>
<span class="c1">// 因为字符串字面量不应当被修改（即&quot;foo&quot;[0] = &#39;a&#39;犯了大忌）</span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">my_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;This is my very own string&quot;</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">my_str</span><span class="p">);</span><span class="w"> </span><span class="c1">// =&gt; &#39;T&#39;</span>

<span class="c1">// 如果字符串是数组，（多半是用字符串字面量初始化的）</span>
<span class="c1">// 情况就不一样了，字符串位于可写的内存中</span>
<span class="kt">char</span><span class="w"> </span><span class="n">foo</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foo&quot;</span><span class="p">;</span>
<span class="n">foo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 这是合法的，foo现在包含&quot;aoo&quot;</span>

<span class="n">function_1</span><span class="p">();</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// main函数结束</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// 函数</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// 函数声明语法:</span>
<span class="c1">// &lt;返回值类型&gt; &lt;函数名称&gt;(&lt;参数&gt;)</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">add_two_ints</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x2</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x2</span><span class="p">;</span><span class="w"> </span><span class="c1">// 用return来返回一个值</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">函数是按值传递的。当调用一个函数的时候，传递给函数的参数</span>
<span class="cm">是原有值的拷贝（数组除外）。你在函数内对参数所进行的操作</span>
<span class="cm">不会改变该参数原有的值。</span>

<span class="cm">但是你可以通过指针来传递引用，这样函数就可以更改值</span>

<span class="cm">例子：字符串本身翻转</span>
<span class="cm">*/</span>

<span class="c1">// 类型为void的函数没有返回值</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">str_reverse</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str_in</span><span class="p">){</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">str_in</span><span class="p">);</span><span class="w"> </span><span class="c1">// `strlen()`` 是C标准库函数</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">ii</span><span class="o">++</span><span class="p">){</span>
<span class="w">        </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str_in</span><span class="p">[</span><span class="n">ii</span><span class="p">];</span>
<span class="w">        </span><span class="n">str_in</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str_in</span><span class="p">[</span><span class="n">len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="c1">// 从倒数第ii个开始</span>
<span class="w">        </span><span class="n">str_in</span><span class="p">[</span><span class="n">len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">char c[] = &quot;This is a test.&quot;;</span>
<span class="cm">str_reverse(c);</span>
<span class="cm">printf(&quot;%s\n&quot;, c); // =&gt; &quot;.tset a si sihT&quot;</span>
<span class="cm">*/</span>

<span class="c1">// 如果引用函数之外的变量，必须使用extern关键字</span>
<span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">testFunc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="c1">// 使用外部变量 i</span>
<span class="p">}</span>

<span class="c1">// 使用static确保external变量为源文件私有</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// 其他使用 testFunc()的文件无法访问变量i</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">testFunc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//**你同样可以声明函数为static**</span>


<span class="c1">///////////////////////////////////////</span>
<span class="c1">// 用户自定义类型和结构</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// typedef 可以创建类型别名</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">my_type</span><span class="p">;</span>
<span class="n">my_type</span><span class="w"> </span><span class="n">my_type_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// struct是数据的集合，成员依序分配，按照</span>
<span class="c1">// 编写的顺序</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">height</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 一般而言，以下断言不成立：</span>
<span class="c1">// sizeof(struct rectangle) == sizeof(int) + sizeof(int)</span>
<span class="c1">//这是因为structure成员之间可能存在潜在的间隙（为了对齐）[1]</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">function_1</span><span class="p">(){</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="n">my_rec</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 通过 . 来访问结构中的数据</span>
<span class="w">    </span><span class="n">my_rec</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">    </span><span class="n">my_rec</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 你也可以声明指向结构体的指针</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="o">*</span><span class="n">my_rec_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">my_rec</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 通过取消引用来改变结构体的成员...</span>
<span class="w">    </span><span class="p">(</span><span class="o">*</span><span class="n">my_rec_ptr</span><span class="p">).</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// ... 或者用 -&gt; 操作符作为简写提高可读性</span>
<span class="w">    </span><span class="n">my_rec_ptr</span><span class="o">-&gt;</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="c1">// Same as (*my_rec_ptr).height = 10;</span>
<span class="p">}</span>

<span class="c1">// 你也可以用typedef来给一个结构体起一个别名</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="n">rect</span><span class="p">;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">area</span><span class="p">(</span><span class="n">rect</span><span class="w"> </span><span class="n">r</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 如果struct较大，你可以通过指针传递，避免</span>
<span class="c1">// 复制整个struct。</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">area</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">rect</span><span class="w"> </span><span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// 函数指针</span>
<span class="c1">///////////////////////////////////////</span>
<span class="cm">/*</span>
<span class="cm">在运行时，函数本身也被存放到某块内存区域当中</span>
<span class="cm">函数指针就像其他指针一样（不过是存储一个内存地址） 但却可以被用来直接调用函数,</span>
<span class="cm">并且可以四处传递回调函数</span>
<span class="cm">但是，定义的语法初看令人有些迷惑</span>

<span class="cm">例子：通过指针调用str_reverse</span>
<span class="cm">*/</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">str_reverse_through_pointer</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str_in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 定义一个函数指针 f.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"> </span><span class="c1">// 签名一定要与目标函数相同</span>
<span class="w">    </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">str_reverse</span><span class="p">;</span><span class="w"> </span><span class="c1">// 将函数的地址在运行时赋给指针</span>
<span class="w">    </span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="n">str_in</span><span class="p">);</span><span class="w"> </span><span class="c1">// 通过指针调用函数</span>
<span class="w">    </span><span class="c1">// f(str_in); // 等价于这种调用方式</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">只要函数签名是正确的，任何时候都能将任何函数赋给某个函数指针</span>
<span class="cm">为了可读性和简洁性，函数指针经常和typedef搭配使用：</span>
<span class="cm">*/</span>

<span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">my_fnp_type</span><span class="p">)(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>

<span class="c1">// 实际声明函数指针会这么用:</span>
<span class="c1">// ...</span>
<span class="c1">// my_fnp_type f;</span>

<span class="c1">// 特殊字符</span>
<span class="sc">&#39;\a&#39;</span><span class="w"> </span><span class="c1">// bell</span>
<span class="sc">&#39;\n&#39;</span><span class="w"> </span><span class="c1">// 换行</span>
<span class="sc">&#39;\t&#39;</span><span class="w"> </span><span class="c1">// tab</span>
<span class="sc">&#39;\v&#39;</span><span class="w"> </span><span class="c1">// vertical tab</span>
<span class="sc">&#39;\f&#39;</span><span class="w"> </span><span class="c1">// formfeed</span>
<span class="sc">&#39;\r&#39;</span><span class="w"> </span><span class="c1">// 回车</span>
<span class="sc">&#39;\b&#39;</span><span class="w"> </span><span class="c1">// 退格</span>
<span class="sc">&#39;\0&#39;</span><span class="w"> </span><span class="c1">// null，通常置于字符串的最后。</span>
<span class="w">     </span><span class="c1">//   hello\n\0. 按照惯例，\0用于标记字符串的末尾。</span>
<span class="sc">&#39;\\&#39;</span><span class="w"> </span><span class="c1">// 反斜杠</span>
<span class="sc">&#39;\?&#39;</span><span class="w"> </span><span class="c1">// 问号</span>
<span class="sc">&#39;\&#39;&#39;</span><span class="w"> </span><span class="c1">// 单引号</span>
<span class="sc">&#39;\&quot;&#39;</span><span class="w"> </span><span class="c1">// 双引号</span>
<span class="err">&#39;\</span><span class="n">xhh</span><span class="err">&#39;</span><span class="w"> </span><span class="c1">// 十六进制数字. 例子: &#39;\xb&#39; = vertical tab</span>
<span class="err">&#39;\</span><span class="n">ooo</span><span class="err">&#39;</span><span class="w"> </span><span class="c1">// 八进制数字. 例子: &#39;\013&#39; = vertical tab</span>

<span class="c1">// 打印格式：</span>
<span class="s">&quot;%d&quot;</span><span class="w">    </span><span class="c1">// 整数</span>
<span class="s">&quot;%3d&quot;</span><span class="w">   </span><span class="c1">// 3位以上整数 （右对齐文本）</span>
<span class="s">&quot;%s&quot;</span><span class="w">    </span><span class="c1">// 字符串</span>
<span class="s">&quot;%f&quot;</span><span class="w">    </span><span class="c1">// float</span>
<span class="s">&quot;%ld&quot;</span><span class="w">   </span><span class="c1">// long</span>
<span class="s">&quot;%3.2f&quot;</span><span class="w"> </span><span class="c1">// 左3位以上、右2位以上十进制浮</span>
<span class="s">&quot;%7.4s&quot;</span><span class="w"> </span><span class="c1">// (字符串同样适用)</span>
<span class="s">&quot;%c&quot;</span><span class="w">    </span><span class="c1">// 字母</span>
<span class="s">&quot;%p&quot;</span><span class="w">    </span><span class="c1">// 指针</span>
<span class="s">&quot;%x&quot;</span><span class="w">    </span><span class="c1">// 十六进制</span>
<span class="s">&quot;%o&quot;</span><span class="w">    </span><span class="c1">// 八进制</span>
<span class="s">&quot;%%&quot;</span><span class="w">    </span><span class="c1">// 打印 %</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// 演算优先级</span>
<span class="c1">///////////////////////////////////////</span>
<span class="c1">//---------------------------------------------------//</span>
<span class="c1">//        操作符                     | 组合          //</span>
<span class="c1">//---------------------------------------------------//</span>
<span class="c1">// () [] -&gt; .                        | 从左到右      //</span>
<span class="c1">// ! ~ ++ -- + - *(type)sizeof       | 从右到左      //</span>
<span class="c1">// * / %                             | 从左到右      //</span>
<span class="c1">// + -                               | 从左到右      //</span>
<span class="c1">// &lt;&lt; &gt;&gt;                             | 从左到右      //</span>
<span class="c1">// &lt; &lt;= &gt; &gt;=                         | 从左到右      //</span>
<span class="c1">// == !=                             | 从左到右      //</span>
<span class="c1">// &amp;                                 | 从左到右      //</span>
<span class="c1">// ^                                 | 从左到右      //</span>
<span class="c1">// |                                 | 从左到右      //</span>
<span class="c1">// &amp;&amp;                                | 从左到右      //</span>
<span class="c1">// ||                                | 从左到右      //</span>
<span class="c1">// ?:                                | 从右到左      //</span>
<span class="c1">// = += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;= | 从右到左      //</span>
<span class="c1">// ,                                 | 从左到右      //</span>
<span class="c1">//---------------------------------------------------//</span>
</pre></div>
<h2>更多阅读</h2>
<p>最好找一本 <a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">K&amp;R, aka &quot;The C Programming Language&quot;, “C程序设计语言”</a>。它是关于C最重要的一本书，由C的创作者撰写。不过需要留意的是它比较古老了，因此有些不准确的地方。</p>
<p>如果你有问题，请阅读<a href="http://c-faq.com/">compl.lang.c Frequently Asked Questions</a>。</p>
<p>使用合适的空格、缩进，保持一致的代码风格非常重要。可读性强的代码比聪明的代码、高速的代码更重要。可以参考下<a href="https://www.kernel.org/doc/Documentation/process/coding-style.rst">Linux内核编码风格</a>
。
除了这些，多多Google吧</p>
<p>[1] <a href="http://stackoverflow.com/questions/119123/why-isnt-sizeof-for-a-struct-equal-to-the-sum-of-sizeof-of-each-member">stackoverflow.com/questions/119123/why-isnt-sizeof-for-a-struct-equal-to-the-sum-of-sizeof-of-each-member</a></p>

        <hr>
        <p>
          有建议？或者发现什么错误？在GitHub上<a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">开一个issue</a>，或者发起<a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/zh-cn/c.md">pull request</a>！
        </p>
        <p class="contributed">
          原著Adam Bard，并由<a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/zh-cn/c.md">10个好心人</a>修改。
        </p>

        <footer>
          <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width: 0; width: 80px; height: 28px; padding-bottom: 5px;" src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-sa.svg" /></a>
          <p>
            &copy; 2025
            <a href="http://adambard.com/">Adam Bard</a>
          </p>
        </footer>
      </div>
    </div>
  </body>
</html>