<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-WXC8R75DEN');
    </script>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="Content-Language" content="zh-CN">
    <title>Learn Solidity in Y Minutes</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto+Slab:wght@100..900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/screen.css">
    <link rel="stylesheet" href="/css/light.css">
    <link rel="stylesheet" href="/css/dark.css">

    <link rel="canonical" href="https://learnxinyminutes.com/zh-cn/solidity/">
    <script>
      localStorage.removeItem("lxiym_theme");
    </script>
  </head>
  <body>
    <div class="container">
      <div class="share">
        <span class="sharemsg">
          <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fzh-cn%2Fsolidity%2F&amp;text=Y%E5%88%86%E9%92%9F%E9%80%9F%E6%88%90X%2C+%E5%85%B6%E4%B8%AD+X%3DSolidity">
            分享此页
          </a>
        </span>
        <span class='st_facebook_large' displayText='Facebook'></span>
        <span class='st_twitter_large' displayText='Tweet'></span>
      </div>
      <h1><a href="/">Y分钟速成X</a></h1>
      <h2>其中 X=Solidity</h2>
      <p class="filelink">
        源代码下载：
        <a href="/zh-cn/files/learnSolidity.sol">learnSolidity.sol</a>
      </p>
      <div id="doc">
<p>Solidity 使你在<a href="https://www.ethereum.org/">以太坊</a>上编程，一个基于区块链的虚拟机，
允许创建和执行智能合约，无需中心化的或可信的一方。</p>
<p>Solidity 是一种与 JavaScript 和 C 的相似的、静态类型的合约编程语言。与OOP（面向对象）中
的对象一样，每个合约都包含状态变量、函数和公共数据类型。合约特定功能包括修饰符（guard）子句，
事件通知的侦听器及自定义的全局变量。</p>
<p>以太坊合约的例子包括众筹、投票以及盲拍（私密拍卖）。</p>
<p>Solidity 代码中存在高风险和高成本的错误，因此你必须非常小心地进行测试并慢慢地发布。<strong>随着
以太坊的快速变化，本文档不可能是最新的，所以你应该关注最新的的 Solidity 聊天室和以太网博客。
照搬这里的代码，会存在重大错误或弃用代码模式的风险。（说人话--别照抄例子中的代码）</strong></p>
<p>与其他代码不同，可能还需要添加如暂停、弃用和限制使用的设计模式，来降低风险。本文档主要讨论语法，
因此排除了许多流行的设计模式。</p>
<p>由于 Solidity 和以太坊正在积极开发，通常会标记为实验或 beta 特性，并很可能会更改。因此欢迎
提交更改请求。</p>
<div class="highlight"><pre lang="solidity"><span class="c1">// 首先，一个简单的银行合约</span>
<span class="c1">// 允许存款、取款、以及检查余额</span>

<span class="c1">// simple_bank.sol (注意 .sol 后缀)</span>
<span class="cm">/* **** 例子开始 **** */</span>

<span class="c1">// 声明源文件的编译器版本</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.4.19</span><span class="p">;</span>

<span class="c1">// 开始 Natspec 注释（三个斜杠）</span>
<span class="c1">// 用作文档 - 及UI元素、动作的描述性数据</span>

<span class="c1">/// @title SimpleBank</span>
<span class="c1">/// @author nemild</span>

<span class="cm">/* &#39;contract&#39; 和其他语言的 &#39;class&#39; 类似 (类变量、继承等) */</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">SimpleBank</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 单词首字母大写</span>
<span class="w">    </span><span class="c1">// 声明函数外的状态变量，合约生命周期内可用</span>

<span class="w">    </span><span class="c1">// 地址映射到余额的字典，总是要小心数字的溢出攻击</span>
<span class="w">    </span><span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="kt">private</span><span class="w"> </span>balances<span class="p">;</span>

<span class="w">    </span><span class="c1">// &quot;private&quot; 的意思是其他合约不能直接查询余额，但对于区块链上的其他方来说，数据仍然是可见的。</span>

<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="k">public </span><span class="nv">owner</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// &#39;public&#39; 使用户或合约可以从外部读取（不可写）</span>

<span class="w">    </span><span class="c1">// Events（事件） - 向外部监听器发布动作</span>
<span class="w">    </span><span class="kt">event</span><span class="w"> </span><span class="nv">LogDepositMade</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">accountAddress</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Constructor（构造函数）（译者注：Solidity 从0.4.22开始使用 constructor() 作为构造函数）</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">SimpleBank</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// msg 提供了发送给合约的消息详情</span>
<span class="w">        </span><span class="c1">// msg.sender 是合约的调用者（这里是合约创建者的地址）</span>
<span class="w">        </span>owner<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.sender</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// @notice 存款 ether (以太币)</span>
<span class="w">    </span><span class="c1">/// @return 存款后用户的余额</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">deposit</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 使用 &#39;require&#39; 来检测用户的输入，&#39;assert&#39; 是内部常量</span>
<span class="w">        </span><span class="c1">// 我们要确保不会发生溢出问题（上溢）</span>
<span class="w">        </span><span class="kt">require</span><span class="p">((</span>balances<span class="p">[</span><span class="k">msg.sender</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">msg.value</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span>balances<span class="p">[</span><span class="k">msg.sender</span><span class="p">]);</span>

<span class="w">        </span>balances<span class="p">[</span><span class="k">msg.sender</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="k">msg.value</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// 状态变量不需要 &quot;this.&quot; 或 &quot;self.&quot;</span>
<span class="w">        </span><span class="c1">// 默认情况下，所有值都设置为数据类型的初始值</span>

<span class="w">        </span>LogDepositMade<span class="p">(</span><span class="k">msg.sender</span><span class="p">,</span><span class="w"> </span><span class="k">msg.value</span><span class="p">);</span><span class="w"> </span><span class="c1">// 触发事件</span>

<span class="w">        </span><span class="kt">return</span><span class="w"> </span>balances<span class="p">[</span><span class="k">msg.sender</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// @notice 从银行取款以太币 （ether）</span>
<span class="w">    </span><span class="c1">/// @dev 不会返回任何多余的以太币（ether）</span>
<span class="w">    </span><span class="c1">/// @param withdrawAmount 取款的数量</span>
<span class="w">    </span><span class="c1">/// @return 用户还剩下的余额</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">withdraw</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">withdrawAmount</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">remainingBal</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>withdrawAmount<span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span>balances<span class="p">[</span><span class="k">msg.sender</span><span class="p">]);</span>

<span class="w">        </span><span class="c1">// 注意在发送任何交易，即通过 .transfer .send 调用外部函数之前，马上减掉取款数量</span>
<span class="w">        </span><span class="c1">// 这可以允许调用者使用递归请求大于其余额的金额。目标是在调用外部函数之前提交状态，</span>
<span class="w">        </span><span class="c1">// 包括.transfer / .send</span>
<span class="w">        </span>balances<span class="p">[</span><span class="k">msg.sender</span><span class="p">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span>withdrawAmount<span class="p">;</span>

<span class="w">        </span><span class="c1">// 这会自动引发失败，也就是说还原了更新的余额</span>
<span class="w">        </span><span class="k">msg.sender</span><span class="p">.</span>transfer<span class="p">(</span>withdrawAmount<span class="p">);</span>

<span class="w">        </span><span class="kt">return</span><span class="w"> </span>balances<span class="p">[</span><span class="k">msg.sender</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// @notice 获取余额</span>
<span class="w">    </span><span class="c1">/// @return 用户的余额</span>
<span class="w">    </span><span class="c1">// &#39;view&#39; 防止函数编辑状态变量；允许函数本地运行或链下运行</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">balance</span><span class="p">()</span><span class="w"> </span>view<span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>balances<span class="p">[</span><span class="k">msg.sender</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">// ** 例子结束 **</span>


<span class="c1">// 下面， Solidity 基础</span>

<span class="c1">// 1. 数据类型与关联的方法</span>
<span class="c1">// uint 类型用作现金数量（没有双浮点型或单浮点型）及日期（用 unix 时间）</span>
<span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">;</span>

<span class="c1">// 256字节的 int， 实例化后不能改变</span>
<span class="kt">int</span><span class="w"> </span><span class="nv">constant</span><span class="w"> </span>a<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">8</span><span class="p">;</span>
<span class="kt">int256</span><span class="w"> </span><span class="nv">constant</span><span class="w"> </span>a<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">8</span><span class="p">;</span><span class="w"> </span><span class="c1">// 和上一行一样，这里256字节显性化了</span>
<span class="kt">uint</span><span class="w"> </span><span class="nv">constant</span><span class="w"> </span>VERSION_ID<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x123A1</span><span class="p">;</span><span class="w"> </span><span class="c1">// 16进制常量</span>
<span class="c1">// &#39;constant&#39; 关键字, 编译器在每个出现的地方替换为实际的值</span>

<span class="c1">// 所有的状态变量（函数之外的那些），默认是 &#39;internal&#39; 的，只能在合约及所有继承的合约内</span>
<span class="c1">// 可以访问。需要显性的设置为 &#39;public&#39; 才能允许外部合约访问。</span>
<span class="kt">int256</span><span class="w"> </span><span class="k">public </span><span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">8</span><span class="p">;</span>

<span class="c1">// 对于 int 和 uint，可以显性的设置位数（从8位到256位，8位跳跃），如int8, int16, int24</span>
<span class="kt">uint8</span><span class="w"> </span><span class="nv">b</span><span class="p">;</span>
<span class="kt">int64</span><span class="w"> </span><span class="nv">c</span><span class="p">;</span>
<span class="kt">uint248</span><span class="w"> </span><span class="nv">e</span><span class="p">;</span>

<span class="c1">// 当心不要溢出以及免收此类攻击，例如，对于加法最好这么做：</span>
<span class="kt">uint256</span><span class="w"> </span><span class="nv">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>a<span class="w"> </span><span class="o">+</span><span class="w"> </span>b<span class="p">;</span>
assert<span class="p">(</span>c<span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span>a<span class="p">);</span><span class="w"> </span><span class="c1">// assert 测试内部不变的值；require 用来测试用户输入</span>
<span class="c1">// 更多通用算法问题的例子，参考 Zeppelin&#39;s SafeMath library</span>
<span class="c1">// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol</span>


<span class="c1">// 没有内建的随机函数，使用其他合约获得随机数</span>

<span class="c1">// 类型转换</span>
<span class="kt">int</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span>b<span class="p">);</span>

<span class="kt">bool</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// 或 &#39;var b = true;&#39; 隐含的类型</span>

<span class="c1">// 地址 - 20个字节或160位以太坊地址（16进制数字），不允许进行运算</span>
<span class="kt">address</span><span class="w"> </span><span class="k">public </span><span class="nv">owner</span><span class="p">;</span>

<span class="c1">// 账户类型：</span>
<span class="c1">// 合约账户：在创建时设置地址（创建者地址函数，交易发送）</span>
<span class="c1">// 外部账户：（个人账户）从公钥创建的地址</span>

<span class="c1">// &#39;public&#39; 的含义是自动创建的 getter 方法，而不是 setter 方法可以公开的、外部访问。</span>

<span class="c1">// 所有地址都可以进行转账</span>
owner<span class="p">.</span>transfer<span class="p">(</span>SOME_BALANCE<span class="p">);</span><span class="w"> </span><span class="c1">// 失败后还原</span>

<span class="c1">// 还可以调用较低级别的 .send ， 转账失败会返回 false</span>
<span class="kt">if</span><span class="w"> </span><span class="p">(</span>owner<span class="p">.</span>send<span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="c1">// 记住：用 &#39;if&#39; 包着 send 函数，因为合约地址执行这些函数转账时，可能会失败</span>
<span class="c1">// 另外，确保转账前先减掉余额，因为存在递归调用的风险。</span>

<span class="c1">// 检查余额</span>
owner<span class="p">.</span>balance<span class="p">;</span><span class="w"> </span><span class="c1">// 所有者的余额（用户或合约）</span>


<span class="c1">// 字符类型，从1到32位可用</span>
byte<span class="w"> </span>a<span class="p">;</span><span class="w"> </span><span class="c1">// byte 等同于 byte1</span>
bytes2<span class="w"> </span>b<span class="p">;</span>
<span class="kt">bytes32</span><span class="w"> </span><span class="nv">c</span><span class="p">;</span>

<span class="c1">// 动态大小的字符</span>
<span class="kt">bytes</span><span class="w"> </span><span class="nv">m</span><span class="p">;</span><span class="w"> </span><span class="c1">// 特殊的数组，等同于 byte[]，比 byte1 到 byte32 更贵</span>
<span class="c1">// 尽可能不用 bytes</span>

<span class="c1">// 等同于 bytes，但不允许长度或索引的访问</span>
<span class="kt">string</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;hello&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// UTF8存储，注意双引号而不是单引号</span>
<span class="c1">// 字符功能未来会增加，推荐使用 bytes32 或 bytes</span>

<span class="c1">// 推断类型</span>
<span class="c1">// var 会根据第一次赋值决定类型，不能用来作为函数的参数</span>
<span class="kt">var</span><span class="w"> </span>a<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>
<span class="c1">// 小心使用，推断可能带来错误的类型，例如，int8，而计数器需要的是 int16</span>

<span class="c1">// 函数可以用 var 类型赋值给变量</span>
<span class="kt">function</span><span class="w"> </span><span class="nv">a</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">return</span><span class="w"> </span>x<span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">var</span><span class="w"> </span>f<span class="w"> </span><span class="o">=</span><span class="w"> </span>a<span class="p">;</span>
f<span class="p">(</span><span class="m m-Decimal">22</span><span class="p">);</span><span class="w"> </span><span class="c1">// 调用</span>

<span class="c1">// 默认的，所有值实例化后都设为 0</span>

<span class="c1">// 大多数类型上可以调用删除（不会销毁值，而是设置为0，初始值）</span>
<span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">5</span><span class="p">;</span>


<span class="c1">// 集合</span>
<span class="p">(</span>x<span class="p">,</span><span class="w"> </span>y<span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="m m-Decimal">2</span><span class="p">,</span><span class="w"> </span><span class="m m-Decimal">7</span><span class="p">);</span><span class="w"> </span><span class="c1">// 多值的赋值</span>


<span class="c1">// 2. 数据结构</span>
<span class="c1">// 数组</span>
<span class="kt">bytes32</span><span class="p">[</span><span class="m m-Decimal">5</span><span class="p">]</span><span class="w"> </span>nicknames<span class="p">;</span><span class="w"> </span><span class="c1">// 静态数组</span>
<span class="kt">bytes32</span><span class="p">[]</span><span class="w"> </span>names<span class="p">;</span><span class="w"> </span><span class="c1">// 动态数组</span>
<span class="kt">uint</span><span class="w"> </span><span class="nv">newLength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>names<span class="p">.</span>push<span class="p">(</span><span class="s2">&quot;John&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// 添加返回数组的新长度</span>
<span class="c1">// 长度</span>
names<span class="p">.</span>length<span class="p">;</span><span class="w"> </span><span class="c1">// 获得数组长度</span>
names<span class="p">.</span>length<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// 可以设定长度（仅针对 storage 中的动态数组）</span>

<span class="c1">// 多维数组</span>
<span class="kt">uint</span><span class="p">[][</span><span class="m m-Decimal">5</span><span class="p">]</span><span class="w"> </span>x<span class="p">;</span><span class="w"> </span><span class="c1">// 5个动态数组元素的数组(和多数语言的顺序相反)</span>

<span class="c1">// 字典类型 (任一类型到其他类型的映射)</span>
<span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>balances<span class="p">;</span>
balances<span class="p">[</span><span class="s2">&quot;charles&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
<span class="c1">// balances[&quot;ada&quot;]得到 0, 所有没有设定key值的，返回0</span>
<span class="c1">// &#39;public&#39; 允许跟着（调用）另一份合约</span>
contractName<span class="p">.</span>balances<span class="p">(</span><span class="s2">&quot;charles&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// returns 1</span>
<span class="c1">// &#39;public&#39; 创建 getter （而不是 setter ）如下：</span>
<span class="kt">function</span><span class="w"> </span><span class="nv">balances</span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="nv">_account</span><span class="p">)</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">balance</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">return</span><span class="w"> </span>balances<span class="p">[</span>_account<span class="p">];</span>
<span class="p">}</span>

<span class="c1">// 内嵌的 mapping</span>
<span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">uint</span><span class="p">))</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>custodians<span class="p">;</span>

<span class="c1">// 删除</span>
delete<span class="w"> </span>balances<span class="p">[</span><span class="s2">&quot;John&quot;</span><span class="p">];</span>
delete<span class="w"> </span>balances<span class="p">;</span><span class="w"> </span><span class="c1">// 所有元素设为 0</span>

<span class="c1">// 不像其他语言，不知道 keys 的话不能列出 mapping 中的所有元素 - 可以在这之上构建数据结构</span>

<span class="c1">// 结构</span>
<span class="kt">struct</span><span class="w"> </span><span class="nv">Bank</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">owner</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">balance</span><span class="p">;</span>
<span class="p">}</span>
Bank<span class="w"> </span>b<span class="w"> </span><span class="o">=</span><span class="w"> </span>Bank<span class="p">({</span>
<span class="w">    </span>owner<span class="o">:</span><span class="w"> </span><span class="k">msg.sender</span><span class="p">,</span>
<span class="w">    </span>balance<span class="o">:</span><span class="w"> </span><span class="m m-Decimal">5</span>
<span class="p">});</span>
<span class="c1">// 或</span>
Bank<span class="w"> </span>c<span class="w"> </span><span class="o">=</span><span class="w"> </span>Bank<span class="p">(</span><span class="k">msg.sender</span><span class="p">,</span><span class="w"> </span><span class="m m-Decimal">5</span><span class="p">);</span>

c<span class="p">.</span>balance<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// 设为新值</span>
delete<span class="w"> </span>b<span class="p">;</span>
<span class="c1">// 设为初始值，结构内所有变量设为0，除了 mapping</span>

<span class="c1">// 枚举</span>
<span class="kt">enum</span><span class="w"> </span><span class="nv">State</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>Created<span class="p">,</span><span class="w"> </span>Locked<span class="p">,</span><span class="w"> </span>Inactive<span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// 常常作为状态机</span>
State<span class="w"> </span><span class="kt">public</span><span class="w"> </span>state<span class="p">;</span><span class="w"> </span><span class="c1">// 声明枚举变量</span>
state<span class="w"> </span><span class="o">=</span><span class="w"> </span>State<span class="p">.</span>Created<span class="p">;</span>
<span class="c1">// 枚举类型可以显性化的转换为 ints</span>
<span class="kt">uint</span><span class="w"> </span><span class="nv">createdState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">uint</span><span class="p">(</span>State<span class="p">.</span>Created<span class="p">);</span><span class="w"> </span><span class="c1">//  0</span>

<span class="c1">// 数据位置：内存（Memory） vs. 存储（storage） vs. 调用数据（calldata）</span>
<span class="c1">// 所有复杂类型（数据、结构）都有一个数据位置，内存数据不持久，而存储的数据是持久的。</span>
<span class="c1">// 本地变量和状态变量默认是存储，函数参数默认是内存。堆栈存放较小的本地变量</span>

<span class="c1">// 多数类型，可以显性化的设定使用的数据位置</span>


<span class="c1">// 3. 简单操作符</span>
<span class="c1">// Solidity 提供了比较、位运算及数学运算的功能</span>
<span class="c1">// 指数运算: **</span>
<span class="c1">// 异或运算: ^</span>
<span class="c1">// 按位取反: ~</span>


<span class="c1">// 4. 值得注意的全局变量</span>
<span class="c1">// ** this **</span>
<span class="kt">this</span><span class="p">;</span><span class="w"> </span><span class="c1">// 合约的地址</span>
<span class="c1">// 常常用在合约生命周期结束前，转走剩下的余额</span>
<span class="kt">this</span><span class="p">.</span>balance<span class="p">;</span>
<span class="kt">this</span><span class="p">.</span>someFunction<span class="p">();</span><span class="w"> </span><span class="c1">// 通过 call 的方式而不是内部跳转的方式，从外部调用函数</span>

<span class="c1">// ** msg - 合约收到的当前消息 ** **</span>
<span class="k">msg.sender</span><span class="p">;</span><span class="w"> </span><span class="c1">// 发送者的地址</span>
<span class="k">msg.value</span><span class="p">;</span><span class="w"> </span><span class="c1">// 该合约内的以太币数量（单位 wei），该函数应该标记为 &quot;payable&quot;</span>
<span class="k">msg.data</span><span class="p">;</span><span class="w"> </span><span class="c1">// 字符，完整的调用数据</span>
<span class="k">msg.gas</span><span class="p">;</span><span class="w"> </span><span class="c1">// 剩余 gas</span>

<span class="c1">// ** tx - 交易信息 **</span>
<span class="k">tx.origin</span><span class="p">;</span><span class="w"> </span><span class="c1">// 本次交易的发送者地址</span>
<span class="k">tx.gasprice</span><span class="p">;</span><span class="w"> </span><span class="c1">// 本次交易的 gas price</span>

<span class="c1">// ** block - 当前区块信息 **</span>
now<span class="p">;</span><span class="w"> </span><span class="c1">// 当前时间（大概）block.timestamp的别名 (采用的 Unix 时间)</span>
<span class="c1">// 注意这个可能被矿工操纵，因此请小心使用</span>

<span class="k">block.number</span><span class="p">;</span><span class="w"> </span><span class="c1">// 当前区块号</span>
<span class="k">block.difficulty</span><span class="p">;</span><span class="w"> </span><span class="c1">// 当前区块难度</span>
<span class="k">block.blockhash</span><span class="p">(</span><span class="m m-Decimal">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// 返回 bytes32，只对最近 256 个区块有效</span>
<span class="k">block.gasLimit</span><span class="p">();</span>

<span class="c1">// ** 存储 - 持久化存储哈希 **</span>
storage<span class="p">[</span><span class="s1">&#39;abc&#39;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;def&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 256 位单词 到 256 位单词的映射</span>


<span class="c1">// 4. 函数及更多</span>
<span class="c1">// A. 函数</span>
<span class="c1">// 简单函数</span>
<span class="kt">function</span><span class="w"> </span><span class="nv">increment</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>x<span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">return</span><span class="w"> </span>x<span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 函数可以通过指定返回的参数名，来返回多个参数</span>
<span class="kt">function</span><span class="w"> </span><span class="nv">increment</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>x<span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
<span class="w">    </span>y<span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 调用前一个函数</span>
<span class="kt">uint</span><span class="w"> </span><span class="p">(</span>a<span class="p">,</span>b<span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>increment<span class="p">(</span><span class="m m-Decimal">1</span><span class="p">,</span><span class="m m-Decimal">1</span><span class="p">);</span>

<span class="c1">// &#39;view&#39; (&#39;constant&#39;的别名)</span>
<span class="c1">// 表明函数不会改变持久化的变量，View函数会本地执行，而不是链上运行。</span>
<span class="c1">// 注意：constant 关键字很快会废弃。</span>
<span class="kt">uint</span><span class="w"> </span><span class="nv">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>

<span class="kt">function</span><span class="w"> </span><span class="nv">increment</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>x<span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>
<span class="w">    </span>y<span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// 这一行会失败</span>
<span class="w">    </span><span class="c1">// y 是一个状态变量，不能在 view 的函数里改变 y</span>
<span class="p">}</span>

<span class="c1">// &#39;pure&#39; 比 &#39;view&#39; 或 &#39;constant&#39; 更加严格，甚至不允许读取状态变量</span>
<span class="c1">// 具体的规则很复杂，请参考</span>
<span class="c1">// view/pure:</span>
<span class="c1">// http://solidity.readthedocs.io/en/develop/contracts.html#view-functions</span>

<span class="c1">// &#39;函数可见性指示器&#39;</span>
<span class="c1">// &#39;view&#39;可以有以下修饰符，包括：</span>
<span class="c1">// public - 内部及外部可见（函数的默认值）</span>
<span class="c1">// external - 仅外部可见(包括 this 发起的调用)</span>
<span class="c1">// private - 仅当前合约可见</span>
<span class="c1">// internal - 仅当前合约及继承的合约可见</span>

<span class="c1">// 通常，显性的标记每个函数是个好主意</span>

<span class="c1">// 函数的挂起 - 可以将函数赋值给变量</span>
<span class="kt">function</span><span class="w"> </span><span class="nv">a</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">var</span><span class="w"> </span>z<span class="w"> </span><span class="o">=</span><span class="w"> </span>b<span class="p">;</span>
<span class="w">    </span>b<span class="p">();</span>
<span class="p">}</span>

<span class="kt">function</span><span class="w"> </span><span class="nv">b</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="p">}</span>

<span class="c1">// 所有接收 ether 的函数必须标记为 &#39;payable&#39;</span>
<span class="kt">function</span><span class="w"> </span><span class="nv">depositEther</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>balances<span class="p">[</span><span class="k">msg.sender</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="k">msg.value</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// 首选循环来递归（最大的调用堆栈深度是 1024），另外不要设置没有限制的循环，</span>
<span class="c1">// 因为这可能会达到 gas limit</span>

<span class="c1">// B. 事件</span>
<span class="c1">// 事件通知外部各方; 易于搜索和访问来自外部区块链（使用轻客户端）的事件</span>
<span class="c1">// 通常在合约参数之后声明</span>

<span class="c1">// 通常，首字母大写并在前面加上 Log ，防止与函数混淆</span>

<span class="c1">// 声明</span>
<span class="kt">event</span><span class="w"> </span><span class="nv">LogSent</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">indexed</span><span class="w"> </span>from<span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">indexed</span><span class="w"> </span>to<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">);</span><span class="w"> </span><span class="c1">// 注意 capital first letter</span>

<span class="c1">// 调用</span>
LogSent<span class="p">(</span>from<span class="p">,</span><span class="w"> </span>to<span class="p">,</span><span class="w"> </span>amount<span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">    // 对于外部方（合约或外部实体），使用 Web3 JavaScript 库来监听</span>
<span class="cm">    // 以下是JavaScript代码,不是Solidity代码</span>
<span class="cm">    Coin.LogSent().watch({}, &#39;&#39;, function(error, result) {</span>
<span class="cm">        if (!error) {</span>
<span class="cm">            console.log(&quot;Coin transfer: &quot; + result.args.amount +</span>
<span class="cm">                &quot; coins were sent from &quot; + result.args.from +</span>
<span class="cm">                &quot; to &quot; + result.args.to + &quot;.&quot;);</span>
<span class="cm">            console.log(&quot;Balances now:\n&quot; +</span>
<span class="cm">                &quot;Sender: &quot; + Coin.balances.call(result.args.from) +</span>
<span class="cm">                &quot;Receiver: &quot; + Coin.balances.call(result.args.to));</span>
<span class="cm">        }</span>
<span class="cm">    }</span>

<span class="cm">*/</span>

<span class="c1">// 一个合约依赖另一个合约的共同范例（例如，合约取决于另一个合约提供的当前汇率）</span>

<span class="c1">// C. 修饰器</span>
<span class="c1">// 修饰器验证函数的输入，例如最小余额或用户身份验证; 类似于其他语言的保护子句</span>

<span class="c1">// &#39;_&#39; （下划线）经常用在代码的最后一行，表明被调用的函数放在那里</span>
<span class="kt">modifier</span><span class="w"> </span>onlyAfter<span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">_time</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">require</span><span class="w"> </span><span class="p">(</span>now<span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span>_time<span class="p">);</span><span class="w"> </span>_<span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="kt">modifier</span><span class="w"> </span>onlyOwner<span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">require</span><span class="p">(</span><span class="k">msg.sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>owner<span class="p">)</span><span class="w"> </span>_<span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="c1">// 常用于状态机</span>
<span class="kt">modifier</span><span class="w"> </span>onlyIfStateA<span class="w"> </span><span class="p">(</span>State<span class="w"> </span>currState<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">require</span><span class="p">(</span>currState<span class="w"> </span><span class="o">==</span><span class="w"> </span>State<span class="p">.</span>A<span class="p">)</span><span class="w"> </span>_<span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="c1">// 修饰器紧跟在函数声明之后</span>
<span class="kt">function</span><span class="w"> </span><span class="nv">changeOwner</span><span class="p">(</span>newOwner<span class="p">)</span>
onlyAfter<span class="p">(</span>someTime<span class="p">)</span>
onlyOwner<span class="p">()</span>
onlyIfState<span class="p">(</span>State<span class="p">.</span>A<span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span>owner<span class="w"> </span><span class="o">=</span><span class="w"> </span>newOwner<span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 下划线可以包含在代码结束之前，但明显地返回将跳过后面的代码，因此谨慎使用</span>
<span class="kt">modifier</span><span class="w"> </span>checkValue<span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>_<span class="p">;</span>
<span class="w">    </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">msg.value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span>amount<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amountToRefund</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>amount<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="k">msg.value</span><span class="p">;</span>
<span class="w">        </span><span class="k">msg.sender</span><span class="p">.</span>transfer<span class="p">(</span>amountToRefund<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>


<span class="c1">// 6. 判断和循环</span>

<span class="c1">// 所有基本的逻辑判断都有效 - 包括 if else, for, while, break, continue</span>
<span class="c1">// return - 但不跳转</span>

<span class="c1">// 语法同 JavaScript, 但没有从非布尔值到布尔值的类型转换</span>
<span class="c1">// (必须使用比较操作符获得布尔变量值)</span>

<span class="c1">// 请注意由用户行为决定的循环 - 因为合约对于代码块具有最大量的 gas 限制 -</span>
<span class="c1">// 如果超过限制该代码则将失败</span>
<span class="c1">// 例如：</span>
<span class="kt">for</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"> </span>x<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>refundAddressList<span class="p">.</span>length<span class="p">;</span><span class="w"> </span>x<span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>refundAddressList<span class="p">[</span>x<span class="p">].</span>transfer<span class="p">(</span>SOME_AMOUNT<span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 上述两个错误:</span>
<span class="c1">// 1. 转账失败会阻塞循环完成，钱被占用</span>
<span class="c1">// 2. 该循环可能会很长（根据需要赔偿的用户数量而定），并且也可能由于超过一个区块最大 gas 限制</span>
<span class="c1">// 而总是失败。你应该让人们自己从他们的子账户取款并标记取款完成</span>
<span class="c1">// 例如，首选拉动式的付款，而不是推动式的付款</span>


<span class="c1">// 7. 对象与合约</span>

<span class="c1">// A. 调用外部合约</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">InfoFeed</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">info</span><span class="p">()</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">ret</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">return</span><span class="w"> </span><span class="m m-Decimal">42</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Consumer</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>InfoFeed<span class="w"> </span>feed<span class="p">;</span><span class="w"> </span><span class="c1">// 指向区块链上的一个合约</span>

<span class="w">    </span><span class="c1">// 设置 feed 为已存在的合约实例</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">setFeed</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">addr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 当心类型自动转换；不会调用构造函数</span>
<span class="w">        </span>feed<span class="w"> </span><span class="o">=</span><span class="w"> </span>InfoFeed<span class="p">(</span>addr<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 设置 feed 为一个合约的新实例</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">createNewFeed</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>feed<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span>InfoFeed<span class="p">();</span><span class="w"> </span><span class="c1">// 创建新实例，调用构造函数</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">callFeed</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 最后的括号调用合约，可选择的增加自定义的 ether 或 gas 价格</span>
<span class="w">        </span>feed<span class="p">.</span>info<span class="p">.</span>value<span class="p">(</span><span class="m m-Decimal">10</span><span class="p">).</span>gas<span class="p">(</span><span class="m m-Decimal">800</span><span class="p">)();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// B. 继承</span>

<span class="c1">// 和顺序有关，最后继承的合约（如 &#39;def&#39;）可以覆盖之前已继承合约的部分</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">MyContract</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>abc<span class="p">,</span><span class="w"> </span>def<span class="p">(</span><span class="s2">&quot;a custom argument to def&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="c1">// 覆盖函数</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">z</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">msg.sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>owner<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span>def<span class="p">.</span>z<span class="p">();</span><span class="w"> </span><span class="c1">// 调用覆盖的函数</span>
<span class="w">            </span>super<span class="p">.</span>z<span class="p">();</span><span class="w"> </span><span class="c1">// 调用继承的上层合约的函数</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 抽象函数</span>
<span class="kt">function</span><span class="w"> </span><span class="nv">someAbstractFunction</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">);</span>
<span class="c1">// 不可以编译，因此用在基础或抽象合约中，等待实现</span>

<span class="c1">// C. 导入</span>

<span class="kt">import</span><span class="w"> </span><span class="s2">&quot;filename&quot;</span><span class="p">;</span>
<span class="kt">import</span><span class="w"> </span><span class="s2">&quot;github.com/ethereum/dapp-bin/library/iterable_mapping.sol&quot;</span><span class="p">;</span>


<span class="c1">// 8. 其他关键字</span>

<span class="c1">// A. 自毁</span>
<span class="c1">// 自毁当前的合约，转账资金到一个地址（常常是创建者的地址）</span>
selfdestruct<span class="p">(</span>SOME_ADDRESS<span class="p">);</span>

<span class="c1">// 从当前或以后的区块中移除存储或代码，会帮助客户端瘦身，但之前的数据会永久在区块链中</span>

<span class="c1">// 常见模式，让所有者结束合约并收回剩余的资金</span>
<span class="kt">function</span><span class="w"> </span><span class="nv">remove</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">if</span><span class="p">(</span><span class="k">msg.sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>creator<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 只有合约的创建者可以这么做</span>
<span class="w">        </span>selfdestruct<span class="p">(</span>creator<span class="p">);</span><span class="w"> </span><span class="c1">// 自毁合约，返还资金</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 可能希望手动停用合约，而不是自毁</span>
<span class="c1">// (发送到自毁合约的 ether 会丢失掉)</span>


<span class="c1">// 9. 注意合约的设计</span>

<span class="c1">// A. 困惑</span>
<span class="c1">// 区块链上所有变量都是公开可见的，因此任何私有的需求变得很困惑。(好比哈希的秘密)</span>

<span class="c1">// 步骤: 1. 承诺某事, 2. 揭示承诺</span>
<span class="nb">keccak256</span><span class="p">(</span><span class="s2">&quot;some_bid_amount&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;some secret&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// commit</span>

<span class="c1">// 以后调用合约的 reveal 函数，展示出用 SHA3 哈希的 bid 加 secret</span>
reveal<span class="p">(</span><span class="m m-Decimal">100</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;mySecret&quot;</span><span class="p">);</span>

<span class="c1">// B. 存储优化</span>
<span class="c1">// 写入区块链可能很昂贵，因为数据是永久存储的；鼓励用巧妙的方法使用内存</span>
<span class="c1">//（最终，编译会更好，但现在有利于规划数据结构 - 并将最小数量存储在区块链中）</span>

<span class="c1">// 多维数组这样的变量可能会成本很高</span>
<span class="c1">// (成本用于存储数据 - 而不是声明未填充的变量)</span>

<span class="c1">// C. 区块链中的数据访问</span>
<span class="c1">// 不能限制人或计算机读取交易或交易状态的内容</span>

<span class="c1">// 然而 &#39;private&#39; 可以防止其他*合约*直接读取数据 - 任意其他方仍然可以从区块链读取数据</span>

<span class="c1">// 从开始的所有数据都存在区块链上，因此任何人都可以查看之前的所有数据和变化</span>

<span class="c1">// D. 定时任务</span>
<span class="c1">// 必须手动调用合约来处理时间相关的调度；也可以创建外部代码来定期的ping，</span>
<span class="c1">// 或为其他人提供激励（以太）</span>

<span class="c1">// E. 观察者模式</span>
<span class="c1">//观察者模式允许您注册为订阅者，然后注册一个由oracle调用的函数</span>
<span class="c1">//（注意，oracle 需要付费来运行此操作）。与 Pub / sub 中的订阅有些相似之处</span>

<span class="c1">// 这是一个抽象合约，包括客户端和服务器端的类的导入，客户端应该要实现</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">SomeOracleCallback</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">oracleCallback</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="nv">_value</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">_time</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">info</span><span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">contract</span><span class="w"> </span><span class="ni">SomeOracle</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>SomeOracleCallback<span class="p">[]</span><span class="w"> </span>callbacks<span class="p">;</span><span class="w"> </span><span class="c1">// 所有订阅者的数组</span>

<span class="w">    </span><span class="c1">// 注册订阅者</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">addSubscriber</span><span class="p">(</span>SomeOracleCallback<span class="w"> </span>a<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>callbacks<span class="p">.</span>push<span class="p">(</span>a<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">notify</span><span class="p">(</span>value<span class="p">,</span><span class="w"> </span>time<span class="p">,</span><span class="w"> </span>info<span class="p">)</span><span class="w"> </span><span class="kt">private</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">for</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span>i<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>callbacks<span class="p">.</span>length<span class="p">;</span><span class="w"> </span>i<span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 所有调用的订阅者必须实现 oracleCallback</span>
<span class="w">            </span>callbacks<span class="p">[</span>i<span class="p">].</span>oracleCallback<span class="p">(</span>value<span class="p">,</span><span class="w"> </span>time<span class="p">,</span><span class="w"> </span>info<span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">doSomething</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 实现的代码</span>

<span class="w">        </span><span class="c1">// 通知所有的订阅者</span>
<span class="w">        </span>notify<span class="p">(</span>_value<span class="p">,</span><span class="w"> </span>_time<span class="p">,</span><span class="w"> </span>_info<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 现在你的客户端合约可以通过 importing SomeOracleCallback 和注册某些 Oracle 来</span>
<span class="c1">// addSubscriber 添加订阅者</span>

<span class="c1">// F. 状态机</span>
<span class="c1">// 参见如下的例子，枚举类型的 State 和 修饰器 inState</span>


<span class="c1">// *** 例子: 众筹的例子（与 Kickstarter 大致相似）***</span>
<span class="c1">// ** 开始例子 **</span>

<span class="c1">// CrowdFunder.sol</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.4.19</span><span class="p">;</span>

<span class="c1">/// @title CrowdFunder</span>
<span class="c1">/// @author nemild</span>
<span class="c1">/// @translator bobjiang</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">CrowdFunder</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 由创建者创建的变量</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="k">public </span><span class="nv">creator</span><span class="p">;</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="k">public </span><span class="nv">fundRecipient</span><span class="p">;</span><span class="w"> </span><span class="c1">// 创建者可能和收件人不同</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">public </span><span class="nv">minimumToRaise</span><span class="p">;</span><span class="w"> </span><span class="c1">// 需要提示，否则每个人都会得到退款</span>
<span class="w">    </span><span class="kt">string</span><span class="w"> </span><span class="nv">campaignUrl</span><span class="p">;</span>
<span class="w">    </span>byte<span class="w"> </span><span class="kt">constant</span><span class="w"> </span>version<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 数据结构</span>
<span class="w">    </span><span class="kt">enum</span><span class="w"> </span><span class="nv">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span>Fundraising<span class="p">,</span>
<span class="w">        </span>ExpiredRefund<span class="p">,</span>
<span class="w">        </span>Successful
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">struct</span><span class="w"> </span><span class="nv">Contribution</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">;</span>
<span class="w">        </span><span class="kt">address</span><span class="w"> </span><span class="nv">contributor</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 状态变量State variables</span>
<span class="w">    </span>State<span class="w"> </span><span class="kt">public</span><span class="w"> </span>state<span class="w"> </span><span class="o">=</span><span class="w"> </span>State<span class="p">.</span>Fundraising<span class="p">;</span><span class="w"> </span><span class="c1">// 创建时实例化</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">public </span><span class="nv">totalRaised</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">public </span><span class="nv">raiseBy</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">public </span><span class="nv">completeAt</span><span class="p">;</span>
<span class="w">    </span>Contribution<span class="p">[]</span><span class="w"> </span>contributions<span class="p">;</span>

<span class="w">    </span><span class="kt">event</span><span class="w"> </span><span class="nv">LogFundingReceived</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">currentTotal</span><span class="p">);</span>
<span class="w">    </span><span class="kt">event</span><span class="w"> </span><span class="nv">LogWinnerPaid</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">winnerAddress</span><span class="p">);</span>

<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>inState<span class="p">(</span>State<span class="w"> </span>_state<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>state<span class="w"> </span><span class="o">==</span><span class="w"> </span>_state<span class="p">);</span>
<span class="w">        </span>_<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>isCreator<span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span><span class="k">msg.sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>creator<span class="p">);</span>
<span class="w">        </span>_<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 允许合约销毁之前，最终合约状态后要等待24周</span>
<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>atEndOfLifecycle<span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">require</span><span class="p">(((</span>state<span class="w"> </span><span class="o">==</span><span class="w"> </span>State<span class="p">.</span>ExpiredRefund<span class="w"> </span><span class="o">||</span><span class="w"> </span>state<span class="w"> </span><span class="o">==</span><span class="w"> </span>State<span class="p">.</span>Successful<span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">        </span>completeAt<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">24</span><span class="w"> </span>weeks<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>now<span class="p">));</span>
<span class="w">        </span>_<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">CrowdFunder</span><span class="p">(</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">timeInHoursForFundraising</span><span class="p">,</span>
<span class="w">        </span><span class="kt">string</span><span class="w"> </span><span class="nv">_campaignUrl</span><span class="p">,</span>
<span class="w">        </span><span class="kt">address</span><span class="w"> </span><span class="nv">_fundRecipient</span><span class="p">,</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">_minimumToRaise</span><span class="p">)</span>
<span class="w">        </span><span class="kt">public</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span>creator<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.sender</span><span class="p">;</span>
<span class="w">        </span>fundRecipient<span class="w"> </span><span class="o">=</span><span class="w"> </span>_fundRecipient<span class="p">;</span>
<span class="w">        </span>campaignUrl<span class="w"> </span><span class="o">=</span><span class="w"> </span>_campaignUrl<span class="p">;</span>
<span class="w">        </span>minimumToRaise<span class="w"> </span><span class="o">=</span><span class="w"> </span>_minimumToRaise<span class="p">;</span>
<span class="w">        </span>raiseBy<span class="w"> </span><span class="o">=</span><span class="w"> </span>now<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span>timeInHoursForFundraising<span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="w"> </span>hours<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">contribute</span><span class="p">()</span>
<span class="w">    </span><span class="kt">public</span>
<span class="w">    </span><span class="kt">payable</span>
<span class="w">    </span>inState<span class="p">(</span>State<span class="p">.</span>Fundraising<span class="p">)</span>
<span class="w">    </span><span class="kt">returns</span><span class="p">(</span><span class="kt">uint256</span><span class="w"> </span><span class="nv">id</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span>contributions<span class="p">.</span>push<span class="p">(</span>
<span class="w">            </span>Contribution<span class="p">({</span>
<span class="w">                </span>amount<span class="o">:</span><span class="w"> </span><span class="k">msg.value</span><span class="p">,</span>
<span class="w">                </span>contributor<span class="o">:</span><span class="w"> </span><span class="k">msg.sender</span>
<span class="w">            </span><span class="p">})</span><span class="w"> </span><span class="c1">// 采用数组，因此可以遍历</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">        </span>totalRaised<span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="k">msg.value</span><span class="p">;</span>

<span class="w">        </span>LogFundingReceived<span class="p">(</span><span class="k">msg.sender</span><span class="p">,</span><span class="w"> </span><span class="k">msg.value</span><span class="p">,</span><span class="w"> </span>totalRaised<span class="p">);</span>

<span class="w">        </span>checkIfFundingCompleteOrExpired<span class="p">();</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>contributions<span class="p">.</span>length<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// 返回 id</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">checkIfFundingCompleteOrExpired</span><span class="p">()</span>
<span class="w">    </span><span class="kt">public</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>totalRaised<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span>minimumToRaise<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span>state<span class="w"> </span><span class="o">=</span><span class="w"> </span>State<span class="p">.</span>Successful<span class="p">;</span>
<span class="w">            </span>payOut<span class="p">();</span>

<span class="w">            </span><span class="c1">// 可以激励在这里发起状态改变的人</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="kt">else</span><span class="w"> </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span>now<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span>raiseBy<span class="w"> </span><span class="p">)</span><span class="w">  </span><span class="p">{</span>
<span class="w">            </span>state<span class="w"> </span><span class="o">=</span><span class="w"> </span>State<span class="p">.</span>ExpiredRefund<span class="p">;</span><span class="w"> </span><span class="c1">// 支持者可以通过调用 getRefund(id) 收取退款</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span>completeAt<span class="w"> </span><span class="o">=</span><span class="w"> </span>now<span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">payOut</span><span class="p">()</span>
<span class="w">    </span><span class="kt">public</span>
<span class="w">    </span>inState<span class="p">(</span>State<span class="p">.</span>Successful<span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span>fundRecipient<span class="p">.</span>transfer<span class="p">(</span><span class="kt">this</span><span class="p">.</span>balance<span class="p">);</span>
<span class="w">        </span>LogWinnerPaid<span class="p">(</span>fundRecipient<span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">getRefund</span><span class="p">(</span><span class="kt">uint256</span><span class="w"> </span><span class="nv">id</span><span class="p">)</span>
<span class="w">    </span>inState<span class="p">(</span>State<span class="p">.</span>ExpiredRefund<span class="p">)</span>
<span class="w">    </span><span class="kt">public</span>
<span class="w">    </span><span class="kt">returns</span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>contributions<span class="p">.</span>length<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span>id<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>id<span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>contributions<span class="p">[</span>id<span class="p">].</span>amount<span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">amountToRefund</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>contributions<span class="p">[</span>id<span class="p">].</span>amount<span class="p">;</span>
<span class="w">        </span>contributions<span class="p">[</span>id<span class="p">].</span>amount<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span>

<span class="w">        </span>contributions<span class="p">[</span>id<span class="p">].</span>contributor<span class="p">.</span>transfer<span class="p">(</span>amountToRefund<span class="p">);</span>

<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">removeContract</span><span class="p">()</span>
<span class="w">    </span><span class="kt">public</span>
<span class="w">    </span>isCreator<span class="p">()</span>
<span class="w">    </span>atEndOfLifecycle<span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span>selfdestruct<span class="p">(</span><span class="k">msg.sender</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// 创建者获得所有未被声明的钱</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">// ** 结束例子 **</span>

<span class="c1">// 10. 其他原生的函数</span>

<span class="c1">// 货币单位</span>
<span class="c1">// 货币使用 wei 来定义，以太币的最小单位 = 1 wei;</span>
<span class="kt">uint</span><span class="w"> </span><span class="nv">minAmount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="w"> </span>wei<span class="p">;</span>
<span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="w"> </span>finney<span class="p">;</span><span class="w"> </span><span class="c1">// 1 ether == 1000 finney</span>
<span class="c1">// 其他单位，请参阅: http://ether.fund/tool/converter</span>

<span class="c1">// 时间单位</span>
<span class="m m-Decimal">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="w"> </span>second
<span class="m m-Decimal">1</span><span class="w"> </span>minutes<span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">60</span><span class="w"> </span>seconds

<span class="c1">// 可以乘以带时间单位的变量，因为单位不会存储在变量中</span>
<span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">5</span><span class="p">;</span>
<span class="p">(</span>x<span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="w"> </span>days<span class="p">);</span><span class="w"> </span><span class="c1">// 5 天</span>

<span class="c1">// 小心闰秒闰年与平等声明的时间</span>
<span class="c1">// (相反，首选大于或小于)</span>

<span class="c1">// 加密算法</span>
<span class="c1">// 传递的所有字符串在哈希操作之前需要连接在一起</span>
sha3<span class="p">(</span><span class="s2">&quot;ab&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;cd&quot;</span><span class="p">);</span>
ripemd160<span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">);</span>
sha256<span class="p">(</span><span class="s2">&quot;def&quot;</span><span class="p">);</span>

<span class="c1">// 11. 安全</span>

<span class="c1">// 以太坊的合约中，错误可能是灾难性的 - 即使在 Solidity 中是流行的模式，也可能发现是反模式的</span>

<span class="c1">// 参见文档底部的安全链接</span>

<span class="c1">// 12. 较低层次的函数</span>
<span class="c1">// call - 较低层次，不会经常使用，不提供类型安全性</span>
successBoolean<span class="w"> </span><span class="o">=</span><span class="w"> </span>someContractAddress<span class="p">.</span>call<span class="p">(</span><span class="s1">&#39;function_name&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;arg1&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;arg2&#39;</span><span class="p">);</span>

<span class="c1">// callcode - 在调用合约的*上下文*中执行的目标地址上的代码</span>
<span class="c1">// 提供库功能</span>
someContractAddress<span class="p">.</span>callcode<span class="p">(</span><span class="s1">&#39;function_name&#39;</span><span class="p">);</span>


<span class="c1">// 13. 注意风格</span>
<span class="c1">// 基于 Python 的 PEP8 风格指南</span>
<span class="c1">// 全部风格指南: http://solidity.readthedocs.io/en/develop/style-guide.html</span>

<span class="c1">// 快速总结:</span>
<span class="c1">// 4个空格缩进</span>
<span class="c1">// 两行隔开合约声明（和其他高级别的声明）</span>
<span class="c1">// 避免括号内留出多余的空格</span>
<span class="c1">// 可以省略一行语句的花括号 (if, for, 等)</span>
<span class="c1">// else 应该单独一行</span>


<span class="c1">// 14. NATSPEC 注释</span>
<span class="c1">// 用于文档、注释和外部UI</span>

<span class="c1">// 合约的 natspec - 总是在合约定义的上面</span>
<span class="c1">/// @title 合约标题</span>
<span class="c1">/// @author 作者名字</span>

<span class="c1">// 函数的 natspec</span>
<span class="c1">/// @notice 函数做什么的相关信息；展示什么时候执行该函数、</span>
<span class="c1">/// @dev 开发者使用的函数文档</span>

<span class="c1">// 函数参数、返回值的 natspec</span>
<span class="c1">/// @param 有关参数用途的描述</span>
<span class="c1">/// @return 返回值的描述</span>
</pre></div>
<h2>更多资源</h2>
<ul>
<li><a href="https://solidity.readthedocs.org/en/latest/">Solidity Docs</a></li>
<li><a href="https://github.com/ConsenSys/smart-contract-best-practices">Smart Contract Best Practices</a></li>
<li><a href="https://ethfiddle.com/">EthFiddle - The JsFiddle for Solidity</a></li>
<li><a href="https://remix.ethereum.org/">Browser-based Solidity Editor</a></li>
<li><a href="https://gitter.im/ethereum/solidity">Gitter Solidity Chat room</a></li>
<li><a href="https://docs.erisindustries.com/tutorials/solidity/">Modular design strategies for Ethereum Contracts</a></li>
</ul>
<h2>重要的库文件</h2>
<ul>
<li><a href="https://github.com/OpenZeppelin/zeppelin-solidity/">Zeppelin</a>: Libraries that provide common contract patterns (crowdfuding, safemath, etc)</li>
</ul>
<h2>示例合约</h2>
<ul>
<li><a href="https://github.com/ethereum/dapp-bin">Dapp Bin</a></li>
<li><a href="https://github.com/fivedogit/solidity-baby-steps/tree/master/contracts">Solidity Baby Step Contracts</a></li>
<li><a href="https://github.com/ConsenSys/dapp-store-contracts">ConsenSys Contracts</a></li>
<li><a href="http://dapps.ethercasts.com/">State of Dapps</a></li>
</ul>
<h2>安全</h2>
<ul>
<li><a href="https://blog.ethereum.org/2016/06/19/thinking-smart-contract-security/">Thinking About Smart Contract Security</a></li>
<li><a href="https://blog.ethereum.org/2016/06/10/smart-contract-security/">Smart Contract Security</a></li>
<li><a href="http://hackingdistributed.com/">Hacking Distributed Blog</a></li>
</ul>
<h2>风格</h2>
<ul>
<li><a href="http://solidity.readthedocs.io/en/latest/style-guide.html">Solidity Style Guide</a>: Ethereum's style guide is heavily derived from Python's <a href="https://www.python.org/dev/peps/pep-0008/">PEP 8</a> style guide.</li>
</ul>
<h2>编辑器</h2>
<ul>
<li><a href="https://github.com/ethereum/emacs-solidity">Emacs Solidity Mode</a></li>
<li><a href="https://github.com/tomlion/vim-solidity">Vim Solidity</a></li>
<li>Editor Snippets (<a href="https://gist.github.com/nemild/98343ce6b16b747788bc">Ultisnips format</a>)</li>
</ul>
<h2>Future to Dos</h2>
<ul>
<li>新关键字: protected, inheritable</li>
<li>常见设计模式列表 (throttling, RNG, version upgrade)</li>
<li>常见的安全反模式</li>
</ul>
<p>请随意发送 pull request 或者发邮件给作者  nemild -/at-/ gmail</p>
<p>或者发邮件给译者 jiangxb -/at-/ gmail.com</p>

        <hr>
        <p>
          有建议？或者发现什么错误？在GitHub上<a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">开一个issue</a>，或者发起<a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/zh-cn/solidity.md">pull request</a>！
        </p>
        <p class="contributed">
          原著Nemil Dalal，并由<a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/zh-cn/solidity.md">4个好心人</a>修改。
        </p>

        <footer>
          <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width: 0; width: 88px; height: 31px;" src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-sa.svg" /></a>
          <p>
            &copy; 2025
            <a href="https://www.nemil.com">Nemil Dalal</a>,
            Joseph Chow,
            <a href="https://github.com/varshard">Bhoomtawath Plinsut</a>,
            <a href="https://github.com/liushooter">Shooter</a>
          </p>
        </footer>
      </div>
    </div>
  </body>
</html>