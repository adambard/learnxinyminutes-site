<!DOCTYPE html>
<html lang="it">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-WXC8R75DEN');
    </script>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="Content-Language" content="it">
    <title>Learn Rust in Y Minutes</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto+Slab:wght@100..900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/screen.css">
    <link rel="stylesheet" href="/css/light.css">
    <link rel="stylesheet" href="/css/dark.css">

    <link rel="canonical" href="https://learnxinyminutes.com/it/rust/">
    <script>
      localStorage.removeItem("lxiym_theme");
    </script>
  </head>
  <body>
    <div class="container">
      <div class="share">
        <span class="sharemsg">
          <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fit%2Frust%2F&amp;text=Impara+X+in+Y+minuti%2C+dove+X%3DRust">
            Condividi questa pagina
          </a>
        </span>
        <span class='st_facebook_large' displayText='Facebook'></span>
        <span class='st_twitter_large' displayText='Tweet'></span>
      </div>
      <h1><a href="/">Impara X in Y minuti</a></h1>
      <h2>Dove X=Rust</h2>
      <p class="filelink">
        Scarica il codice sorgente:
        <a href="/it/files/rust.rs">rust.rs</a>
      </p>
      <div id="doc">
<p>Rust è un linguaggio di programmazione sviluppato da Mozilla Research.
Rust combina il controllo a basso livello sulle prestazioni con alcune comodità
ad alto livello e stringenti garanzie di sicurezza.</p>
<p>Rust raggiunge questi obiettivi senza richiedere la garbage collection né una grossa
libreria di supporto run-time, rendendo così possibile l'uso di librerie scritte in Rust
come rimpiazzo di librerie scritte in C.</p>
<p>La prima versione pubblica di Rust, la 0.1, è stata rilasciata nel gennaio 2012, e per 3 anni
lo sviluppo è proceduto così rapidamente che l'utilizzo delle versioni
stabili veniva scoraggiato, e piuttosto si consigliava di utilizzare le versioni notturne
(nightly build).</p>
<p>Il 15 maggio 2015, la versione 1.0 di Rust è stata rilasciata con la garanzia
che nelle successive versioni 1.x non ci sarebbero state modifiche che avrebbero reso
incompatibile il codice scritto per tale versione.
Nelle nightly build sono attualmente disponibili migliorie al tempo di compilazione
e ad altri aspetti del compilatore. Rust ha adottato un modello di rilascio a scaglioni
con rilasci regolari ogni sei settimane. Per esempio, la versione 1.1 beta è stata resa
disponibile contestualmente al rilascio della versione stabile 1.0.</p>
<p>Sebbene Rust sia un linguaggio di livello relativamente basso, Rust ha alcuni concetti
di programmazione funzionale che solitamente si trovano solo nei linguaggi di livello più alto.
Ciò rende Rust non solo veloce, ma anche facile ed comodo da usare.</p>
<div class="highlight"><pre lang="rust"><span class="c1">// I commenti che stanno su una sola riga sono fatti così...</span>
<span class="cm">/* ...mentre così sono fatti</span>
<span class="cm">i commenti che richiedono</span>
<span class="cm">più righe */</span>

<span class="c1">///////////////////</span>
<span class="c1">// 1. Fondamenti //</span>
<span class="c1">///////////////////</span>

<span class="c1">// Funzioni</span>
<span class="c1">// `i32` è il tipo per gli interi a 32-bit con segno</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">add2</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// return implicito (senza punto-e-virgola)</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>
<span class="p">}</span>

<span class="c1">// Funzione &quot;main&quot;</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Numeri //</span>

<span class="w">    </span><span class="c1">// Binding (ossia &quot;variabili&quot;) immutabili</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Suffissi intero/virgola mobile</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">13</span><span class="k">i32</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="p">:</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.3</span><span class="k">f64</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Inferenza di tipo</span>
<span class="w">    </span><span class="c1">// La maggior parte delle volte, il compilatore Rust può inferire</span>
<span class="w">    </span><span class="c1">// di quale tipo sia l&#39;espressione usata per inizializzare un binding,</span>
<span class="w">    </span><span class="c1">// e quindi non è necessario specificare esplicitamente il tipo.</span>
<span class="w">    </span><span class="c1">// In tutto questo tutorial, i tipi vengono specificati esplicitamente in molti posti,</span>
<span class="w">    </span><span class="c1">// ma solo a scopo dimostrativo. La maggior parte delle volte se ne potrebbe</span>
<span class="w">    </span><span class="c1">// fare a meno, grazie all&#39;inferenza di tipo.</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">implicito_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">implicito_f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.3</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Aritmetica</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">somma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">13</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Variabile mutevole</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">mutevole</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">mutevole</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">    </span><span class="n">mutevole</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Stringhe //</span>

<span class="w">    </span><span class="c1">// Letterali di stringa</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="kt">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Ciao mondo!&quot;</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Stampa</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{} {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// 1.3 Ciao mondo!</span>

<span class="w">    </span><span class="c1">// Una `String` – una stringa allocata nello heap</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Ciao mondo&quot;</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Uno slice (fetta) di stringa – una vista immutabile</span>
<span class="w">    </span><span class="c1">// all&#39;interno di un&#39;altra stringa.</span>
<span class="w">    </span><span class="c1">// Uno slice è una coppia immutabile di puntatori al buffer contenuto</span>
<span class="w">    </span><span class="c1">// nella stringa - non contiene dei caratteri, solo dei puntatori a</span>
<span class="w">    </span><span class="c1">// un buffer statico o a un buffer contenuto in un altro oggetto (in questo caso, `s`)</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s_slice</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="kt">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">;</span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{} - {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">s_slice</span><span class="p">);</span><span class="w"> </span><span class="c1">// Ciao mondo - Ciao mondo</span>

<span class="w">    </span><span class="c1">// Vettori/array //</span>

<span class="w">    </span><span class="c1">// Un array di lunghezza fissa</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">quattro_int</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span>

<span class="w">    </span><span class="c1">// Un array dinamico (vettore)</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">vettore</span><span class="p">:</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span>
<span class="w">    </span><span class="n">vettore</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Uno slice – una vista immutabile all&#39;interno di un vettore o di un array</span>
<span class="w">    </span><span class="c1">// E&#39; molto simile a uno slice di stringa, ma per i vettori</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">slice</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="p">[</span><span class="kt">i32</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vettore</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Usa `{:?}` per stampare qualcosa a scopo di debugging</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{:?} {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">vettore</span><span class="p">,</span><span class="w"> </span><span class="n">slice</span><span class="p">);</span><span class="w"> </span><span class="c1">// [1, 2, 3, 4, 5] [1, 2, 3, 4, 5]</span>

<span class="w">    </span><span class="c1">// Tuple //</span>

<span class="w">    </span><span class="c1">// Una tupla è un insieme ordinato di dimensione fissa di valori aventi tipi eventualmente diversi</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="kt">f64</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ciao&quot;</span><span class="p">,</span><span class="w"> </span><span class="mf">3.4</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Il `let` che destruttura</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{} {} {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"> </span><span class="c1">// 1 ciao 3.4</span>

<span class="w">    </span><span class="c1">// Indicizzazione</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// ciao</span>

<span class="w">    </span><span class="c1">/////////////</span>
<span class="w">    </span><span class="c1">// 2. Tipi //</span>
<span class="w">    </span><span class="c1">/////////////</span>

<span class="w">    </span><span class="c1">// Strutture</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Punto</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span>
<span class="w">        </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">origine</span><span class="p">:</span><span class="w"> </span><span class="nc">Punto</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Punto</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// Una struct con campi senza nome, chiamata ‘tuple struct’</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Punto2</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">);</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">origine2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Punto2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Enum basilare, analoga a quelle del linguaggio C</span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="nc">Direzione</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Sinistra</span><span class="p">,</span>
<span class="w">        </span><span class="n">Destra</span><span class="p">,</span>
<span class="w">        </span><span class="n">Su</span><span class="p">,</span>
<span class="w">        </span><span class="n">Giu</span><span class="p">,</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">su</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Direzione</span><span class="p">::</span><span class="n">Su</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Enum con campi</span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="nc">OpzionaleI32</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">UnI32</span><span class="p">(</span><span class="kt">i32</span><span class="p">),</span>
<span class="w">        </span><span class="n">Niente</span><span class="p">,</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">due</span><span class="p">:</span><span class="w"> </span><span class="nc">OpzionaleI32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OpzionaleI32</span><span class="p">::</span><span class="n">UnI32</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">niente</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OpzionaleI32</span><span class="p">::</span><span class="n">Niente</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Generici //</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">bar</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Questo è definito nella libreria standard come `Option`</span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="nc">Opzionale</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">QualcheValore</span><span class="p">(</span><span class="n">T</span><span class="p">),</span>
<span class="w">        </span><span class="n">NessunValore</span><span class="p">,</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Metodi //</span>

<span class="w">    </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// I metodi di oggetto prendono un parametro `self` esplicito</span>
<span class="w">        </span><span class="k">fn</span><span class="w"> </span><span class="nf">get_bar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">bar</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a_foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">bar</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a_foo</span><span class="p">.</span><span class="n">get_bar</span><span class="p">());</span><span class="w"> </span><span class="c1">// 1</span>

<span class="w">    </span><span class="c1">// I trait (tratti), noti come &quot;interfacce&quot; o &quot;mixin&quot; in altri linguaggi</span>

<span class="w">    </span><span class="k">trait</span><span class="w"> </span><span class="n">Maneggiamento</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">fn</span><span class="w"> </span><span class="nf">maneggia</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Maneggiamento</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">fn</span><span class="w"> </span><span class="nf">maneggia</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">bar</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">altro_foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">bar</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">altro_foo</span><span class="p">.</span><span class="n">maneggia</span><span class="p">());</span><span class="w"> </span><span class="c1">// Some(1)</span>

<span class="w">    </span><span class="c1">/////////////////////////</span>
<span class="w">    </span><span class="c1">// 3. Pattern matching //</span>
<span class="w">    </span><span class="c1">/////////////////////////</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OpzionaleI32</span><span class="p">::</span><span class="n">UnI32</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">OpzionaleI32</span><span class="p">::</span><span class="n">UnI32</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;E&#39; un i32: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">),</span>
<span class="w">        </span><span class="n">OpzionaleI32</span><span class="p">::</span><span class="n">Niente</span><span class="w">  </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Non vale niente!&quot;</span><span class="p">),</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Pattern matching avanzato</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">FooBar</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">OpzionaleI32</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FooBar</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">OpzionaleI32</span><span class="p">::</span><span class="n">UnI32</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="p">};</span>

<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">FooBar</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">OpzionaleI32</span><span class="p">::</span><span class="n">UnI32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span>
<span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;I numeri valgono zero!&quot;</span><span class="p">),</span>
<span class="w">        </span><span class="n">FooBar</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">n</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">OpzionaleI32</span><span class="p">::</span><span class="n">UnI32</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=&gt;</span>
<span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;I numeri sono identici&quot;</span><span class="p">),</span>
<span class="w">        </span><span class="n">FooBar</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">n</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">OpzionaleI32</span><span class="p">::</span><span class="n">UnI32</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span>
<span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Numeri diversi: {} {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">),</span>
<span class="w">        </span><span class="n">FooBar</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">_</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">OpzionaleI32</span><span class="p">::</span><span class="n">Niente</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span>
<span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Il secondo numbero non vale niente!&quot;</span><span class="p">),</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">///////////////////////////////////////////</span>
<span class="w">    </span><span class="c1">// 4. Flusso di controllo (Control flow) //</span>
<span class="w">    </span><span class="c1">///////////////////////////////////////////</span>

<span class="w">    </span><span class="c1">// Ciclo/iterazione con `for`</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Range</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="k">u32</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">print!</span><span class="p">(</span><span class="s">&quot;{} &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Stampa `0 1 2 3 4 5 6 7 8 9 `</span>

<span class="w">    </span><span class="c1">// `if`</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;La matematica funziona!&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Oh no...&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// `if` come espressione</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="s">&quot;bene&quot;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="s">&quot;male&quot;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// Ciclo `while`</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;L&#39;universo sta funzionando regolarmente.&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Ciclo infinito</span>
<span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Ciao!&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/////////////////////////////////////////////////</span>
<span class="w">    </span><span class="c1">// 5. La sicurezza della memoria e i puntatori //</span>
<span class="w">    </span><span class="c1">/////////////////////////////////////////////////</span>

<span class="w">    </span><span class="c1">// Puntatore posseduto (owned) – solamente una cosa sola per volta può ‘possedere’ questo puntatore</span>
<span class="w">    </span><span class="c1">// Ciò significa che quando il `Box` abbandona il suo scope, verrà automaticamente deallocato in sicurezza.</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">mio</span><span class="p">:</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="o">*</span><span class="n">mio</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// dereference</span>
<span class="w">    </span><span class="c1">// Qui, `adesso_e_mio` acquisisce la proprietà di `mio`. In altre parole, `mio` viene spostato.</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">adesso_e_mio</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mio</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">adesso_e_mio</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">adesso_e_mio</span><span class="p">);</span><span class="w"> </span><span class="c1">// 7</span>
<span class="w">    </span><span class="c1">// println!(&quot;{}&quot;, mio); // questo non compilerebbe perché `adesso_e_mio` adesso possiede il puntatore</span>

<span class="w">    </span><span class="c1">// Riferimento (reference) – un puntatore immutabile che si riferisce ad altri dati</span>
<span class="w">    </span><span class="c1">// Quando un riferimento viene preso a un valore, diciamo che quel valore</span>
<span class="w">    </span><span class="c1">// è stato ‘preso in prestito’ (borrowed).</span>
<span class="w">    </span><span class="c1">// Mentre un valore è preso in prestito immutabilmente, non può venire mutato né spostato.</span>
<span class="w">    </span><span class="c1">// Un prestito dura fino alla fine dello scope in cui è stato creato.</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">    </span><span class="n">var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ref_var</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">;</span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">var</span><span class="p">);</span><span class="w"> </span><span class="c1">// Diversamente da `mio`, `var` può ancora essere usato</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">ref_var</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// var = 5; // questo non compilerebbe, perché `var` è stato preso in prestito</span>
<span class="w">    </span><span class="c1">// *ref_var = 6; // neanche questo, perché `ref_var` è un riferimento immutabile</span>

<span class="w">    </span><span class="c1">// Riferimento immutabile</span>
<span class="w">    </span><span class="c1">// Mentre un valore è preso in presto mutevolmente, non può essere acceduto in nessun modo.</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">var2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ref_var2</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">var2</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">ref_var2</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">         </span><span class="c1">// &#39;*&#39; serve a puntare al binding var2, preso in presto mutevolmente</span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">ref_var2</span><span class="p">);</span><span class="w"> </span><span class="c1">// 6</span>
<span class="w">    </span><span class="c1">// var2 non compilerebbe. ref_var2 è di tipo &amp;mut i32, e quindi</span>
<span class="w">    </span><span class="c1">// immagazzina un riferimento a un i32, e non il valore stesso.</span>
<span class="w">    </span><span class="c1">// var2 = 2; // questo non compilerebbe, perché `var2` è stato preso in prestito</span>
<span class="p">}</span>
</pre></div>
<h2>Ulteriori letture</h2>
<p>C'è molto di più in Rust — questi sono solo i fondamenti di Rust, che servono a capire
le cose più importanti.</p>
<p>Purtroppo c'è pochissima documentazione in italiano, tra cui:
<a href="https://www.mozillaitalia.org/home/2015/05/30/primi-passi-con-rust/">mozillaitalia.org/home/2015/05/30/primi-passi-con-rust/</a></p>
<p>Però ce n'è parecchia in inglese. Per saperne di più, leggi <a href="http://doc.rust-lang.org/book/index.html">The Rust Programming
Language</a> e tieni d'occhio l'area di interesse di Reddit (subreddit)
<a href="http://reddit.com/r/rust">/r/rust</a>.</p>
<p>Puoi anche provare a programmare in varie versioni di Rust usando il compilatore online al sito ufficiale
<a href="https://play.rust-lang.org">Rust Playground</a>.</p>

        <hr>
        <p>
          Hai un suggerimento? Oppure una correzione? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Apri un issue</a> sul GitHub, o fa un <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/it/rust.md">pull request</a> da solo!
        </p>
        <p class="contributed">
          In origine contribuita da Carlo Milanesi, e modificata da <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/it/rust.md">5 contributore(i)</a>.
        </p>

        <footer>
          <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width: 0; width: 80px; height: 28px; padding-bottom: 5px;" src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-sa.svg" /></a>
          <p>
            &copy; 2025
            <a href="http://github.com/carlomilanesi">Carlo Milanesi</a>
          </p>
        </footer>
      </div>
    </div>
  </body>
</html>