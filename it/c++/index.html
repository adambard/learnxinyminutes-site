<!DOCTYPE html>
<html lang="it">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-WXC8R75DEN');
    </script>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="Content-Language" content="it">
    <title>Learn C++ in Y Minutes</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto+Slab:wght@100..900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/screen.css">
    <link rel="stylesheet" href="/css/light.css">
    <link rel="stylesheet" href="/css/dark.css">

    <link rel="canonical" href="https://learnxinyminutes.com/it/c++/">
    <script>
      localStorage.removeItem("lxiym_theme");
    </script>
  </head>
  <body>
    <div class="container">
      <div class="share">
        <span class="sharemsg">
          <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fit%2Fc%2B%2B%2F&amp;text=Impara+X+in+Y+minuti%2C+dove+X%3DC%2B%2B">
            Condividi questa pagina
          </a>
        </span>
        <span class='st_facebook_large' displayText='Facebook'></span>
        <span class='st_twitter_large' displayText='Tweet'></span>
      </div>
      <h1><a href="/">Impara X in Y minuti</a></h1>
      <h2>Dove X=C++</h2>
      <p class="filelink">
        Scarica il codice sorgente:
        <a href="/it/files/learncpp.cpp">learncpp.cpp</a>
      </p>
      <div id="doc">
<p>Il C++ è un linguaggio di programmazione il quale,
<a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">secondo il suo inventore Bjarne Stroustrup</a>,
è stato progettato per</p>
<ul>
<li>essere un &quot;miglior C&quot;</li>
<li>supportare l'astrazione dei dati</li>
<li>supportare la programmazione orientata agli oggetti</li>
<li>supportare la programmazione generica</li>
</ul>
<p>Nonostante la sintassi possa risultare più difficile o complessa di linguaggi più recenti,
è usato in maniera vasta poichè viene compilato in istruzioni macchina che possono
essere eseguite direttamente dal processore ed offre un controllo stretto sull'hardware (come il linguaggio C)
ed allo stesso tempo offre caratteristiche ad alto livello come i generici, le eccezioni, e le classi.
Questa combinazione di velocità e funzionalità rende il C++
uno dei più utilizzati linguaggi di programmazione.</p>
<div class="highlight"><pre lang="c++"><span class="c1">//////////////////</span>
<span class="c1">// Confronto con il C</span>
<span class="c1">//////////////////</span>

<span class="c1">// Il C++ è _quasi_ un superset del C e con esso condivide la sintassi di base per</span>
<span class="c1">// la dichiarazione di variabili, tipi primitivi, e funzioni.</span>

<span class="c1">// Proprio come nel C, l&#39;inizio del programma è una funzione chiamata</span>
<span class="c1">// main con un intero come tipo di ritorno,</span>
<span class="c1">// Questo valore serve come stato d&#39;uscita del programma.</span>
<span class="c1">// Vedi http://it.wikipedia.org/wiki/Valore_di_uscita per maggiori informazioni.</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Gli argomenti a linea di comando sono passati tramite argc e argv così come</span>
<span class="w">    </span><span class="c1">// avviene in C.</span>
<span class="w">    </span><span class="c1">// argc indica il numero di argomenti,</span>
<span class="w">    </span><span class="c1">// e argv è un array di stringhe in stile-C (char*)</span>
<span class="w">    </span><span class="c1">// che rappresenta gli argomenti.</span>
<span class="w">    </span><span class="c1">// Il primo argomento è il nome che è stato assegnato al programma.</span>
<span class="w">    </span><span class="c1">// argc e argv possono essere omessi se non hai bisogno di argomenti,</span>
<span class="w">    </span><span class="c1">// in questa maniera la funzione avrà int main() come firma.</span>

<span class="w">    </span><span class="c1">// Lo stato di uscita 0 indica successo.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Tuttavia, il C++ varia nei seguenti modi:</span>

<span class="c1">// In C++, i caratteri come letterali sono dei char.</span>
<span class="k">sizeof</span><span class="p">(</span><span class="sc">&#39;c&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span>

<span class="c1">// In C, i caratteri come letterali sono degli interi.</span>
<span class="k">sizeof</span><span class="p">(</span><span class="sc">&#39;c&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>


<span class="c1">// C++ ha prototipizzazione rigida</span>
<span class="kt">void</span><span class="w"> </span><span class="n">func</span><span class="p">();</span><span class="w"> </span><span class="c1">// funziona che non accetta argomenti</span>

<span class="c1">// In C</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">();</span><span class="w"> </span><span class="c1">// funzione che può accettare un qualsiasi numero di argomenti</span>

<span class="c1">// Usa nullptr invece di NULL in C++</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="c1">// Gli header C standard sono disponibili in C++,</span>
<span class="c1">// ma sono prefissati con &quot;c&quot; e non hanno il suffisso &quot;.h&quot;.</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdio&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Ciao, mondo!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">///////////////////////////////</span>
<span class="c1">// Overloading per le funzioni</span>
<span class="c1">//////////////////////////////</span>

<span class="c1">// Il C++ supporta l&#39;overloading per le funzioni</span>
<span class="c1">// sia dato che ogni funzione accetta parametri diversi.</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">myString</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Stringa %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">myString</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">myInt</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Il mio int è %d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">myInt</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;Ciao&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Viene chiamata void print(const char*)</span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span><span class="w"> </span><span class="c1">//  Viene chiamata void print(int)</span>
<span class="p">}</span>

<span class="c1">////////////////////////</span>
<span class="c1">// Argomenti di default</span>
<span class="c1">///////////////////////</span>

<span class="c1">// Puoi fornire argomenti di default per una funzione</span>
<span class="c1">// se non sono forniti dal chiamante.</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">faiQualcosaConInteri</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// fai qualcosa con gli interi qui</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">faiQualcosaConInteri</span><span class="p">();</span><span class="w">      </span><span class="c1">// a = 1,  b = 4</span>
<span class="w">    </span><span class="n">faiQualcosaConInteri</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w">    </span><span class="c1">// a = 20, b = 4</span>
<span class="w">    </span><span class="n">faiQualcosaConInteri</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// a = 20, b = 5</span>
<span class="p">}</span>

<span class="c1">// Gli argomenti di default devono essere alla fine della lista degli argomenti.</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">dichiarazioneInvalida</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="c1">// Errore!</span>
<span class="p">{</span>
<span class="p">}</span>


<span class="c1">/////////////</span>
<span class="c1">// Namespaces</span>
<span class="c1">/////////////</span>

<span class="c1">// I namespaces forniscono visibilità separata per dichiarazioni di variabili, funzioni,</span>
<span class="c1">// ed altro.</span>
<span class="c1">// I namespaces possono essere annidati.</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">Primo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Annidato</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Questa è Primo::Annidato::foo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// fine di namespace Annidato</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// fine di namespace Primo</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">Secondo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Questa è Secondo::foo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Questa è foo globale</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Include tutti i simboli del namespace Secondo nello scope attuale.</span>
<span class="w">    </span><span class="c1">// Osserva che chiamare semplicemente foo() non va più bene perché è ambiguo:</span>
<span class="w">    </span><span class="c1">// bisogna specificare se vogliamo chiamare foo definita nel namespace Secondo</span>
<span class="w">    </span><span class="c1">// o foo definita nel livello principale del programma.</span>

<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Secondo</span><span class="p">;</span>

<span class="w">    </span><span class="n">Secondo</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// stampa &quot;Questa è Secondo::foo&quot;</span>
<span class="w">    </span><span class="n">Primo</span><span class="o">::</span><span class="n">Annidato</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// stampa &quot;Questa è Primo::Annidato::foo&quot;</span>
<span class="w">    </span><span class="o">::</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// stampa &quot;Questa è foo globale&quot;</span>
<span class="p">}</span>

<span class="c1">///////////////</span>
<span class="c1">// Input/Output</span>
<span class="c1">///////////////</span>

<span class="c1">// L&#39;input e l&#39;output in C++ utilizza gli streams</span>
<span class="c1">// cin, cout, e cerr i quali rappresentano stdin, stdout, e stderr.</span>
<span class="c1">// &lt;&lt; è l&#39;operatore di inserzione &gt;&gt; è l&#39;operatore di estrazione.</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="c1"> // Include gli streams di I/O</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"> </span><span class="c1">// Gli streams sono nel namespace std (libreria standard)</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">myInt</span><span class="p">;</span>

<span class="w">   </span><span class="c1">// Stampa su stdout (o terminalee/schermo)</span>
<span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Inserisci il tuo numero preferito:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">   </span><span class="c1">// Prende l&#39;input</span>
<span class="w">   </span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">myInt</span><span class="p">;</span>

<span class="w">   </span><span class="c1">// cout può anche essere formattato</span>
<span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Il tuo numero preferito è &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myInt</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">   </span><span class="c1">// stampa &quot;Il tuo numero preferito è &lt;myInt&gt;&quot;</span>

<span class="w">    </span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Usato per messaggi di errore&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">////////////</span>
<span class="c1">// Stringhe</span>
<span class="c1">///////////</span>

<span class="c1">// Le stringhe in C++ sono oggetti ed hanno molte funzioni membro</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"> </span><span class="c1">// Anche le stringhe sono contenute nel namespace std (libreria standard)</span>

<span class="n">string</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Ciao&quot;</span><span class="p">;</span>
<span class="n">string</span><span class="w"> </span><span class="n">myOtherString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot; Mondo&quot;</span><span class="p">;</span>

<span class="c1">// + è usato per la concatenazione.</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">myOtherString</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;Ciao Mondo&quot;</span>

<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; Bella&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;Ciao Bella&quot;</span>

<span class="c1">// le stringhe in C++ possono essere modificate.</span>
<span class="n">myString</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot; Mario&quot;</span><span class="p">);</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myString</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;Ciao Mario&quot;</span>


<span class="c1">///////////////</span>
<span class="c1">// Riferimenti</span>
<span class="c1">//////////////</span>

<span class="c1">// Oltre ai puntatori come quelli in C,</span>
<span class="c1">// il C++ ha i _riferimenti_.</span>
<span class="c1">// Questi non sono tipi puntatori che non possono essere riassegnati una volta settati</span>
<span class="c1">// e non possono essere null.</span>
<span class="c1">// Inoltre, essi hanno la stessa sintassi della variabile stessa:</span>
<span class="c1">// * non è necessario per la dereferenziazione e</span>
<span class="c1">// &amp; (&quot;indirizzo di&quot;) non è usato per l&#39;assegnamento.</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="n">string</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Io sono foo&quot;</span><span class="p">;</span>
<span class="n">string</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Io sono bar&quot;</span><span class="p">;</span>


<span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">fooRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w"> </span><span class="c1">// Questo crea un riferimento a foo.</span>
<span class="n">fooRef</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;. Ciao!&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Modifica foo attraverso il riferimento</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fooRef</span><span class="p">;</span><span class="w"> </span><span class="c1">// Stampa &quot;Io sono foo. Ciao!&quot;</span>

<span class="c1">// Non riassegna &quot;fooRef&quot;. Questo è come scrivere &quot;foo = bar&quot;, e</span>
<span class="c1">//   foo == &quot;Io sono bar&quot;</span>
<span class="c1">// dopo questa riga.</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fooRef</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Stampa l&#39;indirizzo di foo</span>
<span class="n">fooRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fooRef</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Stampa lo stesso l&#39;indirizzo di foo</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fooRef</span><span class="p">;</span><span class="w">  </span><span class="c1">// Stampa &quot;Io sono bar&quot;</span>

<span class="c1">// L&#39;indirizzo di fooRef rimane lo stesso, ovvero si riferisce ancora a foo.</span>


<span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">barRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span><span class="w"> </span><span class="c1">// Crea un riferimento const a bar.</span>
<span class="c1">// Come in C, i valori const (i puntatori e i riferimenti) non possono essere modificati.</span>
<span class="n">barRef</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;. Ciao!&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Errore, i riferimenti const non possono essere modificati.</span>

<span class="c1">// Facciamo un piccolo excursus: prima di approfondire ancora i riferimenti, è necessario</span>
<span class="c1">// introdurre il concetto di oggetto temporaneo. Supponiamo di avere il seguente codice:</span>
<span class="n">string</span><span class="w"> </span><span class="nf">tempObjectFun</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="n">string</span><span class="w"> </span><span class="n">retVal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tempObjectFun</span><span class="p">();</span>

<span class="c1">// Nella seconda riga si ha che:</span>
<span class="c1">//   - un oggetto di tipo stringa viene ritornato da tempObjectFun</span>
<span class="c1">//   - viene costruita una nuova stringa, utilizzando l&#39;oggetto ritornato come</span>
<span class="c1">//     argomento per il costruttore</span>
<span class="c1">//   - l&#39;oggetto ritornato da tempObjectFun viene distrutto</span>
<span class="c1">// L&#39;oggetto ritornato da tempObjectFun viene detto oggetto temporaneo.</span>
<span class="c1">// Un oggetto temporaneo viene creato quando una funzione ritorna un oggetto, e viene</span>
<span class="c1">// distrutto quando l&#39;espressione che lo racchiude termina la sua esecuzione - questo</span>
<span class="c1">// comportamento viene definito dallo standard, ma i compilatori possono modificarlo</span>
<span class="c1">// a piacere. Cerca su google &quot;return value optimization&quot; se vuoi approfondire.</span>
<span class="c1">// Dunque nel seguente codice:</span>
<span class="n">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">(</span><span class="n">tempObjectFun</span><span class="p">()))</span>

<span class="c1">// dando per scontato che foo e bar esistano, l&#39;oggetto ritornato da tempObjectFun</span>
<span class="c1">// è passato a bar ed è distrutto prima dell&#39;invocazione di foo.</span>

<span class="c1">// Tornando ai riferimenti, c&#39;è un&#39;eccezione a quanto appena detto.</span>
<span class="c1">// Infatti un oggetto temporaneo &quot;viene distrutto quando l&#39;espressione</span>
<span class="c1">// che lo racchiude termina la sua esecuzione&quot;, tranne quando è legato ad un</span>
<span class="c1">// riferimento di tipo const. In tal caso la sua vita viene estesa per tutto</span>
<span class="c1">// lo scope attuale:</span>

<span class="kt">void</span><span class="w"> </span><span class="n">constReferenceTempObjectFun</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// constRef riceve l&#39;oggetto temporaneo, che non viene distrutto fino</span>
<span class="w">    </span><span class="c1">// alla fine di questa funzione.</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">constRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tempObjectFun</span><span class="p">();</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>

<span class="c1">// Un altro tipo di riferimento introdotto nel C++11 è specifico per gli</span>
<span class="c1">// oggetti temporanei. Non puoi dichiarare una variabile di quel tipo, ma</span>
<span class="c1">// ha la precedenza nella risoluzione degli overload:</span>

<span class="kt">void</span><span class="w"> </span><span class="n">someFun</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">  </span><span class="c1">// Riferimento normale</span>
<span class="kt">void</span><span class="w"> </span><span class="n">someFun</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">  </span><span class="c1">// Riferimento ad un oggetto temporaneo</span>

<span class="n">string</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>
<span class="n">someFun</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span><span class="w">  </span><span class="c1">// Chiama la versione con il riferimento normale</span>
<span class="n">someFun</span><span class="p">(</span><span class="n">tempObjectFun</span><span class="p">());</span><span class="w">  </span><span class="c1">// Chiama la versione con il riferimento temporaneo</span>

<span class="c1">// Ad esempio potrai vedere questi due costruttori per std::basic_string:</span>
<span class="n">basic_string</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">basic_string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
<span class="n">basic_string</span><span class="p">(</span><span class="n">basic_string</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>

<span class="c1">// L&#39;idea è che se noi costruiamo una nuova stringa a partire da un oggetto temporaneo</span>
<span class="c1">// (che in ogni caso verrà distrutto), possiamo avere un costruttore più efficiente</span>
<span class="c1">// che in un certo senso &quot;recupera&quot; parti di quella stringa temporanea.</span>
<span class="c1">// Ci si riferisce a questo concetto come &quot;move semantics&quot;.</span>

<span class="c1">/////////////////////</span>
<span class="c1">// Enum</span>
<span class="c1">/////////////////////</span>

<span class="c1">// Gli enum sono un modo per assegnare un valore ad una costante, e sono</span>
<span class="c1">// principalmente usati per rendere il codice più leggibile.</span>
<span class="k">enum</span><span class="w"> </span><span class="nc">ETipiMacchine</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">AlfaRomeo</span><span class="p">,</span>
<span class="w">  </span><span class="n">Ferrari</span><span class="p">,</span>
<span class="w">  </span><span class="n">SUV</span><span class="p">,</span>
<span class="w">  </span><span class="n">Panda</span>
<span class="p">};</span>

<span class="n">ETipiMacchine</span><span class="w"> </span><span class="nf">GetPreferredCarType</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ETipiMacchine</span><span class="o">::</span><span class="n">Ferrari</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Dal C++11 in poi c&#39;è un modo molto semplice per assegnare un tipo ad un enum,</span>
<span class="c1">// che può essere utile per la serializzazione dei dati o per convertire gli enum</span>
<span class="c1">// tra il tipo desiderato e le rispettive costanti.</span>
<span class="k">enum</span><span class="w"> </span><span class="nc">ETipiMacchine</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">uint8_t</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">AlfaRomeo</span><span class="p">,</span><span class="w"> </span><span class="c1">// 0</span>
<span class="w">  </span><span class="n">Ferrari</span><span class="p">,</span><span class="w"> </span><span class="c1">// 1</span>
<span class="w">  </span><span class="n">SUV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">254</span><span class="p">,</span><span class="w"> </span><span class="c1">// 254</span>
<span class="w">  </span><span class="n">Ibrida</span><span class="w"> </span><span class="c1">// 255</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">WriteByteToFile</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">InputValue</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Serializza InputValue in un file</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">WritePreferredCarTypeToFile</span><span class="p">(</span><span class="n">ETipiMacchine</span><span class="w"> </span><span class="n">InputCarType</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// L&#39;enum viene implicitamente convertito ad un uint8_t poiché</span>
<span class="w">    </span><span class="c1">// è stato dichiarato come tale</span>
<span class="w">    </span><span class="n">WriteByteToFile</span><span class="p">(</span><span class="n">InputCarType</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// D&#39;altro canto potresti voler evitare che un enum venga accidentalmente convertito</span>
<span class="c1">// in un intero o in un altro tipo, quindi è possibile create una classe enum che</span>
<span class="c1">// impedisce la conversione implicita.</span>
<span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">ETipiMacchine</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">uint8_t</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">AlfaRomeo</span><span class="p">,</span><span class="w"> </span><span class="c1">// 0</span>
<span class="w">  </span><span class="n">Ferrari</span><span class="p">,</span><span class="w"> </span><span class="c1">// 1</span>
<span class="w">  </span><span class="n">SUV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">254</span><span class="p">,</span><span class="w"> </span><span class="c1">// 254</span>
<span class="w">  </span><span class="n">Ibrida</span><span class="w"> </span><span class="c1">// 255</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">WriteByteToFile</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">InputValue</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Serializza InputValue in un file</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">WritePreferredCarTypeToFile</span><span class="p">(</span><span class="n">ETipiMacchine</span><span class="w"> </span><span class="n">InputCarType</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Il compilatore darà errore anche se ETipiMacchine è un uint8_t: questo</span>
<span class="w">    </span><span class="c1">// perchè abbiamo dichiarato l&#39;enum come &quot;enum class&quot;!</span>
<span class="w">    </span><span class="n">WriteByteToFile</span><span class="p">(</span><span class="n">InputCarType</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//////////////////////////////////////////////////</span>
<span class="c1">// Classi e programmazione orientata agli oggetti</span>
<span class="c1">/////////////////////////////////////////////////</span>

<span class="c1">// Primo esempio delle classi</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="c1">// Dichiara una classe.</span>
<span class="c1">// Le classi sono in genere dichiara in un header file (.h o .hpp).</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Cane</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Variabili e funzioni membro sono private di default.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">nome</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">peso</span><span class="p">;</span>

<span class="c1">// Tutti i membri dopo questo sono pubblici (public)</span>
<span class="c1">// finchè &quot;private:&quot; o &quot;protected:&quot; non compaiono.</span>
<span class="k">public</span><span class="o">:</span>

<span class="w">    </span><span class="c1">// Costruttore di default</span>
<span class="w">    </span><span class="n">Cane</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Dichiarazioni di funzioni membro (le implentazioni sono a seguito)</span>
<span class="w">    </span><span class="c1">// Nota che stiamo usando std::string invece di porre</span>
<span class="w">    </span><span class="c1">// using namespace std;</span>
<span class="w">    </span><span class="c1">// sopra.</span>
<span class="w">    </span><span class="c1">// Mai usare uno statement &quot;using namespace&quot; in uno header.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">impostaNome</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">nomeCane</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">impostaPeso</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">pesoCane</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Le funzioni che non modificano lo stato dell&#39;oggetto</span>
<span class="w">    </span><span class="c1">// dovrebbero essere marcate come const.</span>
<span class="w">    </span><span class="c1">// Questo permette di chiamarle con un riferimento const all&#39;oggetto.</span>
<span class="w">    </span><span class="c1">// Inoltre, nota che le funzioni devono essere dichiarate espliciamente come _virtual_</span>
<span class="w">    </span><span class="c1">// per essere sovrascritte in classi derivate.</span>
<span class="w">    </span><span class="c1">// Le funzioni non sono virtual di default per motivi di performance.</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Le funzioni possono essere definite anche all&#39;interno del corpo della classe.</span>
<span class="w">    </span><span class="c1">// Le funzioni definite in questo modo sono automaticamente inline.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">abbaia</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">nome</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; abbaia!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Assieme con i costruttori, il C++ fornisce i distruttori.</span>
<span class="w">    </span><span class="c1">// Questi sono chiamati quando un oggetto è rimosso o esce dalla visibilità.</span>
<span class="w">    </span><span class="c1">// Questo permette paradigmi potenti come il RAII</span>
<span class="w">    </span><span class="c1">// (vedi sotto)</span>
<span class="w">    </span><span class="c1">// I distruttori devono essere virtual per permettere a classi di essere</span>
<span class="w">    </span><span class="c1">// derivate da questa; altrimenti, il distruttore della classe derivata</span>
<span class="w">    </span><span class="c1">// non viene chiamato se l&#39;oggetto viene distrutto tramite un riferimento alla</span>
<span class="w">    </span><span class="c1">// classe da cui ha ereditato o tramite un puntatore.</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Dog</span><span class="p">();</span>

<span class="p">};</span><span class="w"> </span><span class="c1">// Un punto e virgola deve seguire la definizione della funzione</span>

<span class="c1">// Le funzioni membro di una classe sono generalmente implementate in files .cpp .</span>
<span class="n">Cane</span><span class="o">::</span><span class="n">Cane</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Un cane è stato costruito</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Gli oggetti (ad esempio le stringhe) devono essere passati per riferimento</span>
<span class="c1">// se li stai modificando o come riferimento const altrimenti.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">Cane</span><span class="o">::</span><span class="n">impostaNome</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">nomeCane</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">nome</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nomeCane</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">Cane</span><span class="o">::</span><span class="n">impostaPeso</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">pesoCane</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">peso</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pesoCane</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Notare che &quot;virtual&quot; è solamente necessario nelle dichiarazioni, non nelle definizioni.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">Cane</span><span class="o">::</span><span class="n">print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Il cane è &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">nome</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; e pesa &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">peso</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;kg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Cane</span><span class="o">::~</span><span class="n">Cane</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Ciao ciao &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">nome</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Cane</span><span class="w"> </span><span class="n">myDog</span><span class="p">;</span><span class="w"> </span><span class="c1">// stampa &quot;Un cane è stato costruito&quot;</span>
<span class="w">    </span><span class="n">myDog</span><span class="p">.</span><span class="n">impostaNome</span><span class="p">(</span><span class="s">&quot;Barkley&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">myDog</span><span class="p">.</span><span class="n">impostaPeso</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="n">myDog</span><span class="p">.</span><span class="n">print</span><span class="p">();</span><span class="w"> </span><span class="c1">// stampa &quot;Il cane è Barkley e pesa 10 kg&quot;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// stampa &quot;Ciao ciao Barkley&quot;</span>

<span class="c1">// Ereditarietà:</span>

<span class="c1">// Questa classe eredita tutto ciò che è public e protected dalla classe Cane,</span>
<span class="c1">// ma anche ciò che privato: tuttavia non potrà accedere direttamente a membri/metodi</span>
<span class="c1">// privati se non c&#39;è un metodo pubblico o privato che permetta di farlo.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MioCane</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Cane</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">impostaProprietario</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">proprietarioCane</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Sovrascrivi il comportamento della funzione print per tutti i MioCane. Vedi</span>
<span class="w">    </span><span class="c1">// http://it.wikipedia.org/wiki/Polimorfismo_%28informatica%29</span>
<span class="w">    </span><span class="c1">// per una introduzione più generale se non sei familiare con</span>
<span class="w">    </span><span class="c1">// il polimorfismo.</span>
<span class="w">    </span><span class="c1">// La parola chiave override è opzionale ma fa sì che tu stia effettivamente</span>
<span class="w">    </span><span class="c1">// sovrascrivendo il metodo nella classe base.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">proprietario</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Nel frattempo, nel file .cpp corrispondente:</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">MioCane::impostaProprietario</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">proprietarioCane</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">proprietario</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">proprietarioCane</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">MioCane::print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Cane</span><span class="o">::</span><span class="n">print</span><span class="p">();</span><span class="w"> </span><span class="c1">// Chiama la funzione print nella classe base Cane</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Il cane è di &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">proprietario</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// stampa &quot;Il cane è &lt;nome&gt; e pesa &lt;peso&gt;&quot;</span>
<span class="w">    </span><span class="c1">//        &quot;Il cane è di &lt;proprietario&gt;&quot;</span>
<span class="p">}</span>

<span class="c1">///////////////////////////////////////////////////</span>
<span class="c1">// Inizializzazione ed Overloading degli Operatori</span>
<span class="c1">//////////////////////////////////////////////////</span>

<span class="c1">// In C++ puoi sovrascrivere il comportamento di operatori come +, -, *, /, ecc...</span>
<span class="c1">// Questo è possibile definendo una funzione che viene chiamata</span>
<span class="c1">// ogniqualvolta l&#39;operatore è usato.</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Punto</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// Così si assegna alle variabili membro un valore di default.</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Definisce un costruttore di default che non fa nulla</span>
<span class="w">    </span><span class="c1">// ma inizializza il Punto ai valori di default (0, 0)</span>
<span class="w">    </span><span class="n">Punto</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// La sintassi seguente è nota come lista di inizializzazione</span>
<span class="w">    </span><span class="c1">// ed è il modo appropriato di inizializzare i valori membro della classe</span>
<span class="w">    </span><span class="n">Punto</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">        </span><span class="n">x</span><span class="p">(</span><span class="n">a</span><span class="p">),</span>
<span class="w">        </span><span class="n">y</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="cm">/* Non fa nulla eccetto inizializzare i valori */</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Sovrascrivi l&#39;operatore +.</span>
<span class="w">    </span><span class="n">Punto</span><span class="w"> </span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Punto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Sovrascrivi l&#39;operatore +=</span>
<span class="w">    </span><span class="n">Punto</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Punto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Avrebbe senso aggiungere gli operatori - e -=,</span>
<span class="w">    </span><span class="c1">// ma li saltiamo per rendere la guida più breve.</span>
<span class="p">};</span>

<span class="n">Punto</span><span class="w"> </span><span class="n">Punto</span><span class="o">::</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Punto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Crea un nuovo punto come somma di questo e di rhs.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Punto</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Punto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Punto</span><span class="o">::</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Punto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Punto</span><span class="w"> </span><span class="nf">su</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">Punto</span><span class="w"> </span><span class="nf">destro</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Questo chiama l&#39;operatore + di Punto</span>
<span class="w">    </span><span class="c1">// Il Punto su chiama la funzione + con destro come argomento</span>
<span class="w">    </span><span class="n">Punto</span><span class="w"> </span><span class="n">risultato</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">su</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">destro</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Stampa &quot;Risultato è spostato in (1,1)&quot;</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Risultato è spostato (&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">risultato</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;,&#39;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">risultato</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/////////////////</span>
<span class="c1">// Templates</span>
<span class="c1">////////////////</span>

<span class="c1">// Generalmente i templates in C++ sono utilizzati per programmazione generica, anche se</span>
<span class="c1">// sono molto più potenti dei costrutti generici in altri linguaggi. Inoltre,</span>
<span class="c1">// supportano specializzazione esplicita e parziale, classi in stile funzionale,</span>
<span class="c1">// e sono anche complete per Turing.</span>

<span class="c1">// Iniziamo con il tipo di programmazione generica con cui forse sei familiare. Per</span>
<span class="c1">// definire una classe o una funzione che prende un parametro di un dato tipo:</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Box</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// In questa classe, T può essere usato come qualsiasi tipo.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">inserisci</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Durante la compilazione, il compilatore in effetti genera copie di ogni template</span>
<span class="c1">// con i parametri sostituiti, e così la definizione completa della classe deve essere</span>
<span class="c1">// presente ad ogni invocazione. Questo è il motivo per cui vedrai le classi template definite</span>
<span class="c1">// interamente in header files.</span>

<span class="c1">// Per instanziare una classe template sullo stack:</span>
<span class="n">Box</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">intBox</span><span class="p">;</span>

<span class="c1">// e puoi usarla come aspettato:</span>
<span class="n">intBox</span><span class="p">.</span><span class="n">inserisci</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>

<span class="c1">//Puoi, ovviamente, innestare i templates:</span>
<span class="n">Box</span><span class="o">&lt;</span><span class="n">Box</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">boxOfBox</span><span class="p">;</span>
<span class="n">boxOfBox</span><span class="p">.</span><span class="n">inserisci</span><span class="p">(</span><span class="n">intBox</span><span class="p">);</span>

<span class="c1">// Fino al C++11, devi porre uno spazio tra le due &#39;&gt;&#39;, altrimenti &#39;&gt;&gt;&#39;</span>
<span class="c1">// viene visto come l&#39;operatore di shift destro.</span>

<span class="c1">// Qualche volta vedrai</span>
<span class="c1">// template&lt;typename T&gt;</span>
<span class="c1">// invece. La parole chiavi &#39;class&#39; e &#39;typename&#39; sono _generalmente_</span>
<span class="c1">// intercambiabili in questo caso. Per una spiegazione completa, vedi</span>
<span class="c1">// http://en.wikipedia.org/wiki/Typename</span>
<span class="c1">// (si, quella parola chiave ha una sua pagina di Wikipedia propria).</span>

<span class="c1">// Similmente, una funzione template:</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">abbaiaTreVolte</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">input</span><span class="p">.</span><span class="n">abbaia</span><span class="p">();</span>
<span class="w">    </span><span class="n">input</span><span class="p">.</span><span class="n">abbaia</span><span class="p">();</span>
<span class="w">    </span><span class="n">input</span><span class="p">.</span><span class="n">abbaia</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Nota che niente è specificato relativamente al tipo di parametri. Il compilatore</span>
<span class="c1">// genererà  e poi verificherà il tipo di ogni invocazione del template, così che</span>
<span class="c1">// la funzione di cui sopra funzione con ogni tipo &#39;T&#39; che ha const &#39;abbaia&#39; come metodo!</span>

<span class="n">Cane</span><span class="w"> </span><span class="n">fluffy</span><span class="p">;</span>
<span class="n">fluffy</span><span class="p">.</span><span class="n">impostaNome</span><span class="p">(</span><span class="s">&quot;Fluffy&quot;</span><span class="p">)</span>
<span class="n">abbaiaTreVolte</span><span class="p">(</span><span class="n">fluffy</span><span class="p">);</span><span class="w"> </span><span class="c1">// Stampa &quot;Fluffy abbaia&quot; tre volte.</span>

<span class="c1">// I parametri template non devono essere classi:</span>
<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">Y</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">stampaMessaggio</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Impara il C++ in &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; minuti!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// E poi esplicitamente specializzare i template per avere codice più efficiente. Ovviamente,</span>
<span class="c1">// la maggior parte delle casistiche reali non sono così triviali.</span>
<span class="c1">// Notare che avrai comunque bisogna di dichiarare la funzione (o classe) come un template</span>
<span class="c1">// anche se hai esplicitamente specificato tutti i parametri.</span>
<span class="k">template</span><span class="o">&lt;&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">stampaMessaggio</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Impara il C++ più velocemente in soli 10 minuti!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">printMessage</span><span class="o">&lt;</span><span class="mi">20</span><span class="o">&gt;</span><span class="p">();</span><span class="w">  </span><span class="c1">// Stampa &quot;impara il C++ in 20 minuti!&quot;</span>
<span class="n">printMessage</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span><span class="p">();</span><span class="w">  </span><span class="c1">// Stampa &quot;Impara il C++ più velocemente in soli 10 minuti!&quot;                                   </span>

<span class="c1">////////////////////////////</span>
<span class="c1">// Gestione delle eccezioni</span>
<span class="c1">///////////////////////////</span>

<span class="c1">// La libreria standard fornisce un paio di tipi d&#39;eccezioni</span>
<span class="c1">// (vedi http://en.cppreference.com/w/cpp/error/exception)</span>
<span class="c1">// ma ogni tipo può essere lanciato come eccezione</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exception&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdexcept&gt;</span>

<span class="c1">// Tutte le eccezioni lanciate all&#39;interno del blocco _try_ possono essere catturate dai successivi</span>
<span class="c1">// handlers _catch_.</span>
<span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Non allocare eccezioni nello heap usando _new_.</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;C&#39;è stato un problema.&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Cattura le eccezioni come riferimenti const se sono oggetti</span>
<span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Cattura ogni eccezioni non catturata dal blocco _catch_ precedente</span>
<span class="k">catch</span><span class="w"> </span><span class="p">(...)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Catturata un&#39;eccezione sconosciuta&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">throw</span><span class="p">;</span><span class="w"> </span><span class="c1">// Rilancia l&#39;eccezione</span>
<span class="p">}</span>

<span class="c1">///////</span>
<span class="c1">// RAII</span>
<span class="c1">///////</span>

<span class="c1">// RAII sta per &quot;Resource Allocation Is Initialization&quot;.</span>
<span class="c1">// Spesso viene considerato come il più potente paradigma in C++.</span>
<span class="c1">// È un concetto semplice: un costruttore di un oggetto</span>
<span class="c1">// acquisisce le risorse di tale oggetto ed il distruttore le rilascia.</span>

<span class="c1">// Per comprendere come questo sia vantaggioso,</span>
<span class="c1">// consideriamo una funzione che usa un gestore di file in C:</span>
<span class="kt">void</span><span class="w"> </span><span class="n">faiQualcosaConUnFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">nomefile</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Per cominciare, assumiamo che niente possa fallire.</span>

<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">nomefile</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Apri il file in modalità lettura.</span>

<span class="w">    </span><span class="n">faiQualcosaConIlFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="n">faiQualcosAltroConEsso</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Chiudi il gestore di file.</span>
<span class="p">}</span>

<span class="c1">// Sfortunatamente, le cose vengono complicate dalla gestione degli errori.</span>
<span class="c1">// Supponiamo che fopen fallisca, e che faiQualcosaConUnFile e</span>
<span class="c1">// faiQualcosAltroConEsso ritornano codici d&#39;errore se falliscono.</span>
<span class="c1">//  (Le eccezioni sono la maniera preferita per gestire i fallimenti,</span>
<span class="c1">//   ma alcuni programmatori, specialmente quelli con un passato in C,</span>
<span class="c1">//   non sono d&#39;accordo con l&#39;utilità delle eccezioni).</span>
<span class="c1">// Adesso dobbiamo verificare che ogni chiamata per eventuali fallimenti e chiudere il gestore di file</span>
<span class="c1">// se un problema è avvenuto.</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">faiQualcosaConUnFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">nomefile</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">nomefile</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Apre il file in modalità lettura</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fh</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="c1">// Il puntatore restituito è null in caso di fallimento.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Riporta il fallimento al chiamante.</span>

<span class="w">    </span><span class="c1">// Assumiamo che ogni funzione ritorni false se ha fallito</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">faiQualcosaConIlFile</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Chiude il gestore di file così che non sprechi memoria.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Propaga l&#39;errore.</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">faiQualcosAltroConEsso</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Chiude il gestore di file così che non sprechi memoria.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Propaga l&#39;errore.</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Chiudi il gestore di file così che non sprechi memoria.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// Indica successo</span>
<span class="p">}</span>

<span class="c1">// I programmatori C in genere puliscono questa procedura usando goto:</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">faiQualcosaConUnFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">nomefile</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">nomefile</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fh</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">faiQualcosaConIlFile</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">fallimento</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">faiQualcosAltroConEsso</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">fallimento</span><span class="p">;</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Chiude il file</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// Indica successo</span>

<span class="nl">fallimento</span><span class="p">:</span>
<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Propaga l&#39;errore</span>
<span class="p">}</span>

<span class="c1">// Se le funzioni indicano errori usando le eccezioni,</span>
<span class="c1">// le cose sono un pò più pulite, ma sono sempre sub-ottimali.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">faiQualcosaConUnFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">nomefile</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">nomefile</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Apre il file in modalità lettura</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fh</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Errore nell&#39;apertura del file.&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">faiQualcosaConIlFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">        </span><span class="n">faiQualcosAltroConEsso</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">catch</span><span class="w"> </span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Fai sì che il file venga chiuso se si ha un errore.</span>
<span class="w">        </span><span class="k">throw</span><span class="p">;</span><span class="w"> </span><span class="c1">// Poi rilancia l&#39;eccezione.</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Chiudi il file</span>
<span class="w">    </span><span class="c1">// Tutto è andato bene</span>
<span class="p">}</span>

<span class="c1">// Confronta questo con l&#39;utilizzo della classe C++ file stream (fstream)</span>
<span class="c1">// fstream usa i distruttori per chiudere il file.</span>
<span class="c1">// Come detto sopra, i distruttori sono automaticamente chiamati</span>
<span class="c1">// ogniqualvolta un oggetto esce dalla visibilità.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">faiQualcosaConUnFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">nomefile</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// ifstream è l&#39;abbreviazione di input file stream</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span><span class="w"> </span><span class="nf">fh</span><span class="p">(</span><span class="n">nomefile</span><span class="p">);</span><span class="w"> </span><span class="c1">// Apre il file</span>

<span class="w">    </span><span class="c1">// Fai qualcosa con il file</span>
<span class="w">    </span><span class="n">faiQualcosaConIlFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="n">faiQualcosAltroConEsso</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// Il file viene chiuso automaticamente chiuso qui dal distruttore</span>

<span class="c1">// Questo ha vantaggi _enormi_:</span>
<span class="c1">// 1. Può succedere di tutto ma</span>
<span class="c1">//    la risorsa (in questo caso il file handler) verrà ripulito.</span>
<span class="c1">//    Una volta che scrivi il distruttore correttamente,</span>
<span class="c1">//    È _impossibile_ scordarsi di chiudere l&#39;handler e sprecare memoria.</span>
<span class="c1">// 2. Nota che il codice è molto più pulito.</span>
<span class="c1">//    Il distruttore gestisce la chiusura del file dietro le scene</span>
<span class="c1">//    senza che tu debba preoccupartene.</span>
<span class="c1">// 3. Il codice è sicuro da eccezioni.</span>
<span class="c1">//    Una eccezione può essere lanciata in qualunque punto nella funzione e la ripulitura</span>
<span class="c1">//    avverrà lo stesso.</span>

<span class="c1">// Tutto il codice C++ idiomatico usa RAII in maniera vasta su tutte le risorse.</span>
<span class="c1">// Esempi aggiuntivi includono</span>
<span class="c1">// - Utilizzo della memoria con unique_ptr e shared_ptr</span>
<span class="c1">// - I contenitori - la lista della libreria standard,</span>
<span class="c1">//   vettori (i.e. array auto-aggiustati), mappe hash, e così via</span>
<span class="c1">//   sono tutti automaticamente distrutti con i loro contenuti quando escono dalla visibilità.</span>
<span class="c1">// - I mutex usano lock_guard e unique_lock</span>

<span class="c1">// I contenitori che utilizzano chiavi non-primitive (classi personalizzate)</span>
<span class="c1">// richiedono la funzione di confronto nell&#39;oggetto stesso, o tramite un puntatore a funzione.</span>
<span class="c1">// Le chiavi primitive hanno funzioni di confronto già definite, ma puoi sovrascriverle.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">    </span><span class="n">Foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">j</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">funzioneDiConfronto</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">Foo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Foo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">j</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="c1">// Questo non è permesso, anche se qualche compilatore potrebbe non dare problemi</span>
<span class="c1">//std::map&lt;Foo, int&gt; fooMap;</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">funzioneDiConfronto</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fooMap</span><span class="p">;</span>
<span class="n">fooMap</span><span class="p">[</span><span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">fooMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w"> </span><span class="o">--</span><span class="w"> </span><span class="n">vero</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Espressioni Lambda (C++11 e superiori)</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// Le espressioni lambda (più semplicemente &quot;lambda&quot;) sono utilizzate</span>
<span class="c1">// per definire una funzione anonima nel punto in cui viene invocata, o</span>
<span class="c1">// dove viene passata come argomento ad una funzione</span>

<span class="c1">// Ad esempio, consideriamo l&#39;ordinamento di un vettore costituito da una</span>
<span class="c1">// coppia di interi, utilizzando il secondo elemento per confrontare</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">tester</span><span class="p">;</span>
<span class="n">tester</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">));</span>
<span class="n">tester</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">));</span>
<span class="n">tester</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span>

<span class="c1">// Passiamo una lambda come terzo argomento alla funzione di ordinamento</span>
<span class="c1">// `sort` è contenuta nell&#39;header &lt;algorithm&gt;</span>
<span class="n">sort</span><span class="p">(</span><span class="n">tester</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">tester</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">lhs</span><span class="p">.</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<span class="p">});</span>

<span class="c1">// Nota bene la sintassi utilizzata nelle lambda:</span>
<span class="c1">// [] serve per &quot;catturare&quot; le variabili.</span>
<span class="c1">// La &quot;Lista di Cattura&quot; definisce tutte le variabili esterne che devono essere disponibili</span>
<span class="c1">// all&#39;interno della funzione, e in che modo.</span>
<span class="c1">// La lista può contenere:</span>
<span class="c1">//     1. un valore: [x]</span>
<span class="c1">//     2. un riferimento: [&amp;x]</span>
<span class="c1">//     3. qualunque variabile nello scope corrente, per riferimento [&amp;]</span>
<span class="c1">//     4. qualunque variabile nello scope corrente, per valore [=]</span>
<span class="c1">// Esempio:</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">id_cani</span><span class="p">;</span>
<span class="c1">// numero_cani = 3;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">id_cani</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">pesi</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">30</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">};</span>

<span class="c1">// Mettiamo che vuoi ordinare id_cani in base al peso dei cani</span>
<span class="c1">// Alla fine, id_cani sarà: [2, 0, 1]</span>

<span class="c1">// Le lambda vengono in aiuto</span>

<span class="n">sort</span><span class="p">(</span><span class="n">id_cani</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">id_cani</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">pesi</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">pesi</span><span class="p">[</span><span class="n">lhs</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">pesi</span><span class="p">[</span><span class="n">rhs</span><span class="p">];</span>
<span class="p">});</span>
<span class="c1">// Nota come abbiamo catturato &quot;pesi&quot; per riferimento nell&#39;esempio.</span>
<span class="c1">// Altre informazioni sulle lambda in C++: http://stackoverflow.com/questions/7627098/what-is-a-lambda-expression-in-c11</span>

<span class="c1">///////////////////////////////</span>
<span class="c1">// Ciclo For semplificato(C++11 e superiori)</span>
<span class="c1">///////////////////////////////</span>

<span class="c1">// Puoi usare un ciclo for per iterare su un tipo di dato contenitore</span>
<span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span>

<span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">elem</span><span class="o">:</span><span class="w"> </span><span class="n">arr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Puoi usare &quot;auto&quot; senza preoccuparti del tipo degli elementi nel contenitore</span>
<span class="c1">// Ad esempio:</span>

<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">elem</span><span class="o">:</span><span class="w"> </span><span class="n">arr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Fai qualcosa con `elem`</span>
<span class="p">}</span>

<span class="c1">///////////////////////</span>
<span class="c1">// Roba divertente</span>
<span class="c1">//////////////////////</span>

<span class="c1">// Aspetti del C++ che potrebbero sbalordire i nuovi arrivati (e anche qualche veterano).</span>
<span class="c1">// Questa sezione è, sfortunatamente, selvaggiamente incompleta; il C++ è uno dei linguaggi</span>
<span class="c1">// più facili con cui puoi spararti da solo nel piede.</span>

<span class="c1">// Puoi sovrascrivere metodi privati!</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">();</span>
<span class="p">};</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FooSub</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">();</span><span class="w">  </span><span class="c1">// Sovrascrive Foo::bar!</span>
<span class="p">};</span>


<span class="c1">// 0 == false == NULL (la maggior parte delle volte)!</span>
<span class="kt">bool</span><span class="o">*</span><span class="w"> </span><span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">bool</span><span class="p">;</span>
<span class="o">*</span><span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// Setta il valore puntato da &#39;pt&#39; come falso.</span>
<span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// Setta &#39;pt&#39; al puntatore null. Entrambe le righe vengono compilate senza warnings.</span>

<span class="c1">// nullptr dovrebbe risolvere alcune di quei problemi:</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">pt2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>
<span class="o">*</span><span class="n">pt2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"> </span><span class="c1">// Non compila</span>
<span class="n">pt2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w">  </span><span class="c1">// Setta pt2 a null.</span>

<span class="c1">// C&#39;è un&#39;eccezione per i bool.</span>
<span class="c1">// Questo permette di testare un puntatore a null con if(!ptr), ma</span>
<span class="c1">// come conseguenza non puoi assegnare nullptr a un bool direttamente!</span>
<span class="o">*</span><span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w">  </span><span class="c1">// Questo compila, anche se &#39;*pt&#39; è un bool!</span>


<span class="c1">// &#39;=&#39; != &#39;=&#39; != &#39;=&#39;!</span>
<span class="c1">// Chiama Foo::Foo(const Foo&amp;) o qualche variante (vedi &quot;move semantics&quot;)</span>
<span class="c1">// del costruttore di copia.</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span>

<span class="c1">// Chiama Foo::Foo(const Foo&amp;) o qualche variante, ma solo copie di &#39;Foo&#39; che fanno parte di</span>
<span class="c1">// &#39;fooSub&#39;. Ogni altro membro di &#39;fooSub&#39; viene scartato. Questo comportamento</span>
<span class="c1">// orribile viene chiamato &quot;object slicing.&quot;</span>
<span class="n">FooSub</span><span class="w"> </span><span class="n">fooSub</span><span class="p">;</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fooSub</span><span class="p">;</span>

<span class="c1">// Chiama Foo::operator=(Foo&amp;) o una sua variante.</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f1</span><span class="p">;</span>
<span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span>


<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Tuple (C++11 e superiori)</span>
<span class="c1">///////////////////////////////////////</span>

<span class="cp">#include</span><span class="cpf">&lt;tuple&gt;</span>

<span class="c1">// Concettualmente le tuple sono simili alle strutture del C, ma invece di avere</span>
<span class="c1">// i membri rappresentati con dei nomi, l&#39;accesso agli elementi avviene tramite</span>
<span class="c1">// il loro ordine all&#39;interno della tupla.</span>

<span class="c1">// Cominciamo costruendo una tupla.</span>
<span class="c1">// Inserire i valori in una tupla</span>
<span class="k">auto</span><span class="w"> </span><span class="n">prima</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;A&#39;</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maxN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1e9</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maxL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">15</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">seconda</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_tuple</span><span class="p">(</span><span class="n">maxN</span><span class="p">,</span><span class="w"> </span><span class="n">maxL</span><span class="p">);</span>

<span class="c1">// Vediamo gli elementi contenuti nella tupla &quot;prima&quot;</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">prima</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">prima</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// stampa : 10 A</span>

<span class="c1">// Vediamo gli elementi contenuti nella tupla &quot;seconda&quot;</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">seconda</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">seconda</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// stampa: 1000000000 15</span>

<span class="c1">// Estrarre i valori dalla tupla, salvandoli nelle variabili</span>
<span class="kt">int</span><span class="w"> </span><span class="n">primo_intero</span><span class="p">;</span>
<span class="kt">char</span><span class="w"> </span><span class="n">primo_char</span><span class="p">;</span>
<span class="n">tie</span><span class="p">(</span><span class="n">primo_intero</span><span class="p">,</span><span class="w"> </span><span class="n">primo_char</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prima</span><span class="p">;</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">primo_intero</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">primo_char</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w">  </span><span class="c1">// stampa : 10 A</span>

<span class="c1">// E&#39; possibile creare tuple anche in questo modo</span>
<span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">terza</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;A&#39;</span><span class="p">,</span><span class="w"> </span><span class="mf">3.14141</span><span class="p">);</span>

<span class="c1">// tuple_size ritorna il numero di elementi in una tupla (come constexpr)</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">tuple_size</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">terza</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// stampa: 3</span>

<span class="c1">// tuple_cat concatena gli elementi di tutte le tuple, nell&#39;esatto ordine</span>
<span class="c1">// in cui sono posizionati all&#39;interno delle tuple stesse</span>
<span class="k">auto</span><span class="w"> </span><span class="n">tupla_concatenata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tuple_cat</span><span class="p">(</span><span class="n">prima</span><span class="p">,</span><span class="w"> </span><span class="n">seconda</span><span class="p">,</span><span class="w"> </span><span class="n">terza</span><span class="p">);</span>
<span class="c1">// tupla_concatenata diventa = (10, &#39;A&#39;, 1e9, 15, 11, &#39;A&#39; ,3.14141)</span>

<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tupla_concatenata</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// stampa: 10</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tupla_concatenata</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// stampa: 15</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tupla_concatenata</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// stampa: &#39;A&#39;</span>


<span class="c1">/////////////////////</span>
<span class="c1">// Contenitori</span>
<span class="c1">/////////////////////</span>

<span class="c1">// I Contenitori della &quot;Standard Template Library&quot;, ovvero la libreria standard</span>
<span class="c1">// dei template contenuti nel C++, sono template predefiniti.</span>
<span class="c1">// I Contenitori si occupano di come allocare lo spazio per gli elementi contenuti,</span>
<span class="c1">// e forniscono funzioni per accedervi e manipolarli</span>

<span class="c1">// Vediamo alcuni tipi di contenitori:</span>

<span class="c1">// Vector (array dinamici/vettori)</span>
<span class="c1">// Permettono di definire un vettore, o una lista di oggetti, a runtime</span>
<span class="cp">#include</span><span class="cpf">&lt;vector&gt;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">Tipo_Dato</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nome_vettore</span><span class="p">;</span><span class="w"> </span><span class="c1">// usato per inizializzare un vettore</span>
<span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="n">nome_vettore</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">val</span><span class="p">);</span><span class="w"> </span><span class="c1">// inserisce il valore di &quot;val&quot; nel vettore</span>

<span class="c1">// Per iterare in un vettore, abbiamo due possibilità:</span>
<span class="c1">// Ciclo normale</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">nome_vettore</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="c1">// Cicla dall&#39;indice zero fino all&#39;ultimo</span>

<span class="c1">// Iteratore</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">Tipo_Dato</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="p">;</span><span class="w"> </span><span class="c1">// inizializza l&#39;iteratore per il vettore</span>
<span class="k">for</span><span class="p">(</span><span class="n">it</span><span class="o">=</span><span class="n">nome_vettore</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="o">!=</span><span class="n">nome_vettore</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="o">++</span><span class="n">it</span><span class="p">)</span>
<span class="c1">// Nota che adesso non cicla più sugli indici, ma direttamente sugli elementi!</span>

<span class="c1">// Per accedere agli elementi del vettore</span>
<span class="c1">// Operatore []</span>
<span class="n">var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nome_vettore</span><span class="p">[</span><span class="n">indice</span><span class="p">];</span><span class="w"> </span><span class="c1">// Assegna a &quot;var&quot; il valore del vettore all&#39;indice dato</span>


<span class="c1">// Set (insiemi)</span>
<span class="c1">// Gli insiemi sono contenitori che memorizzano elementi secondo uno specifico ordine.</span>
<span class="c1">// Gli insiemi vengono per lo più utilizzati per memorizzare valori unici, secondo</span>
<span class="c1">// un ordine, senza scrivere ulteriore codice.</span>

<span class="cp">#include</span><span class="cpf">&lt;set&gt;</span>
<span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">insieme</span><span class="p">;</span><span class="w">    </span><span class="c1">// Inizializza un insieme di interi</span>
<span class="n">insieme</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span><span class="w">  </span><span class="c1">// Inserisce il valore 30 nell&#39;insieme</span>
<span class="n">insieme</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w">  </span><span class="c1">// Inserisce il valore 10 nell&#39;insieme</span>
<span class="n">insieme</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w">  </span><span class="c1">// Inserisce il valore 20 nell&#39;insieme</span>
<span class="n">insieme</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span><span class="w">  </span><span class="c1">// Inserisce il valore 30 nell&#39;insieme</span>
<span class="c1">// Gli elementi dell&#39;insieme sono:</span>
<span class="c1">//  10 20 30</span>

<span class="c1">// Per cancellare un elemento</span>
<span class="n">insieme</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w">  </span><span class="c1">// Cancella l&#39;elemento con valore 20</span>
<span class="c1">// L&#39;insieme contiene adesso: 10 30</span>

<span class="c1">// Per iterare su un insieme, usiamo gli iteratori</span>
<span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="n">it</span><span class="o">=</span><span class="n">insieme</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="n">it</span><span class="o">&lt;</span><span class="n">insieme</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="n">it</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// Stampa:</span>
<span class="c1">// 10</span>
<span class="c1">// 30</span>

<span class="c1">// Per svuotare il contenitore usiamo il metodo &quot;clear&quot;</span>
<span class="n">insieme</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">insieme</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="c1">// Stampa: 0</span>

<span class="c1">// Nota: per permettere elementi duplicati, possiamo usare &quot;multiset&quot;</span>

<span class="c1">// Map (mappa/tabella di hash)</span>
<span class="c1">// Le mappe servono per memorizzare un elemento, detto chiave, a cui viene</span>
<span class="c1">// associato un valore, il tutto secondo uno specifico ordine.</span>

<span class="cp">#include</span><span class="cpf">&lt;map&gt;</span>
<span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mia_mappa</span><span class="p">;</span><span class="w">  </span><span class="c1">// Inizializza una mappa che usa i char come chiave, e gli interi come valore</span>

<span class="n">mia_mappa</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="sc">&#39;A&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
<span class="c1">// Inserisce il valore 1 per la chiave A</span>
<span class="n">mia_mappa</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="sc">&#39;Z&#39;</span><span class="p">,</span><span class="mi">26</span><span class="p">));</span>
<span class="c1">// Inserisce il valore 26 per la chiave Z</span>

<span class="c1">// Per iterare</span>
<span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">it</span><span class="o">=</span><span class="n">mia_mappa</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="o">!=</span><span class="n">mia_mappa</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;-&gt;&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="c1">// Stampa:</span>
<span class="c1">// A-&gt;1</span>
<span class="c1">// Z-&gt;26</span>

<span class="c1">// Per trovare il valore corrispondente ad una data chiave</span>
<span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mia_mappa</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39;Z&#39;</span><span class="p">);</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
<span class="c1">// Stampa: 26</span>


<span class="c1">///////////////////////////////////</span>
<span class="c1">// Operatori logici e bitwise(bit-a-bit)</span>
<span class="c1">//////////////////////////////////</span>

<span class="c1">// La maggior parte di questi operatori in C++ sono gli stessi degli altri linguaggi</span>

<span class="c1">// Operatori logici</span>

<span class="c1">// Il C++ usa la &quot;Short-circuit evaluation&quot; per le espressioni booleane. Cosa significa?</span>
<span class="c1">// In pratica, in una condizione con due argomenti, il secondo viene considerato solo se</span>
<span class="c1">// il primo non basta a determinate il valore finale dell&#39;espresione.</span>

<span class="nb">true</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="c1">// Effettua il **and logico** e ritorna falso</span>
<span class="nb">true</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="c1">// Effettua il **or logico** e ritorna vero</span>
<span class="o">!</span><span class="w"> </span><span class="nb">true</span><span class="w">        </span><span class="c1">// Effettua il **not logico** e ritorna falso</span>

<span class="c1">// Invece di usare i simboli, si possono usare le keyword equivalenti</span>
<span class="nb">true</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="c1">// Effettua il **and logico** e ritorna falso</span>
<span class="nb">true</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="nb">false</span><span class="w">  </span><span class="c1">// Effettua il **or logico** e ritorna vero</span>
<span class="k">not</span><span class="w"> </span><span class="nb">true</span><span class="w">       </span><span class="c1">// Effettua il **not logico** e ritorna falso</span>

<span class="c1">// Operatori bitwise(bit-a-bit)</span>

<span class="c1">// **&lt;&lt;** Operatore di Shift a Sinistra</span>
<span class="c1">// &lt;&lt; sposta i bit a sinistra</span>
<span class="mi">4</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// Sposta a sinistra di 1 i bit di 4, ottenendo 8</span>
<span class="c1">// x &lt;&lt; n in pratica realizza x * 2^n</span>


<span class="c1">// **&gt;&gt;** Operatore di Shift a Destra</span>
<span class="c1">// &gt;&gt; sposta i bit a destra</span>
<span class="mi">4</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// Sposta a destra di 1 i bit di 4, ottenendo 2</span>
<span class="c1">// x &gt;&gt; n in pratica realizza x / 2^n</span>

<span class="o">~</span><span class="mi">4</span><span class="w">    </span><span class="c1">// Effettua il NOT bit-a-bit</span>
<span class="mi">4</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">// Effettua il OR bit-a-bit</span>
<span class="mi">4</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">// Effettua il AND bit-a-bit</span>
<span class="mi">4</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">// Effettua il XOR bit-a-bit</span>

<span class="c1">// Le keyword equivalenti sono</span>
<span class="k">compl</span><span class="w"> </span><span class="mi">4</span><span class="w">    </span><span class="c1">// Effettua il NOT bit-a-bit</span>
<span class="mi">4</span><span class="w"> </span><span class="k">bitor</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="c1">// Effettua il OR bit-a-bit</span>
<span class="mi">4</span><span class="w"> </span><span class="k">bitand</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">// Effettua il AND bit-a-bit</span>
<span class="mi">4</span><span class="w"> </span><span class="k">xor</span><span class="w"> </span><span class="mi">3</span><span class="w">    </span><span class="c1">// Effettua il XOR bit-a-bit</span>
</pre></div>
<p>Letture consigliate:</p>
<ul>
<li>Un riferimento aggiornato del linguaggio può essere trovato qui <a href="http://cppreference.com/w/cpp">CPP Reference</a>.</li>
<li>Risorse addizionali possono essere trovate qui <a href="http://cplusplus.com">CPlusPlus</a>.</li>
<li>Un tutorial che copre le basi del linguaggio e l'impostazione dell'ambiente di codifica è disponibile su <a href="https://www.youtube.com/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb">TheChernoProject - C ++</a>.</li>
</ul>

        <hr>
        <p>
          Hai un suggerimento? Oppure una correzione? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Apri un issue</a> sul GitHub, o fa un <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/it/c++.md">pull request</a> da solo!
        </p>
        <p class="contributed">
          In origine contribuita da Steven Basart, e modificata da <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/it/c++.md">5 contributore(i)</a>.
        </p>

        <footer>
          <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width: 0; width: 80px; height: 28px; padding-bottom: 5px;" src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-sa.svg" /></a>
          <p>
            &copy; 2025
            <a href="http://github.com/xksteven">Steven Basart</a>,
            <a href="https://github.com/mrkline">Matt Kline</a>,
            <a href="http://geoffliu.me">Geoff Liu</a>,
            <a href="http://github.com/connorwaters">Connor Waters</a>
          </p>
        </footer>
      </div>
    </div>
  </body>
</html>