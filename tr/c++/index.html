<!DOCTYPE html>
<html lang="tr">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-WXC8R75DEN');
    </script>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="Content-Language" content="tr">
    <title>Learn C++ in Y Minutes</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto+Slab:wght@100..900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/screen.css">
    <link rel="stylesheet" href="/css/light.css">
    <link rel="stylesheet" href="/css/dark.css">

    <link rel="canonical" href="https://learnxinyminutes.com/tr/c++/">
    <script>
      localStorage.removeItem("lxiym_theme");
    </script>
  </head>
  <body>
    <div class="container">
      <div class="share">
        <span class="sharemsg">
          <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Ftr%2Fc%2B%2B%2F&amp;text=Y+dakikada+X+%C3%B6%C4%9Fren%2C+burada+X%3DC%2B%2B">
            Bu sayfayı paylaş
          </a>
        </span>
        <span class='st_facebook_large' displayText='Facebook'></span>
        <span class='st_twitter_large' displayText='Tweet'></span>
      </div>
      <h1><a href="/">Y dakikada X öğren</a></h1>
      <h2>Burada X=C++</h2>
      <p class="filelink">
        Kodu al:
        <a href="/tr/files/learncpp.cpp">learncpp.cpp</a>
      </p>
      <div id="doc">
<p>C++
<a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">yaratıcısı Bjarne Stroustrup'a göre</a>,</p>
<ul>
<li>&quot;daha iyi bir C&quot; yapmak</li>
<li>veri soyutlamayı desteklemek</li>
<li>nesneye yönelik programlamayı deskteklemek</li>
<li>tipten bağımsız programlamayı desteklemek</li>
</ul>
<p>için tasarlanmış bir sistem programlama dilir.</p>
<p>Sözdizimi daha yeni dillerden daha zor veya karmaşık olsa da işlemcinin doğrudan çalıştırabileceği
native komutlara derlenerek, donanım üzerinde (C gibi) sıkı bir kontrol sağlar, bunu yaparken
tipten bağımsızlık, exception'lar ve sınıflar gibi yüksek-seviyeli özellikleri destekler.
Bu hız ve kullanışlılık C++'ı en çok kullanılan dillerden biri yapar.</p>
<div class="highlight"><pre lang="c++"><span class="c1">//////////////////////</span>
<span class="c1">// C ile karşılaştırma</span>
<span class="c1">//////////////////////</span>

<span class="c1">// C++ _neredeyse_ C&#39;nin bir üstkümesidir, değişken tanımı, basit tipleri</span>
<span class="c1">// ve fonksiyonları için temelde aynı sözdizimini paylaşır.</span>

<span class="c1">// Aynı C gibi, programın başlangıç noktası bir integer döndüren </span>
<span class="c1">// main fonksiyonudur.</span>
<span class="c1">// Bu değer programın bitiş statüsünü belli eder.</span>
<span class="c1">// Daha fazla bilgi için bknz http://en.wikipedia.org/wiki/Exit_status .</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Komut satırı argümanları C&#39;de olduğu gibi argv ve argc ile geçilir</span>
<span class="w">    </span><span class="c1">// argc, argüman sayısını belli eder,</span>
<span class="w">    </span><span class="c1">// argv, argümanları belli eden, C-stili string&#39;lerin (char*) dizisidir.</span>
<span class="w">    </span><span class="c1">// İlk argüman çağrılan programın adıdır.</span>
<span class="w">    </span><span class="c1">// Eğer argümanları umursamıyorsan, argv ve argc kullanılmayabilir </span>
<span class="w">    </span><span class="c1">// int main() gibi</span>

<span class="w">    </span><span class="c1">// 0 çıkış durumu başarıyı belirtir.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Bunlara rağmen C++ aşağıdaki noktalarda farklılaşır:</span>

<span class="c1">// C++&#39;ta, karakterler char türündendir</span>
<span class="k">sizeof</span><span class="p">(</span><span class="sc">&#39;c&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span>

<span class="c1">// C&#39;de, karakterler int türündendir</span>
<span class="k">sizeof</span><span class="p">(</span><span class="sc">&#39;c&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>


<span class="c1">// C++ katı bir prototip kuralına sahiptir</span>
<span class="kt">void</span><span class="w"> </span><span class="n">func</span><span class="p">();</span><span class="w"> </span><span class="c1">// fonksiyon argüman kabul etmez</span>

<span class="c1">// C&#39;de</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">();</span><span class="w"> </span><span class="c1">// fonksiyon herhangi bir sayıda argüman kabul edebilir</span>

<span class="c1">// C++&#39;da NULL yerine nullptr kullanılır</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="c1">// C standard başlıkları başına &quot;c&quot; eklenip, sondaki .h</span>
<span class="c1">// kullanılmadan C++&#39;ta kullanılabilir</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdio&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, world!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//////////////////////////////////</span>
<span class="c1">// Fonksiyonun fazladan yüklenmesi</span>
<span class="c1">//////////////////////////////////</span>

<span class="c1">// C++ herbir fonksiyonun farklı parametereler</span>
<span class="c1">// aldığı fonksiyon fazladan yüklenmesini desktekler </span>

<span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">myString</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;String %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">myString</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">myInt</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;My int is %d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">myInt</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// void print(const char*) fonksiyonunu çağırır.</span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span><span class="w"> </span><span class="c1">// void print(int) fonksiyonunu çağırır.</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////</span>
<span class="c1">// Default fonksiyon argümanları</span>
<span class="c1">////////////////////////////////</span>

<span class="c1">// Eğer çağırıcı tarafından fonksiyona argüman sağlanmamışsa,</span>
<span class="c1">// fonksiyona default argüman verebilirsin</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">doSomethingWithInts</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Burada int&#39;lerle birşeyler yap</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">doSomethingWithInts</span><span class="p">();</span><span class="w">      </span><span class="c1">// a = 1,  b = 4</span>
<span class="w">    </span><span class="n">doSomethingWithInts</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w">    </span><span class="c1">// a = 20, b = 4</span>
<span class="w">    </span><span class="n">doSomethingWithInts</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// a = 20, b = 5</span>
<span class="p">}</span>

<span class="c1">// Default argümanlar, argüman listesinin sonunda yer almalı.</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">invalidDeclaration</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="c1">// Hata!</span>
<span class="p">{</span>
<span class="p">}</span>


<span class="c1">/////////////////////////</span>
<span class="c1">// Namespace(İsim uzayı)</span>
<span class="c1">/////////////////////////</span>

<span class="c1">// Namespace&#39;ler değişken, fonksiyon ve diğer bildirimlerin </span>
<span class="c1">// kapsama alanını ayırır. </span>
<span class="c1">// Namespace&#39;ler içiçe geçebilir.</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">First</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Nested</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;This is First::Nested::foo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// Nested namespace&#39;inin sonu</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// First namespace&#39;inin sonu</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">Second</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;This is Second::foo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;This is global foo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Second namespace&#39;i içinideki tüm sembolleri mevcut kapsama alanına dahil eder.</span>
<span class="w">    </span><span class="c1">// Dikkat edersen artık yalnızca foo() çağrısı çalışmayacaktır çünkü hangi</span>
<span class="w">    </span><span class="c1">// namespace&#39;ten çağrıldığı açık değildir.</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Second</span><span class="p">;</span>

<span class="w">    </span><span class="n">Second</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// &quot;This is Second::foo&quot; yazdırıır</span>
<span class="w">    </span><span class="n">First</span><span class="o">::</span><span class="n">Nested</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// &quot;This is First::Nested::foo&quot; yazdırır</span>
<span class="w">    </span><span class="o">::</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// &quot;This is global foo&quot; yazdırır.</span>
<span class="p">}</span>

<span class="c1">///////////////</span>
<span class="c1">// Input/Output</span>
<span class="c1">///////////////</span>

<span class="c1">// C++&#39;ta input ve output stream&#39;leri kullanır.</span>
<span class="c1">// cin, cout ve cerr,sırasıyla, stdin, stdout, ve stderr&#39;i temsil eder.</span>
<span class="c1">// &lt;&lt; araya ekleme ve &gt;&gt; aradan çıkarma operatörüdür.</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="c1"> // I/O stream&#39;lerini dahil etmek için</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"> </span><span class="c1">// Streamler std namespace&#39;i içindedir(standard kütüphane)</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">myInt</span><span class="p">;</span>

<span class="w">   </span><span class="c1">// stdout (veya terminal/screen)&#39;ta çıktı verir</span>
<span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Enter your favorite number:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">   </span><span class="c1">// Girdiyi alır </span>
<span class="w">   </span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">myInt</span><span class="p">;</span>

<span class="w">   </span><span class="c1">// cout ayrıca formatlanabilir</span>
<span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Your favorite number is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myInt</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">   </span><span class="c1">// prints &quot;Your favorite number is &lt;myInt&gt;&quot;</span>

<span class="w">    </span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Used for error messages&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//////////////</span>
<span class="c1">// String&#39;ler</span>
<span class="c1">/////////////</span>

<span class="c1">// String&#39;ler C++&#39;ta nesnedir ve pek çok üye fonksiyonu vardır</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"> </span><span class="c1">// String&#39;ler de std namespace&#39;i içindedir. (standard kütüphane)</span>

<span class="n">string</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span><span class="p">;</span>
<span class="n">string</span><span class="w"> </span><span class="n">myOtherString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot; World&quot;</span><span class="p">;</span>

<span class="c1">// + eklemek için kullanıldır </span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">myOtherString</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;Hello World&quot;</span>

<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; You&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;Hello You&quot;</span>

<span class="c1">// C++&#39;ta  stringler are mutable&#39;dır (değişebilir).</span>
<span class="n">myString</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot; Dog&quot;</span><span class="p">);</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">myString</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;Hello Dog&quot;</span>


<span class="c1">///////////////////////</span>
<span class="c1">// Reference (Referans)</span>
<span class="c1">///////////////////////</span>

<span class="c1">// C&#39;deki pointer&#39;lara ek olarak </span>
<span class="c1">// C++ _reference_&#39;lara sahiptir.</span>
<span class="c1">// Bunlar bir kere atandınğında tekrardan atanamayan pointer&#39;dır</span>
<span class="c1">// ve null olamaz.</span>
<span class="c1">// Değişkenin kendisiyle aynı sözdizimine sahiptir:</span>
<span class="c1">// Değerine ulaşmak için * ihtiyaç yoktur ve</span>
<span class="c1">// atama için &amp; (address of) kullanılmaz.</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="n">string</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;I am foo&quot;</span><span class="p">;</span>
<span class="n">string</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;I am bar&quot;</span><span class="p">;</span>


<span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">fooRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w"> </span><span class="c1">// Bu foo&#39;nun reference&#39;ını oluşturur.</span>
<span class="n">fooRef</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;. Hi!&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// foo&#39;yu reference&#39;ı üzerinden değiştirir.</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fooRef</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;I am foo. Hi!&quot; yazdırır.</span>

<span class="c1">// &quot;fooRef&quot;e yeniden atama yapmaz. Bu &quot;foo = bar&quot; denktir ve bu satırdan sonra</span>
<span class="c1">//  foo == &quot;I am bar&quot; olur</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fooRef</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// foo&#39;un adresini yazdırır</span>
<span class="n">fooRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fooRef</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">//Hala foo&#39;nun adresini yazdırır</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fooRef</span><span class="p">;</span><span class="w">  </span><span class="c1">//&quot;I am bar&quot; yazdırır</span>

<span class="c1">// fooRef&#39;in adresi aynı kalır yani hala foo&#39;nun adresidir.</span>

<span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">barRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span><span class="w"> </span><span class="c1">// bar&#39;a const reference oluşturur</span>
<span class="c1">// C&#39;de olduğu gibi, const değerler (pointer&#39;lar ve reference&#39;ler) değiştirilemez.</span>
<span class="n">barRef</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;. Hi!&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Hata, const reference&#39;ler değiştirilemez.</span>

<span class="c1">// Kısa bir ekleme: reference&#39;lere devam etmeden önce, geçici nesne konseptinden</span>
<span class="c1">// bahsetmeliyiz. Mesela aşadaki gibi bir kod var:</span>
<span class="n">string</span><span class="w"> </span><span class="nf">tempObjectFun</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="n">string</span><span class="w"> </span><span class="n">retVal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tempObjectFun</span><span class="p">();</span>

<span class="c1">// Bu iki satırda aslında ne oluyor:</span>
<span class="c1">//   - tempObjectFun fonksiyonundan bir string nesnesi dönüyor</span>
<span class="c1">//   - dönmüş olan nesneyle yeni bir string oluşturuyor</span>
<span class="c1">//   - dönmüş olan nesne yok ediliyor</span>
<span class="c1">// İşte bu dönen nesneye geçici nesne denir. Geçici nesneler fonksiyon nesne</span>
<span class="c1">// döndürdüğünde oluşturulur ve ifade işini bitirdiğinde yok edilir (Aslında,</span>
<span class="c1">// standard&#39;ın söylediği şey bu ama derleyiciler bu davranışı değiştirmemize </span>
<span class="c1">// izin veriyor. Daha fazla detay için &quot;return value optimization&quot; diye</span>
<span class="c1">// aratabilirsin. Sonuç olarak aşağıdaki kodda:</span>
<span class="n">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">(</span><span class="n">tempObjectFun</span><span class="p">()))</span>

<span class="c1">// foo ve bar&#39;ın varolduğunu kabul ediyoruz, tempObjectFun&#39;dan dönen nesne</span>
<span class="c1">// bar&#39;a geçti ve foo çağrılmadan önce yokedildir.</span>

<span class="c1">// Şimdi reference&#39;lara dönelim. &quot;ifadenin sonunda&quot; kuralının bir istisnası</span>
<span class="c1">// eğer geçici nesne const reference&#39;a geçildiyse oratya çıkar, bu durumda</span>
<span class="c1">// nesnenin ömrü mevcut kapsama alanına kadar uzar:</span>

<span class="kt">void</span><span class="w"> </span><span class="n">constReferenceTempObjectFun</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// constRef geçici nesneyi alır ve bu durum fonksiyonun sonuna kadar geçerlidir.</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">constRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tempObjectFun</span><span class="p">();</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>

<span class="c1">// C++11 ile gelen diğer bir reference geçici nesnelere özeldir. Bu türden birden </span>
<span class="c1">// bir tip tanımlayamazsın ama aşırı yüklenme sırasında bu tipler öncelik alır:</span>
<span class="kt">void</span><span class="w"> </span><span class="n">someFun</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">  </span><span class="c1">// Regular reference</span>
<span class="kt">void</span><span class="w"> </span><span class="n">someFun</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">  </span><span class="c1">// Geçici nesneye reference </span>

<span class="n">string</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>
<span class="n">someFun</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span><span class="w">  </span><span class="c1">// regular reference&#39;ı çağırır</span>
<span class="n">someFun</span><span class="p">(</span><span class="n">tempObjectFun</span><span class="p">());</span><span class="w">  </span><span class="c1">// geçici reference&#39;ı çağırır</span>

<span class="c1">/////////////////////</span>
<span class="c1">// Enum</span>
<span class="c1">/////////////////////</span>

<span class="c1">// Enum&#39;lar sabit değerler yapmak için kullanılır ve çoğunlukla kodun daha okunaklı</span>
<span class="c1">// olması için kullanılır</span>

<span class="k">enum</span><span class="w"> </span><span class="nc">ECarTypes</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Sedan</span><span class="p">,</span>
<span class="w">  </span><span class="n">Hatchback</span><span class="p">,</span>
<span class="w">  </span><span class="n">SUV</span><span class="p">,</span>
<span class="w">  </span><span class="n">Wagon</span>
<span class="p">};</span>

<span class="n">ECarTypes</span><span class="w"> </span><span class="nf">GetPreferredCarType</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">ECarTypes</span><span class="o">::</span><span class="n">Hatchback</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// C++11 ile beraber bir tipi enum&#39;a atamanın kolay bir yolu var, bu enum&#39;un istenen</span>
<span class="c1">// tipe dönüştürmek için kullanışlı bir yöntem</span>
<span class="k">enum</span><span class="w"> </span><span class="nc">ECarTypes</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">uint8_t</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Sedan</span><span class="p">,</span><span class="w"> </span><span class="c1">// 0</span>
<span class="w">  </span><span class="n">Hatchback</span><span class="p">,</span><span class="w"> </span><span class="c1">// 1</span>
<span class="w">  </span><span class="n">SUV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">254</span><span class="p">,</span><span class="w"> </span><span class="c1">// 254</span>
<span class="w">  </span><span class="n">Hybrid</span><span class="w"> </span><span class="c1">// 255</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">WriteByteToFile</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">InputValue</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">	</span><span class="c1">// Serialize the InputValue to a file</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">WritePreferredCarTypeToFile</span><span class="p">(</span><span class="n">ECarTypes</span><span class="w"> </span><span class="n">InputCarType</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">	</span><span class="c1">// enum uint8_t tipine dönüştürüldü</span>
<span class="w">	</span><span class="n">WriteByteToFile</span><span class="p">(</span><span class="n">InputCarType</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Diğer yandan enum&#39;ların yanlışlıkla integer tipini veya diğer enumlara dönüşmesini</span>
<span class="c1">// istemiyorsan enum class olarak tanımlayabilirsin</span>
<span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">ECarTypes</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">uint8_t</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Sedan</span><span class="p">,</span><span class="w"> </span><span class="c1">// 0</span>
<span class="w">  </span><span class="n">Hatchback</span><span class="p">,</span><span class="w"> </span><span class="c1">// 1</span>
<span class="w">  </span><span class="n">SUV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">254</span><span class="p">,</span><span class="w"> </span><span class="c1">// 254</span>
<span class="w">  </span><span class="n">Hybrid</span><span class="w"> </span><span class="c1">// 255</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">WriteByteToFile</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">InputValue</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">	</span><span class="c1">// Serialize the InputValue to a file</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">WritePreferredCarTypeToFile</span><span class="p">(</span><span class="n">ECarTypes</span><span class="w"> </span><span class="n">InputCarType</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">	</span><span class="c1">// ECarTypes, uint8_t tipinde olmasına rağmen, &quot;enum class&quot; olarak </span>
<span class="w">	</span><span class="c1">// tanımlandığından derlenmeyecektir!</span>
<span class="w">	</span><span class="n">WriteByteToFile</span><span class="p">(</span><span class="n">InputCarType</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">///////////////////////////////////////////</span>
<span class="c1">// Sınıflar ve nesneye yönelik proglamalama</span>
<span class="c1">///////////////////////////////////////////</span>

<span class="c1">// Sınıflara(class) ilk örnek</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="c1">// Sınıfı tanımla.</span>
<span class="c1">// Sınıflar genelde header (.h veya .hpp) dosyalarında tanımlanır.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Dog</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Üye değişkenler ve fonksiyonlar default olarak private&#39;dir.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">weight</span><span class="p">;</span>

<span class="c1">// Aşağıda, &quot;private:&quot; veya &quot;protected:&quot; bulunana kadar</span>
<span class="c1">// bütün üyeler public&#39;tir.</span>
<span class="k">public</span><span class="o">:</span>

<span class="w">    </span><span class="c1">// Default constructor</span>
<span class="w">    </span><span class="n">Dog</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Üye fonksiyon bildirimi (gerçeklenimi aşağıda)</span>
<span class="w">    </span><span class="c1">// Dikkat ederseniz using namespace std; yerine</span>
<span class="w">    </span><span class="c1">// std::string kullandık.</span>
<span class="w">    </span><span class="c1">// Hiçbir zaman header dosyasında &quot;using namespace std;&quot; kullanma.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">setName</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dogsName</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">setWeight</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">dogsWeight</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Nesnenin durumunu değiştirmeyen fonksiyonlar const ile işaretlenmelidir</span>

<span class="w">    </span><span class="c1">// Türetilen sınıflarda fonksiyonu override edebilmek için başına </span>
<span class="w">    </span><span class="c1">// _virtual_ eklenmelidir.</span>
<span class="w">    </span><span class="c1">// Fonksiyonlar, performanslar ilgili nedenlerden ötürü default olarak virtual değildir</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Fonksiyonlar class içinde de tanımlanabilir.</span>
<span class="w">    </span><span class="c1">// Bu şekille tanımlanan fonksiyonlar otomatik olarak inline olur.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">bark</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; barks!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// C++ constructor&#39;ların yanında destructor&#39;da sağlar.</span>
<span class="w">    </span><span class="c1">// Bunlar nesne silindiğinde veya scope&#39;un dışına çıktığında çağrılır.</span>
<span class="w">    </span><span class="c1">// Bu RAII gibi güçlü paradigmaları etkin kılar.</span>
<span class="w">    </span><span class="c1">// (aşağıda açıklandı)</span>
<span class="w">    </span><span class="c1">// Eğer sınıf kendisinden türetiliyorsa, destructor virtual olmalıdır,</span>
<span class="w">    </span><span class="c1">// eğer virtual değilse, türetilmiş sınıfın destructor&#39;ı nesne, ana sınıf</span>
<span class="w">    </span><span class="c1">// referans&#39;ı veya pointer&#39;ı üzerinden yok edildiğinde, çağrılmayacaktır.</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Dog</span><span class="p">();</span>

<span class="p">};</span><span class="w"> </span><span class="c1">// class tanımının sonuda noktalı virgül(;) olmalıdır.</span>

<span class="c1">// Sınıfın üye fonksiyonları genelde .cpp dosyaları içinde gerçeklenir.</span>
<span class="n">Dog</span><span class="o">::</span><span class="n">Dog</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;A dog has been constructed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Objects (such as strings) should be passed by reference</span>
<span class="c1">// Nesneler (string gibi) reference ile fonksiyonlara geçilmelidir</span>
<span class="c1">// Eğer nesneleri değiştirilecekse reference ile fonksiyonlara geçilmelidir,</span>
<span class="c1">// değiştirilmeyecekse const reference ile geçilmelidir.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">Dog</span><span class="o">::</span><span class="n">setName</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dogsName</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dogsName</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">Dog</span><span class="o">::</span><span class="n">setWeight</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">dogsWeight</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dogsWeight</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Dikkat edersen &quot;virtual&quot; yalnızca bildirimde gerekli, tanımlamada değil.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">Dog</span><span class="o">::</span><span class="n">print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Dog is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; and weighs &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;kg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Dog</span><span class="o">::~</span><span class="n">Dog</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Goodbye &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Dog</span><span class="w"> </span><span class="n">myDog</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;A dog has been constructed&quot; yazdırır</span>
<span class="w">    </span><span class="n">myDog</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">&quot;Barkley&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">myDog</span><span class="p">.</span><span class="n">setWeight</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="n">myDog</span><span class="p">.</span><span class="n">print</span><span class="p">();</span><span class="w"> </span><span class="c1">// &quot;Dog is Barkley and weighs 10 kg&quot; yazdırır.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// &quot;Goodbye Barkley&quot; yazdırır.</span>

<span class="c1">// Inheritance(Miras)</span>

<span class="c1">// Bu sınıf, Dog sınıfında public ve protected olan herşeyi miras alır, </span>
<span class="c1">// private olanları da miras alır ama, public ve protected sınıflar aracılıyla</span>
<span class="c1">// yapılmıyorsa, doğrudan erişemez.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">OwnedDog</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Dog</span><span class="w"> </span><span class="p">{</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">setOwner</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dogsOwner</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// print fonksiyonunun davranışını bütün OwnedDogs sınıfı için override eder</span>
<span class="w">    </span><span class="c1">// (üstünden geçer, kendine uyarlar).</span>
<span class="w">    </span><span class="c1">// bknz http://en.wikipedia.org/wiki/Polymorphism_(computer_science)</span>
<span class="w">    </span><span class="c1">// override anahtar sözcüpü kullanılma da olur ama kullanılması aslında bir temel</span>
<span class="w">    </span><span class="c1">// temel sınıf fonksiyonunun üzerinden geçtiğimizi gösterir.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">owner</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Bu arada takip eden .cpp dosyasında:</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">OwnedDog::setOwner</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dogsOwner</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dogsOwner</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">OwnedDog::print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Dog</span><span class="o">::</span><span class="n">print</span><span class="p">();</span><span class="w"> </span><span class="c1">// Ana dog sınıfındaki print fonksiyonunu çağırır </span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Dog is owned by &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">owner</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// 	      &quot;Dog is &lt;name&gt; and weights &lt;weight&gt;&quot;</span>
<span class="w">    </span><span class="c1">//        &quot;Dog is owned by &lt;owner&gt;&quot;</span>
<span class="w">    </span><span class="c1">// 	       yazdırır</span>
<span class="p">}</span>

<span class="c1">/////////////////////////////////////////////////////</span>
<span class="c1">// ilk değer atama ve Operatörün fazladan yüklenmesi</span>
<span class="c1">/////////////////////////////////////////////////////</span>

<span class="c1">// C++ dilinde +, -, *, /, gibi operatörlerin davranışını fazladan yükleyebilirsiniz.</span>
<span class="c1">// Bu, operator her kullandınıldığında çağrılan bir fonksiyon tanımlamasıyla yapılır.</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Point</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// Üye değişkenkenlere default değer atanabilir.</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Default constructor</span>
<span class="w">    </span><span class="n">Point</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span>

<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">        </span><span class="n">x</span><span class="p">(</span><span class="n">a</span><span class="p">),</span>
<span class="w">        </span><span class="n">y</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="cm">/* İlk değer atama dışında birşey yapma */</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// + operatorünün fazladan yükle.</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// += operatorünü fazladan yükle</span>
<span class="w">    </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// - ve -= operatorleri fazladan yüklemek de mantıklı olurdu</span>
<span class="w">    </span><span class="c1">// ama kısa tutmak için burda değinmedik.</span>
<span class="p">};</span>

<span class="n">Point</span><span class="w"> </span><span class="n">Point</span><span class="o">::</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// yeni bir nokta oluştur ve bunu rhs ile topla</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Point</span><span class="o">::</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="nf">up</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="nf">right</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Bu Point + operatorünü çağırır</span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// &quot;Result is upright (1,1)&quot; yazdırır.</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Result is upright (&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;,&#39;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">////////////////////////</span>
<span class="c1">// Şablonlar (Templates)</span>
<span class="c1">////////////////////////</span>

<span class="c1">// Şablonlar C++ dilinde tipten bağımsız programlama için kullanılır.</span>

<span class="c1">// Zaten aşina olduğun tipten bağımsız programlamayla başladık. Bir tip parametresi</span>
<span class="c1">// alan fonksiyon veya sınıf tanımlamaık için:</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Box</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// Bu sınıfta T, herhangi bir tip için kullanılabilir.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Derleme esnasında derleyici aslında, parametreleri yerine konmuş şekilde herbir şablonu üretir,</span>
<span class="c1">// bu yüzden sınıfın tam tanımı her çağrılma sırasında var olmak zorundadır. Bu nedenle şablon sınıflarını</span>
<span class="c1">// tamamen header dosyalarında görürsün.</span>

<span class="c1">// Stack&#39;ta şablon sınıfın bir örneğini oluşturmak için:</span>
<span class="n">Box</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">intBox</span><span class="p">;</span>

<span class="c1">// ve, anladığın gibi, kullanabilirsin:</span>
<span class="n">intBox</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>

<span class="c1">// Tabi, şablonları içiçe geçirebilirsin:</span>
<span class="n">Box</span><span class="o">&lt;</span><span class="n">Box</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">boxOfBox</span><span class="p">;</span>
<span class="n">boxOfBox</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">intBox</span><span class="p">);</span>

<span class="c1">// C++11&#39;den önce iki &#39;&gt;&#39; arasına boşluk koymak zorundaydık yoksa sağa kaydırma </span>
<span class="c1">// operatörü olarak algılanabilirdi.</span>

<span class="c1">// Bazen şunu da görebilirsin</span>
<span class="c1">//   template&lt;typename T&gt;</span>
<span class="c1">// &#39;class&#39; ve &#39;typename&#39; anahtar sözcükleri çoğunlukla </span>
<span class="c1">// birbirlerinin yerine kullanılabilir. Tam açıklama için, bknz.</span>
<span class="c1">//   http://en.wikipedia.org/wiki/Typename</span>
<span class="c1">// (evet, bu anahtar sözcüğün kendi Wikipedia sayfası var).</span>

<span class="c1">// Benzer şekilde, bir şablon fonksiyon:</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">barkThreeTimes</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">input</span><span class="p">.</span><span class="n">bark</span><span class="p">();</span>
<span class="w">    </span><span class="n">input</span><span class="p">.</span><span class="n">bark</span><span class="p">();</span>
<span class="w">    </span><span class="n">input</span><span class="p">.</span><span class="n">bark</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Dikkat edersen tip parametresi hakkında birşey belirtilmedi. Derleyici bunları üretecek</span>
<span class="c1">// ve her parametre geçişinde tip-kontrolü yapacaktır, bu nedenle de fonksiyon herhangi bir T</span>
<span class="c1">// tipi için çalışacaktır!</span>

<span class="n">Dog</span><span class="w"> </span><span class="n">fluffy</span><span class="p">;</span>
<span class="n">fluffy</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">&quot;Fluffy&quot;</span><span class="p">)</span>
<span class="n">barkThreeTimes</span><span class="p">(</span><span class="n">fluffy</span><span class="p">);</span><span class="w"> </span><span class="c1">// Üç kere &quot;Fluffy barks&quot; yazdırır.</span>

<span class="c1">// Şablonun parametresi sınıf olmak zorunda değildir:</span>
<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">Y</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">printMessage</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Learn C++ in &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; minutes!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Ve template&#39;i daha etkili kod için dışarıdan özelleştirebilirsin. </span>
<span class="c1">// Tabiki gerçek-dünya kullanımlarında özelleştirme bunun kadar kolay değildir.</span>
<span class="c1">// Dikkat edersen, bütün parametreleri dıştan özelleştirmiş olsak bile</span>
<span class="c1">// hala fonksiyonu (veya sınıfı( template olarak tanımlamamız gerekli.</span>
<span class="k">template</span><span class="o">&lt;&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">printMessage</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Learn C++ faster in only 10 minutes!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">printMessage</span><span class="o">&lt;</span><span class="mi">20</span><span class="o">&gt;</span><span class="p">();</span><span class="w">  </span><span class="c1">// &quot;Learn C++ in 20 minutes!&quot; yazdırır</span>
<span class="n">printMessage</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span><span class="p">();</span><span class="w">  </span><span class="c1">// &quot;Learn C++ faster in only 10 minutes!&quot; yazdırır</span>


<span class="c1">///////////////////////////////////////////////</span>
<span class="c1">// İstisnai Durum Yönetimi (Exception Handling)</span>
<span class="c1">///////////////////////////////////////////////</span>

<span class="c1">// Standard kütüphane bazı istisnai tipler sağlar</span>
<span class="c1">// (bknz http://en.cppreference.com/w/cpp/error/exception)</span>
<span class="c1">// ama herhangi bir tip de istisnai durum fırlatabilir </span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exception&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdexcept&gt;</span>

<span class="c1">// _try_ bloğu içinde fırlatılan bütün istisnai durumlar, takip eden, _catch_ ile </span>
<span class="c1">// yakalanabilir.</span>
<span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// _new_ kullanarak heap&#39;ten istisnai durumlar için yer ayırma</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;A problem occurred&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// istisnai durumlar nesne ise  const reference ile yakala</span>
<span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Bir önceki _catch_ bloğundan kaçan istisnai durum burda yakala</span>
<span class="k">catch</span><span class="w"> </span><span class="p">(...)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Unknown exception caught&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">throw</span><span class="p">;</span><span class="w"> </span><span class="c1">// Tekrardan istisnai durum fırlatır</span>
<span class="p">}</span>

<span class="c1">///////</span>
<span class="c1">// RAII</span>
<span class="c1">///////</span>

<span class="c1">// RAII, &quot;Resource Acquisition Is Initialization&quot; kelimelerinin kısaltmasıdır.</span>
<span class="c1">// Bu Türkçe, &quot;Kaynak alımı aynı zamanda ilk değer atamasıdır.&quot; olarak çevrilebilir.</span>
<span class="c1">// Bunu basitçe constructor ile ayrılan hafızanın destructor ile iade edilmesi olarak </span>
<span class="c1">// düşünebiliriz.</span>

<span class="c1">// Bunun ne şekilde kullanışlı olduğunu görmek için</span>
<span class="c1">// bir C dosyasının, dosya işleme biçimine bakabiliriz:</span>
<span class="kt">void</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Başlangıçta herşeyin yolunda gittiğini düşünelim</span>

<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Dosyayı okuma modunda aç</span>

<span class="w">    </span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Dosyayı kapat</span>
<span class="p">}</span>

<span class="c1">// Malesef hatalarla başa çıkmaya çalışırken işler hızlıca karmaşıklaşır.</span>
<span class="c1">// Mesela fopen&#39;ın başarısız olduğunu varsayalım, ve doSoomethingWithTheFile ve </span>
<span class="c1">// doSomethingWithIt hata kodları gönderdi.</span>
<span class="c1">//  (İstisnai durumlar yonetimi, hata koduna tercih ediler bir yöntemdir, ama bazı</span>
<span class="c1">//   programcılar, özellikle C arkaplanı olanlar, aynı fikirde değildir.</span>
<span class="c1">// Bu durumda her bir fonksiyon çağrısını kontrol etmeli ve bir problem oluştuysa</span>
<span class="c1">// dosyayı kapatmalıyız.</span>

<span class="kt">bool</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span><span class="w">  </span><span class="c1">// Dosyayı okuma modunda aç</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fh</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="c1">// Başarısız olma durumunda dönen değer null olur</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Başarısız olma durumunu çağırıcıya bildir</span>

<span class="w">    </span><span class="c1">// Başarısız olma durumunda her iki fonksiyonun da false döndürdüğünü kabul edelim</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Dosyayı kapatalım, akıntı olmasın.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Hatayı bildir</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Dosyayı kapatalım, akıntı olmasın.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Hatayı bildir</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Dosyayı kapat</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// Başarı durumunu ifade eder</span>
<span class="p">}</span>

<span class="c1">// C programcıları biraz goto kullanarak bu durumu temizler</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fh</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">failure</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">failure</span><span class="p">;</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Dosyayı kapat </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// Başarı durumunu ifade eder</span>

<span class="nl">failure</span><span class="p">:</span>
<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Hatayı bildir</span>
<span class="p">}</span>

<span class="c1">// Eğer fonksiyon istisnai durum yönetimi araçlarını kullanırsa</span>
<span class="c1">// işler daha temiz olur ama hala en iyi durumun altında kalır.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fh</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Could not open the file.&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">        </span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">catch</span><span class="w"> </span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Hata durumunda dosyayı kapattığından emin ol</span>
<span class="w">        </span><span class="k">throw</span><span class="p">;</span><span class="w"> </span><span class="c1">// Sonra, tekrardan istisnai durum fırlat</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span><span class="w"> </span><span class="c1">// Dosyayı kapat</span>
<span class="w">    </span><span class="c1">// Herşey başarılı</span>
<span class="p">}</span>

<span class="c1">// Şimdi aynı şeyi C++&#39;ın dosya stream sınıfıyla (fstream) karşılaştıralım</span>
<span class="c1">// fstream, dosyayı kapatmak için kendi destructor&#39;ını kullanır.</span>
<span class="c1">// Destructor&#39;ın, nesne scope dışına çıktığında otomatik olarak çağrıldığını </span>
<span class="c1">// hatırlayın.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">doSomethingWithAFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span><span class="w"> </span><span class="nf">fh</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span><span class="w"> </span><span class="c1">// Dosyayı aç</span>

<span class="w">    </span><span class="c1">// Dosyayla birşeyler yap</span>
<span class="w">    </span><span class="n">doSomethingWithTheFile</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
<span class="w">    </span><span class="n">doSomethingElseWithIt</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// Dosya, destructor tarafından otomatik olarak kapatıldı</span>

<span class="c1">// Bunun _çok büyük_ avantajları var:</span>
<span class="c1">// 1. Ne olursa olursun,</span>
<span class="c1">//    kaynak (bu örnekte dosya tutucusu) temizlenecektir.</span>
<span class="c1">//    Destructor doğru yazıldığında,</span>
<span class="c1">//    Tutucuyu kapatmayı unutma ve kaynak akıntısı _imkansız_dır.</span>
<span class="c1">// 2. Kodun çok daha temiz olduğuna dikkat edin.</span>
<span class="c1">//    Destructor, dosyayı kapatma işini, endilenmemize gerek kalmadan</span>
<span class="c1">//    arka planda halleder.</span>
<span class="c1">// 3. Kod, istisnai durumlara karşı korunaklıdır.</span>
<span class="c1">//    İstisnai durum fonksiyonun herhangi bir yerinde fırlatılabilir ve</span>
<span class="c1">//    temizleme işi gene de yapılır.</span>

<span class="c1">// Bütün C++ kodu deyimleri RAII prensibini tüm kaynakları için kullanır.</span>
<span class="c1">// Ek örnekler şunlardır:</span>
<span class="c1">// - unique_ptr ve shared_ptr ile hafıza kullanımı</span>
<span class="c1">// - Tutucular - standard kütüphane linked list,</span>
<span class="c1">//   vector (yani kendiliğinden boyu ayarlanan dizi), hash map vs.</span>
<span class="c1">//   scope&#39;un dışına çıktığında içerini otomatik olarak yok eden tüm yapılar.</span>
<span class="c1">// - lock_guard ve unique_lock kullanan mutex&#39;ler</span>

<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Lambda İfadeleri (C++11 ve yukarısı)</span>
<span class="c1">///////////////////////////////////////</span>

<span class="c1">// lambda&#39;lar, tam olarak çağrıldığı yerde bir anonim fonksiyon tanımlamak</span>
<span class="c1">// veya fonksiyona argüman geçmek için uygun bir yoldur.</span>

<span class="c1">// Mesela, pair&#39;lardan oluşan bir vector&#39;u, pair&#39;ın ikinci değerine </span>
<span class="c1">// göre sıralamak isteyelim</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">tester</span><span class="p">;</span>
<span class="n">tester</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">));</span>
<span class="n">tester</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">));</span>
<span class="n">tester</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span>

<span class="c1">// sort fonksiyonuna üçüncü argüman olarak lambda ifadesini geç</span>
<span class="c1">// sort, &lt;algorithm&gt; başlığında tanımlı</span>

<span class="n">sort</span><span class="p">(</span><span class="n">tester</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">tester</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">lhs</span><span class="p">.</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<span class="w">    </span><span class="p">});</span>

<span class="c1">// Lambda ifadesinin söz dizimine dikkat edin, </span>
<span class="c1">// lambda&#39;daki [], değişkenleri &quot;tutmak&quot; için kullanılır</span>
<span class="c1">// &quot;Tutma listesi&quot;, fonksiyon gövdesinde nelerin, ne şekilde erişilebilir olduğunu tanımlar</span>
<span class="c1">// Şunlardan biri olabilir:</span>
<span class="c1">// 	1. bir değer : [x]</span>
<span class="c1">//	2. bir referans : [&amp;x]</span>
<span class="c1">//	3. mevcut scope içindeki herhangi bir değişkene referans ile [&amp;]</span>
<span class="c1">//	4. 3 ile aynı, ama değer ile [=]</span>
<span class="c1">// Mesela:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dog_ids</span><span class="p">;</span>
<span class="c1">// number_of_dogs = 3;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">	</span><span class="n">dog_ids</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">weight</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">30</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">};</span>

<span class="c1">// Mesela dog_ids vector&#39;unu dog&#39;ların ağırlıklarına göre sıralamak isteyelim</span>
<span class="c1">// Yani en sonunda şöyle olmalı: [2, 0, 1]</span>

<span class="c1">// Burada lambda ifadesi oldukça kullanışlıdır</span>

<span class="n">sort</span><span class="p">(</span><span class="n">dog_ids</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">dog_ids</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">weight</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">weight</span><span class="p">[</span><span class="n">lhs</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">weight</span><span class="p">[</span><span class="n">rhs</span><span class="p">];</span>
<span class="w">    </span><span class="p">});</span>
<span class="c1">// Dikkat edersen &quot;weight&quot; dizisini referans ile aldık.</span>
<span class="c1">// C++&#39;da lambdalar hakkında daha fazla bilgi için : http://stackoverflow.com/questions/7627098/what-is-a-lambda-expression-in-c11</span>

<span class="c1">//////////////////////////////////</span>
<span class="c1">// Akıllı For (C++11 ve yukarısı)</span>
<span class="c1">//////////////////////////////////</span>

<span class="c1">// Akıllı for döngüsünü bir tutucuyu dolaşmak için kullanabilirsin</span>
<span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span>

<span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">elem</span><span class="o">:</span><span class="w"> </span><span class="n">arr</span><span class="p">){</span>
<span class="w">	</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Tutucunun elemanlarının tipi için endişe etmeden &quot;auto&quot; kullanabilirsin</span>
<span class="c1">// Mesela:</span>

<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">elem</span><span class="o">:</span><span class="w"> </span><span class="n">arr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">	</span><span class="c1">// arr dizisinin elemanlarıyla ilgili bir şeyler yap</span>
<span class="p">}</span>

<span class="c1">////////////////</span>
<span class="c1">// Güzel Şeyler</span>
<span class="c1">////////////////</span>

<span class="c1">// C++ dilinin bakış açısı yeni başlayanlar için (hatta dili iyi bilenler için bile)</span>
<span class="c1">// şaşırtıcı olabilir. </span>
<span class="c1">// Bu bölüm, ne yazık ki, büyük ölçüde tam değil; C++ kendi ayağına ateş edilebilecek kolay</span>
<span class="c1">// dillerden biridir.</span>

<span class="c1">// private metodları override edebilirsin!</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">();</span>
<span class="p">};</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FooSub</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">();</span><span class="w">  </span><span class="c1">// Foo::bar fonksiyonu override edilir!</span>
<span class="p">};</span>


<span class="c1">// 0 == false == NULL (çoğu zaman)!</span>
<span class="kt">bool</span><span class="o">*</span><span class="w"> </span><span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">bool</span><span class="p">;</span>
<span class="o">*</span><span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// &#39;pt&#39;nin gösterdiği değere false atar.</span>
<span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// &#39;pt&#39;ye null pointer atar. Her iki satır uyarısız derlenir.</span>

<span class="c1">// nullptr&#39;ın bu meselenin bazılarını çözmesi beklenmiştir:</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">pt2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>
<span class="o">*</span><span class="n">pt2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"> </span><span class="c1">// Derlenmez.</span>
<span class="n">pt2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w">  </span><span class="c1">// pt2&#39;ye null atar.</span>

<span class="c1">// bool tipleri için bir istisna vardır.</span>
<span class="c1">// Bu null pointer&#39;ları if(!ptr) ile test etmek içindir.</span>
<span class="c1">// ama sonuç olarak bir bool değerine nullptr atayabilirsin!</span>
<span class="o">*</span><span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w">  </span><span class="c1">// &#39;*pt&#39; değeri bir boll olmasına rağmen, hala derlenir!</span>


<span class="c1">// &#39;=&#39; != &#39;=&#39; != &#39;=&#39;!</span>
<span class="c1">// Calls Foo::Foo(const Foo&amp;) or some variant (see move semantics) copy</span>
<span class="c1">// Foo::Foo(const Foo&amp;) çağrısını veya kopyalama constructor&#39;ının bir çeşidinin çağrısınıyapar(taşıma semantiklerine bknz.)</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span>

<span class="c1">// Foo::operator=(Foo&amp;) çağrısını yapar.</span>
<span class="n">Foo</span><span class="w"> </span><span class="n">f1</span><span class="p">;</span>
<span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span>


<span class="c1">///////////////////////////////////////</span>
<span class="c1">// Tuple (C++11 ve yukarısı)</span>
<span class="c1">///////////////////////////////////////</span>

<span class="cp">#include</span><span class="cpf">&lt;tuple&gt;</span>

<span class="c1">// Ana fikir olarak, Tuple, eski veri yapılarına (C&#39;deki struct&#39;lar) benzer ama isimli veri üyeleri yerine </span>
<span class="c1">// elemanlarına tuple içindeki sırasına göre erişilir.</span>

<span class="c1">// Tuple&#39;ı inşa ederek başlayalım</span>
<span class="c1">// değişkenleri tuple içinde paketliyoruz</span>
<span class="k">auto</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;A&#39;</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maxN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1e9</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maxL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">15</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_tuple</span><span class="p">(</span><span class="n">maxN</span><span class="p">,</span><span class="w"> </span><span class="n">maxL</span><span class="p">);</span>

<span class="c1">// &#39;first&#39; tuple&#39;ının değerlerini yazdırma</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">first</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">first</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 10 A yazdırır</span>

<span class="c1">// &#39;second&#39; tuple&#39;ının değerlerini yazdırma</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">second</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">second</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 1000000000 15 yazdırır</span>

<span class="c1">// Değişkenleri tuple&#39;dan çıkarma</span>

<span class="kt">int</span><span class="w"> </span><span class="n">first_int</span><span class="p">;</span>
<span class="kt">char</span><span class="w"> </span><span class="n">first_char</span><span class="p">;</span>
<span class="n">tie</span><span class="p">(</span><span class="n">first_int</span><span class="p">,</span><span class="w"> </span><span class="n">first_char</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first</span><span class="p">;</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">first_int</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">first_char</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w">  </span><span class="c1">// 10 A yazdırır</span>

<span class="c1">// Ayrıca şu şekide de tuple oluşturabiliriz.</span>

<span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">third</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;A&#39;</span><span class="p">,</span><span class="w"> </span><span class="mf">3.14141</span><span class="p">);</span>
<span class="c1">// tuple_size, tuple&#39;daki eleman sayısını (constexpr olarak) döndürür</span>

<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">tuple_size</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">third</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 3 yazdırır</span>

<span class="c1">// tuple_cat, tuple&#39;daki tüm elemanları aynı sırada birleştirir.</span>

<span class="k">auto</span><span class="w"> </span><span class="n">concatenated_tuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tuple_cat</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">second</span><span class="p">,</span><span class="w"> </span><span class="n">third</span><span class="p">);</span>
<span class="c1">// concatenated_tuple = (10, &#39;A&#39;, 1e9, 15, 11, &#39;A&#39;, 3.14141) olur</span>

<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">concatenated_tuple</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 10 yazdırır</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">concatenated_tuple</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 15 yazdırır</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">&gt;</span><span class="p">(</span><span class="n">concatenated_tuple</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// &#39;A&#39; yazdırır</span>


<span class="c1">/////////////////////</span>
<span class="c1">// Tutucular</span>
<span class="c1">/////////////////////</span>

<span class="c1">// Tutucular veya Standard Şablon Kütüphanesi(STL) önceden tanımlanmış şablonlar sunar.</span>
<span class="c1">// Bunlar elemanları için ayrılan hafıza alanını yönetir</span>
<span class="c1">// ve onlara erişim ve değiştirmek için üye fonksiyonlar sağlar</span>

<span class="c1">// Bazı tutucular şunlardır:</span>

<span class="c1">// Vector (Dinamik Dizi)</span>
<span class="c1">// koşma anında nesne dizisi veya list oluşturmamızı sağlar</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<span class="n">string</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">my_vector</span><span class="p">;</span><span class="w"> </span><span class="c1">// vector&#39;ü tanımla</span>
<span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="n">my_vector</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">val</span><span class="p">);</span><span class="w"> </span><span class="c1">// val değerini my_vector vectörüne push edecektir</span>
<span class="n">my_vector</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">val</span><span class="p">);</span><span class="w"> </span><span class="c1">// val değerini yeniden push edecektir (şu an iki elemanı var)</span>

<span class="c1">// vector içinde dolaşmak için iki seçenek var:</span>
<span class="c1">// ya klasik döngüyle (0. index&#39;ten son index&#39;e kadar iterasyon yaparak)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">my_vector</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">	</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">my_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// vector&#39;ün elemanlarına uşamak için [] operatörünü kullanabiliriz</span>
<span class="p">}</span>

<span class="c1">// ya da iteratör kulllanarak:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="p">;</span><span class="w"> </span><span class="c1">// vector için iterator tanımla</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_vector</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">my_vector</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">	</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="w">  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Set(Küme)</span>
<span class="c1">// Set&#39;ler benzersiz(unique) elemanları belirli bir sırada saklayan tutuculardır.</span>
<span class="c1">// Set, benzersiz değerleri, herhangi bir fonksiyon veya kod gerektirmeksizin, sıralı olarak</span>

<span class="cp">#include</span><span class="cpf">&lt;set&gt;</span>
<span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ST</span><span class="p">;</span><span class="w">    </span><span class="c1">// int tipi için set tanımlar</span>
<span class="n">ST</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span><span class="w">  </span><span class="c1">// ST kümesini 30 değerini dahil eder</span>
<span class="n">ST</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w">  </span><span class="c1">// ST kümesini 10 değerini dahil eder</span>
<span class="n">ST</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w">  </span><span class="c1">// ST kümesini 20 değerini dahil eder</span>
<span class="n">ST</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span><span class="w">  </span><span class="c1">// ST kümesini 30 değerini dahil eder</span>
<span class="c1">// Şimdi kümedeki elemanlar aşağıdaki gibidir</span>
<span class="c1">//  10 20 30</span>

<span class="c1">// Bir eleman silmek için:</span>
<span class="n">ST</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w">  </span><span class="c1">// 20 değerine sahip elemanı siler</span>
<span class="c1">// Set ST: 10 30</span>
<span class="c1">// Iterator kullanarak Set içinde iterasyon yapmak için:</span>
<span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="n">it</span><span class="o">=</span><span class="n">ST</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="n">it</span><span class="o">&lt;</span><span class="n">ST</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="n">it</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">	</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// Output:</span>
<span class="c1">// 10</span>
<span class="c1">// 30</span>

<span class="c1">// Tutucuyu tamamen silmek için Tutucu_Adi.clear() kullanırız</span>
<span class="n">ST</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ST</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w">  </span><span class="c1">// ST kümesinin eleman sayısı(size)nı yazdırır.</span>
<span class="c1">// Output: 0</span>

<span class="c1">// NOTE: Aynı elemanlari içerebilen kümle için multiset kullanırız</span>

<span class="c1">// Map(Harita)</span>
<span class="c1">// Map, elemanları anahtar değer, haritalanmış değer şeklinde özel bir sırada saklar.</span>
<span class="c1">// anahtar_değer -&gt; haritalanmış_değer</span>

<span class="cp">#include</span><span class="cpf">&lt;map&gt;</span>
<span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mymap</span><span class="p">;</span><span class="w">  </span><span class="c1">// Anahtar char ve değer int olacak şekilde map tanımlar</span>

<span class="n">mymap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="sc">&#39;A&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
<span class="c1">// 1 değeri için A anahtar değerini ekler</span>
<span class="n">mymap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="sc">&#39;Z&#39;</span><span class="p">,</span><span class="mi">26</span><span class="p">));</span>
<span class="c1">// 26 değeri için Z anahtar değerini ekler</span>

<span class="c1">// Map&#39;te dolaşma</span>
<span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">it</span><span class="o">=</span><span class="n">mymap</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="o">!=</span><span class="n">mymap</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;-&gt;&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="c1">// Output:</span>
<span class="c1">// A-&gt;1</span>
<span class="c1">// Z-&gt;26</span>

<span class="c1">// Anahtar&#39;a atanmış değeri bulmak için</span>
<span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mymap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39;Z&#39;</span><span class="p">);</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>

<span class="c1">// Output: 26</span>


<span class="c1">/////////////////////////////////////////////</span>
<span class="c1">// Mantıksal ve Bit seviyesindeki operatörler</span>
<span class="c1">/////////////////////////////////////////////</span>

<span class="c1">// Pek çok C++ operatörleri diğer dillerdekiyle aynıdır</span>

<span class="c1">// Mantıksal operatörler</span>

<span class="c1">// C++, bool ifadelerinde Kısa-devre değerlendirmesini kullanır yani ikinci argüman yalnızca ilk argüman</span>
<span class="c1">// ifadenin değerine karar vermek için yeterli değilse çalıştırılır</span>

<span class="nb">true</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="c1">// **mantıksal ve** işlemi yapılır ve yanlış sonucu üretilir</span>
<span class="nb">true</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="c1">// **mantıksal veya** işlemi yapılır ve true  sonucu üretilir </span>
<span class="o">!</span><span class="w"> </span><span class="nb">true</span><span class="w">        </span><span class="c1">// **mantıksal değil** işlemi yapılır ve yalnış sonucu üretilir</span>

<span class="c1">// Sembolleri kullanmak yerine onlara karşılık gelen anahtar kelimeler kullanılabilir</span>
<span class="nb">true</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="c1">// **mantıksal ve** işlemi yapılır ve yanlış sonucu üretilir</span>
<span class="nb">true</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="nb">false</span><span class="w">  </span><span class="c1">// **mantıksal veya** işlemi yapılır ve true  sonucu üretilir </span>
<span class="k">not</span><span class="w"> </span><span class="nb">true</span><span class="w">       </span><span class="c1">// **mantıksal değil** işlemi yapılır ve yalnış sonucu üretilir</span>

<span class="c1">// Bit seviyesindeki operatörler</span>

<span class="c1">// **&lt;&lt;** Sola kaydırma operatörü</span>
<span class="c1">// &lt;&lt; bitleri sola kaydırır</span>
<span class="mi">4</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// 4&#39;ün bitlerini 1 sola kaydırır ve 8 sonucunu verir</span>
<span class="c1">// x &lt;&lt; n, x * 2^n olarak düşünülebilir</span>


<span class="c1">// **&gt;&gt;** Sağa kaydırma operatörü</span>
<span class="c1">// &gt;&gt; bitleri sağa kaydırır</span>
<span class="mi">4</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// 4&#39;ün bitlerini 1 sağa kaydırır ve 2 sonucunu verir</span>
<span class="c1">// x &gt;&gt; n, x / 2^n olarak düşünülebilir</span>

<span class="o">~</span><span class="mi">4</span><span class="w">    </span><span class="c1">// Bit seviyesinde değil işlemini gerçekleştirir</span>
<span class="mi">4</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">// Bit seviyesinde veya işlemini gerçekleştirir</span>
<span class="mi">4</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">// Bit seviyesinde ve işlemini gerçekleştirir</span>
<span class="mi">4</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">// Bit seviyesinde xor işlemini gerçekleştirir</span>

<span class="c1">// Eşdeğer anahtar kelimeler</span>
<span class="k">compl</span><span class="w"> </span><span class="mi">4</span><span class="w">    </span><span class="c1">// Bit seviyesinde değil işlemini gerçekleştirir</span>
<span class="mi">4</span><span class="w"> </span><span class="k">bitor</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="c1">// Bit seviyesinde veya işlemini gerçekleştiri</span>
<span class="mi">4</span><span class="w"> </span><span class="k">bitand</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">// Bit seviyesinde ve işlemini gerçekleştirir</span>
<span class="mi">4</span><span class="w"> </span><span class="k">xor</span><span class="w"> </span><span class="mi">3</span><span class="w">    </span><span class="c1">// Bit seviyesinde xor işlemini gerçekleştirir</span>
</pre></div>
<p>İleri okuma:</p>
<ul>
<li>Güncel bir referans <a href="http://cppreference.com/w/cpp">CPP Reference</a> adresinde bulunabilir.</li>
<li>Ek kaynaklar <a href="http://cplusplus.com">CPlusPlus</a> adresinde bulunabilir.</li>
<li>Dilin temellerini ve kodlama ortamını belirleyen bir öğretici <a href="https://www.youtube.com/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb">TheChernoProject - C ++</a> adresinde bulunabilir.</li>
</ul>

        <hr>
        <p>
          Bir öneriniz mi var? Belki bir düzeltme? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Bir konu açın</a> GitHub deposundan, ya da kendi <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/tr/c++.md">PR</a>'nizi hazırlayın!
        </p>
        <p class="contributed">
          Aslen katkıda bulunan Steven Basart, ve güncelleştiren <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/tr/c++.md">3 geliştirici(ler)</a>.
        </p>

        <footer>
          <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width: 0; width: 80px; height: 28px; padding-bottom: 5px;" src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-sa.svg" /></a>
          <p>
            &copy; 2025
            <a href="http://github.com/xksteven">Steven Basart</a>,
            <a href="https://github.com/mrkline">Matt Kline</a>,
            <a href="http://geoffliu.me">Geoff Liu</a>,
            <a href="http://github.com/connorwaters">Connor Waters</a>,
            <a href="http://github.com/ankushg07">Ankush Goyal</a>,
            <a href="https://github.com/jatindhankhar">Jatin Dhankhar</a>,
            <a href="https://github.com/p1v0t">Adem Budak</a>
          </p>
        </footer>
      </div>
    </div>
  </body>
</html>