<!DOCTYPE html>
<html lang="en">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-WXC8R75DEN');
    </script>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="Content-Language" content="en">
    <title>Learn Zig in Y Minutes</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto+Slab:wght@100..900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/screen.css">
    <link rel="stylesheet" href="/css/light.css">
    <link rel="stylesheet" href="/css/dark.css">

    <link rel="canonical" href="https://learnxinyminutes.com/zig/">
    <script>
      localStorage.removeItem("lxiym_theme");
    </script>
  </head>
  <body>
    <div class="container">
      <div class="share">
        <span class="sharemsg">
          <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fzig%2F&amp;text=Learn+X+in+Y+minutes%2C+where+X%3DZig">
            Share this page
          </a>
        </span>
        <span class='st_facebook_large' displayText='Facebook'></span>
        <span class='st_twitter_large' displayText='Tweet'></span>
      </div>
      <h1><a href="/">Learn X in Y minutes</a></h1>
      <h2>Where X=Zig</h2>
      <p class="filelink">
        Get the code:
        <a href="/files/learnzig.zig">learnzig.zig</a>
      </p>
      <div id="doc">
<p><a href="https://ziglang.org">Zig</a> aims to be a replacement for the C programming language.</p>
<p><strong>WARNING</strong>: this document expects you to understand a few basic concepts in computer
science, such as pointers, stack and heap memory, etc. Prior knowledge of C is
recommended.</p>
<h2>Quick overview: Zig compared to C</h2>
<ul>
<li>Syntax is mostly the same, with some improvements (less ambiguity).</li>
<li>Zig introduces namespaces.</li>
<li><code>try</code> and <code>catch</code> mechanism, which is both convenient, efficient and optional.</li>
<li>Most of the C undefined behaviors (UBs) are fixed.</li>
<li>Compared to C, raw pointers are safer to use and less likely to be needed.
<ul>
<li>The type system distinguishes between a pointer to a single value, or multiple values, etc.</li>
<li>Slices are preferred, which is a structure with a pointer and a runtime known size, which characterizes most uses of pointers in the first place.</li>
</ul>
</li>
<li>Some arbitrary language limitations are removed. For example, enumerations, structures and unions can have functions.</li>
<li>Simple access to SIMD operations (basic maths on vectors).</li>
<li>Zig provides both low-level features of C and the one provided through compiler extensions.
For example: packed structures.</li>
<li>An extensive standard library, including data structures and algorithms.</li>
<li>Cross-compilation capability is provided by default, without any dependency.
Different libc are provided to ease the process.
Cross-compilation works from, and to, any operating system and architecture.</li>
</ul>
<h2>Zig language</h2>
<div class="highlight"><pre lang="zig"><span class="c1">//! Top-level documentation.</span>

<span class="c1">/// Documentation comment.</span>

<span class="c1">// Simple comment.</span>
</pre></div>
<h3>Hello world.</h3>
<div class="highlight"><pre lang="zig"><span class="c1">// Import standard library, reachable through the &quot;std&quot; constant.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">std</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@import</span><span class="p">(</span><span class="s">&quot;std&quot;</span><span class="p">);</span>

<span class="c1">// &quot;info&quot; now refers to the &quot;std.log.info&quot; function.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">;</span>

<span class="c1">// Usual hello world.</span>
<span class="c1">// syntax: [pub] fn &lt;function-name&gt;(&lt;arguments&gt;) &lt;return-type&gt; { &lt;body&gt; }</span>
<span class="kr">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Contrary to C functions, Zig functions have a fixed number of arguments.</span>
<span class="w">    </span><span class="c1">// In C: &quot;printf&quot; takes any number of arguments.</span>
<span class="w">    </span><span class="c1">// In Zig: std.log.info takes a format and a list of elements to print.</span>
<span class="w">    </span><span class="n">info</span><span class="p">(</span><span class="s">&quot;hello world&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{});</span><span class="w">  </span><span class="c1">// .{} is an empty anonymous tuple.</span>
<span class="p">}</span>
</pre></div>
<h3>Booleans, integers and float.</h3>
<div class="highlight"><pre lang="zig"><span class="c1">// Booleans.</span>
<span class="c1">// Keywords are preferred to operators for boolean operations.</span>
<span class="n">print</span><span class="p">(</span><span class="s">&quot;{}</span><span class="se">\n</span><span class="s">{}</span><span class="se">\n</span><span class="s">{}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span>
<span class="w">    </span><span class="kc">true</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">    </span><span class="kc">true</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">    </span><span class="o">!</span><span class="kc">true</span><span class="p">,</span>
<span class="p">});</span>

<span class="c1">// Integers.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">one_plus_one</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="s">&quot;1 + 1 = {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">one_plus_one</span><span class="p">});</span><span class="w"> </span><span class="c1">// 2</span>

<span class="c1">// Floats.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">seven_div_three</span><span class="o">:</span><span class="w"> </span><span class="kt">f32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">7.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">3.0</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="s">&quot;7.0 / 3.0 = {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">seven_div_three</span><span class="p">});</span><span class="w"> </span><span class="c1">// 2.33333325e+00</span>

<span class="c1">// Integers have arbitrary value lengths.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">myvar</span><span class="o">:</span><span class="w"> </span><span class="n">u10</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// 10-bit unsigned integer</span>
<span class="c1">// Useful for example to read network packets, or complex binary formats.</span>

<span class="c1">// Number representation is greatly improved compared to C.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">one_billion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="n">_000_000_000</span><span class="p">;</span><span class="w">         </span><span class="c1">// Decimal.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">binary_mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mb">0b1</span><span class="n">_1111_1111</span><span class="p">;</span><span class="w">         </span><span class="c1">// Binary. Ex: network mask.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">permissions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0o7</span><span class="n">_5_5</span><span class="p">;</span><span class="w">               </span><span class="c1">// Octal.  Ex: Unix permissions.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">big_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xFF80</span><span class="n">_0000_0000_0000</span><span class="p">;</span><span class="w"> </span><span class="c1">// Hexa.   Ex: IPv6 address.</span>


<span class="c1">// Overflow operators: tell the compiler when it&#39;s okay to overflow.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">i</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// &quot;i&quot; is an unsigned 8-bit integer</span>
<span class="n">i</span><span class="w">  </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">        </span><span class="c1">// runtime overflow error (unsigned value always are positive)</span>
<span class="n">i</span><span class="w"> </span><span class="o">-%=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">        </span><span class="c1">// okay (wrapping operator), i == 255</span>

<span class="c1">// Saturation operators: values will stick to their lower and upper bounds.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">i</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">200</span><span class="p">;</span><span class="w">   </span><span class="c1">// &quot;i&quot; is an unsigned 8-bit integer (values: from 0 to 255)</span>
<span class="n">i</span><span class="w">  </span><span class="o">+|</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">255</span><span class="w">   </span><span class="c1">// u8: won&#39;t go higher than 255</span>
<span class="n">i</span><span class="w">  </span><span class="o">-|</span><span class="w"> </span><span class="mi">300</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="c1">// unsigned, won&#39;t go lower than 0</span>
<span class="n">i</span><span class="w">  </span><span class="o">*|</span><span class="w"> </span><span class="mi">2</span><span class="w">   </span><span class="o">==</span><span class="w"> </span><span class="mi">255</span><span class="w">   </span><span class="c1">// u8: won&#39;t go higher than 255</span>
<span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;|</span><span class="w"> </span><span class="mi">8</span><span class="w">   </span><span class="o">==</span><span class="w"> </span><span class="mi">255</span><span class="w">   </span><span class="c1">// u8: won&#39;t go higher than 255</span>
</pre></div>
<h3>Arrays.</h3>
<div class="highlight"><pre lang="zig"><span class="c1">// An array is a well-defined structure with a length attribute (len).</span>

<span class="c1">// 5-byte array with undefined content (stack garbage).</span>
<span class="kr">var</span><span class="w"> </span><span class="n">array1</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">undefined</span><span class="p">;</span>

<span class="c1">// 5-byte array with defined content.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">array2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">};</span>
<span class="c1">// [_] means the compiler knows the length at compile-time.</span>

<span class="c1">// 1000-byte array with defined content (0).</span>
<span class="kr">var</span><span class="w"> </span><span class="n">array3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="mi">0</span><span class="p">}</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span>

<span class="c1">// Another 1000-byte array with defined content.</span>
<span class="c1">// The content is provided by the &quot;foo&quot; function, called at compile-time and</span>
<span class="c1">// allows complex initializations.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">array4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="n">foo</span><span class="p">()}</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span>

<span class="c1">// In any case, array.len gives the length of the array,</span>
<span class="c1">// array1.len and array2.len produce 5, array3.len and array4.len produce 1000.</span>


<span class="c1">// Modifying and accessing arrays content.</span>

<span class="c1">// Array of 10 32-bit undefined integers.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">some_integers</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">undefined</span><span class="p">;</span>

<span class="n">some_integers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">;</span><span class="w"> </span><span class="c1">// first element of the array is now 30</span>

<span class="kr">var</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_integers</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="c1">// &quot;x&quot; now equals to 30, its type is inferred.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_integers</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="c1">// Second element of the array isn&#39;t defined.</span>
<span class="w">                          </span><span class="c1">// &quot;y&quot; got a stack garbage value (no runtime error).</span>

<span class="c1">// Array of 10 32-bit undefined integers.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">some_integers</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">undefined</span><span class="p">;</span>

<span class="kr">var</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_integers</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span><span class="w"> </span><span class="c1">// index &gt; array size, compilation error.</span>

<span class="c1">// At runtime, we loop over the elements of &quot;some_integers&quot; with an index.</span>
<span class="c1">// Index i = 20, then we try:</span>
<span class="k">try</span><span class="w"> </span><span class="n">some_integers</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"> </span><span class="c1">// Runtime error &#39;index out of bounds&#39;.</span>
<span class="w">                      </span><span class="c1">// &quot;try&quot; keyword is necessary when accessing an array with</span>
<span class="w">                      </span><span class="c1">// an index, since there is a potential runtime error.</span>
<span class="w">                      </span><span class="c1">// More on that later.</span>
</pre></div>
<h3>Multidimensional arrays.</h3>
<div class="highlight"><pre lang="zig"><span class="kr">const</span><span class="w"> </span><span class="n">mat4x4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span><span class="kt">f32</span><span class="p">{</span>
<span class="w">    </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">f32</span><span class="p">{</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">f32</span><span class="p">{</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">f32</span><span class="p">{</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">f32</span><span class="p">{</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">},</span>
<span class="p">};</span>

<span class="c1">// Access the 2D array then the inner array through indexes.</span>
<span class="k">try</span><span class="w"> </span><span class="n">expect</span><span class="p">(</span><span class="n">mat4x4</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>

<span class="c1">// Here we iterate with for loops.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">mat4x4</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">row_index</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">row</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">cell</span><span class="p">,</span><span class="w"> </span><span class="n">column_index</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h3>Strings.</h3>
<div class="highlight"><pre lang="zig"><span class="c1">// Simple string constant.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">greetings</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p">;</span>
<span class="c1">// ... which is equivalent to:</span>
<span class="kr">const</span><span class="w"> </span><span class="n">greetings</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="kr">const</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p">;</span>
<span class="c1">// In words: &quot;greetings&quot; is a constant value, a pointer on a constant array of 5</span>
<span class="c1">// elements (8-bit unsigned integers), with an extra &#39;0&#39; at the end.</span>
<span class="c1">// The extra &quot;0&quot; is called a &quot;sentinel value&quot;.</span>

<span class="n">print</span><span class="p">(</span><span class="s">&quot;string: {s}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">greetings</span><span class="p">});</span>

<span class="c1">// This represents rather faithfully C strings. Although, Zig strings are</span>
<span class="c1">// structures, no need for &quot;strlen&quot; to compute their size.</span>
<span class="c1">// greetings.len == 5</span>
</pre></div>
<h3>Slices.</h3>
<div class="highlight"><pre lang="zig"><span class="c1">// A slice is a pointer and a size, an array without compile-time known size.</span>
<span class="c1">// Slices have runtime out-of-band verifications.</span>

<span class="kr">const</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span><span class="w">     </span><span class="c1">// [_] = array with compile-time known size.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">..</span><span class="n">array</span><span class="p">.</span><span class="n">len</span><span class="p">];</span><span class="w">  </span><span class="c1">// &quot;slice&quot; represents the whole array.</span>
<span class="w">                                    </span><span class="c1">// slice[10] gives a runtime error.</span>
</pre></div>
<h3>Pointers.</h3>
<div class="highlight"><pre lang="zig"><span class="c1">// Pointer on a value can be created with &quot;&amp;&quot;.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="kr">const</span><span class="w"> </span><span class="n">pointer</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w">  </span><span class="c1">// &quot;pointer&quot; is a pointer on the i32 var &quot;x&quot;.</span>
<span class="n">print</span><span class="p">(</span><span class="s">&quot;1 = {}, {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">pointer</span><span class="p">});</span>

<span class="c1">// Pointer values are accessed and modified with &quot;.*&quot;.</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pointer</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;x value == {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">pointer</span><span class="p">.</span><span class="o">*</span><span class="p">});</span>
<span class="p">}</span>

<span class="c1">// &quot;.?&quot; is a shortcut for &quot;orelse unreachable&quot;.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pointer</span><span class="p">.</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// Get the pointed value, otherwise crash.</span>
</pre></div>
<h3>Optional values (?&lt;type&gt;).</h3>
<div class="highlight"><pre lang="zig"><span class="c1">// An optional is a value than can be of any type or null.</span>

<span class="c1">// Example: &quot;optional_value&quot; can either be &quot;null&quot; or an unsigned 32-bit integer.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">optional_value</span><span class="o">:</span><span class="w"> </span><span class="o">?</span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w"> </span><span class="c1">// optional_value == null</span>
<span class="n">optional_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w">             </span><span class="c1">// optional_value != null</span>

<span class="c1">// &quot;some_function&quot; returns ?u32</span>
<span class="kr">var</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_function</span><span class="p">();</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">value</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// In case &quot;some_function&quot; returned a value.</span>
<span class="w">    </span><span class="c1">// Do something with &#39;value&#39;.</span>
<span class="p">}</span>
</pre></div>
<h3>Errors.</h3>
<div class="highlight"><pre lang="zig"><span class="c1">// Zig provides an unified way to express errors.</span>

<span class="c1">// Errors are defined in error enumerations, example:</span>
<span class="kr">const</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">error</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">WatchingAnyNetflixTVShow</span><span class="p">,</span>
<span class="w">    </span><span class="n">BeOnTwitter</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// Normal enumerations are expressed the same way, but with &quot;enum&quot; keyword.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">SuccessStory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">DoingSport</span><span class="p">,</span>
<span class="w">    </span><span class="n">ReadABook</span><span class="p">,</span>
<span class="p">};</span>


<span class="c1">// Error union (!).</span>
<span class="c1">// Either the value &quot;mylife&quot; is an an error or a normal value.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">mylife</span><span class="o">:</span><span class="w"> </span><span class="n">Error</span><span class="o">!</span><span class="n">SuccessStory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Error</span><span class="p">.</span><span class="n">BeOnTwitter</span><span class="p">;</span>
<span class="c1">// mylife is an error. Sad.</span>

<span class="n">mylife</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SuccessStory</span><span class="p">.</span><span class="n">ReadABook</span><span class="p">;</span>
<span class="c1">// Now mylife is an enum.</span>


<span class="c1">// Zig ships with many pre-defined errors. Example:</span>
<span class="kr">const</span><span class="w"> </span><span class="n">value</span><span class="o">:</span><span class="w"> </span><span class="kt">anyerror</span><span class="o">!</span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">error</span><span class="p">.</span><span class="n">Broken</span><span class="p">;</span>


<span class="c1">// Handling errors.</span>

<span class="c1">// Some error examples.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">error</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UnExpected</span><span class="p">,</span>
<span class="w">    </span><span class="n">Authentication</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// &quot;some_function&quot; can either return an &quot;Error&quot; or an integer.</span>
<span class="k">fn</span><span class="w"> </span><span class="n">some_function</span><span class="p">()</span><span class="w"> </span><span class="n">Error</span><span class="o">!</span><span class="kt">u8</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Error</span><span class="p">.</span><span class="n">UnExpected</span><span class="p">;</span><span class="w"> </span><span class="c1">// It returns an error.</span>
<span class="p">}</span>

<span class="c1">// Errors can be &quot;catch&quot; without intermediate variable.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_function</span><span class="p">()</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="o">|</span><span class="n">err</span><span class="o">|</span><span class="w"> </span><span class="k">switch</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Error</span><span class="p">.</span><span class="n">UnExpected</span><span class="w">     </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">,</span><span class="w">   </span><span class="c1">// Returns the error.</span>
<span class="w">    </span><span class="n">Error</span><span class="p">.</span><span class="n">Authentication</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">unreachable</span><span class="p">,</span><span class="w">  </span><span class="c1">// Not expected. Crashes the program.</span>
<span class="w">    </span><span class="k">else</span><span class="w">                 </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">unreachable</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// An error can be &quot;catch&quot; without giving it a name.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">unwrapped</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_function</span><span class="p">()</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="mi">1234</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;unwrapped&quot; = 1234</span>

<span class="c1">// &quot;try&quot; is a very handy shortcut for &quot;catch |err| return err&quot;.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">some_function</span><span class="p">();</span>
<span class="c1">// If &quot;some_function&quot; fails, the current function stops and returns the error.</span>
<span class="c1">// &quot;value&quot; can only have a valid value, the error already is handled with &quot;try&quot;.</span>
</pre></div>
<h3>Control flow.</h3>
<div class="highlight"><pre lang="zig"><span class="c1">// Conditional branching.</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">condition</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
<span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>

<span class="c1">// Ternary.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">condition</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>

<span class="c1">// Shortcut for &quot;if (x) x else 0&quot;</span>
<span class="kr">var</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">orelse</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// If &quot;a&quot; is an optional, which may contain a value.</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">value</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;value: {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">value</span><span class="p">});</span>
<span class="p">}</span>
<span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;&#39;a&#39; is null</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{});</span>
<span class="p">}</span>

<span class="c1">// Get a pointer on the value (if it exists).</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">|*</span><span class="n">value</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>


<span class="c1">// Loops.</span>

<span class="c1">// Syntax examples:</span>
<span class="c1">//   while (condition) statement</span>
<span class="c1">//   while (condition) : (end-of-iteration-statement) statement</span>
<span class="c1">//</span>
<span class="c1">//   for (iterable) statement</span>
<span class="c1">//   for (iterable) |capture| statement</span>
<span class="c1">//   for (iterable) statement else statement</span>

<span class="c1">// Note: loops work the same way over arrays or slices.</span>

<span class="c1">// Simple &quot;while&quot; loop.</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="c1">// While loop with a &quot;continue expression&quot;</span>
<span class="c1">// (expression executed as the last expression of the loop).</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="c1">// Same, with a more complex continue expression (block of code).</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2000</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">({</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>

<span class="c1">// To iterate over a portion of a slice, reslice.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">..</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">|</span><span class="n">value</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="c1">// Loop over every item of an array (or slice).</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">items</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">value</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="c1">// Iterate and get pointers on values instead of copies.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">items</span><span class="p">)</span><span class="w"> </span><span class="o">|*</span><span class="n">value</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="c1">// Iterate with an index.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">items</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;val[{}] = {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">});</span><span class="w"> </span><span class="p">}</span>

<span class="c1">// Iterate with pointer and index.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">items</span><span class="p">)</span><span class="w"> </span><span class="o">|*</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;val[{}] = {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">});</span><span class="w"> </span><span class="n">value</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>


<span class="c1">// Break and continue are supported.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">items</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">value</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// For loops can also be used as expressions.</span>
<span class="c1">// Similar to while loops, when you break from a for loop,</span>
<span class="c1">// the else branch is not evaluated.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">sum</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="c1">// The &quot;for&quot; loop has to provide a value, which will be the &quot;else&quot; value.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">items</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">value</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">value</span><span class="p">.</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;result&quot; will be the last &quot;sum&quot; value.</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">                  </span><span class="c1">// Last value.</span>
</pre></div>
<h3>Labels.</h3>
<div class="highlight"><pre lang="zig"><span class="c1">// Labels are a way to name an instruction, a location in the code.</span>
<span class="c1">// Labels can be used to &quot;continue&quot; or &quot;break&quot; in a nested loop.</span>
<span class="n">outer</span><span class="o">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">([</span><span class="n">_</span><span class="p">]</span><span class="kt">i32</span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">([</span><span class="n">_</span><span class="p">]</span><span class="kt">i32</span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">count</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="k">continue</span><span class="w"> </span><span class="o">:</span><span class="n">outer</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;continue&quot; for the first loop.</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// count = 8</span>
<span class="n">outer</span><span class="o">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">([</span><span class="n">_</span><span class="p">]</span><span class="kt">i32</span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">([</span><span class="n">_</span><span class="p">]</span><span class="kt">i32</span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">count</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="k">break</span><span class="w"> </span><span class="o">:</span><span class="n">outer</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;break&quot; for the first loop.</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// count = 1</span>


<span class="c1">// Labels can also be used to return a value from a block.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="kr">const</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blk</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">break</span><span class="w"> </span><span class="o">:</span><span class="n">blk</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="c1">// Now &quot;x&quot; equals 6.</span>
<span class="p">};</span>
<span class="c1">// Relevant in cases like &quot;for else&quot; expression (explained in the following).</span>

<span class="c1">// For loops can be used as expressions.</span>
<span class="c1">// When you break from a for loop, the else branch is not evaluated.</span>
<span class="c1">// WARNING: counter-intuitive.</span>
<span class="c1">//      The &quot;for&quot; loop will run, then the &quot;else&quot; block will run.</span>
<span class="c1">//      The &quot;else&quot; keyword has to be followed by the value to give to &quot;result&quot;.</span>
<span class="c1">//      See later for another form.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">sum</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kr">const</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">items</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">value</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"> </span><span class="c1">// result = 8</span>

<span class="c1">// In this case, the &quot;else&quot; keyword is followed by a value, too.</span>
<span class="c1">// However, the syntax is different: it is labeled.</span>
<span class="c1">// Instead of a value, there is a label followed by a block of code, which</span>
<span class="c1">// allows to do stuff before returning the value (see the &quot;break&quot; invocation).</span>
<span class="kr">const</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">items</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">value</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// First: loop.</span>
<span class="w">    </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="n">blk</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w">                        </span><span class="c1">// Second: &quot;else&quot; block.</span>
<span class="w">    </span><span class="n">std</span><span class="p">.</span><span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;executed AFTER the loop!&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{});</span>
<span class="w">    </span><span class="k">break</span><span class="w"> </span><span class="o">:</span><span class="n">blk</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span><span class="w"> </span><span class="c1">// The &quot;sum&quot; value will replace the label &quot;blk&quot;.</span>
<span class="p">};</span>
</pre></div>
<h3>Switch.</h3>
<div class="highlight"><pre lang="zig"><span class="c1">// As a switch in C, but slightly more advanced.</span>
<span class="c1">// Syntax:</span>
<span class="c1">//   switch (value) {</span>
<span class="c1">//       pattern =&gt; expression,</span>
<span class="c1">//       pattern =&gt; expression,</span>
<span class="c1">//       else    =&gt; expression</span>
<span class="c1">//   };</span>

<span class="c1">// A switch only checking for simple values.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">switch</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Error</span><span class="p">.</span><span class="n">UnExpected</span><span class="w">     </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">,</span>
<span class="w">    </span><span class="n">Error</span><span class="p">.</span><span class="n">Authentication</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">unreachable</span><span class="p">,</span>
<span class="w">    </span><span class="k">else</span><span class="w">                 </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">unreachable</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// A slightly more advanced switch, accepting a range of values:</span>
<span class="kr">const</span><span class="w"> </span><span class="n">foo</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kr">const</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="mi">0</span><span class="w">                        </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&quot;zero&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="mi">1</span><span class="p">...</span><span class="n">std</span><span class="p">.</span><span class="n">math</span><span class="p">.</span><span class="n">maxInt</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&quot;positive&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="k">else</span><span class="w">                     </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&quot;negative&quot;</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
<h3>Structures.</h3>
<div class="highlight"><pre lang="zig"><span class="c1">// Structure containing a single value.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">Full</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">number</span><span class="o">:</span><span class="w"> </span><span class="kt">u16</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// Packed structure, with guaranteed in-memory layout.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">Divided</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kr">packed</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">half1</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span>
<span class="w">    </span><span class="n">quarter3</span><span class="o">:</span><span class="w"> </span><span class="n">u4</span><span class="p">,</span>
<span class="w">    </span><span class="n">quarter4</span><span class="o">:</span><span class="w"> </span><span class="n">u4</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// Point is a constant representing a structure containing two u32, &quot;x&quot; and &quot;y&quot;.</span>
<span class="c1">// &quot;x&quot; has a default value, which wasn&#39;t possible in C.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="c1">// default value</span>
<span class="w">    </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// Variable &quot;p&quot; is a new Point, with x = 1 (default value) and y = 2.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">};</span>

<span class="c1">// Fields are accessed as usual with the dot notation: variable.field.</span>
<span class="n">print</span><span class="p">(</span><span class="s">&quot;p.x: {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">});</span><span class="w"> </span><span class="c1">// 1</span>
<span class="n">print</span><span class="p">(</span><span class="s">&quot;p.y: {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">});</span><span class="w"> </span><span class="c1">// 2</span>


<span class="c1">// A structure can also contain public constants and functions.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">pub</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="n">some_constant</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">;</span>

<span class="w">    </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// This function &quot;init&quot; creates a Point and returns it.</span>
<span class="w">    </span><span class="kr">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">init</span><span class="p">()</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Point</span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>


<span class="c1">// How to access a structure public constant.</span>
<span class="c1">// The value isn&#39;t accessed from an &quot;instance&quot; of the structure, but from the</span>
<span class="c1">// constant representing the structure definition (Point).</span>
<span class="n">print</span><span class="p">(</span><span class="s">&quot;constant: {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">Point</span><span class="p">.</span><span class="n">some_constant</span><span class="p">});</span>

<span class="c1">// Having an &quot;init&quot; function is rather idiomatic in the standard library.</span>
<span class="c1">// More on that later.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">.</span><span class="n">init</span><span class="p">();</span>
<span class="n">print</span><span class="p">(</span><span class="s">&quot;p.x: {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">});</span><span class="w"> </span><span class="c1">// p.x = 0</span>
<span class="n">print</span><span class="p">(</span><span class="s">&quot;p.y: {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">});</span><span class="w"> </span><span class="c1">// p.y = 0</span>


<span class="c1">// Structures often have functions to modify their state, similar to</span>
<span class="c1">// object-oriented programming.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">Self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@This</span><span class="p">();</span><span class="w"> </span><span class="c1">// Refers to its own type (later called &quot;Point&quot;).</span>

<span class="w">    </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// Take a look at the signature. First argument is of type *Self: &quot;self&quot; is</span>
<span class="w">    </span><span class="c1">// a pointer on the instance of the structure.</span>
<span class="w">    </span><span class="c1">// This allows the same &quot;dot&quot; notation as in OOP, like &quot;instance.set(x,y)&quot;.</span>
<span class="w">    </span><span class="c1">// See the following example.</span>
<span class="w">    </span><span class="kr">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">set</span><span class="p">(</span><span class="n">self</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">        </span><span class="n">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Again, look at the signature. First argument is of type Self (not *Self),</span>
<span class="w">    </span><span class="c1">// this isn&#39;t a pointer. In this case, &quot;self&quot; refers to the instance of the</span>
<span class="w">    </span><span class="c1">// structure, but can&#39;t be modified.</span>
<span class="w">    </span><span class="kr">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">getx</span><span class="p">(</span><span class="n">self</span><span class="o">:</span><span class="w"> </span><span class="n">Self</span><span class="p">)</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// PS: two previous functions may be somewhat useless.</span>
<span class="w">    </span><span class="c1">//     Attributes can be changed directly, no need for accessor functions.</span>
<span class="w">    </span><span class="c1">//     It was just an example.</span>
<span class="p">};</span>

<span class="c1">// Let&#39;s use the previous structure.</span>
<span class="kr">var</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// &quot;p&quot; variable is a Point.</span>

<span class="n">p</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">);</span><span class="w"> </span><span class="c1">// x and y attributes of &quot;p&quot; are modified via the &quot;set&quot; function.</span>
<span class="n">print</span><span class="p">(</span><span class="s">&quot;p.x: {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">});</span><span class="w"> </span><span class="c1">// 10</span>
<span class="n">print</span><span class="p">(</span><span class="s">&quot;p.y: {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">});</span><span class="w"> </span><span class="c1">// 30</span>

<span class="c1">// In C:</span>
<span class="c1">//   1. We would have written something like: point_set(p, 10, 30).</span>
<span class="c1">//   2. Since all functions are in the same namespace, it would have been</span>
<span class="c1">//      very cumbersome to create functions with different names for different</span>
<span class="c1">//      structures. Many long names, painful to read.</span>
<span class="c1">//</span>
<span class="c1">// In Zig, structures provide namespaces for their own functions.</span>
<span class="c1">// Different structures can have the same names for their functions,</span>
<span class="c1">// which brings clarity.</span>
</pre></div>
<h3>Tuples.</h3>
<div class="highlight"><pre lang="zig"><span class="c1">// A tuple is a list of elements, possibly of different types.</span>

<span class="kr">const</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="p">};</span>
<span class="c1">// foo.len == 3</span>
</pre></div>
<h3>Enumerations.</h3>
<div class="highlight"><pre lang="zig"><span class="kr">const</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ok</span><span class="p">,</span><span class="w"> </span><span class="n">not_ok</span><span class="w"> </span><span class="p">};</span>

<span class="kr">const</span><span class="w"> </span><span class="n">CardinalDirections</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">North</span><span class="p">,</span><span class="w"> </span><span class="n">South</span><span class="p">,</span><span class="w"> </span><span class="n">East</span><span class="p">,</span><span class="w"> </span><span class="n">West</span><span class="w"> </span><span class="p">};</span>
<span class="kr">const</span><span class="w"> </span><span class="n">direction</span><span class="o">:</span><span class="w"> </span><span class="n">CardinalDirections</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">North</span><span class="p">;</span>
<span class="kr">const</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">direction</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// shorthand for CardinalDirections.North</span>
<span class="w">    </span><span class="p">.</span><span class="n">North</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">false</span>
<span class="p">};</span>

<span class="c1">// Switch statements need exhaustiveness.</span>
<span class="c1">// WARNING: won&#39;t compile. East and West are missing.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">direction</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">North</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">South</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// This compiles without errors, since it exhaustively lists all possible values</span>
<span class="kr">const</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">direction</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">North</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">South</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">East</span><span class="p">,</span><span class="w">          </span><span class="c1">// Its value is the same as the following pattern: false.</span>
<span class="w">    </span><span class="p">.</span><span class="n">West</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="p">};</span>


<span class="c1">// Enumerations are like structures: they can have functions.</span>
</pre></div>
<h3>Unions.</h3>
<div class="highlight"><pre lang="zig"><span class="kr">const</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">boolean</span><span class="o">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span>
<span class="w">    </span><span class="n">int</span><span class="o">:</span><span class="w"> </span><span class="kt">i16</span><span class="p">,</span>
<span class="w">    </span><span class="n">float</span><span class="o">:</span><span class="w"> </span><span class="kt">f32</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// Both syntaxes are equivalent.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Bar</span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="p">};</span>
<span class="kr">const</span><span class="w"> </span><span class="n">foo</span><span class="o">:</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.{</span><span class="w"> </span><span class="p">.</span><span class="n">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="p">};</span>

<span class="c1">// Unions, like enumerations and structures, can have functions.</span>
</pre></div>
<h3>Tagged unions.</h3>
<div class="highlight"><pre lang="zig"><span class="c1">// Unions can be declared with an enum tag type, allowing them to be used in</span>
<span class="c1">// switch expressions.</span>

<span class="kr">const</span><span class="w"> </span><span class="n">MaybeEnum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">success</span><span class="p">,</span>
<span class="w">    </span><span class="n">failure</span><span class="p">,</span>
<span class="p">};</span>

<span class="kr">const</span><span class="w"> </span><span class="n">Maybe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">union</span><span class="p">(</span><span class="n">MaybeEnum</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">success</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span>
<span class="w">    </span><span class="n">failure</span><span class="o">:</span><span class="w"> </span><span class="p">[]</span><span class="kr">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// First value: success!</span>
<span class="kr">const</span><span class="w"> </span><span class="n">yay</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Maybe</span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">success</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="p">};</span>
<span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">yay</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">success</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">|</span><span class="n">value</span><span class="o">|</span><span class="w">     </span><span class="n">std</span><span class="p">.</span><span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;success: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">value</span><span class="p">}),</span>
<span class="w">    </span><span class="p">.</span><span class="n">failure</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">|</span><span class="n">err_msg</span><span class="o">|</span><span class="w">   </span><span class="n">std</span><span class="p">.</span><span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;failure: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">err_msg</span><span class="p">}),</span>
<span class="p">}</span>

<span class="c1">// Second value: failure! :(</span>
<span class="kr">const</span><span class="w"> </span><span class="n">nay</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Maybe</span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">failure</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;I was too lazy&quot;</span><span class="w"> </span><span class="p">};</span>
<span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">nay</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">success</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">|</span><span class="n">value</span><span class="o">|</span><span class="w">     </span><span class="n">std</span><span class="p">.</span><span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;success: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">value</span><span class="p">}),</span>
<span class="w">    </span><span class="p">.</span><span class="n">failure</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">|</span><span class="n">err_msg</span><span class="o">|</span><span class="w">   </span><span class="n">std</span><span class="p">.</span><span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;failure: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">err_msg</span><span class="p">}),</span>
<span class="p">}</span>
</pre></div>
<h3>Defer and errdefer.</h3>
<div class="highlight"><pre lang="zig"><span class="c1">// Make sure that an action (single instruction or block of code) is executed</span>
<span class="c1">// before the end of the scope (function, block of code).</span>
<span class="c1">// Even on error, that action will be executed.</span>
<span class="c1">// Useful for memory allocations, and resource management in general.</span>

<span class="kr">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Should be executed at the end of the function.</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;third!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{});</span>

<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Last element of its scope: will be executed right away.</span>
<span class="w">        </span><span class="k">defer</span><span class="w"> </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;first!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{});</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;second!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{});</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="n">hello_world</span><span class="p">()</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;end of function</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{});</span><span class="w"> </span><span class="c1">// after &quot;hello world!&quot;</span>

<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;hello world!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{});</span>
<span class="p">}</span>

<span class="c1">// errdefer executes the instruction (or block of code) only on error.</span>
<span class="k">fn</span><span class="w"> </span><span class="n">second_hello_world</span><span class="p">()</span><span class="w"> </span><span class="o">!</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">errdefer</span><span class="w"> </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;2. something went wrong!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{});</span><span class="w"> </span><span class="c1">// if &quot;foo&quot; fails.</span>
<span class="w">    </span><span class="k">defer</span><span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;1. second hello world</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{});</span><span class="w">    </span><span class="c1">// executed after &quot;foo&quot;</span>

<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">// Defer statements can be seen as stacked: first one is executed last.</span>
</pre></div>
<h3>Memory allocators.</h3>
<p>Memory isn't managed directly in the standard library, instead an &quot;allocator&quot; is asked every time an operation on memory is required.
Thus, the standard library lets developers handle memory as they need, through structures called &quot;allocators&quot;, handling all memory operations.</p>
<p><strong>NOTE</strong>: the choice of the allocator isn't in the scope of this document.
A whole book could be written about it.
However, here are some examples, to get an idea of what you can expect:</p>
<ul>
<li><code>page_allocator</code>.
Allocate a whole page of memory each time we ask for some memory.
Very simple, very dumb, very wasteful.</li>
<li><code>GeneralPurposeAllocator</code>.
Get some memory first and manage some buckets of memory in order to
reduce the number of allocations.
A bit complex. Can be combined with other allocators.
Can detect leaks and provide useful information to find them.</li>
<li><code>FixedBufferAllocator</code>.
Use a fixed buffer to get its memory, don't ask memory to the kernel.
Very simple, limited and wasteful (can't deallocate), but very fast.</li>
<li><code>ArenaAllocator</code>.
Allow to free all allocated memory at once.
To use in combinations with another allocator.
Very simple way of avoiding leaks.</li>
</ul>
<p>A first example.</p>
<div class="highlight"><pre lang="zig"><span class="c1">// &quot;!void&quot; means the function doesn&#39;t return any value except for errors.</span>
<span class="c1">// In this case we try to allocate memory, and this may fail.</span>
<span class="k">fn</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="o">!</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// In this example we use a page allocator.</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">allocator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">heap</span><span class="p">.</span><span class="n">page_allocator</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// &quot;list&quot; is an ArrayList of 8-bit unsigned integers.</span>
<span class="w">    </span><span class="c1">// An ArrayList is a contiguous, growable list of elements in memory.</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">ArrayList</span><span class="p">(</span><span class="kt">u8</span><span class="p">).</span><span class="n">initAllocated</span><span class="p">(</span><span class="n">allocator</span><span class="p">);</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="n">list</span><span class="p">.</span><span class="n">deinit</span><span class="p">();</span><span class="w"> </span><span class="c1">// Free the memory at the end of the scope. Can&#39;t leak.</span>
<span class="w">    </span><span class="c1">// &quot;defer&quot; allows to express memory release right after its allocation,</span>
<span class="w">    </span><span class="c1">// regardless of the complexity of the function (loops, conditions, etc.).</span>

<span class="w">    </span><span class="n">list</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// Some memory is allocated here, with the provided allocator.</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">list</span><span class="p">.</span><span class="n">items</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">item</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="p">.</span><span class="n">debug</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">&quot;item: {}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.{</span><span class="n">item</span><span class="p">});</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h3>Memory allocation combined with error management and defer.</h3>
<div class="highlight"><pre lang="zig"><span class="k">fn</span><span class="w"> </span><span class="n">some_memory_allocation_example</span><span class="p">()</span><span class="w"> </span><span class="o">!</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Memory allocation may fail, so we &quot;try&quot; to allocate the memory and</span>
<span class="w">    </span><span class="c1">// in case there is an error, the current function returns it.</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">page_allocator</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Defer memory release right after the allocation.</span>
<span class="w">    </span><span class="c1">// Will happen even if an error occurs.</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="n">page_allocator</span><span class="p">.</span><span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Second allocation.</span>
<span class="w">    </span><span class="c1">// In case of a failure, the first allocation is correctly released.</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">buf2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">page_allocator</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="n">page_allocator</span><span class="p">.</span><span class="n">free</span><span class="p">(</span><span class="n">buf2</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// In case of failure, both previous allocations are correctly deallocated.</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">foo</span><span class="p">();</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="n">bar</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
<h3>Memory allocators: a taste of the standard library.</h3>
<div class="highlight"><pre lang="zig"><span class="c1">// Allocators: 4 main functions to know</span>
<span class="c1">//   single_value = create (type)</span>
<span class="c1">//   destroy (single_value)</span>
<span class="c1">//   slice = alloc (type, size)</span>
<span class="c1">//   free (slice)</span>

<span class="c1">// Page Allocator</span>
<span class="k">fn</span><span class="w"> </span><span class="n">page_allocator_fn</span><span class="p">()</span><span class="w"> </span><span class="o">!</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">heap</span><span class="p">.</span><span class="n">page_allocator</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">heap</span><span class="p">.</span><span class="n">page_allocator</span><span class="p">.</span><span class="n">free</span><span class="p">(</span><span class="n">slice</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// playing_with_a_slice(slice);</span>
<span class="p">}</span>

<span class="c1">// GeneralPurposeAllocator</span>
<span class="k">fn</span><span class="w"> </span><span class="n">general_purpose_allocator_fn</span><span class="p">()</span><span class="w"> </span><span class="o">!</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// GeneralPurposeAllocator has to be configured.</span>
<span class="w">    </span><span class="c1">// In this case, we want to track down memory leaks.</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.{.</span><span class="n">safety</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">};</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">gpa</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">heap</span><span class="p">.</span><span class="n">GeneralPurposeAllocator</span><span class="p">(</span><span class="n">config</span><span class="p">){};</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gpa</span><span class="p">.</span><span class="n">deinit</span><span class="p">();</span>

<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">allocator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gpa</span><span class="p">.</span><span class="n">allocator</span><span class="p">();</span>

<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">allocator</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="n">allocator</span><span class="p">.</span><span class="n">free</span><span class="p">(</span><span class="n">slice</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// playing_with_a_slice(slice);</span>
<span class="p">}</span>

<span class="c1">// FixedBufferAllocator</span>
<span class="k">fn</span><span class="w"> </span><span class="n">fixed_buffer_allocator_fn</span><span class="p">()</span><span class="w"> </span><span class="o">!</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="kt">u8</span><span class="p">{</span><span class="mi">0</span><span class="p">}</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="c1">// array of 1000 u8, all initialized at zero.</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">fba</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">heap</span><span class="p">.</span><span class="n">FixedBufferAllocator</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">..]);</span>
<span class="w">    </span><span class="c1">// Side note: buffer[0..] is a way to create a slice from an array.</span>
<span class="w">    </span><span class="c1">//            Since the function takes a slice and not an array, this makes</span>
<span class="w">    </span><span class="c1">//            the type system happy.</span>

<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">allocator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fba</span><span class="p">.</span><span class="n">allocator</span><span class="p">();</span>

<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">allocator</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// No need for &quot;free&quot;, memory cannot be freed with a fixed buffer allocator.</span>
<span class="w">    </span><span class="c1">// defer allocator.free(slice);</span>

<span class="w">    </span><span class="c1">// playing_with_a_slice(slice);</span>
<span class="p">}</span>

<span class="c1">// ArenaAllocator</span>
<span class="k">fn</span><span class="w"> </span><span class="n">arena_allocator_fn</span><span class="p">()</span><span class="w"> </span><span class="o">!</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Reminder: arena doesn&#39;t allocate memory, it uses an inner allocator.</span>
<span class="w">    </span><span class="c1">// In this case, we combine the arena allocator with the page allocator.</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">arena</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">heap</span><span class="p">.</span><span class="n">arena_allocator</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">std</span><span class="p">.</span><span class="n">heap</span><span class="p">.</span><span class="n">page_allocator</span><span class="p">);</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="n">arena</span><span class="p">.</span><span class="n">deinit</span><span class="p">();</span><span class="w"> </span><span class="c1">// end of function = all allocations are freed.</span>

<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">allocator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arena</span><span class="p">.</span><span class="n">allocator</span><span class="p">();</span>

<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">allocator</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// No need for &quot;free&quot;, memory will be freed anyway.</span>

<span class="w">    </span><span class="c1">// playing_with_a_slice(slice);</span>
<span class="p">}</span>


<span class="c1">// Combining the general purpose and arena allocators. Both are very useful,</span>
<span class="c1">// and their combinations should be in everyone&#39;s favorite cookbook.</span>
<span class="k">fn</span><span class="w"> </span><span class="n">gpa_arena_allocator_fn</span><span class="p">()</span><span class="w"> </span><span class="o">!</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.{.</span><span class="n">safety</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">};</span>
<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">gpa</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">heap</span><span class="p">.</span><span class="n">GeneralPurposeAllocator</span><span class="p">(</span><span class="n">config</span><span class="p">){};</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gpa</span><span class="p">.</span><span class="n">deinit</span><span class="p">();</span>

<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">gpa_allocator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gpa</span><span class="p">.</span><span class="n">allocator</span><span class="p">();</span>

<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">arena</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arena_allocator</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">gpa_allocator</span><span class="p">);</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="n">arena</span><span class="p">.</span><span class="n">deinit</span><span class="p">();</span>

<span class="w">    </span><span class="kr">const</span><span class="w"> </span><span class="n">allocator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arena</span><span class="p">.</span><span class="n">allocator</span><span class="p">();</span>

<span class="w">    </span><span class="kr">var</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">allocator</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="n">allocator</span><span class="p">.</span><span class="n">free</span><span class="p">(</span><span class="n">slice</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// playing_with_a_slice(slice);</span>
<span class="p">}</span>
</pre></div>
<h3>Comptime.</h3>
<div class="highlight"><pre lang="zig"><span class="c1">// Comptime is a way to avoid the pre-processor.</span>
<span class="c1">// The idea is simple: run code at compilation.</span>

<span class="kr">inline</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="kr">comptime</span><span class="w"> </span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="kt">type</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">var</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="kr">var</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="kt">f32</span><span class="p">,</span><span class="w"> </span><span class="mf">10.50</span><span class="p">,</span><span class="w"> </span><span class="mf">32.19</span><span class="p">);</span>


<span class="c1">// Comptime: creating generic structures.</span>

<span class="k">fn</span><span class="w"> </span><span class="n">List</span><span class="p">(</span><span class="kr">comptime</span><span class="w"> </span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="kt">type</span><span class="p">)</span><span class="w"> </span><span class="kt">type</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">items</span><span class="o">:</span><span class="w"> </span><span class="p">[]</span><span class="n">T</span><span class="p">,</span>

<span class="w">        </span><span class="k">fn</span><span class="w"> </span><span class="n">init</span><span class="p">()</span><span class="w">   </span><span class="p">...</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="w">        </span><span class="k">fn</span><span class="w"> </span><span class="n">deinit</span><span class="p">()</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="w">        </span><span class="k">fn</span><span class="w"> </span><span class="n">do</span><span class="p">()</span><span class="w">     </span><span class="p">...</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">};</span>
<span class="p">}</span>

<span class="kr">const</span><span class="w"> </span><span class="n">MyList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">List</span><span class="p">(</span><span class="kt">u8</span><span class="p">);</span>


<span class="c1">// use</span>
<span class="kr">var</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyList</span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">items</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="c1">// memory allocation</span>
<span class="p">};</span>

<span class="n">list</span><span class="p">.</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
</pre></div>
<h3>Conditional compilation.</h3>
<div class="highlight"><pre lang="zig"><span class="kr">const</span><span class="w"> </span><span class="n">available_os</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">OpenBSD</span><span class="p">,</span><span class="w"> </span><span class="n">Linux</span><span class="w"> </span><span class="p">};</span>
<span class="kr">const</span><span class="w"> </span><span class="n">myos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">available_os</span><span class="p">.</span><span class="n">OpenBSD</span><span class="p">;</span>


<span class="c1">// The following switch is based on a constant value.</span>
<span class="c1">// This means that the only possible outcome is known at compile-time.</span>
<span class="c1">// Thus, there is no need to build the rest of the possibilities.</span>
<span class="c1">// Similar to the &quot;#ifdef&quot; in C, but without requiring a pre-processor.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">myos</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="p">.</span><span class="n">OpenBSD</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&quot;OpenBSD is awesome!&quot;</span><span class="p">,</span>
<span class="w">   </span><span class="p">.</span><span class="n">Linux</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&quot;Linux rocks!&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// Also works in this case.</span>
<span class="kr">const</span><span class="w"> </span><span class="n">myprint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">switch</span><span class="p">(</span><span class="n">myos</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">OpenBSD</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">debug</span><span class="p">.</span><span class="n">print</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">Linux</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
<h3>Testing our functions.</h3>
<div class="highlight"><pre lang="zig"><span class="kr">const</span><span class="w"> </span><span class="n">std</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">@import</span><span class="p">(</span><span class="s">&quot;std&quot;</span><span class="p">);</span>
<span class="kr">const</span><span class="w"> </span><span class="n">expect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">testing</span><span class="p">.</span><span class="n">expect</span><span class="p">;</span>

<span class="c1">// Function to test.</span>
<span class="kr">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">some_function</span><span class="p">()</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// This &quot;test&quot; block can be run with &quot;zig test&quot;.</span>
<span class="c1">// It will test the function at compile-time.</span>
<span class="k">test</span><span class="w"> </span><span class="s">&quot;returns true&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">expect</span><span class="p">(</span><span class="kc">false</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">some_function</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
<h3>Compiler built-ins.</h3>
<p>The compiler has special functions called &quot;built-ins&quot;, starting with an &quot;@&quot;.
There are more than a hundred built-ins, allowing very low-level stuff:</p>
<ul>
<li>compile-time errors, logging, verifications</li>
<li>type coercion and conversion, even in an unsafe way</li>
<li>alignment management</li>
<li>memory tricks (such as getting the byte offset of a field in a struct)</li>
<li>calling functions at compile-time</li>
<li>including C headers to transparently call C functions</li>
<li>atomic operations</li>
<li>embed files into the executable (@embedFile)</li>
<li>frame manipulations (for async functions, for example)</li>
<li>etc.</li>
</ul>
<p>Example: enums aren't integers, they have to be converted with a built-in.</p>
<div class="highlight"><pre lang="zig"><span class="kr">const</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">zero</span><span class="p">,</span><span class="w"> </span><span class="n">stuff</span><span class="p">,</span><span class="w"> </span><span class="n">blah</span><span class="w"> </span><span class="p">};</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">@enumToInt</span><span class="p">(</span><span class="n">Value</span><span class="p">.</span><span class="n">zero</span><span class="p">)</span><span class="w">  </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">@enumToInt</span><span class="p">(</span><span class="n">Value</span><span class="p">.</span><span class="n">stuff</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">@enumToInt</span><span class="p">(</span><span class="n">Value</span><span class="p">.</span><span class="n">blah</span><span class="p">)</span><span class="w">  </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
</pre></div>
<h3>A few &quot;not yourself in the foot&quot; measures in the Zig language.</h3>
<ul>
<li>Namespaces: name conflicts are easily avoided.
In practice, that means a unified API between different structures (data types).</li>
<li>Enumerations aren't integers. Comparing an enumeration to an integer requires a conversion.</li>
<li>Explicit casts, coercion exists but is limited.
Types are slightly more enforced than in C, just a taste:
Pointers aren't integers, explicit conversion is necessary.
You won't lose precision by accident, implicit coercions are only authorized in cases where no precision can be lost.
Unions cannot be reinterpreted (in a union with an integer and a float, one cannot take a value for another by accident).
Etc.</li>
<li>Removing most of the C undefined behaviors (UBs), and when the compiler encounters one, it stops.</li>
<li>Slice and Array structures are preferred to pointers.
Types enforced by the compiler are less prone to errors than pointer manipulations.</li>
<li>Numerical overflows produce an error, unless explicitly accepted using wrapping operators.</li>
<li><code>try</code> and <code>catch</code> mechanism.
It's both handy, trivially implemented (simple error enumeration), and it takes almost no space nor computation time.</li>
<li>Unused variables are considered to be errors by the compiler.</li>
<li>Many pointer types exist in order to represent what is pointed to.
Example: is this a single value or an array, is the length known, etc.</li>
<li>Structures need a value for their attributes, and it is still possible to give an undefined value (stack garbage), but at least it is explicitly undefined.</li>
</ul>
<h2>Further Reading</h2>
<p>For a start, some concepts are presented on <a href="https://zig.guide/">zig.guide</a>.</p>
<p>The <a href="https://ziglang.org/documentation/">official website</a> provides the reference documentation of the language. The standard library <a href="https://ziglang.org/documentation/master/std/">has its own documentation</a>.</p>

        <hr>
        <p>
          Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the GitHub Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/zig.md">pull request</a> yourself!
        </p>
        <p class="contributed">
          Originally contributed by Philippe Pittoli, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/zig.md">5 contributors</a>.
        </p>

        <footer>
          <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width: 0; width: 88px; height: 31px;" src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-sa.svg" /></a>
          <p>
            &copy; 2025
            <a href="https://karchnu.fr/">Philippe Pittoli</a>
          </p>
        </footer>
      </div>
    </div>
  </body>
</html>