<!DOCTYPE html>
<html lang="en">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-WXC8R75DEN');
    </script>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="Content-Language" content="en">
    <title>Learn Vimscript in Y Minutes</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto+Slab:wght@100..900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/screen.css">
    <link rel="stylesheet" href="/css/light.css">
    <link rel="stylesheet" href="/css/dark.css">

    <link rel="canonical" href="https://learnxinyminutes.com/vimscript/">
    <script>
      localStorage.removeItem("lxiym_theme");
    </script>
  </head>
  <body>
    <div class="container">
      <h1><a href="/">Learn X in Y minutes</a></h1>
      <h2>Where X=Vimscript</h2>

      <p class="filelink">
        Get the code:
        <a href="/files/learnvimscript.vim">learnvimscript.vim</a>
      </p>
      <div id="doc">
<div class="highlight"><pre lang="vim"><span class="c">&quot; ##############</span>
<span class="c">&quot;  Introduction</span>
<span class="c">&quot; ##############</span>
<span class="c">&quot;</span>
<span class="c">&quot; Vim script (also called VimL) is the subset of Vim&#39;s ex-commands which</span>
<span class="c">&quot; supplies a number of features one would expect from a scripting language,</span>
<span class="c">&quot; such as values, variables, functions or loops. Always keep in the back of</span>
<span class="c">&quot; your mind that a Vim script file is just a sequence of ex-commands. It is</span>
<span class="c">&quot; very common for a script to mix programming-language features and raw</span>
<span class="c">&quot; ex-commands.</span>
<span class="c">&quot;</span>
<span class="c">&quot; You can run Vim script directly by entering the commands in command-line mode</span>
<span class="c">&quot; (press `:` to enter command-line mode), or you can write them to a file</span>
<span class="c">&quot; (without the leading `:`) and source it in a running Vim instance (`:source</span>
<span class="c">&quot; path/to/file`). Some files are sourced automatically as part of your</span>
<span class="c">&quot; configuration (see |startup|). This guide assumes that you are familiar</span>
<span class="c">&quot; with ex-commands and will only cover the scripting. Help topics to the</span>
<span class="c">&quot; relevant manual sections are included.</span>
<span class="c">&quot;</span>
<span class="c">&quot; See |usr_41.txt| for the official introduction to Vim script. A comment is</span>
<span class="c">&quot; anything following an unmatched `&quot;` until the end of the line, and `|`</span>
<span class="c">&quot; separates instructions (what `;` does in most other languages). References to</span>
<span class="c">&quot; the manual as surrounded with `|`, such as |help.txt|.</span>

<span class="c">&quot; This is a comment</span>

<span class="c">&quot; The vertical line &#39;|&#39; (pipe) separates commands</span>
echo <span class="s1">&#39;Hello&#39;</span> <span class="p">|</span> echo <span class="s1">&#39;world!&#39;</span>

<span class="c">&quot; Putting a comment after a command usually works</span>
<span class="k">pwd</span>                   <span class="c">&quot; Displays the current working directory</span>

<span class="c">&quot; Except for some commands it does not; use the command delimiter before the</span>
<span class="c">&quot; comment (echo assumes that the quotation mark begins a string)</span>
echo <span class="s1">&#39;Hello world!&#39;</span>  <span class="p">|</span> <span class="c">&quot; Displays a message</span>

<span class="c">&quot; Line breaks can be escaped by placing a backslash as the first non-whitespace</span>
<span class="c">&quot; character on the *following* line. Only works in script files, not on the</span>
<span class="c">&quot; command line</span>
echo <span class="c">&quot; Hello</span>
    \ world <span class="c">&quot;</span>

echo [<span class="m">1</span><span class="p">,</span>
    \ <span class="m">2</span>]

echo {
    \ <span class="s1">&#39;a&#39;</span>: <span class="m">1</span><span class="p">,</span>
    \ <span class="s1">&#39;b&#39;</span>: <span class="m">2</span>
\}


<span class="c">&quot; #######</span>
<span class="c">&quot;  Types</span>
<span class="c">&quot; #######</span>
<span class="c">&quot;</span>
<span class="c">&quot; For an overview of types see |E712|. For an overview of operators see</span>
<span class="c">&quot; |expression-syntax|</span>

<span class="c">&quot; Numbers (|expr-number|)</span>
<span class="c">&quot; #######</span>

echo  <span class="m">123</span>         <span class="p">|</span> <span class="c">&quot; Decimal</span>
echo  <span class="m">0</span>b<span class="m">1111011</span>   <span class="p">|</span> <span class="c">&quot; Binary</span>
echo  <span class="m">0173</span>        <span class="p">|</span> <span class="c">&quot; Octal</span>
echo  <span class="m">0</span>x<span class="m">7</span>B        <span class="p">|</span> <span class="c">&quot; Hexadecimal</span>
echo  <span class="m">123</span>.<span class="m">0</span>       <span class="p">|</span> <span class="c">&quot; Floating-point</span>
echo  <span class="m">1</span>.<span class="m">23</span>e<span class="m">2</span>      <span class="p">|</span> <span class="c">&quot; Floating-point (scientific notation)</span>

<span class="c">&quot; Note that an *integer* number with a leading `0` is in octal notation. The</span>
<span class="c">&quot; usual arithmetic operations are supported.</span>

echo  <span class="m">1</span> <span class="p">+</span> <span class="m">2</span>       <span class="p">|</span> <span class="c">&quot; Addition</span>
echo  <span class="m">1</span> <span class="p">-</span> <span class="m">2</span>       <span class="p">|</span> <span class="c">&quot; Subtraction</span>
echo  <span class="p">-</span> <span class="m">1</span>         <span class="p">|</span> <span class="c">&quot; Negation (unary minus)</span>
echo  <span class="p">+</span> <span class="m">1</span>         <span class="p">|</span> <span class="c">&quot; Unary plus (does nothing really, but still legal)</span>
echo  <span class="m">1</span> * <span class="m">2</span>       <span class="p">|</span> <span class="c">&quot; Multiplication</span>
echo  <span class="m">1</span> / <span class="m">2</span>       <span class="p">|</span> <span class="c">&quot; Division</span>
echo  <span class="m">1</span> % <span class="m">2</span>       <span class="p">|</span> <span class="c">&quot; Modulo (remainder)</span>

<span class="c">&quot; Booleans (|Boolean|)</span>
<span class="c">&quot; ########</span>
<span class="c">&quot;</span>
<span class="c">&quot; The number 0 is false, every other number is true. Strings are implicitly</span>
<span class="c">&quot; converted to numbers (see below). There are two pre-defined semantic</span>
<span class="c">&quot; constants.</span>

echo  <span class="k">v</span>:true      <span class="p">|</span> <span class="c">&quot; Evaluates to 1 or the string &#39;v:true&#39;</span>
echo  <span class="k">v</span>:false     <span class="p">|</span> <span class="c">&quot; Evaluates to 0 or the string &#39;v:false&#39;</span>

<span class="c">&quot; Boolean values can result from comparison of two objects.</span>

echo  <span class="k">x</span> <span class="p">==</span> <span class="k">y</span>             <span class="p">|</span> <span class="c">&quot; Equality by value</span>
echo  <span class="k">x</span> <span class="p">!=</span> <span class="k">y</span>             <span class="p">|</span> <span class="c">&quot; Inequality</span>
echo  <span class="k">x</span> <span class="p">&gt;</span>  <span class="k">y</span>             <span class="p">|</span> <span class="c">&quot; Greater than</span>
echo  <span class="k">x</span> <span class="p">&gt;=</span> <span class="k">y</span>             <span class="p">|</span> <span class="c">&quot; Greater than or equal</span>
echo  <span class="k">x</span> <span class="p">&lt;</span>  <span class="k">y</span>             <span class="p">|</span> <span class="c">&quot; Smaller than</span>
echo  <span class="k">x</span> <span class="p">&lt;=</span> <span class="k">y</span>             <span class="p">|</span> <span class="c">&quot; Smaller than or equal</span>
echo  <span class="k">x</span> <span class="k">is</span> <span class="k">y</span>             <span class="p">|</span> <span class="c">&quot; Instance identity (lists and dictionaries)</span>
echo  <span class="k">x</span> isnot <span class="k">y</span>          <span class="p">|</span> <span class="c">&quot; Instance non-identity (lists and dictionaries)</span>

<span class="c">&quot; Strings are compared based on their alphanumerical ordering</span>
<span class="c">&quot; echo &#39;a&#39; &lt; &#39;b&#39;. Case sensitivity depends on the setting of &#39;ignorecase&#39;</span>
<span class="c">&quot;</span>
<span class="c">&quot; Explicit case-sensitivity is specified by appending &#39;#&#39; (match case) or &#39;?&#39;</span>
<span class="c">&quot; (ignore case) to the operator. Prefer explicitly case sensitivity when writing</span>
<span class="c">&quot; portable scripts.</span>

echo  <span class="s1">&#39;a&#39;</span> <span class="p">&lt;</span>  <span class="s1">&#39;B&#39;</span>         <span class="p">|</span> <span class="c">&quot; True or false depending on &#39;ignorecase&#39;</span>
echo  <span class="s1">&#39;a&#39;</span> <span class="p">&lt;</span>? <span class="s1">&#39;B&#39;</span>         <span class="p">|</span> <span class="c">&quot; True</span>
echo  <span class="s1">&#39;a&#39;</span> <span class="p">&lt;</span># <span class="s1">&#39;B&#39;</span>         <span class="p">|</span> <span class="c">&quot; False</span>

<span class="c">&quot; Regular expression matching</span>
echo  <span class="s2">&quot;hi&quot;</span> <span class="p">=~</span>  <span class="s2">&quot;hello&quot;</span>    <span class="p">|</span> <span class="c">&quot; Regular expression match, uses &#39;ignorecase&#39;</span>
echo  <span class="s2">&quot;hi&quot;</span> <span class="p">=~</span># <span class="s2">&quot;hello&quot;</span>    <span class="p">|</span> <span class="c">&quot; Regular expression match, case sensitive</span>
echo  <span class="s2">&quot;hi&quot;</span> <span class="p">=~</span>? <span class="s2">&quot;hello&quot;</span>    <span class="p">|</span> <span class="c">&quot; Regular expression match, case insensitive</span>
echo  <span class="s2">&quot;hi&quot;</span> <span class="p">!~</span>  <span class="s2">&quot;hello&quot;</span>    <span class="p">|</span> <span class="c">&quot; Regular expression unmatch, use &#39;ignorecase&#39;</span>
echo  <span class="s2">&quot;hi&quot;</span> <span class="p">!~</span># <span class="s2">&quot;hello&quot;</span>    <span class="p">|</span> <span class="c">&quot; Regular expression unmatch, case sensitive</span>
echo  <span class="s2">&quot;hi&quot;</span> <span class="p">!~</span>? <span class="s2">&quot;hello&quot;</span>    <span class="p">|</span> <span class="c">&quot; Regular expression unmatch, case insensitive</span>

<span class="c">&quot; Boolean operations are possible.</span>

echo  <span class="k">v</span>:true &amp;&amp; <span class="k">v</span>:false       <span class="p">|</span> <span class="c">&quot; Logical AND</span>
echo  <span class="k">v</span>:true <span class="p">||</span> <span class="k">v</span>:false       <span class="p">|</span> <span class="c">&quot; Logical OR</span>
echo  <span class="p">!</span> <span class="k">v</span>:true                <span class="p">|</span> <span class="c">&quot; Logical NOT</span>
echo  <span class="k">v</span>:true ? <span class="s1">&#39;yes&#39;</span> : <span class="s1">&#39;no&#39;</span>   <span class="p">|</span> <span class="c">&quot; Ternary operator</span>


<span class="c">&quot; Strings (|String|)</span>
<span class="c">&quot; #######</span>
<span class="c">&quot;</span>
<span class="c">&quot; An ordered zero-indexed sequence of bytes. The encoding of text into bytes</span>
<span class="c">&quot; depends on the option |&#39;encoding&#39;|.</span>

<span class="c">&quot; Literal constructors</span>
echo  <span class="s2">&quot;Hello world\n&quot;</span>   <span class="p">|</span> <span class="c">&quot; The last two characters stand for newline</span>
echo  <span class="s1">&#39;Hello world\n&#39;</span>   <span class="p">|</span> <span class="c">&quot; The last two characters are literal</span>
echo  <span class="s1">&#39;Let&#39;&#39;s go!&#39;</span>      <span class="p">|</span> <span class="c">&quot; Two single quotes become one quote character</span>

<span class="c">&quot; Single-quote strings take all characters are literal, except two single</span>
<span class="c">&quot; quotes, which are taken to be a single quote in the string itself. See</span>
<span class="c">&quot; |expr-quote| for all possible escape sequences.</span>

<span class="c">&quot; String concatenation</span>
<span class="c">&quot; The .. operator is preferred, but only supported in since Vim 8.1.1114</span>
echo  <span class="s1">&#39;Hello &#39;</span> .  <span class="s1">&#39;world&#39;</span>  <span class="p">|</span> <span class="c">&quot; String concatenation</span>
echo  <span class="s1">&#39;Hello &#39;</span> .. <span class="s1">&#39;world&#39;</span>  <span class="p">|</span> <span class="c">&quot; String concatenation (new variant)</span>

<span class="c">&quot; String indexing</span>
echo  <span class="s1">&#39;Hello&#39;</span>[<span class="m">0</span>]           <span class="p">|</span> <span class="c">&quot; First byte</span>
echo  <span class="s1">&#39;Hello&#39;</span>[<span class="m">1</span>]           <span class="p">|</span> <span class="c">&quot; Second byte</span>
echo  <span class="s1">&#39;Hellö&#39;</span>[<span class="m">4</span>]           <span class="p">|</span> <span class="c">&quot; Returns a byte, not the character &#39;ö&#39;</span>

<span class="c">&quot; Substrings (second index is inclusive)</span>
echo  <span class="s1">&#39;Hello&#39;</span>[:]           <span class="p">|</span> <span class="c">&quot; Copy of entire string</span>
echo  <span class="s1">&#39;Hello&#39;</span>[<span class="m">1</span>:<span class="m">3</span>]         <span class="p">|</span> <span class="c">&quot; Substring, second to fourth byte</span>
echo  <span class="s1">&#39;Hello&#39;</span>[<span class="m">1</span>:<span class="m">-2</span>]        <span class="p">|</span> <span class="c">&quot; Substring until second to last byte</span>
echo  <span class="s1">&#39;Hello&#39;</span>[<span class="m">1</span>:]          <span class="p">|</span> <span class="c">&quot; Substring with starting index</span>
echo  <span class="s1">&#39;Hello&#39;</span>[:<span class="m">2</span>]          <span class="p">|</span> <span class="c">&quot; Substring with ending index</span>
echo  <span class="s1">&#39;Hello&#39;</span>[<span class="m">-2</span>:]         <span class="p">|</span> <span class="c">&quot; Substring relative to end of string</span>

<span class="c">&quot; A negative index is relative to the end of the string. See</span>
<span class="c">&quot; |string-functions| for all string-related functions.</span>

<span class="c">&quot; Lists (|List|)</span>
<span class="c">&quot; #####</span>
<span class="c">&quot;</span>
<span class="c">&quot; An ordered zero-indexed heterogeneous sequence of arbitrary Vim script</span>
<span class="c">&quot; objects.</span>

<span class="c">&quot; Literal constructor</span>
echo  []                   <span class="p">|</span> <span class="c">&quot; Empty list</span>
echo  [<span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="s1">&#39;Hello&#39;</span>]      <span class="p">|</span> <span class="c">&quot; List with elements</span>
echo  [<span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="s1">&#39;Hello&#39;</span><span class="p">,</span> ]    <span class="p">|</span> <span class="c">&quot; Trailing comma permitted</span>
echo  [[<span class="m">1</span><span class="p">,</span> <span class="m">2</span>]<span class="p">,</span> <span class="s1">&#39;Hello&#39;</span>]    <span class="p">|</span> <span class="c">&quot; Lists can be nested arbitrarily</span>

<span class="c">&quot; List concatenation</span>
echo  [<span class="m">1</span><span class="p">,</span> <span class="m">2</span>] <span class="p">+</span> [<span class="m">3</span><span class="p">,</span> <span class="m">4</span>]      <span class="p">|</span> <span class="c">&quot; Creates a new list</span>

<span class="c">&quot; List indexing, negative is relative to end of list (|list-index|)</span>
echo  [<span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span>][<span class="m">2</span>]      <span class="p">|</span> <span class="c">&quot; Third element</span>
echo  [<span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span>][<span class="m">-1</span>]     <span class="p">|</span> <span class="c">&quot; Last element</span>

<span class="c">&quot; List slicing (|sublist|)</span>
echo  [<span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span>][:]      <span class="p">|</span> <span class="c">&quot; Shallow copy of entire list</span>
echo  [<span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span>][:<span class="m">2</span>]     <span class="p">|</span> <span class="c">&quot; Sublist until third item (inclusive)</span>
echo  [<span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span>][<span class="m">2</span>:]     <span class="p">|</span> <span class="c">&quot; Sublist from third item (inclusive)</span>
echo  [<span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span>][:<span class="m">-2</span>]    <span class="p">|</span> <span class="c">&quot; Sublist until second-to-last item (inclusive)</span>

<span class="c">&quot; All slicing operations create new lists. To modify a list in-place use list</span>
<span class="c">&quot; functions (|list-functions|) or assign directly to an item (see below about</span>
<span class="c">&quot; variables).</span>


<span class="c">&quot; Dictionaries (|Dictionary|)</span>
<span class="c">&quot; ############</span>
<span class="c">&quot;</span>
<span class="c">&quot; An unordered sequence of key-value pairs, keys are always strings (numbers</span>
<span class="c">&quot; are implicitly converted to strings).</span>

<span class="c">&quot; Dictionary literal</span>
echo  {}                       <span class="p">|</span> <span class="c">&quot; Empty dictionary</span>
echo  {<span class="s1">&#39;a&#39;</span>: <span class="m">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span>: <span class="m">2</span>}         <span class="p">|</span> <span class="c">&quot; Dictionary literal</span>
echo  {<span class="s1">&#39;a&#39;</span>: <span class="m">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span>: <span class="m">2</span><span class="p">,</span> }       <span class="p">|</span> <span class="c">&quot; Trailing comma permitted</span>
echo  {<span class="s1">&#39;x&#39;</span>: {<span class="s1">&#39;a&#39;</span>: <span class="m">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span>: <span class="m">2</span>}}  <span class="p">|</span> <span class="c">&quot; Nested dictionary</span>

<span class="c">&quot; Indexing a dictionary</span>
echo  {<span class="s1">&#39;a&#39;</span>: <span class="m">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span>: <span class="m">2</span>}[<span class="s1">&#39;a&#39;</span>]    <span class="p">|</span> <span class="c">&quot; Literal index</span>
echo  {<span class="s1">&#39;a&#39;</span>: <span class="m">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span>: <span class="m">2</span>}.<span class="k">a</span>       <span class="p">|</span> <span class="c">&quot; Syntactic sugar for simple keys</span>

<span class="c">&quot; See |dict-functions| for dictionary manipulation functions.</span>


<span class="c">&quot; Funcref (|Funcref|)</span>
<span class="c">&quot; #######</span>
<span class="c">&quot;</span>
<span class="c">&quot; Reference to a function, uses the function name as a string for construction.</span>
<span class="c">&quot; When stored in a variable the name of the variable has the same restrictions</span>
<span class="c">&quot; as a function name (see below).</span>

echo  <span class="k">function</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">)</span>                   <span class="p">|</span> <span class="c">&quot; Reference to function type()</span>
<span class="c">&quot; Note that `funcref(&#39;type&#39;)` will throw an error because the argument must be</span>
<span class="c">&quot; a user-defined function; see further below for defining your own functions.</span>
echo  funcref<span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">)</span>                    <span class="p">|</span> <span class="c">&quot; Reference by identity, not name</span>
<span class="c">&quot; A lambda (|lambda|) is an anonymous function; it can only contain one</span>
<span class="c">&quot; expression in its body, which is also its implicit return value.</span>
echo  {<span class="k">x</span> <span class="p">-&gt;</span> <span class="k">x</span> * <span class="k">x</span>}                       <span class="p">|</span> <span class="c">&quot; Anonymous function</span>
echo  <span class="k">function</span><span class="p">(</span><span class="s1">&#39;substitute&#39;</span><span class="p">,</span> [<span class="s1">&#39;hello&#39;</span>]<span class="p">)</span>  <span class="p">|</span> <span class="c">&quot; Partial function</span>


<span class="c">&quot; Regular expression (|regular-expression|)</span>
<span class="c">&quot; ##################</span>
<span class="c">&quot;</span>
<span class="c">&quot; A regular expression pattern is generally a string, but in some cases you can</span>
<span class="c">&quot; also use a regular expression between a pair of delimiters (usually `/`, but</span>
<span class="c">&quot; you can choose anything).</span>

<span class="c">&quot; Substitute &#39;hello&#39; for &#39;Hello&#39;</span>
substitute<span class="sr">/hello/</span>Hello/


<span class="c">&quot; ###########################</span>
<span class="c">&quot;  Implicit type conversions</span>
<span class="c">&quot; ###########################</span>
<span class="c">&quot;</span>
<span class="c">&quot; Strings are converted to numbers, and numbers to strings when necessary. A</span>
<span class="c">&quot; number becomes its decimal notation as a string. A string becomes its</span>
<span class="c">&quot; numerical value if it can be parsed to a number, otherwise it becomes zero.</span>

echo  <span class="s2">&quot;1&quot;</span> <span class="p">+</span> <span class="m">1</span>         <span class="p">|</span> <span class="c">&quot; Number</span>
echo  <span class="s2">&quot;1&quot;</span> .. <span class="m">1</span>        <span class="p">|</span> <span class="c">&quot; String</span>
echo  <span class="s2">&quot;0xA&quot;</span> <span class="p">+</span> <span class="m">1</span>       <span class="p">|</span> <span class="c">&quot; Number</span>

<span class="c">&quot; Strings are treated like numbers when used as booleans</span>
echo <span class="s2">&quot;true&quot;</span> ? <span class="m">1</span> : <span class="m">0</span>   <span class="p">|</span> <span class="c">&quot; This string is parsed to 0, which is false</span>

<span class="c">&quot; ###########</span>
<span class="c">&quot;  Variables</span>
<span class="c">&quot; ###########</span>
<span class="c">&quot;</span>
<span class="c">&quot; Variables are bound within a scope; if no scope is provided a default is</span>
<span class="c">&quot; chosen by Vim. Use `:let` and `:const` to bind a value and `:unlet` to unbind</span>
<span class="c">&quot; it.</span>

<span class="k">let</span> <span class="k">b</span>:my_var <span class="p">=</span> <span class="m">1</span>        <span class="p">|</span> <span class="c">&quot; Local to current buffer</span>
<span class="k">let</span> <span class="k">w</span>:my_var <span class="p">=</span> <span class="m">1</span>        <span class="p">|</span> <span class="c">&quot; Local to current window</span>
<span class="k">let</span> <span class="k">t</span>:my_var <span class="p">=</span> <span class="m">1</span>        <span class="p">|</span> <span class="c">&quot; Local to current tab page</span>
<span class="k">let</span> <span class="k">g</span>:my_var <span class="p">=</span> <span class="m">1</span>        <span class="p">|</span> <span class="c">&quot; Global variable</span>
<span class="k">let</span> <span class="k">l</span>:my_var <span class="p">=</span> <span class="m">1</span>        <span class="p">|</span> <span class="c">&quot; Local to current function (see functions below)</span>
<span class="k">let</span> s:my_var <span class="p">=</span> <span class="m">1</span>        <span class="p">|</span> <span class="c">&quot; Local to current script file</span>
<span class="k">let</span> <span class="k">a</span>:my_arg <span class="p">=</span> <span class="m">1</span>        <span class="p">|</span> <span class="c">&quot; Function argument (see functions below)</span>

<span class="c">&quot; The Vim scope is read-only</span>
echo  <span class="k">v</span>:true            <span class="p">|</span> <span class="c">&quot; Special built-in Vim variables (|v:var|)</span>

<span class="c">&quot; Access special Vim memory like variables</span>
<span class="k">let</span> @<span class="k">a</span> <span class="p">=</span> <span class="s1">&#39;Hello&#39;</span>        <span class="p">|</span> <span class="c">&quot; Register</span>
<span class="k">let</span> $PATH<span class="p">=</span><span class="s1">&#39;&#39;</span>            <span class="p">|</span> <span class="c">&quot; Environment variable</span>
<span class="k">let</span> &amp;<span class="nb">textwidth</span> <span class="p">=</span> <span class="m">79</span>     <span class="p">|</span> <span class="c">&quot; Option</span>
<span class="k">let</span> &amp;<span class="k">l</span>:<span class="nb">textwidth</span> <span class="p">=</span> <span class="m">79</span>   <span class="p">|</span> <span class="c">&quot; Local option</span>
<span class="k">let</span> &amp;<span class="k">g</span>:<span class="nb">textwidth</span> <span class="p">=</span> <span class="m">79</span>   <span class="p">|</span> <span class="c">&quot; Global option</span>

<span class="c">&quot; Access scopes as dictionaries (can be modified like all dictionaries)</span>
<span class="c">&quot; See the |dict-functions|, especially |get()|, for access and manipulation</span>
echo  <span class="k">b</span>:                <span class="p">|</span> <span class="c">&quot; All buffer variables</span>
echo  <span class="k">w</span>:                <span class="p">|</span> <span class="c">&quot; All window variables</span>
echo  <span class="k">t</span>:                <span class="p">|</span> <span class="c">&quot; All tab page variables</span>
echo  <span class="k">g</span>:                <span class="p">|</span> <span class="c">&quot; All global variables</span>
echo  <span class="k">l</span>:                <span class="p">|</span> <span class="c">&quot; All local variables</span>
echo  s:                <span class="p">|</span> <span class="c">&quot; All script variables</span>
echo  <span class="k">a</span>:                <span class="p">|</span> <span class="c">&quot; All function arguments</span>
echo  <span class="k">v</span>:                <span class="p">|</span> <span class="c">&quot; All Vim variables</span>

<span class="c">&quot; Constant variables</span>
const <span class="k">x</span> <span class="p">=</span> <span class="m">10</span>            <span class="p">|</span> <span class="c">&quot; See |:const|, |:lockvar|</span>

<span class="c">&quot; Function reference variables have the same restrictions as function names</span>
<span class="k">let</span> IsString <span class="p">=</span> {<span class="k">x</span> <span class="p">-&gt;</span> type<span class="p">(</span><span class="k">x</span><span class="p">)</span> <span class="p">==</span> type<span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>}    <span class="p">|</span> <span class="c">&quot; Global: capital letter</span>
<span class="k">let</span> s:isNumber <span class="p">=</span> {<span class="k">x</span> <span class="p">-&gt;</span> type<span class="p">(</span><span class="k">x</span><span class="p">)</span> <span class="p">==</span> type<span class="p">(</span><span class="m">0</span><span class="p">)</span>}   <span class="p">|</span> <span class="c">&quot; Local: any name allowed</span>

<span class="c">&quot; When omitted the scope `g:` is implied, except in functions, there `l:` is</span>
<span class="c">&quot; implied.</span>


<span class="c">&quot; Multiple value binding (list unpacking)</span>
<span class="c">&quot; #######################################</span>
<span class="c">&quot;</span>
<span class="c">&quot; Assign values of list to multiple variables (number of items must match)</span>
<span class="k">let</span> [<span class="k">x</span><span class="p">,</span> <span class="k">y</span>] <span class="p">=</span> [<span class="m">1</span><span class="p">,</span> <span class="m">2</span>]

<span class="c">&quot; Assign the remainder to a rest variable (note the semicolon)</span>
<span class="k">let</span> [mother<span class="p">,</span> father; children] <span class="p">=</span> [<span class="s1">&#39;Alice&#39;</span><span class="p">,</span> <span class="s1">&#39;Bob&#39;</span><span class="p">,</span> <span class="s1">&#39;Carol&#39;</span><span class="p">,</span> <span class="s1">&#39;Dennis&#39;</span><span class="p">,</span> <span class="s1">&#39;Emily&#39;</span>]


<span class="c">&quot; ##############</span>
<span class="c">&quot;  Flow control</span>
<span class="c">&quot; ##############</span>

<span class="c">&quot; Conditional (|:if|, |:elseif|, |:else|, |:endif|)</span>
<span class="c">&quot; ###########</span>
<span class="c">&quot;</span>
<span class="c">&quot; Conditions are set between `if` and `endif`. They can be nested.</span>

<span class="k">let</span> condition <span class="p">=</span> <span class="k">v</span>:true

<span class="k">if</span> condition
    echo <span class="s1">&#39;First condition&#39;</span>
<span class="k">elseif</span> another_condition
    echo <span class="s1">&#39;Second condition&#39;</span>
<span class="k">else</span>
    echo <span class="s1">&#39;Fail&#39;</span>
<span class="k">endif</span>

<span class="c">&quot; Loops (|:for|, |:endfor|, |:while|, |:endwhile|, |:break|, |:continue|)</span>
<span class="c">&quot; #####</span>
<span class="c">&quot;</span>
<span class="c">&quot; Two types of loops: `:for` and `:while`. Use `:continue` to skip to the next</span>
<span class="c">&quot; iteration, `:break` to break out of the loop.</span>

<span class="c">&quot; For-loop (|:for|, |:endfor|)</span>
<span class="c">&quot; ========</span>
<span class="c">&quot;</span>
<span class="c">&quot; For-loops iterate over lists and nothing else. If you want to iterate over</span>
<span class="c">&quot; another sequence you need to use a function which will create a list.</span>

<span class="c">&quot; Iterate over a list</span>
<span class="k">for</span> person <span class="k">in</span> [<span class="s1">&#39;Alice&#39;</span><span class="p">,</span> <span class="s1">&#39;Bob&#39;</span><span class="p">,</span> <span class="s1">&#39;Carol&#39;</span><span class="p">,</span> <span class="s1">&#39;Dennis&#39;</span><span class="p">,</span> <span class="s1">&#39;Emily&#39;</span>]
    echo <span class="s1">&#39;Hello &#39;</span> .. person
<span class="k">endfor</span>

<span class="c">&quot; Iterate over a nested list by unpacking it</span>
<span class="k">for</span> [<span class="k">x</span><span class="p">,</span> <span class="k">y</span>] <span class="k">in</span> [[<span class="m">1</span><span class="p">,</span> <span class="m">0</span>]<span class="p">,</span> [<span class="m">0</span><span class="p">,</span> <span class="m">1</span>]<span class="p">,</span> [<span class="m">-1</span><span class="p">,</span> <span class="m">0</span>]<span class="p">,</span> [<span class="m">0</span><span class="p">,</span> <span class="m">-1</span>]]
    echo <span class="s1">&#39;Position: x =&#39;</span>  .. <span class="k">x</span> .. <span class="s1">&#39;, y = &#39;</span> .. <span class="k">y</span>
<span class="k">endfor</span>

<span class="c">&quot; Iterate over a range of numbers</span>
<span class="k">for</span> <span class="k">i</span> <span class="k">in</span> range<span class="p">(</span><span class="m">10</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">-1</span><span class="p">)</span>  <span class="c">&quot; Count down from 10</span>
    echo <span class="s1">&#39;T minus&#39;</span>  .. <span class="k">i</span>
<span class="k">endfor</span>

<span class="c">&quot; Iterate over the keys of a dictionary</span>
<span class="k">for</span> symbol <span class="k">in</span> keys<span class="p">(</span>{<span class="s1">&#39;π&#39;</span>: <span class="m">3</span>.<span class="m">14</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span>: <span class="m">2</span>.<span class="m">71</span>}<span class="p">)</span>
    echo <span class="s1">&#39;The constant &#39;</span> .. symbol .. <span class="s1">&#39; is a transcendent number&#39;</span>
<span class="k">endfor</span>

<span class="c">&quot; Iterate over the values of a dictionary</span>
<span class="k">for</span> value <span class="k">in</span> values<span class="p">(</span>{<span class="s1">&#39;π&#39;</span>: <span class="m">3</span>.<span class="m">14</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span>: <span class="m">2</span>.<span class="m">71</span>}<span class="p">)</span>
    echo <span class="s1">&#39;The value &#39;</span> .. value .. <span class="s1">&#39; approximates a transcendent number&#39;</span>
<span class="k">endfor</span>

<span class="c">&quot; Iterate over the keys and values of a dictionary</span>
<span class="k">for</span> [symbol<span class="p">,</span> value] <span class="k">in</span> items<span class="p">(</span>{<span class="s1">&#39;π&#39;</span>: <span class="m">3</span>.<span class="m">14</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span>: <span class="m">2</span>.<span class="m">71</span>}<span class="p">)</span>
    echo <span class="s1">&#39;The number &#39;</span> .. symbol .. <span class="s1">&#39; is approximately &#39;</span> .. value
<span class="k">endfor</span>

<span class="c">&quot; While-loops (|:while|, |:endwhile|)</span>

<span class="k">let</span> there_yet <span class="p">=</span> <span class="k">v</span>:true
<span class="k">while</span> <span class="p">!</span>there_yet
    echo <span class="s1">&#39;Are we there yet?&#39;</span>
<span class="k">endwhile</span>


<span class="c">&quot; Exception handling (|exception-handling|)</span>
<span class="c">&quot; ##################</span>
<span class="c">&quot;</span>
<span class="c">&quot; Throw new exceptions as strings, catch them by pattern-matching a regular</span>
<span class="c">&quot; expression against the string</span>

<span class="c">&quot; Throw new exception</span>
<span class="k">throw</span> <span class="s2">&quot;Wrong arguments&quot;</span>

<span class="c">&quot; Guard against an exception (the second catch matches any exception)</span>
<span class="k">try</span>
    source <span class="nb">path</span><span class="sr">/to/</span><span class="k">file</span>
<span class="k">catch</span> <span class="sr">/Cannot open/</span>
    echo <span class="s1">&#39;Looks like that file does not exist&#39;</span>
<span class="k">catch</span> <span class="sr">/.*/</span>
    echo <span class="s1">&#39;Something went wrong, but I do not know what&#39;</span>
<span class="k">finally</span>
    echo <span class="s1">&#39;I am done trying&#39;</span>
<span class="k">endtry</span>


<span class="c">&quot; ##########</span>
<span class="c">&quot;  Functions</span>
<span class="c">&quot; ##########</span>

<span class="c">&quot; Defining functions (|:function|, |:endfunction|)</span>
<span class="c">&quot; ##################</span>

<span class="c">&quot; Unscoped function names have to start with a capital letter</span>
<span class="k">function</span><span class="p">!</span> AddNumbersLoudly<span class="p">(</span><span class="k">x</span><span class="p">,</span> <span class="k">y</span><span class="p">)</span>
<span class="c">    &quot; Use a: scope to access arguments</span>
    echo <span class="s1">&#39;Adding&#39;</span>  .. <span class="k">a</span>:<span class="k">x</span> ..  <span class="s1">&#39;and&#39;</span>  .. <span class="k">a</span>:<span class="k">y</span>   <span class="p">|</span> <span class="c">&quot; A side effect</span>
    <span class="k">return</span> <span class="k">a</span>:<span class="k">x</span> <span class="p">+</span> <span class="k">a</span>:<span class="k">y</span>                          <span class="p">|</span> <span class="c">&quot; A return value</span>
<span class="k">endfunction</span>

<span class="c">&quot; Scoped function names may start with a lower-case letter</span>
<span class="k">function</span><span class="p">!</span> s:addNumbersLoudly<span class="p">(</span><span class="k">x</span><span class="p">,</span> <span class="k">y</span><span class="p">)</span>
    echo <span class="s1">&#39;Adding&#39;</span>  .. <span class="k">a</span>:<span class="k">x</span> ..  <span class="s1">&#39;and&#39;</span>  .. <span class="k">a</span>:<span class="k">y</span>
    <span class="k">return</span> <span class="k">a</span>:<span class="k">x</span> <span class="p">+</span> <span class="k">a</span>:<span class="k">y</span>
<span class="k">endfunction</span>

<span class="c">&quot; Without the exclamation mark it would be an error to re-define a function,</span>
<span class="c">&quot; with the exclamation mark the new definition can replace the old one. Since</span>
<span class="c">&quot; Vim script files can be reloaded several times over the course of a session</span>
<span class="c">&quot; it is best to use the exclamation mark unless you really know what you are</span>
<span class="c">&quot; doing.</span>

<span class="c">&quot; Function definitions can have special qualifiers following the argument list.</span>

<span class="c">&quot; Range functions define two implicit arguments, which will be set to the range</span>
<span class="c">&quot; of the ex-command</span>
<span class="k">function</span><span class="p">!</span> FirstAndLastLine<span class="p">()</span> range
    echo [<span class="k">a</span>:firstline<span class="p">,</span> <span class="k">a</span>:lastline]
<span class="k">endfunction</span>

<span class="c">&quot; Prints the first and last line that match a pattern (|cmdline-ranges|)</span>
<span class="sr">/^#!/</span><span class="p">,</span><span class="sr">/!#$/</span><span class="k">call</span> FirstAndLastLine<span class="p">()</span>

<span class="c">&quot; Aborting functions, abort once error occurs (|:func-abort|)</span>
<span class="k">function</span><span class="p">!</span> SourceMyFile<span class="p">()</span> abort
    source my<span class="p">-</span><span class="k">file</span>.<span class="k">vim</span>        <span class="p">|</span> <span class="c">&quot; Try sourcing non-existing file</span>
    echo <span class="s1">&#39;This will never be printed&#39;</span>
<span class="k">endfunction</span>

<span class="c">&quot; Closures, functions carrying values from outer scope (|:func-closure|)</span>
<span class="k">function</span><span class="p">!</span> MakeAdder<span class="p">(</span><span class="k">x</span><span class="p">)</span>
    <span class="k">function</span><span class="p">!</span> Adder<span class="p">(</span><span class="k">n</span><span class="p">)</span> closure
        <span class="k">return</span> <span class="k">a</span>:<span class="k">n</span> <span class="p">+</span> <span class="k">a</span>:<span class="k">x</span>
    <span class="k">endfunction</span>
    <span class="k">return</span> funcref<span class="p">(</span><span class="s1">&#39;Adder&#39;</span><span class="p">)</span>
<span class="k">endfunction</span>
<span class="k">let</span> AddFive <span class="p">=</span> MakeAdder<span class="p">(</span><span class="m">5</span><span class="p">)</span>
echo AddFive<span class="p">(</span><span class="m">3</span><span class="p">)</span>               <span class="p">|</span> <span class="c">&quot; Prints 8</span>

<span class="c">&quot; Dictionary functions, poor man&#39;s OOP methods (|Dictionary-function|)</span>
<span class="k">function</span><span class="p">!</span> Mylen<span class="p">()</span> <span class="nb">dict</span>
    <span class="k">return</span> len<span class="p">(</span>self.data<span class="p">)</span>     <span class="p">|</span> <span class="c">&quot; Implicit variable self</span>
<span class="k">endfunction</span>
<span class="k">let</span> mydict <span class="p">=</span> {<span class="s1">&#39;data&#39;</span>: [<span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span>]<span class="p">,</span> <span class="s1">&#39;len&#39;</span>: <span class="k">function</span><span class="p">(</span><span class="s2">&quot;Mylen&quot;</span><span class="p">)</span>}
echo mydict.len<span class="p">()</span>

<span class="c">&quot; Alternatively, more concise</span>
<span class="k">let</span> mydict <span class="p">=</span> {<span class="s1">&#39;data&#39;</span>: [<span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span>]}
<span class="k">function</span><span class="p">!</span> mydict.len<span class="p">()</span>
    <span class="k">return</span> len<span class="p">(</span>self.data<span class="p">)</span>
<span class="k">endfunction</span>

<span class="c">&quot; Calling functions (|:call|)</span>
<span class="c">&quot; #################</span>

<span class="c">&quot; Call a function for its return value, and possibly for its side effects</span>
<span class="k">let</span> animals <span class="p">=</span> keys<span class="p">(</span>{<span class="s1">&#39;cow&#39;</span>: <span class="s1">&#39;moo&#39;</span><span class="p">,</span> <span class="s1">&#39;dog&#39;</span>: <span class="s1">&#39;woof&#39;</span><span class="p">,</span> <span class="s1">&#39;cat&#39;</span>: <span class="s1">&#39;meow&#39;</span>}<span class="p">)</span>

<span class="c">&quot; Call a function for its side effects only, ignore potential return value</span>
<span class="k">call</span> sign_undefine<span class="p">()</span>

<span class="c">&quot; The call() function calls a function reference and passes parameters as a</span>
<span class="c">&quot; list, and returns the function&#39;s result.</span>
echo  <span class="k">call</span><span class="p">(</span><span class="k">function</span><span class="p">(</span><span class="s1">&#39;get&#39;</span><span class="p">),</span> [{<span class="s1">&#39;a&#39;</span>: <span class="m">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span>: <span class="m">2</span>}<span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="m">3</span>]<span class="p">)</span>   <span class="p">|</span> <span class="c">&quot; Prints 3</span>

<span class="c">&quot; Recall that Vim script is embedded within the ex-commands, that is why we</span>
<span class="c">&quot; cannot just call a function directly, we have to use the `:call` ex-command.</span>

<span class="c">&quot; Function namespaces (|write-library-script|, |autoload|)</span>
<span class="c">&quot; ###################</span>

<span class="c">&quot; Must be defined in autoload/foo/bar.vim</span>
<span class="c">&quot; Namspaced function names do not have to start with a capital letter</span>
<span class="k">function</span><span class="p">!</span> foo#bar#log<span class="p">(</span>value<span class="p">)</span>
    <span class="k">echomsg</span> value
<span class="k">endfunction</span>

<span class="k">call</span> foo#bar#log<span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">)</span>


<span class="c">&quot; #############################</span>
<span class="c">&quot;  Frequently used ex-commands</span>
<span class="c">&quot; #############################</span>


<span class="c">&quot; Sourcing runtime files (|&#39;runtimepath&#39;|)</span>
<span class="c">&quot; ######################</span>

<span class="c">&quot; Source first match among runtime paths</span>
runtime plugin/my<span class="p">-</span>plugin.<span class="k">vim</span>


<span class="c">&quot; Defining new ex-commands (|40.2|, |:command|)</span>
<span class="c">&quot; ########################</span>

<span class="c">&quot; First argument here is the name of the command, rest is the command body</span>
command<span class="p">!</span> SwapAdjacentLines normal<span class="p">!</span> ddp

<span class="c">&quot; The exclamation mark works the same as with `:function`. User-defined</span>
<span class="c">&quot; commands must start with a capital letter. The `:command` command can take a</span>
<span class="c">&quot; number of attributes (some of which have their own parameters with `=`), such</span>
<span class="c">&quot; as `-nargs`, all of them start with a dash to set them apart from the command</span>
<span class="c">&quot; name.</span>

command<span class="p">!</span> <span class="p">-</span>nargs<span class="p">=</span><span class="m">1</span> Error <span class="k">echoerr</span> <span class="p">&lt;</span>args<span class="p">&gt;</span>


<span class="c">&quot; Defining auto-commands (|40.3|, |autocmd|, |autocommand-events|)</span>
<span class="c">&quot; ######################</span>

<span class="c">&quot; The arguments are &quot;events&quot;, &quot;patterns&quot;, rest is &quot;commands&quot;</span>
autocmd <span class="nb">BufWritePost</span> $MYVIMRC source $MYVIMRC

<span class="c">&quot; Events and patterns are separated by commas with no space between. See</span>
<span class="c">&quot; |autocmd-events| for standard events, |User| for custom events. Everything</span>
<span class="c">&quot; else are the ex-commands which will be executed.</span>

<span class="c">&quot; Auto groups</span>
<span class="c">&quot; ===========</span>
<span class="c">&quot;</span>
<span class="c">&quot; When a file is sourced multiple times the auto-commands are defined anew,</span>
<span class="c">&quot; without deleting the old ones, causing auto-commands to pile up over time.</span>
<span class="c">&quot; Use auto-groups and the following ritual to guard against this.</span>

augroup auto<span class="p">-</span>source   <span class="p">|</span> <span class="c">&quot; The name of the group is arbitrary</span>
    autocmd<span class="p">!</span>          <span class="p">|</span> <span class="c">&quot; Deletes all auto-commands in the current group</span>
    autocmd <span class="nb">BufWritePost</span> $MYVIMRC source $MYVIMRC
augroup END           <span class="p">|</span> <span class="c">&quot; Switch back to default auto-group</span>

<span class="c">&quot; It is also possible to assign a group directly. This is useful if the</span>
<span class="c">&quot; definition of the group is in one script and the definition of the</span>
<span class="c">&quot; auto-command is in another script.</span>

<span class="c">&quot; In one file</span>
augroup auto<span class="p">-</span>source
    autocmd<span class="p">!</span>
augroup END

<span class="c">&quot; In another file</span>
autocmd auto<span class="p">-</span>source <span class="nb">BufWritePost</span> $MYVIMRC source $MYVIMRC

<span class="c">&quot; Executing (run-time macros of sorts)</span>
<span class="c">&quot; ####################################</span>

<span class="c">&quot; Sometimes we need to construct an ex-command where part of the command is not</span>
<span class="c">&quot; known until runtime.</span>

<span class="k">let</span> line <span class="p">=</span> <span class="m">3</span>                <span class="p">|</span> <span class="c">&quot; Line number determined at runtime</span>
execute line .. <span class="s1">&#39;delete&#39;</span>    <span class="p">|</span> <span class="c">&quot; Delete a line</span>

<span class="c">&quot; Executing normal-mode commands</span>
<span class="c">&quot; ##############################</span>
<span class="c">&quot;</span>
<span class="c">&quot; Use `:normal` to play back a sequence of normal mode commands from the</span>
<span class="c">&quot; command-line. Add an exclamation mark to ignore user mappings.</span>

normal<span class="p">!</span> ggddGp             <span class="p">|</span> <span class="c">&quot; Transplant first line to end of buffer</span>

<span class="c">&quot; Window commands can be used with :normal, or with :wincmd if :normal would</span>
<span class="c">&quot; not work</span>
<span class="k">wincmd</span> L                   <span class="p">|</span> <span class="c">&quot; Move current window all the way to the right</span>


<span class="c">&quot; ###########################</span>
<span class="c">&quot;  Frequently used functions</span>
<span class="c">&quot; ###########################</span>

<span class="c">&quot; Feature check</span>
echo  has<span class="p">(</span><span class="s1">&#39;nvim&#39;</span><span class="p">)</span>                  <span class="p">|</span> <span class="c">&quot; Running Neovim</span>
echo  has<span class="p">(</span><span class="s1">&#39;python3&#39;</span><span class="p">)</span>               <span class="p">|</span> <span class="c">&quot; Support for Python 3 plugins</span>
echo  has<span class="p">(</span><span class="s1">&#39;unix&#39;</span><span class="p">)</span>                  <span class="p">|</span> <span class="c">&quot; Running on a Unix system</span>
echo  has<span class="p">(</span><span class="s1">&#39;win32&#39;</span><span class="p">)</span>                 <span class="p">|</span> <span class="c">&quot; Running on a Windows system</span>


<span class="c">&quot; Test if something exists</span>
echo  exists<span class="p">(</span><span class="s1">&#39;&amp;mouse&#39;</span><span class="p">)</span>             <span class="p">|</span> <span class="c">&quot; Option (exists only)</span>
echo  exists<span class="p">(</span><span class="s1">&#39;+mouse&#39;</span><span class="p">)</span>             <span class="p">|</span> <span class="c">&quot; Option (exists and works)</span>
echo  exists<span class="p">(</span><span class="s1">&#39;$HOSTNAME&#39;</span><span class="p">)</span>          <span class="p">|</span> <span class="c">&quot; Environment variable</span>
echo  exists<span class="p">(</span><span class="s1">&#39;*strftime&#39;</span><span class="p">)</span>          <span class="p">|</span> <span class="c">&quot; Built-in function</span>
echo  exists<span class="p">(</span><span class="s1">&#39;**s:MyFunc&#39;</span><span class="p">)</span>         <span class="p">|</span> <span class="c">&quot; User-defined function</span>
echo  exists<span class="p">(</span><span class="s1">&#39;bufcount&#39;</span><span class="p">)</span>           <span class="p">|</span> <span class="c">&quot; Variable (scope optional)</span>
echo  exists<span class="p">(</span><span class="s1">&#39;my_dict[&quot;foo&quot;]&#39;</span><span class="p">)</span>     <span class="p">|</span> <span class="c">&quot; Variable (dictionary entry)</span>
echo  exists<span class="p">(</span><span class="s1">&#39;my_dict[&quot;foo&quot;]&#39;</span><span class="p">)</span>     <span class="p">|</span> <span class="c">&quot; Variable (dictionary entry)</span>
echo  exists<span class="p">(</span><span class="s1">&#39;:Make&#39;</span><span class="p">)</span>              <span class="p">|</span> <span class="c">&quot; Command</span>
echo  exists<span class="p">(</span><span class="s2">&quot;#CursorHold&quot;</span><span class="p">)</span>        <span class="p">|</span> <span class="c">&quot; Auto-command defined for event</span>
echo  exists<span class="p">(</span><span class="s2">&quot;#BufReadPre#*.gz&quot;</span><span class="p">)</span>   <span class="p">|</span> <span class="c">&quot; Event and pattern</span>
echo  exists<span class="p">(</span><span class="s2">&quot;#filetypeindent&quot;</span><span class="p">)</span>    <span class="p">|</span> <span class="c">&quot; Auto-command group</span>
echo  exists<span class="p">(</span><span class="s2">&quot;##ColorScheme&quot;</span><span class="p">)</span>      <span class="p">|</span> <span class="c">&quot; Auto-command supported for event</span>

<span class="c">&quot; Various dynamic values (see |expand()|)</span>
echo  expand<span class="p">(</span><span class="s1">&#39;%&#39;</span><span class="p">)</span>                  <span class="p">|</span> <span class="c">&quot; Current file name</span>
echo  expand<span class="p">(</span><span class="s1">&#39;&lt;cword&gt;&#39;</span><span class="p">)</span>            <span class="p">|</span> <span class="c">&quot; Current word under cursor</span>
echo  expand<span class="p">(</span><span class="s1">&#39;%:p&#39;</span><span class="p">)</span>                <span class="p">|</span> <span class="c">&quot; Modifier are possible</span>

<span class="c">&quot; Type tests</span>
<span class="c">&quot; There are unique constants defined for the following types. Older versions</span>
<span class="c">&quot; of Vim lack the type variables, see the reference &quot; documentation for a</span>
<span class="c">&quot; workaround</span>
echo  type<span class="p">(</span>my_var<span class="p">)</span> <span class="p">==</span> <span class="k">v</span>:t_number      <span class="p">|</span> <span class="c">&quot; Number</span>
echo  type<span class="p">(</span>my_var<span class="p">)</span> <span class="p">==</span> <span class="k">v</span>:t_string      <span class="p">|</span> <span class="c">&quot; String</span>
echo  type<span class="p">(</span>my_var<span class="p">)</span> <span class="p">==</span> <span class="k">v</span>:t_func        <span class="p">|</span> <span class="c">&quot; Funcref</span>
echo  type<span class="p">(</span>my_var<span class="p">)</span> <span class="p">==</span> <span class="k">v</span>:t_list        <span class="p">|</span> <span class="c">&quot; List</span>
echo  type<span class="p">(</span>my_var<span class="p">)</span> <span class="p">==</span> <span class="k">v</span>:t_dict        <span class="p">|</span> <span class="c">&quot; Dictionary</span>
echo  type<span class="p">(</span>my_var<span class="p">)</span> <span class="p">==</span> <span class="k">v</span>:t_float       <span class="p">|</span> <span class="c">&quot; Float</span>
echo  type<span class="p">(</span>my_var<span class="p">)</span> <span class="p">==</span> <span class="k">v</span>:t_bool        <span class="p">|</span> <span class="c">&quot; Explicit Boolean</span>
<span class="c">&quot; For the null object should compare it against itself</span>
echo  my_var <span class="k">is</span> <span class="k">v</span>:null

<span class="c">&quot; Format strings</span>
echo  printf<span class="p">(</span><span class="s1">&#39;%d in hexadecimal is %X&#39;</span><span class="p">,</span> <span class="m">123</span><span class="p">,</span> <span class="m">123</span><span class="p">)</span>


<span class="c">&quot; #####################</span>
<span class="c">&quot;  Tricks of the trade</span>
<span class="c">&quot; #####################</span>

<span class="c">&quot; Source guard</span>
<span class="c">&quot; ############</span>

<span class="c">&quot; Prevent a file from being sourced multiple times; users can set the variable</span>
<span class="c">&quot; in their configuration to prevent the plugin from loading at all.</span>
<span class="k">if</span> exists<span class="p">(</span><span class="s1">&#39;g:loaded_my_plugin&#39;</span><span class="p">)</span>
    <span class="k">finish</span>
<span class="k">endif</span>
<span class="k">let</span> <span class="k">g</span>:loaded_my_plugin <span class="p">=</span> <span class="k">v</span>:true

<span class="c">&quot; Default values</span>
<span class="c">&quot; ##############</span>

<span class="c">&quot; Get a default value: if the user defines a variable use it, otherwise use a</span>
<span class="c">&quot; hard-coded default. Uses the fact that a scope is also a dictionary.</span>
<span class="k">let</span> s:greeting <span class="p">=</span> get<span class="p">(</span><span class="k">g</span>:<span class="p">,</span> <span class="s1">&#39;my_plugin_greeting&#39;</span><span class="p">,</span> <span class="s1">&#39;Hello&#39;</span><span class="p">)</span>
</pre></div>

        <hr>
        <p>
          Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the GitHub Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/vimscript.md">pull request</a> yourself!
        </p>
        <p class="contributed">
          Originally contributed by HiPhish, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/vimscript.md">5 contributors</a>.
        </p>

        <footer>
          <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width: 0; width: 80px; height: 28px; padding-bottom: 5px;" src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-sa.svg" /></a>
          <p>
            &copy; 2025
            <a href="http://hiphish.github.io/">HiPhish</a>
          </p>
        </footer>
      </div>

      <script>
        document.addEventListener('DOMContentLoaded', () => {
          const langSelect = document.getElementById('lang-select');
          langSelect?.addEventListener('change', () => {
            const selectedOption = langSelect.options[langSelect.selectedIndex];
            const url = selectedOption?.getAttribute('data-url');
            if (url) {
              window.location.href = url;
            }
          });
        });
      </script>
    </div>
  </body>
</html>