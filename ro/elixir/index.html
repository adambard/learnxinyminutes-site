<!DOCTYPE html>
<html lang="ro">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-WXC8R75DEN');
    </script>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="Content-Language" content="ro">
    <title>Learn Elixir in Y Minutes</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto+Slab:wght@100..900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/screen.css">
    <link rel="stylesheet" href="/css/light.css">
    <link rel="stylesheet" href="/css/dark.css">

    <link rel="canonical" href="https://learnxinyminutes.com/ro/elixir/">
    <script>
      localStorage.removeItem("lxiym_theme");
    </script>
  </head>
  <body>
    <div class="container">
      <div class="share">
        <span class="sharemsg">
          <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fro%2Felixir%2F&amp;text=Learn+X+in+Y+minutes%2C+where+X%3DElixir">
            Share this page
          </a>
        </span>
        <span class='st_facebook_large' displayText='Facebook'></span>
        <span class='st_twitter_large' displayText='Tweet'></span>
      </div>
      <h1><a href="/">Learn X in Y minutes</a></h1>
      <h2>Where X=Elixir</h2>
      <p class="filelink">
        Get the code:
        <a href="/ro/files/learnelixir.ex">learnelixir.ex</a>
      </p>
      <div id="doc">
<p>Elixir este un limbaj funcțional modern construit pe baza mașinii virtuale Erlang.
E total compatibil cu Erlang, dar are o sintaxă mai prietenoasă și propune mai multe
posibilități.</p>
<div class="highlight"><pre lang="elixir"><span class="c1"># Comentariile de o linie încep cu simbolul diez.</span>

<span class="c1"># Pentru comentarii pe mai multe linii nu există sintaxă separată,</span>
<span class="c1"># de aceea folosiți mai multe linii cu comentarii.</span>

<span class="c1"># Pentru a folosi shell-ul Elixir utilizați comanda `iex`.</span>
<span class="c1"># Compilați modulele cu comanda `elixirc`.</span>

<span class="c1"># Ambele comenzi vor lucra în terminal, dacă ați instalat Elixir corect.</span>

<span class="c1">## ---------------------------</span>
<span class="c1">## -- Tipuri de bază</span>
<span class="c1">## ---------------------------</span>

<span class="c1"># Numere</span>
<span class="mi">3</span><span class="w">    </span><span class="c1"># număr întreg</span>
<span class="mh">0x1F</span><span class="w"> </span><span class="c1"># număr întreg</span>
<span class="mf">3.0</span><span class="w">  </span><span class="c1"># număr cu virgulă mobilă</span>

<span class="c1"># Atomii, sunt constante nenumerice. Ei încep cu `:`.</span>
<span class="ss">:salut</span><span class="w"> </span><span class="c1"># atom</span>

<span class="c1"># Tuplele sunt păstrate în memorie consecutiv.</span>
<span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="c1"># tuple</span>

<span class="c1"># Putem accesa elementul tuplelui folosind funcția `elem`:</span>
<span class="n">elem</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">},</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="c1">#=&gt; 1</span>

<span class="c1"># Listele sunt implementate ca liste înlănțuite.</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="c1"># listă</span>

<span class="c1"># Fiecare listă ne vidă are cap (primul element al listei)</span>
<span class="c1"># și coadă (restul elementelor).</span>
<span class="c1"># Putem accesa capul și coada listei cum urmează:</span>
<span class="p">[</span><span class="n">cap</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">coadă</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">cap</span><span class="w">   </span><span class="c1">#=&gt; 1</span>
<span class="n">coadă</span><span class="w"> </span><span class="c1">#=&gt; [2, 3]</span>

<span class="c1"># În Elixir, ca și în Erlang, simbolul `=` denotă potrivirea șabloanelor și</span>
<span class="c1"># nu atribuire.</span>
<span class="c1">#</span>
<span class="c1"># Aceasta înseamnă că expresia din stînga (șablonul) se potrivește cu</span>
<span class="c1"># expresia din dreaptă.</span>
<span class="c1">#</span>
<span class="c1"># În modul acesta exemplul de mai sus lucrează accesînd capul și coada unei liste.</span>

<span class="c1"># Potrivirea șablonului va da eroare cînd expresiile din stînga și dreapta nu se</span>
<span class="c1"># potrivesc, în exemplu acesta tuplele au lungime diferită.</span>
<span class="p">{</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w"> </span><span class="c1">#=&gt; ** (MatchError)</span>

<span class="c1"># Există și date binare</span>
<span class="p">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">&gt;&gt;</span>

<span class="c1"># Sunt două tipuri de șiruri de caractere</span>
<span class="s2">&quot;salut&quot;</span><span class="w"> </span><span class="c1"># șir de caractere Elixir</span>
<span class="s1">&#39;salut&#39;</span><span class="w"> </span><span class="c1"># listă de caractere Erlang</span>

<span class="c1"># Șir de caractere pe mai multe linii</span>
<span class="sh">&quot;&quot;&quot;</span>
<span class="sh">Sunt un șir de caractere</span>
<span class="sh">pe mai multe linii.</span>
<span class="sh">&quot;&quot;&quot;</span>
<span class="c1">#=&gt; &quot;Sunt un șir de caractere\npe mai multe linii..\n&quot;</span>

<span class="c1"># Șirurile de caractere sunt codificate în UTF-8:</span>
<span class="s2">&quot;Bună dimineața&quot;</span><span class="w"> </span><span class="c1">#=&gt; &quot;Bună dimineața&quot;</span>

<span class="c1"># Șirurile de caractere sunt date binare, listele de caractere doar liste.</span>
<span class="p">&lt;&lt;</span><span class="sc">?a</span><span class="p">,</span><span class="w"> </span><span class="sc">?b</span><span class="p">,</span><span class="w"> </span><span class="sc">?c</span><span class="p">&gt;&gt;</span><span class="w"> </span><span class="c1">#=&gt; &quot;abc&quot;</span>
<span class="p">[</span><span class="sc">?a</span><span class="p">,</span><span class="w"> </span><span class="sc">?b</span><span class="p">,</span><span class="w"> </span><span class="sc">?c</span><span class="p">]</span><span class="w">   </span><span class="c1">#=&gt; &#39;abc&#39;</span>

<span class="c1"># `?a` în Elixir întoarce codul ASCII pentru litera `a`</span>
<span class="sc">?a</span><span class="w"> </span><span class="c1">#=&gt; 97</span>

<span class="c1"># Pentru a concatena listele folosiți `++`, pentru date binare - `&lt;&gt;`</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="w">     </span><span class="c1">#=&gt; [1,2,3,4,5]</span>
<span class="s1">&#39;Salut &#39;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s1">&#39;lume&#39;</span><span class="w">  </span><span class="c1">#=&gt; &#39;Salut lume&#39;</span>

<span class="p">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">&gt;&gt;</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="p">&lt;&lt;</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">&gt;&gt;</span><span class="w"> </span><span class="c1">#=&gt; &lt;&lt;1,2,3,4,5&gt;&gt;</span>
<span class="s2">&quot;Salut &quot;</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="s2">&quot;lume&quot;</span><span class="w">  </span><span class="c1">#=&gt; &quot;Salut lume&quot;</span>

<span class="c1"># Diapazoanele sunt reprezentate ca `început..sfîrșit` (inclusiv)</span>
<span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="c1">#=&gt; 1..10</span>
<span class="err">î</span><span class="n">nceput</span><span class="o">..</span><span class="n">sfîrșit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="c1"># Putem folosi potrivirea șabloanelor cu diapazoane de asemenea</span>
<span class="p">[</span><span class="err">î</span><span class="n">nceput</span><span class="p">,</span><span class="w"> </span><span class="n">sfîrșit</span><span class="p">]</span><span class="w"> </span><span class="c1">#=&gt; [1, 10]</span>

<span class="c1"># Dicţionarele stochează chei şi o valoare pentru fiecare cheie</span>
<span class="n">genuri</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">%{</span><span class="s2">&quot;Ion&quot;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s2">&quot;bărbat&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Maria&quot;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s2">&quot;femeie&quot;</span><span class="p">}</span>
<span class="n">genuri</span><span class="p">[</span><span class="s2">&quot;Ion&quot;</span><span class="p">]</span><span class="w"> </span><span class="c1">#=&gt; &quot;bărbat&quot;</span>

<span class="c1"># Dicționare cu chei de tip atom au sintaxă specială</span>
<span class="n">genuri</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">%{</span><span class="ss">ion</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;bărbat&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">maria</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;femeie&quot;</span><span class="p">}</span>
<span class="n">genuri</span><span class="o">.</span><span class="n">ion</span><span class="w"> </span><span class="c1">#=&gt; &quot;bărbat&quot;</span>

<span class="c1">## ---------------------------</span>
<span class="c1">## -- Operatori</span>
<span class="c1">## ---------------------------</span>

<span class="c1"># Operații matematice</span>
<span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="c1">#=&gt; 2</span>
<span class="mi">10</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="c1">#=&gt; 5</span>
<span class="mi">5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="c1">#=&gt; 10</span>
<span class="mi">10</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="c1">#=&gt; 5.0</span>

<span class="c1"># În Elixir operatorul `/` întotdeauna întoarce un număr cu virgulă mobilă.</span>

<span class="c1"># Folosiți `div` pentru împărțirea numerelor întregi</span>
<span class="n">div</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">#=&gt; 5</span>

<span class="c1"># Pentru a obține restul de la împărțire utilizați `rem`</span>
<span class="n">rem</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">#=&gt; 1</span>

<span class="c1"># Există și operatori booleni: `or`, `and` and `not`.</span>
<span class="c1"># Acești operatori așteaptă ca primul argument o expresie booleană.</span>
<span class="no">true</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="c1">#=&gt; true</span>
<span class="no">false</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="c1">#=&gt; true</span>
<span class="mi">1</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="no">true</span><span class="w">    </span><span class="c1">#=&gt; ** (BadBooleanError)</span>

<span class="c1"># Elixir de asemenea  oferă `||`, `&amp;&amp;` și `!` care acceptă argumente de orice tip.</span>
<span class="c1"># Toate valorile în afară de `false` și `nil` se vor evalua ca `true`.</span>
<span class="mi">1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="no">true</span><span class="w">  </span><span class="c1">#=&gt; 1</span>
<span class="no">false</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">#=&gt; false</span>
<span class="no">nil</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="mi">20</span><span class="w">  </span><span class="c1">#=&gt; nil</span>
<span class="o">!</span><span class="no">true</span><span class="w"> </span><span class="c1">#=&gt; false</span>

<span class="c1"># Operatori de comparație: `==`, `!=`, `===`, `!==`, `&lt;=`, `&gt;=`, `&lt;` și `&gt;`</span>
<span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">#=&gt; true</span>
<span class="mi">1</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">#=&gt; false</span>
<span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="c1">#=&gt; true</span>

<span class="c1"># `===` și `!==` au strictețe mai mare cînd comparăm numere întregi și reale:</span>
<span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">1.0</span><span class="w">  </span><span class="c1">#=&gt; true</span>
<span class="mi">1</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="c1">#=&gt; false</span>

<span class="c1"># Putem compara de asemenea și date de diferite tipuri:</span>
<span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="ss">:salut</span><span class="w"> </span><span class="c1">#=&gt; true</span>

<span class="c1"># La compararea diferitor tipuri folosiți următoare prioritate:</span>
<span class="c1"># număr &lt; atom &lt; referință &lt; funcție &lt; port &lt; proces &lt; tuple &lt; listă &lt; șir de caractere</span>

<span class="c1"># Cităm pe Joe Armstrong în acest caz: &quot;Ordinea actuală nu e importantă,</span>
<span class="c1"># dar că ordinea totală este bine definită este important.&quot;</span>

<span class="c1">## ---------------------------</span>
<span class="c1">## -- Ordinea execuției</span>
<span class="c1">## ---------------------------</span>

<span class="c1"># expresia `if`</span>
<span class="k">if</span><span class="w"> </span><span class="no">false</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="s2">&quot;Aceasta nu veți vedea niciodată&quot;</span>
<span class="k">else</span>
<span class="w">  </span><span class="s2">&quot;Aceasta veți vedea&quot;</span>
<span class="k">end</span>

<span class="c1"># expresia opusă `unless`</span>
<span class="k">unless</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="s2">&quot;Aceasta nu veți vedea niciodată&quot;</span>
<span class="k">else</span>
<span class="w">  </span><span class="s2">&quot;Aceasta veți vedea&quot;</span>
<span class="k">end</span>

<span class="c1"># Țineți minte potrivirea șabloanelor? Multe structuri în Elixir se bazează pe ea.</span>

<span class="c1"># `case` ne permite să comparăm o valoare cu multe șabloane:</span>
<span class="k">case</span><span class="w"> </span><span class="p">{</span><span class="ss">:unu</span><span class="p">,</span><span class="w"> </span><span class="ss">:doi</span><span class="p">}</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="p">{</span><span class="ss">:patru</span><span class="p">,</span><span class="w"> </span><span class="ss">:cinci</span><span class="p">}</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="s2">&quot;Aceasta nu se potrivește&quot;</span>
<span class="w">  </span><span class="p">{</span><span class="ss">:unu</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">}</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="s2">&quot;Aceasta se potrivește și atribuie lui `x` `:doi` în acest bloc&quot;</span>
<span class="w">  </span><span class="bp">_</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="s2">&quot;Aceasta se va potrivi cu orice valoare&quot;</span>
<span class="k">end</span>

<span class="c1"># Simbolul `_` se numește variabila anonimă.</span>
<span class="c1"># Folosiți-l pentru valori ce nu vă interesează.</span>
<span class="c1"># De exemplu, dacă doar capul listei ne intereseaza:</span>
<span class="p">[</span><span class="n">cap</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="bp">_</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">cap</span><span class="w"> </span><span class="c1">#=&gt; 1</span>

<span class="c1"># Pentru o citire mai bună putem scri:</span>
<span class="p">[</span><span class="n">cap</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">_coadă</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="ss">:a</span><span class="p">,</span><span class="w"> </span><span class="ss">:b</span><span class="p">,</span><span class="w"> </span><span class="ss">:c</span><span class="p">]</span>
<span class="n">cap</span><span class="w"> </span><span class="c1">#=&gt; :a</span>

<span class="c1"># `cond` ne permite să verificăm multe condiții de odată.</span>
<span class="c1"># Folosiți `cond` în schimbul la multe expresii `if`.</span>
<span class="k">cond</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="s2">&quot;Aceasta nu veți vedea niciodată&quot;</span>
<span class="w">  </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="s2">&quot;Pe mine la fel&quot;</span>
<span class="w">  </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="s2">&quot;Aceasta veți vedea&quot;</span>
<span class="k">end</span>

<span class="c1"># Este obușnuit de setat ultima condiție cu `true`, care se va potrivi întotdeauna.</span>
<span class="k">cond</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="s2">&quot;Aceasta nu veți vedea niciodată&quot;</span>
<span class="w">  </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="s2">&quot;Pe mine la fel&quot;</span>
<span class="w">  </span><span class="no">true</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="s2">&quot;Aceasta veți vedea (este else în esență)&quot;</span>
<span class="k">end</span>

<span class="c1"># Blocul `try/catch` se foloște pentru prelucrarea excepțiilor.</span>
<span class="c1"># Elixir suportă blocul `after` care se execută în orice caz.</span>
<span class="k">try</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="k">throw</span><span class="p">(</span><span class="ss">:salut</span><span class="p">)</span>
<span class="k">catch</span>
<span class="w">  </span><span class="n">mesaj</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s2">&quot;Am primit </span><span class="si">#{</span><span class="n">mesaj</span><span class="si">}</span><span class="s2">.&quot;</span>
<span class="k">after</span>
<span class="w">  </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p">(</span><span class="s2">&quot;Sunt în blocul after.&quot;</span><span class="p">)</span>
<span class="k">end</span>
<span class="c1">#=&gt; Sunt în blocul after.</span>
<span class="c1"># &quot;Am primit salut&quot;</span>

<span class="c1">## ---------------------------</span>
<span class="c1">## -- Module și Funcții</span>
<span class="c1">## ---------------------------</span>

<span class="c1"># Funcții anonime (atenție la punct la apelarea funcției)</span>
<span class="n">square</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">fn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">end</span>
<span class="n">square</span><span class="o">.</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="c1">#=&gt; 25</span>

<span class="c1"># Ele de asemenea aceptă multe clauze și expresii de gardă.</span>
<span class="c1"># Expresiile de gardă vă permit să acordați potrivirea șabloanelor,</span>
<span class="c1"># ele sunt indicate după cuvîntul cheie `when`:</span>
<span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">fn</span>
<span class="w">  </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>
<span class="w">  </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span>
<span class="k">end</span>

<span class="n">f</span><span class="o">.</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">  </span><span class="c1">#=&gt; 4</span>
<span class="n">f</span><span class="o">.</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">#=&gt; -3</span>

<span class="c1"># Elixir de asemenea oferă multe funcții incorporate.</span>
<span class="c1"># Ele sunt accesibile în scopul curent.</span>
<span class="n">is_number</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w">    </span><span class="c1">#=&gt; true</span>
<span class="n">is_list</span><span class="p">(</span><span class="s2">&quot;salut&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">#=&gt; false</span>
<span class="n">elem</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">},</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="c1">#=&gt; 1</span>

<span class="c1"># Puteți grupa cîteva funcții într-un modul. În interiorul modulului folosiți `def`</span>
<span class="c1"># pentru a defini funcțiile necesare.</span>
<span class="kd">defmodule</span><span class="w"> </span><span class="nc">Math</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="kd">def</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="kd">def</span><span class="w"> </span><span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span>
<span class="w">  </span><span class="k">end</span>
<span class="k">end</span>

<span class="nc">Math</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">  </span><span class="c1">#=&gt; 3</span>
<span class="nc">Math</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w">  </span><span class="c1">#=&gt; 9</span>

<span class="c1"># Pentru a compila modulul nostru simplu Math îl salvăm ca `math.ex` și utilizăm `elixirc`.</span>
<span class="c1"># în terminal: elixirc math.ex</span>

<span class="c1"># În interiorul modulului putem defini funcții cu `def` și funcții private cu `defp`.</span>
<span class="kd">defmodule</span><span class="w"> </span><span class="nc">PrivateMath</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="c1"># O funcție definită cu `def` este accesibilă pentru apelare din alte module,</span>
<span class="w">  </span><span class="kd">def</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="n">do_sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="c1"># O funcție privată poate fi apelată doar local.</span>
<span class="w">  </span><span class="kd">defp</span><span class="w"> </span><span class="n">do_sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span>
<span class="w">  </span><span class="k">end</span>
<span class="k">end</span>

<span class="nc">PrivateMath</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">    </span><span class="c1">#=&gt; 3</span>
<span class="nc">PrivateMath</span><span class="o">.</span><span class="n">do_sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">#=&gt; ** (UndefinedFunctionError)</span>

<span class="c1"># Declarația funcției de asemenea suportă expresii de gardă și multe clauze:</span>
<span class="kd">defmodule</span><span class="w"> </span><span class="nc">Geometry</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="kd">def</span><span class="w"> </span><span class="n">area</span><span class="p">({</span><span class="ss">:rectangle</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">h</span><span class="p">})</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="n">w</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">h</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="kd">def</span><span class="w"> </span><span class="n">area</span><span class="p">({</span><span class="ss">:circle</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">})</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">is_number</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="mf">3.14</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span>
<span class="w">  </span><span class="k">end</span>
<span class="k">end</span>

<span class="nc">Geometry</span><span class="o">.</span><span class="n">area</span><span class="p">({</span><span class="ss">:rectangle</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w"> </span><span class="c1">#=&gt; 6</span>
<span class="nc">Geometry</span><span class="o">.</span><span class="n">area</span><span class="p">({</span><span class="ss">:circle</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">       </span><span class="c1">#=&gt; 28.25999999999999801048</span>
<span class="nc">Geometry</span><span class="o">.</span><span class="n">area</span><span class="p">({</span><span class="ss">:circle</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;not_a_number&quot;</span><span class="p">})</span><span class="w"> </span><span class="c1">#=&gt; ** (FunctionClauseError)</span>

<span class="c1"># Din cauza variabilelor imutabile, un rol important îl ocupă funcțiile recursive</span>
<span class="kd">defmodule</span><span class="w"> </span><span class="nc">Recursion</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="kd">def</span><span class="w"> </span><span class="n">sum_list</span><span class="p">([</span><span class="n">head</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">tail</span><span class="p">],</span><span class="w"> </span><span class="n">acc</span><span class="p">)</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="n">sum_list</span><span class="p">(</span><span class="n">tail</span><span class="p">,</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">head</span><span class="p">)</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="kd">def</span><span class="w"> </span><span class="n">sum_list</span><span class="p">([],</span><span class="w"> </span><span class="n">acc</span><span class="p">)</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="n">acc</span>
<span class="w">  </span><span class="k">end</span>
<span class="k">end</span>

<span class="nc">Recursion</span><span class="o">.</span><span class="n">sum_list</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="c1">#=&gt; 6</span>

<span class="c1"># Modulele în Elixir suportă atribute, există atribute incorporate și</span>
<span class="c1"># puteți adăuga altele.</span>
<span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyMod</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="na">@moduledoc</span><span class="w"> </span><span class="sh">&quot;&quot;&quot;</span>
<span class="w">  </span><span class="sh">Este un atribut incorporat</span>
<span class="w">  </span><span class="sh">&quot;&quot;&quot;</span>

<span class="w">  </span><span class="na">@my_data</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="c1"># Acesta e atributul nostru</span>
<span class="w">  </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p">(</span><span class="na">@my_data</span><span class="p">)</span><span class="w"> </span><span class="c1">#=&gt; 100</span>
<span class="k">end</span>

<span class="c1"># Operatorul |&gt; permite transferarea rezultatului unei expresii din stînga</span>
<span class="c1"># ca primul argument al unei funcții din dreapta.</span>
<span class="nc">Range</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">end</span><span class="p">)</span>
<span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">rem</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">end</span><span class="p">)</span>
<span class="c1">#=&gt; [4, 16, 36, 64, 100]</span>

<span class="c1">## ---------------------------</span>
<span class="c1">## -- Structuri și Excepții</span>
<span class="c1">## ---------------------------</span>

<span class="c1"># Structurile sunt extensii a dicționarelor ce au valori implicite,</span>
<span class="c1"># verificări în timpul compilării și polimorfism</span>
<span class="kd">defmodule</span><span class="w"> </span><span class="nc">Person</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="kd">defstruct</span><span class="w"> </span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="no">nil</span><span class="p">,</span><span class="w"> </span><span class="ss">age</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="ss">height</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span>
<span class="k">end</span>

<span class="n">joe_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">%</span><span class="nc">Person</span><span class="p">{</span><span class="w"> </span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Joe&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">age</span><span class="p">:</span><span class="w"> </span><span class="mi">30</span><span class="p">,</span><span class="w"> </span><span class="ss">height</span><span class="p">:</span><span class="w"> </span><span class="mi">180</span><span class="w"> </span><span class="p">}</span>
<span class="c1">#=&gt; %Person{age: 30, height: 180, name: &quot;Joe&quot;}</span>

<span class="c1"># Acesarea cîmpului din structură</span>
<span class="n">joe_info</span><span class="o">.</span><span class="n">name</span><span class="w"> </span><span class="c1">#=&gt; &quot;Joe&quot;</span>

<span class="c1"># Actualizarea valorii cîmpului</span>
<span class="n">older_joe_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">%{</span><span class="w"> </span><span class="n">joe_info</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="ss">age</span><span class="p">:</span><span class="w"> </span><span class="mi">31</span><span class="w"> </span><span class="p">}</span>
<span class="c1">#=&gt; %Person{age: 31, height: 180, name: &quot;Joe&quot;}</span>

<span class="c1"># Blocul `try` cu cuvîntul cheie `rescue` e folosit pentru a prinde excepții</span>
<span class="k">try</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="k">raise</span><span class="w"> </span><span class="s2">&quot;o eroare&quot;</span>
<span class="k">rescue</span>
<span class="w">  </span><span class="nc">RuntimeError</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s2">&quot;a fost prinsă o eroare runtime&quot;</span>
<span class="w">  </span><span class="n">_error</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s2">&quot;aici vor fi prinse toate erorile&quot;</span>
<span class="k">end</span>
<span class="c1">#=&gt; &quot;a fost prinsă o eroare runtime&quot;</span>

<span class="c1"># Toate excepțiile au un mesaj</span>
<span class="k">try</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="k">raise</span><span class="w"> </span><span class="s2">&quot;o eroare&quot;</span>
<span class="k">rescue</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">[</span><span class="nc">RuntimeError</span><span class="p">]</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="n">x</span><span class="o">.</span><span class="n">message</span>
<span class="k">end</span>
<span class="c1">#=&gt; &quot;o eroare&quot;</span>

<span class="c1">## ---------------------------</span>
<span class="c1">## -- Concurența</span>
<span class="c1">## ---------------------------</span>

<span class="c1"># Concurența în Elixir se bazează pe modelul actor. Pentru a scrie programe</span>
<span class="c1"># concurente avem nevoie de trei lucruri:</span>
<span class="c1"># 1. Crearea proceselor</span>
<span class="c1"># 2. Trimiterea mesajelor</span>
<span class="c1"># 3. Primirea mesajelor</span>

<span class="c1"># Un nou proces se crează folosind funcția `spawn`, care primește o funcție</span>
<span class="c1"># ca argument.</span>
<span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k">end</span><span class="w"> </span><span class="c1">#=&gt; #Function&lt;erl_eval.20.80484245&gt;</span>
<span class="n">spawn</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="c1">#=&gt; #PID&lt;0.40.0&gt;</span>

<span class="c1"># `spawn` întoarce identificatorul procesului pid, îl puteți folosi pentru</span>
<span class="c1"># a trimite mesaje procesului. Mesajele se transmit folosind operatorul `send`.  </span>
<span class="c1"># Pentru primirea mesajelor se folosește mecanismul `receive`:</span>

<span class="c1"># Blocul `receive do` este folosit pentru așteptarea mesajelor și prelucrarea lor</span>
<span class="c1"># cînd au fost primite. Blocul `receive do` va procesa doar un singur mesaj primit.</span>
<span class="c1"># Pentru a procesa mai multe mesaje, funcția cu blocul `receive do` trebuie</span>
<span class="c1"># recursiv să se auto apeleze.</span>

<span class="kd">defmodule</span><span class="w"> </span><span class="nc">Geometry</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="kd">def</span><span class="w"> </span><span class="n">area_loop</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="k">receive</span><span class="w"> </span><span class="k">do</span>
<span class="w">      </span><span class="p">{</span><span class="ss">:rectangle</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">h</span><span class="p">}</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">        </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p">(</span><span class="s2">&quot;Aria = </span><span class="si">#{</span><span class="n">w</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">h</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="n">area_loop</span><span class="p">()</span>
<span class="w">      </span><span class="p">{</span><span class="ss">:circle</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">}</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">        </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p">(</span><span class="s2">&quot;Aria = </span><span class="si">#{</span><span class="mf">3.14</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="n">area_loop</span><span class="p">()</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>
<span class="k">end</span>

<span class="c1"># Compilați modulul și creați un proces</span>
<span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spawn</span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nc">Geometry</span><span class="o">.</span><span class="n">area_loop</span><span class="p">()</span><span class="w"> </span><span class="k">end</span><span class="p">)</span><span class="w"> </span><span class="c1">#=&gt; #PID&lt;0.40.0&gt;</span>
<span class="c1"># Un alt mod</span>
<span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spawn</span><span class="p">(</span><span class="nc">Geometry</span><span class="p">,</span><span class="w"> </span><span class="ss">:area_loop</span><span class="p">,</span><span class="w"> </span><span class="p">[])</span>

<span class="c1"># Trimiteți un mesaj către `pid` care se va potrivi cu un șablon din blocul `receive`</span>
<span class="n">send</span><span class="w"> </span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="ss">:rectangle</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span>
<span class="c1">#=&gt; Aria = 6</span>
<span class="c1">#   {:rectangle,2,3}</span>

<span class="n">send</span><span class="w"> </span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="ss">:circle</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span>
<span class="c1">#=&gt; Aria = 12.56000000000000049738</span>
<span class="c1">#   {:circle,2}</span>

<span class="c1"># Interpretatorul este de asemenea un proces, puteți folosi `self` </span>
<span class="c1"># pentru a primi identificatorul de proces: </span>
<span class="n">self</span><span class="p">()</span><span class="w"> </span><span class="c1">#=&gt; #PID&lt;0.27.0&gt;</span>

<span class="c1">## ---------------------------</span>
<span class="c1">## -- Agenții</span>
<span class="c1">## ---------------------------</span>

<span class="c1"># Un agent este un proces care urmărește careva valori ce se schimbă.</span>

<span class="c1"># Creați un agent cu `Agent.start_link`, transmițînd o funcție.</span>
<span class="c1"># Stare inițială a agentului va fi rezultatul funcției.</span>
<span class="p">{</span><span class="n">ok</span><span class="p">,</span><span class="w"> </span><span class="n">my_agent</span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Agent</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;roșu&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;verde&quot;</span><span class="p">]</span><span class="w"> </span><span class="k">end</span><span class="p">)</span>

<span class="c1"># `Agent.get` primește numele agentului și o `fn` care primește starea curentă</span>
<span class="c1"># Orice va întoarce `fn` este ceea ce veți primi înapoi: </span>
<span class="nc">Agent</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">my_agent</span><span class="p">,</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">colors</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">colors</span><span class="w"> </span><span class="k">end</span><span class="p">)</span><span class="w"> </span><span class="c1">#=&gt; [&quot;roșu&quot;, &quot;verde&quot;]</span>

<span class="c1"># Actualizați starea agentului în acelaș mod:</span>
<span class="nc">Agent</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">my_agent</span><span class="p">,</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">colors</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;albastru&quot;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">colors</span><span class="p">]</span><span class="w"> </span><span class="k">end</span><span class="p">)</span>
</pre></div>
<h2>Link-uri utile</h2>
<ul>
<li><a href="http://elixir-lang.org/getting-started/introduction.html">Primii pași</a> de pe <a href="http://elixir-lang.org">situl Elixir</a></li>
<li><a href="http://elixir-lang.org/docs/master/">Documentația oficială Elixir</a></li>
<li><a href="http://media.pragprog.com/titles/elixir/ElixirCheat.pdf">Un mic conspect pe Elixir</a></li>
<li><a href="https://pragprog.com/book/elixir/programming-elixir">Cartea &quot;Programming Elixir&quot;</a> de Dave Thomas</li>
<li><a href="http://learnyousomeerlang.com/">Cartea &quot;Learn You Some Erlang for Great Good!&quot;</a> de Fred Hebert</li>
<li><a href="https://pragprog.com/book/jaerlang2/programming-erlang">Cartea &quot;Programming Erlang: Software for a Concurrent World&quot;</a> de Joe Armstrong</li>
</ul>

        <hr>
        <p>
          Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the GitHub Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/ro/elixir.md">pull request</a> yourself!
        </p>
        <p class="contributed">
          Originally contributed by Joao Marques, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/ro/elixir.md">3 contributors</a>.
        </p>

        <footer>
          <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width: 0; width: 88px; height: 31px;" src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-sa.svg" /></a>
          <p>
            &copy; 2025
            <a href="http://github.com/mrshankly">Joao Marques</a>,
            <a href="https://github.com/dskecse">Dzianis Dashkevich</a>,
            <a href="https://github.com/ryanplant-au">Ryan Plant</a>,
            <a href="https://github.com/evbogdanov">Ev Bogdanov</a>
          </p>
        </footer>
      </div>
    </div>
  </body>
</html>