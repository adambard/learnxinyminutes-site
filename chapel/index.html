<!DOCTYPE html>
<html lang="en">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WXC8R75DEN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-WXC8R75DEN');
    </script>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="Content-Language" content="en">
    <title>Learn Chapel in Y Minutes</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto+Slab:wght@100..900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/screen.css">
    <link rel="stylesheet" href="/css/light.css">
    <link rel="stylesheet" href="/css/dark.css">

    <link rel="canonical" href="https://learnxinyminutes.com/chapel/">
    <script>
      localStorage.removeItem("lxiym_theme");
    </script>
  </head>
  <body>
    <div class="container">
      <div class="share">
        <span class="sharemsg">
          <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fchapel%2F&amp;text=Learn+X+in+Y+minutes%2C+where+X%3DChapel">
            Share this page
          </a>
        </span>
        <span class='st_facebook_large' displayText='Facebook'></span>
        <span class='st_twitter_large' displayText='Tweet'></span>
      </div>
      <h1><a href="/">Learn X in Y minutes</a></h1>
      <h2>Where X=Chapel</h2>
      <p class="filelink">
        Get the code:
        <a href="/files/learnchapel.chpl">learnchapel.chpl</a>
      </p>
      <div id="doc">
<p>You can read all about Chapel at <a href="https://chapel-lang.org">Cray's official Chapel website</a>.
In short, Chapel is an open-source, high-productivity, parallel-programming
language in development at Cray Inc., and is designed to run on multi-core PCs
as well as multi-kilocore supercomputers.</p>
<p>More information and support can be found at the bottom of this document.</p>
<p>You can refer to the official site for <a href="https://chapel-lang.org/docs/master/primers/learnChapelInYMinutes.html">latest version</a> of this document.</p>
<div class="highlight"><pre lang="chapel"><span class="cm">/*</span>
<span class="cm">   Learn Chapel in Y Minutes</span>
<span class="cm">   </span>
<span class="cm">   This primer will go over basic syntax and concepts in Chapel.</span>
<span class="cm">   Last sync with official page: Sun, 08 Mar 2020 08:05:53 +0000</span>
<span class="cm">*/</span>

<span class="c1">// Comments are C-family style</span>

<span class="c1">// one line comment</span>
<span class="cm">/*</span>
<span class="cm">    multi-line comment</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">Basic printing</span>
<span class="cm">*/</span>

<span class="nx">write</span><span class="p">(</span><span class="s">&quot;Hello, &quot;</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;World!&quot;</span><span class="p">);</span>

<span class="c1">// ``write`` and ``writeln`` can take a list of things to print.</span>
<span class="c1">// Each thing is printed right next to the others, so include your spacing!</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;There are &quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; commas (\&quot;,\&quot;) in this line of code&quot;</span><span class="p">);</span>

<span class="c1">// Different output channels:</span>
<span class="k">use</span><span class="w"> </span><span class="nx">IO</span><span class="p">;</span><span class="w"> </span><span class="c1">// Required for accessing the alternative output channels</span>

<span class="nx">stdout</span><span class="p">.</span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;This goes to standard output, just like plain writeln() does&quot;</span><span class="p">);</span>
<span class="nx">stderr</span><span class="p">.</span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;This goes to standard error&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Variables</span>
<span class="cm">*/</span>

<span class="c1">// Variables don&#39;t have to be explicitly typed as long as</span>
<span class="c1">// the compiler can figure out the type that it will hold.</span>
<span class="c1">// 10 is an ``int``, so ``myVar`` is implicitly an ``int``</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="nx">myVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">10</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">mySecondVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">myVar</span><span class="p">;</span>
<span class="c1">// ``var anError;`` would be a compile-time error.</span>

<span class="c1">// We can (and should) explicitly type things.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myThirdVar</span><span class="p">:</span><span class="w"> </span><span class="kt">real</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myFourthVar</span><span class="p">:</span><span class="w"> </span><span class="kt">real</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">1.234</span><span class="p">;</span>
<span class="nx">myThirdVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">myFourthVar</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm">Types</span>
<span class="cm">*/</span>

<span class="c1">// There are a number of basic types.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myInt</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="c1">// Signed ints</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myUint</span><span class="p">:</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1234</span><span class="p">;</span><span class="w"> </span><span class="c1">// Unsigned ints</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myReal</span><span class="p">:</span><span class="w"> </span><span class="kt">real</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">9.876</span><span class="p">;</span><span class="w"> </span><span class="c1">// Floating point numbers</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myImag</span><span class="p">:</span><span class="w"> </span><span class="kt">imag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">5.0i</span><span class="p">;</span><span class="w"> </span><span class="c1">// Imaginary numbers</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myCplx</span><span class="p">:</span><span class="w"> </span><span class="kt">complex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">9i</span><span class="p">;</span><span class="w"> </span><span class="c1">// Complex numbers</span>
<span class="nx">myCplx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">myInt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">myImag</span><span class="p">;</span><span class="w"> </span><span class="c1">// Another way to form complex numbers</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myBool</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Booleans</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">myStr</span><span class="p">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Some string...&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Strings</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">singleQuoteStr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#39;Another string...&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// String literal with single quotes</span>

<span class="c1">// Some types can have sizes.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">my8Int</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="c1">// 8 bit (one byte) sized int;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">my64Real</span><span class="p">:</span><span class="w"> </span><span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.516</span><span class="p">;</span><span class="w"> </span><span class="c1">// 64 bit (8 bytes) sized real</span>

<span class="c1">// Typecasting.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">intFromReal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">myReal</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">intFromReal2</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">myReal</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>

<span class="c1">// Type aliasing.</span>
<span class="kd">type</span><span class="w"> </span><span class="nx">chroma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w">        </span><span class="c1">// Type of a single hue</span>
<span class="kd">type</span><span class="w"> </span><span class="nx">RGBColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">*</span><span class="nx">chroma</span><span class="p">;</span><span class="w"> </span><span class="c1">// Type representing a full color</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">black</span><span class="p">:</span><span class="w"> </span><span class="nx">RGBColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">white</span><span class="p">:</span><span class="w"> </span><span class="nx">RGBColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">255</span><span class="p">,</span><span class="w"> </span><span class="mi">255</span><span class="p">,</span><span class="w"> </span><span class="mi">255</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Constants and Parameters</span>
<span class="cm">*/</span>

<span class="c1">// A ``const`` is a constant, and cannot be changed after set in runtime.</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">almostPi</span><span class="p">:</span><span class="w"> </span><span class="kt">real</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">22.0</span><span class="o">/</span><span class="mf">7.0</span><span class="p">;</span>

<span class="c1">// A ``param`` is a constant whose value must be known statically at</span>
<span class="c1">// compile-time.</span>
<span class="kd">param</span><span class="w"> </span><span class="nx">compileTimeConst</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>

<span class="c1">// The ``config`` modifier allows values to be set at the command line.</span>
<span class="c1">// Set with ``--varCmdLineArg=Value`` or ``--varCmdLineArg Value`` at runtime.</span>
<span class="kd">config</span><span class="w"> </span><span class="kd">var</span><span class="w"> </span><span class="nx">varCmdLineArg</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">123</span><span class="p">;</span>
<span class="kd">config</span><span class="w"> </span><span class="kd">const</span><span class="w"> </span><span class="nx">constCmdLineArg</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">777</span><span class="p">;</span>

<span class="c1">// ``config param`` can be set at compile-time.</span>
<span class="c1">// Set with ``--set paramCmdLineArg=value`` at compile-time.</span>
<span class="kd">config</span><span class="w"> </span><span class="kd">param</span><span class="w"> </span><span class="nx">paramCmdLineArg</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">varCmdLineArg</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">constCmdLineArg</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">paramCmdLineArg</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">References</span>
<span class="cm">*/</span>

<span class="c1">// ``ref`` operates much like a reference in C++. In Chapel, a ``ref`` cannot</span>
<span class="c1">// be made to alias a variable other than the variable it is initialized with.</span>
<span class="c1">// Here, ``refToActual`` refers to ``actual``.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">actual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="kd">ref</span><span class="w"> </span><span class="nx">refToActual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">actual</span><span class="p">;</span><span class="w"> </span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">actual</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; == &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">refToActual</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints the same value</span>
<span class="nx">actual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">123</span><span class="p">;</span><span class="w"> </span><span class="c1">// modify actual (which refToActual refers to)</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">actual</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; == &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">refToActual</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints the same value</span>
<span class="nx">refToActual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">99999999</span><span class="p">;</span><span class="w"> </span><span class="c1">// modify what refToActual refers to (which is actual)</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">actual</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; == &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">refToActual</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints the same value</span>

<span class="cm">/*</span>
<span class="cm">Operators</span>
<span class="cm">*/</span>

<span class="c1">// Math operators:</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">a</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1234</span><span class="p">,</span><span class="w"> </span><span class="nx">thatInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5678</span><span class="p">;</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">  </span><span class="c1">// Addition</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">  </span><span class="c1">// Multiplication</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">  </span><span class="c1">// Subtraction</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">  </span><span class="c1">// Division</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w"> </span><span class="c1">// Exponentiation</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">  </span><span class="c1">// Remainder (modulo)</span>

<span class="c1">// Logical operators:</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">b</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="nx">thisBool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="nx">thatBool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisBool</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">thatBool</span><span class="p">;</span><span class="w"> </span><span class="c1">// Logical and</span>
<span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisBool</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">thatBool</span><span class="p">;</span><span class="w"> </span><span class="c1">// Logical or</span>
<span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="nx">thisBool</span><span class="p">;</span><span class="w">            </span><span class="c1">// Logical negation</span>

<span class="c1">// Relational operators:</span>
<span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">           </span><span class="c1">// Greater-than</span>
<span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">          </span><span class="c1">// Greater-than-or-equal-to</span>
<span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w"> </span><span class="c1">// Less-than, and, less-than-or-equal-to</span>
<span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">          </span><span class="c1">// Not-equal-to</span>
<span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">          </span><span class="c1">// Equal-to</span>

<span class="c1">// Bitwise operators:</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">     </span><span class="c1">// Left-bit-shift by 10 bits;</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thatInt</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">      </span><span class="c1">// Right-bit-shift by 5 bits;</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">~</span><span class="nx">thisInt</span><span class="p">;</span><span class="w">          </span><span class="c1">// Bitwise-negation</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w"> </span><span class="c1">// Bitwise exclusive-or</span>

<span class="c1">// Compound assignment operators:</span>
<span class="nx">a</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">thisInt</span><span class="p">;</span><span class="w">          </span><span class="c1">// Addition-equals (a = a + thisInt;)</span>
<span class="nx">a</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w">          </span><span class="c1">// Times-equals (a = a * thatInt;)</span>
<span class="nx">b</span><span class="w"> </span><span class="o">&amp;&amp;=</span><span class="w"> </span><span class="nx">thatBool</span><span class="p">;</span><span class="w">        </span><span class="c1">// Logical-and-equals (b = b &amp;&amp; thatBool;)</span>
<span class="nx">a</span><span class="w"> </span><span class="o">&lt;&lt;=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">               </span><span class="c1">// Left-bit-shift-equals (a = a &lt;&lt; 10;)</span>

<span class="c1">// Unlike other C family languages, there are no</span>
<span class="c1">// pre/post-increment/decrement operators, such as:</span>
<span class="c1">//</span>
<span class="c1">// ``++j``, ``--j``, ``j++``, ``j--``</span>

<span class="c1">// Swap operator:</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">old_this</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">old_that</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span>
<span class="nx">thisInt</span><span class="w"> </span><span class="o">&lt;=&gt;</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">;</span><span class="w"> </span><span class="c1">// Swap the values of thisInt and thatInt</span>
<span class="nx">writeln</span><span class="p">((</span><span class="nx">old_this</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">thatInt</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="nx">old_that</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">thisInt</span><span class="p">));</span>

<span class="c1">// Operator overloads can also be defined, as we&#39;ll see with procedures.</span>

<span class="cm">/*</span>
<span class="cm">Tuples</span>
<span class="cm">*/</span>

<span class="c1">// Tuples can be of the same type or different types.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">sameTup</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">sameTup2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">6</span><span class="p">);</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">diffTup</span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">real</span><span class="p">,</span><span class="kt">complex</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mf">1.928</span><span class="p">,</span><span class="w"> </span><span class="nx">myCplx</span><span class="p">);</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">diffTupe2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mf">5.64</span><span class="p">,</span><span class="w"> </span><span class="mf">6.0</span><span class="o">+</span><span class="m">1.5i</span><span class="p">);</span>

<span class="c1">// Tuples can be accessed using square brackets or parentheses, and are</span>
<span class="c1">// 1-indexed.</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;(&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">sameTup</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">sameTup</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">diffTup</span><span class="p">);</span>

<span class="c1">// Tuples can also be written into.</span>
<span class="nx">diffTup</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="c1">// Tuple values can be expanded into their own variables.</span>
<span class="kd">var</span><span class="w"> </span><span class="p">(</span><span class="nx">tupInt</span><span class="p">,</span><span class="w"> </span><span class="nx">tupReal</span><span class="p">,</span><span class="w"> </span><span class="nx">tupCplx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">diffTup</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">diffTup</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="nx">tupInt</span><span class="p">,</span><span class="w"> </span><span class="nx">tupReal</span><span class="p">,</span><span class="w"> </span><span class="nx">tupCplx</span><span class="p">));</span>

<span class="c1">// They are also useful for writing a list of variables, as is common in debugging.</span>
<span class="nx">writeln</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">thisInt</span><span class="p">,</span><span class="nx">thatInt</span><span class="p">,</span><span class="nx">thisBool</span><span class="p">,</span><span class="nx">thatBool</span><span class="p">));</span>

<span class="cm">/*</span>
<span class="cm">Control Flow</span>
<span class="cm">*/</span>

<span class="c1">// ``if`` - ``then`` - ``else`` works just like any other C-family language.</span>
<span class="k">if</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="k">then</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;All is well&quot;</span><span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">then</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Continuing to believe reality&quot;</span><span class="p">);</span>
<span class="k">else</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Send mathematician, something&#39;s wrong&quot;</span><span class="p">);</span>

<span class="c1">// You can use parentheses if you prefer.</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">10</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Universe broken. Please reboot universe.&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; is even.&quot;</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; is odd.&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; is even divisible by 3.&quot;</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; is divided by 3 with a remainder of 1.&quot;</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; is divided by 3 with a remainder of 2.&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Ternary: ``if`` - ``then`` - ``else`` in a statement.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">maximum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nx">thisInt</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">thatInt</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="nx">thatInt</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="nx">thisInt</span><span class="p">;</span>

<span class="c1">// ``select`` statements are much like switch statements in other languages.</span>
<span class="c1">// However, ``select`` statements don&#39;t cascade like in C or Java.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">inputOption</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;anOption&quot;</span><span class="p">;</span>
<span class="k">select</span><span class="w"> </span><span class="nx">inputOption</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">when</span><span class="w"> </span><span class="s">&quot;anOption&quot;</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Chose &#39;anOption&#39;&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">when</span><span class="w"> </span><span class="s">&quot;otherOption&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Chose &#39;otherOption&#39;&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Which has a body&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">otherwise</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Any other Input&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;the otherwise case doesn&#39;t need a do if the body is one line&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ``while`` and ``do``-``while`` loops also behave like their C counterparts.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">j</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">jSum</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nx">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1000</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">jSum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">j</span><span class="p">;</span>
<span class="w">  </span><span class="nx">j</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">jSum</span><span class="p">);</span>

<span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">jSum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">j</span><span class="p">;</span>
<span class="w">  </span><span class="nx">j</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nx">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">10000</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">jSum</span><span class="p">);</span>

<span class="c1">// ``for`` loops are much like those in python in that they iterate over a</span>
<span class="c1">// range. Ranges (like the ``1..10`` expression below) are a first-class object</span>
<span class="c1">// in Chapel, and as such can be stored in variables.</span>
<span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">write</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">();</span>

<span class="kd">var</span><span class="w"> </span><span class="nx">iSum</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">1000</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">iSum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">i</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">iSum</span><span class="p">);</span>

<span class="k">for</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">write</span><span class="p">((</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;\t&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">Ranges and Domains</span>
<span class="cm">*/</span>

<span class="c1">// For-loops and arrays both use ranges and domains to define an index set that</span>
<span class="c1">// can be iterated over. Ranges are single dimensional integer indices, while</span>
<span class="c1">// domains can be multi-dimensional and represent indices of different types.</span>

<span class="c1">// They are first-class citizen types, and can be assigned into variables.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">range1to10</span><span class="p">:</span><span class="w"> </span><span class="kt">range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">;</span><span class="w">  </span><span class="c1">// 1, 2, 3, ..., 10</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">range2to11</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="o">..</span><span class="mi">11</span><span class="p">;</span><span class="w"> </span><span class="c1">// 2, 3, 4, ..., 11</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">rangeThisToThat</span><span class="p">:</span><span class="w"> </span><span class="kt">range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisInt</span><span class="o">..</span><span class="nx">thatInt</span><span class="p">;</span><span class="w"> </span><span class="c1">// using variables</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">rangeEmpty</span><span class="p">:</span><span class="w"> </span><span class="kt">range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="o">..-</span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="c1">// this is valid but contains no indices</span>

<span class="c1">// Ranges can be unbounded.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">range1toInf</span><span class="p">:</span><span class="w"> </span><span class="kt">range</span><span class="p">(</span><span class="nx">boundedType</span><span class="o">=</span><span class="nx">BoundedRangeType</span><span class="p">.</span><span class="nx">boundedLow</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="c1">// 1, 2, 3, 4, 5, ...</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">rangeNegInfTo1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">..</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// ..., -4, -3, -2, -1, 0, 1</span>

<span class="c1">// Ranges can be strided (and reversed) using the ``by`` operator.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">range2to10by2</span><span class="p">:</span><span class="w"> </span><span class="kt">range</span><span class="p">(</span><span class="nx">stridable</span><span class="o">=</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// 2, 4, 6, 8, 10</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">reverse2to10by2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// 10, 8, 6, 4, 2</span>

<span class="kd">var</span><span class="w"> </span><span class="nx">trapRange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="o">..</span><span class="mi">1</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Do not be fooled, this is still an empty range</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Size of range &#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">trapRange</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&#39; = &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">trapRange</span><span class="p">.</span><span class="nx">size</span><span class="p">);</span>

<span class="c1">// Note: ``range(boundedType= ...)`` and ``range(stridable= ...)`` are only</span>
<span class="c1">// necessary if we explicitly type the variable.</span>

<span class="c1">// The end point of a range can be computed by specifying the total size</span>
<span class="c1">// of the range using the count (``#``) operator.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">rangeCount</span><span class="p">:</span><span class="w"> </span><span class="kt">range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">5</span><span class="o">..#</span><span class="mi">12</span><span class="p">;</span><span class="w"> </span><span class="c1">// range from -5 to 6</span>

<span class="c1">// Operators can be mixed.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">rangeCountBy</span><span class="p">:</span><span class="w"> </span><span class="kt">range</span><span class="p">(</span><span class="nx">stridable</span><span class="o">=</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">5</span><span class="o">..#</span><span class="mi">12</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// -5, -3, -1, 1, 3, 5</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">rangeCountBy</span><span class="p">);</span>

<span class="c1">// Properties of the range can be queried.</span>
<span class="c1">// In this example, printing the first index, last index, number of indices,</span>
<span class="c1">// stride, and if 2 is include in the range.</span>
<span class="nx">writeln</span><span class="p">((</span><span class="nx">rangeCountBy</span><span class="p">.</span><span class="nx">first</span><span class="p">,</span><span class="w"> </span><span class="nx">rangeCountBy</span><span class="p">.</span><span class="nx">last</span><span class="p">,</span><span class="w"> </span><span class="nx">rangeCountBy</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span>
<span class="w">           </span><span class="nx">rangeCountBy</span><span class="p">.</span><span class="nx">stride</span><span class="p">,</span><span class="w"> </span><span class="nx">rangeCountBy</span><span class="p">.</span><span class="nx">contains</span><span class="p">(</span><span class="mi">2</span><span class="p">)));</span>

<span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">rangeCountBy</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">write</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">rangeCountBy</span><span class="p">.</span><span class="nx">last</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="s">&quot;\n&quot;</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Rectangular domains are defined using the same range syntax,</span>
<span class="c1">// but they are required to be bounded (unlike ranges).</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">domain1to10</span><span class="p">:</span><span class="w"> </span><span class="k">domain</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">};</span><span class="w">        </span><span class="c1">// 1D domain from 1..10;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">twoDimensions</span><span class="p">:</span><span class="w"> </span><span class="k">domain</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="o">..</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="o">..</span><span class="mi">2</span><span class="p">};</span><span class="w"> </span><span class="c1">// 2D domain over product of ranges</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">thirdDim</span><span class="p">:</span><span class="w"> </span><span class="kt">range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">16</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">threeDims</span><span class="p">:</span><span class="w"> </span><span class="k">domain</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="nx">thirdDim</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="o">..</span><span class="mi">10</span><span class="p">};</span><span class="w"> </span><span class="c1">// using a range variable</span>

<span class="c1">// Domains can also be resized</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">resizedDom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">};</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;before, resizedDom = &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">resizedDom</span><span class="p">);</span>
<span class="nx">resizedDom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="o">-</span><span class="mi">10</span><span class="o">..#</span><span class="mi">10</span><span class="p">};</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;after, resizedDom = &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">resizedDom</span><span class="p">);</span>

<span class="c1">// Indices can be iterated over as tuples.</span>
<span class="k">for</span><span class="w"> </span><span class="nx">idx</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">twoDimensions</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="nx">write</span><span class="p">(</span><span class="nx">idx</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">();</span>

<span class="c1">// These tuples can also be destructured.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">)</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">twoDimensions</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">write</span><span class="p">(</span><span class="s">&quot;(&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">writeln</span><span class="p">();</span>

<span class="c1">// Associative domains act like sets.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">stringSet</span><span class="p">:</span><span class="w"> </span><span class="k">domain</span><span class="p">(</span><span class="kt">string</span><span class="p">);</span><span class="w"> </span><span class="c1">// empty set of strings</span>
<span class="nx">stringSet</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="p">;</span>
<span class="nx">stringSet</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;b&quot;</span><span class="p">;</span>
<span class="nx">stringSet</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;c&quot;</span><span class="p">;</span>
<span class="nx">stringSet</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Redundant add &quot;a&quot;</span>
<span class="nx">stringSet</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="s">&quot;c&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Remove &quot;c&quot;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">stringSet</span><span class="p">.</span><span class="nx">sorted</span><span class="p">());</span>

<span class="c1">// Associative domains can also have a literal syntax</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">intSet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">};</span>

<span class="c1">// Both ranges and domains can be sliced to produce a range or domain with the</span>
<span class="c1">// intersection of indices.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">rangeA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="c1">// range from 1 to infinity</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">rangeB</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="o">..</span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// range from negative infinity to 5</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">rangeC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">rangeA</span><span class="p">[</span><span class="nx">rangeB</span><span class="p">];</span><span class="w"> </span><span class="c1">// resulting range is 1..5</span>
<span class="nx">writeln</span><span class="p">((</span><span class="nx">rangeA</span><span class="p">,</span><span class="w"> </span><span class="nx">rangeB</span><span class="p">,</span><span class="w"> </span><span class="nx">rangeC</span><span class="p">));</span>

<span class="kd">var</span><span class="w"> </span><span class="nx">domainA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="o">..</span><span class="mi">20</span><span class="p">};</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">domainB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="o">-</span><span class="mi">5</span><span class="o">..</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">};</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">domainC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">domainA</span><span class="p">[</span><span class="nx">domainB</span><span class="p">];</span>
<span class="nx">writeln</span><span class="p">((</span><span class="nx">domainA</span><span class="p">,</span><span class="w"> </span><span class="nx">domainB</span><span class="p">,</span><span class="w"> </span><span class="nx">domainC</span><span class="p">));</span>

<span class="cm">/*</span>
<span class="cm">Arrays</span>
<span class="cm">*/</span>

<span class="c1">// Arrays are similar to those of other languages.</span>
<span class="c1">// Their sizes are defined using domains that represent their indices.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">intArray</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">intArray2</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">}]</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w"> </span><span class="c1">// equivalent</span>

<span class="c1">// They can be accessed using either brackets or parentheses</span>
<span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="nx">intArray</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="nx">i</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">intArray</span><span class="p">);</span>

<span class="c1">// We cannot access ``intArray[0]`` because it exists outside</span>
<span class="c1">// of the index set, ``{1..10}``, we defined it to have.</span>
<span class="c1">// ``intArray[11]`` is illegal for the same reason.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">realDomain</span><span class="p">:</span><span class="w"> </span><span class="k">domain</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="o">..</span><span class="mi">7</span><span class="p">};</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">realArray</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="nx">realDomain</span><span class="p">]</span><span class="w"> </span><span class="kt">real</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">realArray2</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="o">..</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="kt">real</span><span class="p">;</span><span class="w">   </span><span class="c1">// equivalent</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">realArray3</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="o">..</span><span class="mi">7</span><span class="p">}]</span><span class="w"> </span><span class="kt">real</span><span class="p">;</span><span class="w"> </span><span class="c1">// equivalent</span>

<span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">realDomain</span><span class="p">.</span><span class="nx">dim</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">   </span><span class="c1">// Only use the 2nd dimension of the domain</span>
<span class="w">    </span><span class="nx">realArray</span><span class="p">[</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">1.61803</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">j</span><span class="p">;</span><span class="w">  </span><span class="c1">// Access using index list</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">idx</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">);</span><span class="w">                   </span><span class="c1">// Note: &#39;index&#39; is a keyword</span>
<span class="w">    </span><span class="nx">realArray</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">realArray</span><span class="p">[(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)];</span><span class="w">      </span><span class="c1">// Index using tuples</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Arrays have domains as members, and can be iterated over as normal.</span>
<span class="k">for</span><span class="w"> </span><span class="nx">idx</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">realArray</span><span class="p">.</span><span class="k">domain</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// Again, idx is a 2*int tuple</span>
<span class="w">  </span><span class="nx">realArray</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">realArray</span><span class="p">[</span><span class="nx">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="nx">idx</span><span class="p">[</span><span class="mi">2</span><span class="p">]];</span><span class="w"> </span><span class="c1">// Access by tuple and list</span>
<span class="p">}</span>

<span class="nx">writeln</span><span class="p">(</span><span class="nx">realArray</span><span class="p">);</span>

<span class="c1">// The values of an array can also be iterated directly.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">rSum</span><span class="p">:</span><span class="w"> </span><span class="kt">real</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">realArray</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">rSum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">value</span><span class="p">;</span><span class="w"> </span><span class="c1">// Read a value</span>
<span class="w">  </span><span class="nx">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">rSum</span><span class="p">;</span><span class="w">  </span><span class="c1">// Write a value</span>
<span class="p">}</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">rSum</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">realArray</span><span class="p">);</span>

<span class="c1">// Associative arrays (dictionaries) can be created using associative domains.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">dictDomain</span><span class="p">:</span><span class="w"> </span><span class="k">domain</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;one&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;two&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;three&quot;</span><span class="p">};</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">dict</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="nx">dictDomain</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;one&quot;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;two&quot;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;three&quot;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span>

<span class="k">for</span><span class="w"> </span><span class="nx">key</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">dictDomain</span><span class="p">.</span><span class="nx">sorted</span><span class="p">()</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">dict</span><span class="p">[</span><span class="nx">key</span><span class="p">]);</span>

<span class="c1">// Arrays can be assigned to each other in a few different ways.</span>
<span class="c1">// These arrays will be used in the example.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">thisArray</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">thatArray</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>

<span class="c1">// First, simply assign one to the other. This copies ``thisArray`` into</span>
<span class="c1">// ``thatArray``, instead of just creating a reference. Therefore, modifying</span>
<span class="c1">// ``thisArray`` does not also modify ``thatArray``.</span>

<span class="nx">thatArray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisArray</span><span class="p">;</span>
<span class="nx">thatArray</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">((</span><span class="nx">thisArray</span><span class="p">,</span><span class="w"> </span><span class="nx">thatArray</span><span class="p">));</span>

<span class="c1">// Assign a slice from one array to a slice (of the same size) in the other.</span>
<span class="nx">thatArray</span><span class="p">[</span><span class="mi">4</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisArray</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">2</span><span class="p">];</span>
<span class="nx">writeln</span><span class="p">((</span><span class="nx">thisArray</span><span class="p">,</span><span class="w"> </span><span class="nx">thatArray</span><span class="p">));</span>

<span class="c1">// Operations can also be promoted to work on arrays. &#39;thisPlusThat&#39; is also</span>
<span class="c1">// an array.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">thisPlusThat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">thisArray</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">thatArray</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">thisPlusThat</span><span class="p">);</span>

<span class="c1">// Moving on, arrays and loops can also be expressions, where the loop</span>
<span class="c1">// body&#39;s expression is the result of each iteration.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">arrayFromLoop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">i</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">arrayFromLoop</span><span class="p">);</span>

<span class="c1">// An expression can result in nothing, such as when filtering with an if-expression.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">evensOrFives</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="nx">i</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="nx">arrayFromLoop</span><span class="p">);</span>

<span class="c1">// Array expressions can also be written with a bracket notation.</span>
<span class="c1">// Note: this syntax uses the ``forall`` parallel concept discussed later.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">evensOrFivesAgain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="nx">i</span><span class="p">;</span>

<span class="c1">// They can also be written over the values of the array.</span>
<span class="nx">arrayFromLoop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nx">value</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">arrayFromLoop</span><span class="p">]</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm">Procedures</span>
<span class="cm">*/</span>

<span class="c1">// Chapel procedures have similar syntax functions in other languages. </span>
<span class="k">proc</span><span class="w"> </span><span class="nf">fibonacci</span><span class="p">(</span><span class="nx">n</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">n</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">fibonacci</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">fibonacci</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Input parameters can be untyped to create a generic procedure.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">doublePrint</span><span class="p">(</span><span class="nx">thing</span><span class="p">):</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">write</span><span class="p">(</span><span class="nx">thing</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">thing</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;\n&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// The return type can be inferred, as long as the compiler can figure it out.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">addThree</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">doublePrint</span><span class="p">(</span><span class="nx">addThree</span><span class="p">(</span><span class="nx">fibonacci</span><span class="p">(</span><span class="mi">20</span><span class="p">)));</span>

<span class="c1">// It is also possible to take a variable number of parameters.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">maxOf</span><span class="p">(</span><span class="nx">x</span><span class="w"> </span><span class="o">..</span><span class="p">.?</span><span class="nx">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// x refers to a tuple of one type, with k elements</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">maximum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">x</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">2</span><span class="o">..</span><span class="nx">k</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">maximum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nx">maximum</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="nx">maximum</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">maximum</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">maxOf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">189</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">9071982</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">17</span><span class="p">,</span><span class="w"> </span><span class="mi">20001</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">));</span>

<span class="c1">// Procedures can have default parameter values, and</span>
<span class="c1">// the parameters can be named in the call, even out of order.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">defaultsProc</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="p">:</span><span class="w"> </span><span class="kt">real</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.2634</span><span class="p">):</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">real</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">writeln</span><span class="p">(</span><span class="nx">defaultsProc</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">defaultsProc</span><span class="p">(</span><span class="nx">x</span><span class="o">=</span><span class="mi">11</span><span class="p">));</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">defaultsProc</span><span class="p">(</span><span class="nx">x</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="o">=</span><span class="mf">5.432</span><span class="p">));</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">defaultsProc</span><span class="p">(</span><span class="nx">y</span><span class="o">=</span><span class="mf">9.876</span><span class="p">,</span><span class="w"> </span><span class="nx">x</span><span class="o">=</span><span class="mi">13</span><span class="p">));</span>

<span class="c1">// The ``?`` operator is called the query operator, and is used to take</span>
<span class="c1">// undetermined values like tuple or array sizes and generic types.</span>
<span class="c1">// For example, taking arrays as parameters. The query operator is used to</span>
<span class="c1">// determine the domain of ``A``. This is useful for defining the return type,</span>
<span class="c1">// though it&#39;s not required.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">invertArray</span><span class="p">(</span><span class="nx">A</span><span class="p">:</span><span class="w"> </span><span class="p">[?</span><span class="nx">D</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="p">):</span><span class="w"> </span><span class="p">[</span><span class="nx">D</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">A</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="nx">a</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">A</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">writeln</span><span class="p">(</span><span class="nx">invertArray</span><span class="p">(</span><span class="nx">intArray</span><span class="p">));</span>

<span class="c1">// We can query the type of arguments to generic procedures.</span>
<span class="c1">// Here we define a procedure that takes two arguments of</span>
<span class="c1">// the same type, yet we don&#39;t define what that type is.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">genericProc</span><span class="p">(</span><span class="nx">arg1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">?</span><span class="nx">valueType</span><span class="p">,</span><span class="w"> </span><span class="nx">arg2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">valueType</span><span class="p">):</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">select</span><span class="p">(</span><span class="nx">valueType</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">when</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">arg1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; and &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">arg2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; are ints&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">when</span><span class="w"> </span><span class="kt">real</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">arg1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; and &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">arg2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; are reals&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">otherwise</span><span class="w"> </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">arg1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; and &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">arg2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; are somethings!&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="nx">genericProc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="nx">genericProc</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span><span class="w"> </span><span class="mf">2.3</span><span class="p">);</span>
<span class="nx">genericProc</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="m">2.0i</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0</span><span class="o">+</span><span class="m">4.0i</span><span class="p">);</span>

<span class="c1">// We can also enforce a form of polymorphism with the ``where`` clause</span>
<span class="c1">// This allows the compiler to decide which function to use.</span>
<span class="c1">// Note: That means that all information needs to be known at compile-time.</span>
<span class="c1">// The param modifier on the arg is used to enforce this constraint.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">whereProc</span><span class="p">(</span><span class="kd">param</span><span class="w"> </span><span class="nx">N</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">):</span><span class="w"> </span><span class="kt">void</span>
<span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="p">(</span><span class="nx">N</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;N is greater than 0&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">proc</span><span class="w"> </span><span class="nf">whereProc</span><span class="p">(</span><span class="kd">param</span><span class="w"> </span><span class="nx">N</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">):</span><span class="w"> </span><span class="kt">void</span>
<span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="p">(</span><span class="nx">N</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;N is less than 0&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">whereProc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="nx">whereProc</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">// ``whereProc(0)`` would result in a compiler error because there</span>
<span class="c1">// are no functions that satisfy the ``where`` clause&#39;s condition.</span>
<span class="c1">// We could have defined a ``whereProc`` without a ``where`` clause</span>
<span class="c1">// that would then have served as a catch all for all the other cases</span>
<span class="c1">// (of which there is only one).</span>

<span class="c1">// ``where`` clauses can also be used to constrain based on argument type.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">whereType</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span><span class="w"> </span><span class="p">?</span><span class="nx">t</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="nx">t</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Inside &#39;int&#39; version of &#39;whereType&#39;: &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">proc</span><span class="w"> </span><span class="nf">whereType</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span><span class="w"> </span><span class="p">?</span><span class="nx">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Inside general version of &#39;whereType&#39;: &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">whereType</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="nx">whereType</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Intents</span>
<span class="cm">*/</span>

<span class="cm">/* Intent modifiers on the arguments convey how those arguments are passed to the procedure.</span>

<span class="cm">     * in: copy arg in, but not out</span>
<span class="cm">     * out: copy arg out, but not in</span>
<span class="cm">     * inout: copy arg in, copy arg out</span>
<span class="cm">     * ref: pass arg by reference</span>
<span class="cm">*/</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">intentsProc</span><span class="p">(</span><span class="kd">in</span><span class="w"> </span><span class="nx">inarg</span><span class="p">,</span><span class="w"> </span><span class="kd">out</span><span class="w"> </span><span class="nx">outarg</span><span class="p">,</span><span class="w"> </span><span class="kd">inout</span><span class="w"> </span><span class="nx">inoutarg</span><span class="p">,</span><span class="w"> </span><span class="kd">ref</span><span class="w"> </span><span class="nx">refarg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Inside Before: &quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="nx">inarg</span><span class="p">,</span><span class="w"> </span><span class="nx">outarg</span><span class="p">,</span><span class="w"> </span><span class="nx">inoutarg</span><span class="p">,</span><span class="w"> </span><span class="nx">refarg</span><span class="p">));</span>
<span class="w">  </span><span class="nx">inarg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">inarg</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w">  </span><span class="nx">outarg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">outarg</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w">  </span><span class="nx">inoutarg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">inoutarg</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w">  </span><span class="nx">refarg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">refarg</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Inside After: &quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="nx">inarg</span><span class="p">,</span><span class="w"> </span><span class="nx">outarg</span><span class="p">,</span><span class="w"> </span><span class="nx">inoutarg</span><span class="p">,</span><span class="w"> </span><span class="nx">refarg</span><span class="p">));</span>
<span class="p">}</span>

<span class="kd">var</span><span class="w"> </span><span class="nx">inVar</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">outVar</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">inoutVar</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">refVar</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Outside Before: &quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="nx">inVar</span><span class="p">,</span><span class="w"> </span><span class="nx">outVar</span><span class="p">,</span><span class="w"> </span><span class="nx">inoutVar</span><span class="p">,</span><span class="w"> </span><span class="nx">refVar</span><span class="p">));</span>
<span class="nx">intentsProc</span><span class="p">(</span><span class="nx">inVar</span><span class="p">,</span><span class="w"> </span><span class="nx">outVar</span><span class="p">,</span><span class="w"> </span><span class="nx">inoutVar</span><span class="p">,</span><span class="w"> </span><span class="nx">refVar</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Outside After: &quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="nx">inVar</span><span class="p">,</span><span class="w"> </span><span class="nx">outVar</span><span class="p">,</span><span class="w"> </span><span class="nx">inoutVar</span><span class="p">,</span><span class="w"> </span><span class="nx">refVar</span><span class="p">));</span>

<span class="c1">// Similarly, we can define intents on the return type.</span>
<span class="c1">// ``refElement`` returns a reference to an element of array.</span>
<span class="c1">// This makes more practical sense for class methods where references to</span>
<span class="c1">// elements in a data-structure are returned via a method or iterator.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">refElement</span><span class="p">(</span><span class="nx">array</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[?</span><span class="nx">D</span><span class="p">]</span><span class="w"> </span><span class="p">?</span><span class="nx">T</span><span class="p">,</span><span class="w"> </span><span class="nx">idx</span><span class="p">)</span><span class="w"> </span><span class="kd">ref</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">T</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">array</span><span class="p">[</span><span class="nx">idx</span><span class="p">];</span>
<span class="p">}</span>

<span class="kd">var</span><span class="w"> </span><span class="nx">myChangingArray</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">myChangingArray</span><span class="p">);</span>
<span class="kd">ref</span><span class="w"> </span><span class="nx">refToElem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">refElement</span><span class="p">(</span><span class="nx">myChangingArray</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// store reference to element in ref variable</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">refToElem</span><span class="p">);</span>
<span class="nx">refToElem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// modify reference which modifies actual value in array</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">refToElem</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">myChangingArray</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Operator Definitions</span>
<span class="cm">*/</span>

<span class="c1">// Chapel allows for operators to be overloaded.</span>
<span class="c1">// We can define the unary operators:</span>
<span class="c1">// ``+ - ! ~``</span>
<span class="c1">// and the binary operators:</span>
<span class="c1">// ``+ - * / % ** == &lt;= &gt;= &lt; &gt; &lt;&lt; &gt;&gt; &amp; |  by``</span>
<span class="c1">// ``+= -= *= /= %= **= &amp;= |= = &lt;&lt;= &gt;&gt;= &lt;=&gt;``</span>

<span class="c1">// Boolean exclusive or operator.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">^</span><span class="p">(</span><span class="nx">left</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="nx">right</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">):</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nx">left</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">right</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="nx">left</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">right</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">writeln</span><span class="p">(</span><span class="kc">true</span><span class="w">  </span><span class="o">^</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="kc">false</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="kc">true</span><span class="w">  </span><span class="o">^</span><span class="w"> </span><span class="kc">false</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="kc">false</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="kc">false</span><span class="p">);</span>

<span class="c1">// Define a ``*`` operator on any two types that returns a tuple of those types.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">*</span><span class="p">(</span><span class="nx">left</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">?</span><span class="nx">ltype</span><span class="p">,</span><span class="w"> </span><span class="nx">right</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">?</span><span class="nx">rtype</span><span class="p">):</span><span class="w"> </span><span class="p">(</span><span class="nx">ltype</span><span class="p">,</span><span class="w"> </span><span class="nx">rtype</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;\tIn our &#39;*&#39; overload!&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nx">left</span><span class="p">,</span><span class="w"> </span><span class="nx">right</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">writeln</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Uses our ``*`` operator.</span>
<span class="nx">writeln</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">   </span><span class="c1">// Uses the default ``*`` operator.</span>

<span class="c1">//  Note: You could break everything if you get careless with your overloads.</span>
<span class="c1">//  This here will break everything. Don&#39;t do it.</span>

<span class="cm">/* </span>

<span class="cm">      proc +(left: int, right: int): int {</span>
<span class="cm">        return left - right;</span>
<span class="cm">      }</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">Iterators</span>
<span class="cm">*/</span>

<span class="c1">// Iterators are sisters to the procedure, and almost everything about</span>
<span class="c1">// procedures also applies to iterators. However, instead of returning a single</span>
<span class="c1">// value, iterators may yield multiple values to a loop.</span>
<span class="c1">//</span>
<span class="c1">// This is useful when a complicated set or order of iterations is needed, as</span>
<span class="c1">// it allows the code defining the iterations to be separate from the loop</span>
<span class="c1">// body.</span>
<span class="k">iter</span><span class="w"> </span><span class="nf">oddsThenEvens</span><span class="p">(</span><span class="nx">N</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">):</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="nx">N</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="k">yield</span><span class="w"> </span><span class="nx">i</span><span class="p">;</span><span class="w"> </span><span class="c1">// yield values instead of returning.</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">2</span><span class="o">..</span><span class="nx">N</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="k">yield</span><span class="w"> </span><span class="nx">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">oddsThenEvens</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">write</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">();</span>

<span class="c1">// Iterators can also yield conditionally, the result of which can be nothing</span>
<span class="k">iter</span><span class="w"> </span><span class="nf">absolutelyNothing</span><span class="p">(</span><span class="nx">N</span><span class="p">):</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="nx">N</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">N</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Always false</span>
<span class="w">      </span><span class="k">yield</span><span class="w"> </span><span class="nx">i</span><span class="p">;</span><span class="w">     </span><span class="c1">// Yield statement never happens</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">absolutelyNothing</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Woa there! absolutelyNothing yielded &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// We can zipper together two or more iterators (who have the same number</span>
<span class="c1">// of iterations) using ``zip()`` to create a single zipped iterator, where each</span>
<span class="c1">// iteration of the zipped iterator yields a tuple of one value yielded</span>
<span class="c1">// from each iterator.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">positive</span><span class="p">,</span><span class="w"> </span><span class="nx">negative</span><span class="p">)</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="k">zip</span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">5</span><span class="o">..-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">((</span><span class="nx">positive</span><span class="p">,</span><span class="w"> </span><span class="nx">negative</span><span class="p">));</span>

<span class="c1">// Zipper iteration is quite important in the assignment of arrays,</span>
<span class="c1">// slices of arrays, and array/loop expressions.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">fromThatArray</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..#</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">toThisArray</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">100</span><span class="o">..#</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>

<span class="c1">// Some zipper operations implement other operations.</span>
<span class="c1">// The first statement and the loop are equivalent.</span>
<span class="nx">toThisArray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">fromThatArray</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="k">zip</span><span class="p">(</span><span class="nx">toThisArray</span><span class="p">.</span><span class="k">domain</span><span class="p">,</span><span class="w"> </span><span class="nx">fromThatArray</span><span class="p">.</span><span class="k">domain</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">toThisArray</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">fromThatArray</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// These two chunks are also equivalent.</span>
<span class="nx">toThisArray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nx">j</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="o">-</span><span class="mi">100</span><span class="o">..#</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="nx">j</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">toThisArray</span><span class="p">);</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">j</span><span class="p">)</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="k">zip</span><span class="p">(</span><span class="nx">toThisArray</span><span class="p">.</span><span class="k">domain</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">100</span><span class="o">..#</span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">toThisArray</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">j</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">toThisArray</span><span class="p">);</span>

<span class="c1">// This is very important in understanding why this statement exhibits a runtime error.</span>

<span class="cm">/* </span>
<span class="cm">      var iterArray : [1..10] int = [i in 1..10] if (i % 2 == 1) then i;</span>
<span class="cm">*/</span>

<span class="c1">// Even though the domain of the array and the loop-expression are</span>
<span class="c1">// the same size, the body of the expression can be thought of as an iterator.</span>
<span class="c1">// Because iterators can yield nothing, that iterator yields a different number</span>
<span class="c1">// of things than the domain of the array or loop, which is not allowed.</span>

<span class="cm">/*</span>
<span class="cm">Classes</span>
<span class="cm">*/</span>
<span class="c1">// Classes are similar to those in C++ and Java, allocated on the heap.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="w"> </span><span class="p">{</span>

<span class="c1">// Member variables</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">memberInt</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">memberBool</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>

<span class="c1">// By default, any class that doesn&#39;t define an initializer gets a</span>
<span class="c1">// compiler-generated initializer, with one argument per field and</span>
<span class="c1">// the field&#39;s initial value as the argument&#39;s default value.</span>
<span class="c1">// Alternatively, the user can define initializers manually as shown</span>
<span class="c1">// in the following commented-out routine:</span>
<span class="c1">//</span>
<span class="cm">/*       // proc init(val : real) {</span>
<span class="cm">      //   this.memberInt = ceil(val): int;</span>
<span class="cm">      // }</span>
<span class="cm">*/</span>

<span class="c1">// Explicitly defined deinitializer.</span>
<span class="c1">// If we did not write one, we would get the compiler-generated deinitializer,</span>
<span class="c1">// which has an empty body.</span>
<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">deinit</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;MyClass deinitializer called &quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">memberInt</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">memberBool</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// Class methods.</span>
<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">setMemberInt</span><span class="p">(</span><span class="nx">val</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">memberInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">val</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">setMemberBool</span><span class="p">(</span><span class="nx">val</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">memberBool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">val</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">getMemberInt</span><span class="p">():</span><span class="w"> </span><span class="kt">int</span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">memberInt</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">getMemberBool</span><span class="p">():</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">memberBool</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// end MyClass</span>

<span class="c1">// Call compiler-generated initializer, using default value for memberBool.</span>
<span class="p">{</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">myObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="k">owned</span><span class="w"> </span><span class="nx">MyClass</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="w">      </span><span class="nx">myObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="k">owned</span><span class="w"> </span><span class="nx">MyClass</span><span class="p">(</span><span class="nx">memberInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="c1">// Equivalent</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">myObject</span><span class="p">.</span><span class="nx">getMemberInt</span><span class="p">());</span>

<span class="w">  </span><span class="c1">// Same, but provide a memberBool value explicitly.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">myDiffObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="k">owned</span><span class="w"> </span><span class="nx">MyClass</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span>
<span class="w">      </span><span class="nx">myDiffObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="k">owned</span><span class="w"> </span><span class="nx">MyClass</span><span class="p">(</span><span class="nx">memberInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="w">                                       </span><span class="nx">memberBool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span><span class="w"> </span><span class="c1">// Equivalent</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">myDiffObject</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Similar, but rely on the default value of memberInt, passing in memberBool.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">myThirdObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="k">owned</span><span class="w"> </span><span class="nx">MyClass</span><span class="p">(</span><span class="nx">memberBool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">myThirdObject</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// If the user-defined initializer above had been uncommented, we could</span>
<span class="w">  </span><span class="c1">// make the following calls:</span>
<span class="w">  </span><span class="c1">//</span>
<span class="w">  </span><span class="cm">/*         // var myOtherObject = new MyClass(1.95);</span>
<span class="cm">        //     myOtherObject = new MyClass(val = 1.95);</span>
<span class="cm">        // writeln(myOtherObject.getMemberInt());</span>
<span class="cm">  */</span>

<span class="w">  </span><span class="c1">// We can define an operator on our class as well, but</span>
<span class="w">  </span><span class="c1">// the definition has to be outside the class definition.</span>
<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">+</span><span class="p">(</span><span class="nx">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">MyClass</span><span class="p">,</span><span class="w"> </span><span class="nx">B</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">MyClass</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="k">owned</span><span class="w"> </span><span class="nx">MyClass</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span>
<span class="w">      </span><span class="k">new</span><span class="w"> </span><span class="k">owned</span><span class="w"> </span><span class="nx">MyClass</span><span class="p">(</span><span class="nx">memberInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">A</span><span class="p">.</span><span class="nx">getMemberInt</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">B</span><span class="p">.</span><span class="nx">getMemberInt</span><span class="p">(),</span>
<span class="w">                        </span><span class="nx">memberBool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">A</span><span class="p">.</span><span class="nx">getMemberBool</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">B</span><span class="p">.</span><span class="nx">getMemberBool</span><span class="p">());</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">plusObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">myObject</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">myDiffObject</span><span class="p">;</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">plusObject</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Destruction of an object: calls the deinit() routine and frees its memory.</span>
<span class="w">  </span><span class="c1">// ``unmanaged`` variables should have ``delete`` called on them.</span>
<span class="w">  </span><span class="c1">// ``owned`` variables are destroyed when they go out of scope.</span>
<span class="p">}</span>

<span class="c1">// Classes can inherit from one or more parent classes</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MyChildClass</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">MyClass</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">memberComplex</span><span class="p">:</span><span class="w"> </span><span class="kt">complex</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Here&#39;s an example of generic classes.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">GenericClass</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">type</span><span class="w"> </span><span class="nx">classType</span><span class="p">;</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">classDomain</span><span class="p">:</span><span class="w"> </span><span class="k">domain</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">classArray</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="nx">classDomain</span><span class="p">]</span><span class="w"> </span><span class="nx">classType</span><span class="p">;</span>

<span class="c1">// Explicit initializer.</span>
<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kd">type</span><span class="w"> </span><span class="nx">classType</span><span class="p">,</span><span class="w"> </span><span class="nx">elements</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">classType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">classType</span><span class="p">;</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">classDomain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="nx">elements</span><span class="p">};</span>
<span class="w">    </span><span class="c1">// all generic and const fields must be initialized in &quot;phase 1&quot; prior</span>
<span class="w">    </span><span class="c1">// to a call to the superclass initializer.</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// Copy-style initializer.</span>
<span class="c1">// Note: We include a type argument whose default is the type of the first</span>
<span class="c1">// argument.  This lets our initializer copy classes of different</span>
<span class="c1">// types and cast on the fly.</span>
<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="nx">other</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">GenericClass</span><span class="p">(?),</span>
<span class="w">            </span><span class="kd">type</span><span class="w"> </span><span class="nx">classType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">other</span><span class="p">.</span><span class="nx">classType</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">classType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">classType</span><span class="p">;</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">classDomain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">other</span><span class="p">.</span><span class="nx">classDomain</span><span class="p">;</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">classArray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">o</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">other</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">o</span><span class="p">:</span><span class="w"> </span><span class="nx">classType</span><span class="p">;</span><span class="w">  </span><span class="c1">// copy and cast</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// Define bracket notation on a GenericClass</span>
<span class="c1">// object so it can behave like a normal array</span>
<span class="c1">// i.e. ``objVar[i]`` or ``objVar(i)``</span>
<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">this</span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kd">ref</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">classType</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">classArray</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// Define an implicit iterator for the class</span>
<span class="c1">// to yield values from the array to a loop</span>
<span class="c1">// i.e. ``for i in objVar do ...``</span>
<span class="w">  </span><span class="k">iter</span><span class="w"> </span><span class="nf">these</span><span class="p">()</span><span class="w"> </span><span class="kd">ref</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">classType</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">classDomain</span><span class="w"> </span><span class="k">do</span>
<span class="w">      </span><span class="k">yield</span><span class="w"> </span><span class="k">this</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// end GenericClass</span>

<span class="c1">// Allocate an owned instance of our class</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">realList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="k">owned</span><span class="w"> </span><span class="nx">GenericClass</span><span class="p">(</span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>

<span class="c1">// We can assign to the member array of the object using the bracket</span>
<span class="c1">// notation that we defined.</span>
<span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">realList</span><span class="p">.</span><span class="nx">classDomain</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">realList</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>

<span class="c1">// We can iterate over the values in our list with the iterator</span>
<span class="c1">// we defined.</span>
<span class="k">for</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">realList</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">write</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">();</span>

<span class="c1">// Make a copy of realList using the copy initializer.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">copyList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="k">owned</span><span class="w"> </span><span class="nx">GenericClass</span><span class="p">(</span><span class="nx">realList</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">copyList</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">write</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">();</span>

<span class="c1">// Make a copy of realList and change the type, also using the copy initializer.</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">copyNewTypeList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="k">owned</span><span class="w"> </span><span class="nx">GenericClass</span><span class="p">(</span><span class="nx">realList</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">copyNewTypeList</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">write</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">();</span>


<span class="cm">/*</span>
<span class="cm">Modules</span>
<span class="cm">*/</span>

<span class="c1">// Modules are Chapel&#39;s way of managing name spaces.</span>
<span class="c1">// The files containing these modules do not need to be named after the modules</span>
<span class="c1">// (as in Java), but files implicitly name modules.</span>
<span class="c1">// For example, this file implicitly names the ``learnChapelInYMinutes`` module</span>

<span class="k">module</span><span class="w"> </span><span class="nc">OurModule</span><span class="w"> </span><span class="p">{</span>

<span class="c1">// We can use modules inside of other modules.</span>
<span class="c1">// Time is one of the standard modules.</span>
<span class="w">  </span><span class="k">use</span><span class="w"> </span><span class="nx">Time</span><span class="p">;</span>

<span class="c1">// We&#39;ll use this procedure in the parallelism section.</span>
<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">countdown</span><span class="p">(</span><span class="nx">seconds</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="nx">seconds</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
<span class="w">      </span><span class="nx">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// It is possible to create arbitrarily deep module nests.</span>
<span class="c1">// i.e. submodules of OurModule</span>
<span class="w">  </span><span class="k">module</span><span class="w"> </span><span class="nc">ChildModule</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">proc</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;ChildModule.foo()&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">module</span><span class="w"> </span><span class="nc">SiblingModule</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">proc</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;SiblingModule.foo()&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// end OurModule</span>

<span class="c1">// Using ``OurModule`` also uses all the modules it uses.</span>
<span class="c1">// Since ``OurModule`` uses ``Time``, we also use ``Time``.</span>
<span class="k">use</span><span class="w"> </span><span class="nx">OurModule</span><span class="p">;</span>

<span class="c1">// At this point we have not used ``ChildModule`` or ``SiblingModule`` so</span>
<span class="c1">// their symbols (i.e. ``foo``) are not available to us. However, the module</span>
<span class="c1">// names are available, and we can explicitly call ``foo()`` through them.</span>
<span class="nx">SiblingModule</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span>
<span class="nx">OurModule</span><span class="p">.</span><span class="nx">ChildModule</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span>

<span class="c1">// Now we use ``ChildModule``, enabling unqualified calls.</span>
<span class="k">use</span><span class="w"> </span><span class="nx">ChildModule</span><span class="p">;</span>
<span class="nx">foo</span><span class="p">();</span>

<span class="cm">/*</span>
<span class="cm">Parallelism</span>
<span class="cm">*/</span>

<span class="c1">// In other languages, parallelism is typically done with</span>
<span class="c1">// complicated libraries and strange class structure hierarchies.</span>
<span class="c1">// Chapel has it baked right into the language.</span>

<span class="c1">// We can declare a main procedure, but all the code above main still gets</span>
<span class="c1">// executed.</span>
<span class="k">proc</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="c1">// A ``begin`` statement will spin the body of that statement off</span>
<span class="c1">// into one new task.</span>
<span class="c1">// A ``sync`` statement will ensure that the progress of the main</span>
<span class="c1">// task will not progress until the children have synced back up.</span>

<span class="w">  </span><span class="k">sync</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">begin</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Start of new task&#39;s body</span>
<span class="w">      </span><span class="kd">var</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">1000</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Done: &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">a</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// End of new tasks body</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;spun off a task!&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Back together&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">printFibb</span><span class="p">(</span><span class="nx">n</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;fibonacci(&quot;</span><span class="p">,</span><span class="nx">n</span><span class="p">,</span><span class="s">&quot;) = &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">fibonacci</span><span class="p">(</span><span class="nx">n</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// A ``cobegin`` statement will spin each statement of the body into one new</span>
<span class="c1">// task. Notice here that the prints from each statement may happen in any</span>
<span class="c1">// order.</span>
<span class="w">  </span><span class="k">cobegin</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">printFibb</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w"> </span><span class="c1">// new task</span>
<span class="w">    </span><span class="nx">printFibb</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="c1">// new task</span>
<span class="w">    </span><span class="nx">printFibb</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w">  </span><span class="c1">// new task</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// This is a nested statement body and thus is a single statement</span>
<span class="w">      </span><span class="c1">// to the parent statement, executed by a single task.</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;this gets&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;executed as&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;a whole&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// A ``coforall`` loop will create a new task for EACH iteration.</span>
<span class="c1">// Again we see that prints happen in any order.</span>
<span class="c1">// NOTE: ``coforall`` should be used only for creating tasks!</span>
<span class="c1">// Using it to iterating over a structure is very a bad idea!</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">num_tasks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="c1">// Number of tasks we want</span>
<span class="w">  </span><span class="k">coforall</span><span class="w"> </span><span class="nx">taskID</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="nx">num_tasks</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Hello from task# &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">taskID</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// ``forall`` loops are another parallel loop, but only create a smaller number</span>
<span class="c1">// of tasks, specifically ``--dataParTasksPerLocale=`` number of tasks.</span>
<span class="w">  </span><span class="k">forall</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">write</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">();</span>

<span class="c1">// Here we see that there are sections that are in order, followed by</span>
<span class="c1">// a section that would not follow (e.g. 1, 2, 3, 7, 8, 9, 4, 5, 6,).</span>
<span class="c1">// This is because each task is taking on a chunk of the range 1..10</span>
<span class="c1">// (1..3, 4..6, or 7..9) doing that chunk serially, but each task happens</span>
<span class="c1">// in parallel. Your results may depend on your machine and configuration</span>

<span class="c1">// For both the ``forall`` and ``coforall`` loops, the execution of the</span>
<span class="c1">// parent task will not continue until all the children sync up.</span>

<span class="c1">// ``forall`` loops are particularly useful for parallel iteration over arrays.</span>
<span class="c1">// Lets run an experiment to see how much faster a parallel loop is</span>
<span class="w">  </span><span class="k">use</span><span class="w"> </span><span class="nx">Time</span><span class="p">;</span><span class="w"> </span><span class="c1">// Import the Time module to use Timer objects</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">timer</span><span class="p">:</span><span class="w"> </span><span class="nx">Timer</span><span class="p">;</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">myBigArray</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="mi">1</span><span class="o">..</span><span class="mi">4000</span><span class="p">,</span><span class="mi">1</span><span class="o">..</span><span class="mi">4000</span><span class="p">}]</span><span class="w"> </span><span class="kt">real</span><span class="p">;</span><span class="w"> </span><span class="c1">// Large array we will write into</span>

<span class="c1">// Serial Experiment:</span>
<span class="w">  </span><span class="nx">timer</span><span class="p">.</span><span class="nx">start</span><span class="p">();</span><span class="w"> </span><span class="c1">// Start timer</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">)</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">myBigArray</span><span class="p">.</span><span class="k">domain</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Serial iteration</span>
<span class="w">    </span><span class="nx">myBigArray</span><span class="p">[</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">x</span><span class="p">:</span><span class="kt">real</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="nx">y</span><span class="p">:</span><span class="kt">real</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nx">timer</span><span class="p">.</span><span class="nx">stop</span><span class="p">();</span><span class="w"> </span><span class="c1">// Stop timer</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Serial: &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">timer</span><span class="p">.</span><span class="nx">elapsed</span><span class="p">());</span><span class="w"> </span><span class="c1">// Print elapsed time</span>
<span class="w">  </span><span class="nx">timer</span><span class="p">.</span><span class="nx">clear</span><span class="p">();</span><span class="w"> </span><span class="c1">// Clear timer for parallel loop</span>

<span class="c1">// Parallel Experiment:</span>
<span class="w">  </span><span class="nx">timer</span><span class="p">.</span><span class="nx">start</span><span class="p">();</span><span class="w"> </span><span class="c1">// start timer</span>
<span class="w">  </span><span class="k">forall</span><span class="w"> </span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">)</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">myBigArray</span><span class="p">.</span><span class="k">domain</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Parallel iteration</span>
<span class="w">    </span><span class="nx">myBigArray</span><span class="p">[</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">x</span><span class="p">:</span><span class="kt">real</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="nx">y</span><span class="p">:</span><span class="kt">real</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nx">timer</span><span class="p">.</span><span class="nx">stop</span><span class="p">();</span><span class="w"> </span><span class="c1">// Stop timer</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Parallel: &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">timer</span><span class="p">.</span><span class="nx">elapsed</span><span class="p">());</span><span class="w"> </span><span class="c1">// Print elapsed time</span>
<span class="w">  </span><span class="nx">timer</span><span class="p">.</span><span class="nx">clear</span><span class="p">();</span>

<span class="c1">// You may have noticed that (depending on how many cores you have)</span>
<span class="c1">// the parallel loop went faster than the serial loop.</span>

<span class="c1">// The bracket style loop-expression described</span>
<span class="c1">// much earlier implicitly uses a ``forall`` loop.</span>
<span class="w">  </span><span class="p">[</span><span class="nx">val</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">myBigArray</span><span class="p">]</span><span class="w"> </span><span class="nx">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">val</span><span class="p">;</span><span class="w"> </span><span class="c1">// Parallel operation</span>

<span class="c1">// Atomic variables, common to many languages, are ones whose operations</span>
<span class="c1">// occur uninterrupted. Multiple threads can therefore modify atomic</span>
<span class="c1">// variables and can know that their values are safe.</span>
<span class="c1">// Chapel atomic variables can be of type ``bool``, ``int``,</span>
<span class="c1">// ``uint``, and ``real``.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">uranium</span><span class="p">:</span><span class="w"> </span><span class="k">atomic</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>
<span class="w">  </span><span class="nx">uranium</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="mi">238</span><span class="p">);</span><span class="w">      </span><span class="c1">// atomically write a variable</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">uranium</span><span class="p">.</span><span class="nx">read</span><span class="p">());</span><span class="w"> </span><span class="c1">// atomically read a variable</span>

<span class="c1">// Atomic operations are described as functions, so you can define your own.</span>
<span class="w">  </span><span class="nx">uranium</span><span class="p">.</span><span class="nx">sub</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"> </span><span class="c1">// atomically subtract a variable</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">uranium</span><span class="p">.</span><span class="nx">read</span><span class="p">());</span>

<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">replaceWith</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">239</span><span class="p">;</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">was</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">uranium</span><span class="p">.</span><span class="nx">exchange</span><span class="p">(</span><span class="nx">replaceWith</span><span class="p">);</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;uranium was &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">was</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; but is now &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">replaceWith</span><span class="p">);</span>

<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">isEqualTo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">235</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">uranium</span><span class="p">.</span><span class="nx">compareAndSwap</span><span class="p">(</span><span class="nx">isEqualTo</span><span class="p">,</span><span class="w"> </span><span class="nx">replaceWith</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;uranium was equal to &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">isEqualTo</span><span class="p">,</span>
<span class="w">             </span><span class="s">&quot; so replaced value with &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">replaceWith</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;uranium was not equal to &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">isEqualTo</span><span class="p">,</span>
<span class="w">             </span><span class="s">&quot; so value stays the same...  whatever it was&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">sync</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">begin</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Reader task</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Reader: waiting for uranium to be &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">isEqualTo</span><span class="p">);</span>
<span class="w">      </span><span class="nx">uranium</span><span class="p">.</span><span class="nx">waitFor</span><span class="p">(</span><span class="nx">isEqualTo</span><span class="p">);</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Reader: uranium was set (by someone) to &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">isEqualTo</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">begin</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Writer task</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Writer: will set uranium to the value &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">isEqualTo</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; in...&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="nx">countdown</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="w">      </span><span class="nx">uranium</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">isEqualTo</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// ``sync`` variables have two states: empty and full.</span>
<span class="c1">// If you read an empty variable or write a full variable, you are waited</span>
<span class="c1">// until the variable is full or empty again.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">someSyncVar$</span><span class="p">:</span><span class="w"> </span><span class="k">sync</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w"> </span><span class="c1">// varName$ is a convention not a law.</span>
<span class="w">  </span><span class="k">sync</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">begin</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Reader task</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Reader: waiting to read.&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="kd">var</span><span class="w"> </span><span class="nx">read_sync</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">someSyncVar$</span><span class="p">;</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Reader: value is &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">read_sync</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">begin</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Writer task</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Writer: will write in...&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="nx">countdown</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="w">      </span><span class="nx">someSyncVar$</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">123</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// ``single`` vars can only be written once. A read on an unwritten ``single``</span>
<span class="c1">// results in a wait, but when the variable has a value it can be read indefinitely.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">someSingleVar$</span><span class="p">:</span><span class="w"> </span><span class="k">single</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w"> </span><span class="c1">// varName$ is a convention not a law.</span>
<span class="w">  </span><span class="k">sync</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">begin</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Reader task</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Reader: waiting to read.&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">var</span><span class="w"> </span><span class="nx">read_single</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">someSingleVar$</span><span class="p">;</span>
<span class="w">        </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Reader: iteration &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">,</span><span class="s">&quot;, and the value is &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">read_single</span><span class="p">);</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">begin</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Writer task</span>
<span class="w">      </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Writer: will write in...&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="nx">countdown</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="w">      </span><span class="nx">someSingleVar$</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// first and only write ever.</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// Here&#39;s an example using atomics and a ``sync`` variable to create a</span>
<span class="c1">// count-down mutex (also known as a multiplexer).</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">count</span><span class="p">:</span><span class="w"> </span><span class="k">atomic</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w"> </span><span class="c1">// our counter</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">lock$</span><span class="p">:</span><span class="w"> </span><span class="k">sync</span><span class="w"> </span><span class="kt">bool</span><span class="p">;</span><span class="w">   </span><span class="c1">// the mutex lock</span>

<span class="w">  </span><span class="nx">count</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w">       </span><span class="c1">// Only let two tasks in at a time.</span>
<span class="w">  </span><span class="nx">lock$</span><span class="p">.</span><span class="nx">writeXF</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span><span class="w">  </span><span class="c1">// Set lock$ to full (unlocked)</span>
<span class="w">  </span><span class="c1">// Note: The value doesn&#39;t actually matter, just the state</span>
<span class="w">  </span><span class="c1">// (full:unlocked / empty:locked)</span>
<span class="w">  </span><span class="c1">// Also, writeXF() fills (F) the sync var regardless of its state (X)</span>

<span class="w">  </span><span class="k">coforall</span><span class="w"> </span><span class="nx">task</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Generate tasks</span>
<span class="w">    </span><span class="c1">// Create a barrier</span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">lock$</span><span class="p">;</span><span class="w">                 </span><span class="c1">// Read lock$ (wait)</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nx">count</span><span class="p">.</span><span class="nx">read</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// Keep waiting until a spot opens up</span>

<span class="w">    </span><span class="nx">count</span><span class="p">.</span><span class="nx">sub</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">          </span><span class="c1">// decrement the counter</span>
<span class="w">    </span><span class="nx">lock$</span><span class="p">.</span><span class="nx">writeXF</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span><span class="w"> </span><span class="c1">// Set lock$ to full (signal)</span>

<span class="w">    </span><span class="c1">// Actual &#39;work&#39;</span>
<span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Task #&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">task</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; doing work.&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="nx">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="w">    </span><span class="nx">count</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">        </span><span class="c1">// Increment the counter</span>
<span class="w">    </span><span class="nx">lock$</span><span class="p">.</span><span class="nx">writeXF</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span><span class="w"> </span><span class="c1">// Set lock$ to full (signal)</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// We can define the operations ``+ * &amp; | ^ &amp;&amp; || min max minloc maxloc``</span>
<span class="c1">// over an entire array using scans and reductions.</span>
<span class="c1">// Reductions apply the operation over the entire array and</span>
<span class="c1">// result in a scalar value.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">listOfValues</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">15</span><span class="p">,</span><span class="mi">57</span><span class="p">,</span><span class="mi">354</span><span class="p">,</span><span class="mi">36</span><span class="p">,</span><span class="mi">45</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">456</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">678</span><span class="p">,</span><span class="mi">2</span><span class="p">];</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">sumOfValues</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">reduce</span><span class="w"> </span><span class="nx">listOfValues</span><span class="p">;</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">maxValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">max</span><span class="w"> </span><span class="k">reduce</span><span class="w"> </span><span class="nx">listOfValues</span><span class="p">;</span><span class="w"> </span><span class="c1">// &#39;max&#39; give just max value</span>

<span class="c1">// ``maxloc`` gives max value and index of the max value.</span>
<span class="c1">// Note: We have to zip the array and domain together with the zip iterator.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="p">(</span><span class="nx">theMaxValue</span><span class="p">,</span><span class="w"> </span><span class="nx">idxOfMax</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">maxloc</span><span class="w"> </span><span class="k">reduce</span><span class="w"> </span><span class="k">zip</span><span class="p">(</span><span class="nx">listOfValues</span><span class="p">,</span>
<span class="w">                                                  </span><span class="nx">listOfValues</span><span class="p">.</span><span class="k">domain</span><span class="p">);</span>

<span class="w">  </span><span class="nx">writeln</span><span class="p">((</span><span class="nx">sumOfValues</span><span class="p">,</span><span class="w"> </span><span class="nx">maxValue</span><span class="p">,</span><span class="w"> </span><span class="nx">idxOfMax</span><span class="p">,</span><span class="w"> </span><span class="nx">listOfValues</span><span class="p">[</span><span class="nx">idxOfMax</span><span class="p">]));</span>

<span class="c1">// Scans apply the operation incrementally and return an array with the</span>
<span class="c1">// values of the operation at that index as it progressed through the</span>
<span class="c1">// array from ``array.domain.low`` to ``array.domain.high``.</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">runningSumOfValues</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">scan</span><span class="w"> </span><span class="nx">listOfValues</span><span class="p">;</span>
<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">maxScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">max</span><span class="w"> </span><span class="k">scan</span><span class="w"> </span><span class="nx">listOfValues</span><span class="p">;</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">runningSumOfValues</span><span class="p">);</span>
<span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">maxScan</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// end main()</span>
</pre></div>
<h2>Who is this tutorial for?</h2>
<p>This tutorial is for people who want to learn the ropes of chapel without
having to hear about what fiber mixture the ropes are, or how they were
braided, or how the braid configurations differ between one another. It won't
teach you how to develop amazingly performant code, and it's not exhaustive.
Refer to the <a href="https://chapel-lang.org/docs/latest/language/spec.html">language specification</a> and
the <a href="https://chapel-lang.org/docs/latest/">module documentation</a> for more
details.</p>
<p>Occasionally check back here and on the <a href="https://chapel-lang.org">Chapel site</a>
to see if more topics have been added or more tutorials created.</p>
<h3>What this tutorial is lacking:</h3>
<ul>
<li>Exposition of the <a href="https://chapel-lang.org/docs/latest/modules/standard.html">standard modules</a></li>
<li>Multiple Locales (distributed memory system)</li>
<li>Records</li>
<li>Parallel iterators</li>
</ul>
<h2>Your input, questions, and discoveries are important to the developers!</h2>
<p>The Chapel language is still in active development, so there are
occasional hiccups with performance and language features. The more information
you give the Chapel development team about issues you encounter or features you
would like to see, the better the language becomes.
There are several ways to interact with the developers:</p>
<ul>
<li><a href="https://gitter.im/chapel-lang/chapel">Gitter chat</a></li>
<li><a href="https://sourceforge.net/p/chapel/mailman">sourceforge email lists</a></li>
</ul>
<p>If you're really interested in the development of the compiler or contributing
to the project, <a href="https://github.com/chapel-lang/chapel">check out the master GitHub repository</a>.
It is under the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache 2.0 License</a>.</p>
<h2>Installing the Compiler</h2>
<p><a href="https://chapel-lang.org/docs/usingchapel/QUICKSTART.html">The Official Chapel documentation details how to download and compile the Chapel compiler.</a></p>
<p>Chapel can be built and installed on your average 'nix machine (and cygwin).
<a href="https://github.com/chapel-lang/chapel/releases/">Download the latest release version</a>
and it's as easy as</p>
<ol>
<li><code>tar -xvf chapel-&lt;VERSION&gt;.tar.gz</code></li>
<li><code>cd chapel-&lt;VERSION&gt;</code></li>
<li><code>source util/setchplenv.bash # or .sh or .csh or .fish</code></li>
<li><code>make</code></li>
<li><code>make check # optional</code></li>
</ol>
<p>You will need to <code>source util/setchplenv.EXT</code> from within the Chapel directory
(<code>$CHPL_HOME</code>) every time your terminal starts so it's suggested that you drop
that command in a script that will get executed on startup (like .bashrc).</p>
<p>Chapel is easily installed on macOS with Homebrew</p>
<ol>
<li><code>brew update</code></li>
<li><code>brew install chapel</code></li>
</ol>
<h2>Compiling Code</h2>
<p>Builds like other compilers:</p>
<p><code>chpl myFile.chpl -o myExe</code></p>
<p>Notable arguments:</p>
<ul>
<li><code>--fast</code>: enables a number of optimizations and disables array bounds
checks. Should only enable when application is stable.</li>
<li><code>--set &lt;Symbol Name&gt;=&lt;Value&gt;</code>: set config param <code>&lt;Symbol Name&gt;</code> to <code>&lt;Value&gt;</code>
at compile-time.</li>
<li><code>--main-module &lt;Module Name&gt;</code>: use the main() procedure found in the module
<code>&lt;Module Name&gt;</code> as the executable's main.</li>
<li><code>--module-dir &lt;Directory&gt;</code>: includes <code>&lt;Directory&gt;</code> in the module search path.</li>
</ul>

        <hr>
        <p>
          Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the GitHub Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/chapel.md">pull request</a> yourself!
        </p>
        <p class="contributed">
          Originally contributed by Ian J. Bertolacci, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/chapel.md">10 contributors</a>.
        </p>

        <footer>
          <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width: 0; width: 88px; height: 31px;" src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-sa.svg" /></a>
          <p>
            &copy; 2025
            <a href="https://www.cs.arizona.edu/~ianbertolacci/">Ian J. Bertolacci</a>,
            <a href="https://github.com/benharsh/">Ben Harshbarger</a>
          </p>
        </footer>
      </div>
    </div>
  </body>
</html>